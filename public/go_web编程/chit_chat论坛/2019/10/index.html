<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="&amp;lt;!DOCTYPE html&amp;gt;         ChitChat2.1　ChitChat 简介2.2　应用设计2.3　数据模型2.4　请求的接收与处理2.4.1　多路复用器2.4.2　服务静态文件2.4.3　创建处理器函数2.4.4　使用 cookie 进行访问控制2.5　使用模板生成 HTML 响应整理代码2.6　安装 PostgreSQL2.6.1　在 Linux 或 FreeBS">
<meta property="og:type" content="article">
<meta property="og:title" content="ChitChat">
<meta property="og:url" content="http://logan_2019.github.io/go_web编程/chit_chat论坛/2019/10/index.html">
<meta property="og:site_name" content="OYJX">
<meta property="og:description" content="&amp;lt;!DOCTYPE html&amp;gt;         ChitChat2.1　ChitChat 简介2.2　应用设计2.3　数据模型2.4　请求的接收与处理2.4.1　多路复用器2.4.2　服务静态文件2.4.3　创建处理器函数2.4.4　使用 cookie 进行访问控制2.5　使用模板生成 HTML 响应整理代码2.6　安装 PostgreSQL2.6.1　在 Linux 或 FreeBS">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://images.gitbook.cn/ab30ced0-a47d-11e8-80dc-8d254ca863fe">
<meta property="og:image" content="https://images.gitbook.cn/b114ae70-a47d-11e8-8a5b-85d5618fe6ba">
<meta property="og:image" content="https://images.gitbook.cn/b6574500-a47d-11e8-8b4a-cf3651600922">
<meta property="og:image" content="https://images.gitbook.cn/bc44c190-a47d-11e8-8b4a-cf3651600922">
<meta property="og:image" content="https://images.gitbook.cn/c2d0a100-a47d-11e8-8a5b-85d5618fe6ba">
<meta property="og:image" content="https://images.gitbook.cn/e056c3d0-a47d-11e8-8b4a-cf3651600922">
<meta property="og:image" content="https://images.gitbook.cn/e6c09c50-a47d-11e8-a2aa-0bd41466d20f">
<meta property="og:image" content="https://images.gitbook.cn/f72cdd60-a47d-11e8-8b4a-cf3651600922">
<meta property="og:image" content="https://images.gitbook.cn/fdad9940-a47d-11e8-a2aa-0bd41466d20f">
<meta property="og:updated_time" content="2019-10-13T04:12:02.226Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ChitChat">
<meta name="twitter:description" content="&amp;lt;!DOCTYPE html&amp;gt;         ChitChat2.1　ChitChat 简介2.2　应用设计2.3　数据模型2.4　请求的接收与处理2.4.1　多路复用器2.4.2　服务静态文件2.4.3　创建处理器函数2.4.4　使用 cookie 进行访问控制2.5　使用模板生成 HTML 响应整理代码2.6　安装 PostgreSQL2.6.1　在 Linux 或 FreeBS">
<meta name="twitter:image" content="https://images.gitbook.cn/ab30ced0-a47d-11e8-80dc-8d254ca863fe">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>ChitChat</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">首页</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/go_web编程/Go与Web应用/2019/10/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/go_web编程/2-2处理请求(上)/2019/10/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://logan_2019.github.io/go_web编程/chit_chat论坛/2019/10/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://logan_2019.github.io/go_web编程/chit_chat论坛/2019/10/&text=ChitChat"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://logan_2019.github.io/go_web编程/chit_chat论坛/2019/10/&title=ChitChat"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://logan_2019.github.io/go_web编程/chit_chat论坛/2019/10/&is_video=false&description=ChitChat"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=ChitChat&body=Check out this article: http://logan_2019.github.io/go_web编程/chit_chat论坛/2019/10/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://logan_2019.github.io/go_web编程/chit_chat论坛/2019/10/&title=ChitChat"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://logan_2019.github.io/go_web编程/chit_chat论坛/2019/10/&title=ChitChat"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://logan_2019.github.io/go_web编程/chit_chat论坛/2019/10/&title=ChitChat"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://logan_2019.github.io/go_web编程/chit_chat论坛/2019/10/&title=ChitChat"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://logan_2019.github.io/go_web编程/chit_chat论坛/2019/10/&name=ChitChat&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#21chitchat"><span class="toc-number">1.</span> <span class="toc-text">2.1　ChitChat 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22"><span class="toc-number">2.</span> <span class="toc-text">2.2　应用设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23"><span class="toc-number">3.</span> <span class="toc-text">2.3　数据模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24"><span class="toc-number">4.</span> <span class="toc-text">2.4　请求的接收与处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#241"><span class="toc-number">4.1.</span> <span class="toc-text">2.4.1　多路复用器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#242"><span class="toc-number">4.2.</span> <span class="toc-text">2.4.2　服务静态文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#243"><span class="toc-number">4.3.</span> <span class="toc-text">2.4.3　创建处理器函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#244cookie"><span class="toc-number">4.4.</span> <span class="toc-text">2.4.4　使用 cookie 进行访问控制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25html"><span class="toc-number">5.</span> <span class="toc-text">2.5　使用模板生成 HTML 响应</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#"><span class="toc-number">5.1.</span> <span class="toc-text">整理代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26postgresql"><span class="toc-number">6.</span> <span class="toc-text">2.6　安装 PostgreSQL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#261linuxfreebsd"><span class="toc-number">6.1.</span> <span class="toc-text">2.6.1　在 Linux 或 FreeBSD 系统上安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#262macosx"><span class="toc-number">6.2.</span> <span class="toc-text">2.6.2　在 Mac OS X 系统上安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#263windows"><span class="toc-number">6.3.</span> <span class="toc-text">2.6.3　在 Windows 系统上安装</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27"><span class="toc-number">7.</span> <span class="toc-text">2.7　连接数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28"><span class="toc-number">8.</span> <span class="toc-text">2.8　启动服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29web"><span class="toc-number">9.</span> <span class="toc-text">2.9　Web 应用运作流程回顾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#210"><span class="toc-number">10.</span> <span class="toc-text">2.10　小结</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        ChitChat
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">OYJX</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2019-10-13T04:12:02.225Z" itemprop="datePublished">2019-10-13</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>&lt;!DOCTYPE html&gt;</p>
<html lang="en"><br><head><meta name="generator" content="Hexo 3.8.0"><br>    <meta charset="UTF-8"><br>    <title>ChitChat</title><br></head><br><body><br><article id="articleDiv"><div class="mazi-article-content dont-break-out"><p></p><div class="toc"><br><ul><br><li><ul><br><li><ul><br><li><a href="#21chitchat">2.1　ChitChat 简介</a></li><br><li><a href="#22">2.2　应用设计</a></li><br><li><a href="#23">2.3　数据模型</a></li><br><li><a href="#24">2.4　请求的接收与处理</a><ul><br><li><a href="#241">2.4.1　多路复用器</a></li><br><li><a href="#242">2.4.2　服务静态文件</a></li><br><li><a href="#243">2.4.3　创建处理器函数</a></li><br><li><a href="#244cookie">2.4.4　使用 cookie 进行访问控制</a></li><br></ul><br></li><br><li><a href="#25html">2.5　使用模板生成 HTML 响应</a><ul><br><li><a href="#">整理代码</a></li><br></ul><br></li><br><li><a href="#26postgresql">2.6　安装 PostgreSQL</a><ul><br><li><a href="#261linuxfreebsd">2.6.1　在 Linux 或 FreeBSD 系统上安装</a></li><br><li><a href="#262macosx">2.6.2　在 Mac OS X 系统上安装</a></li><br><li><a href="#263windows">2.6.3　在 Windows 系统上安装</a></li><br></ul><br></li><br><li><a href="#27">2.7　连接数据库</a></li><br><li><a href="#28">2.8　启动服务器</a></li><br><li><a href="#29web">2.9　Web 应用运作流程回顾</a></li><br><li><a href="#210">2.10　小结</a></li><br></ul><br></li><br></ul><br></li><br></ul><br></div><br><p></p><br><p><strong>本章主要内容</strong></p><br><ul><br><li>使用 Go 进行 Web 编程的方法</li><br><li>设计一个典型的 Go Web 应用</li><br><li>编写一个完整的 Go Web 应用</li><br><li>了解 Go Web 应用的各个组成部分</li><br></ul><br><p>上一章在末尾展示了一个非常简单的 Go Web 应用，但是因为该应用只是一个 Hello World 程序，所以它实际上并没有什么用处。在本章中，我们将会构建一个简单的网上论坛 Web 应用，这个应用同样非常基础，但是却有用得多：它允许用户登录到论坛里面，然后在论坛上发布新帖子，又或者回复其他用户发表的帖子。</p><br><p>虽然本章介绍的内容无法让你一下子就学会如何编写一个非常成熟的 Web 应用，但这些内容将教会你如何组织和开发一个 Web 应用。在阅读完这一章之后，你将进一步地了解到使用 Go 进行 Web 应用开发的相关方法。</p><br><p>如果你觉得本章介绍的内容难度较大，又或者你觉得本章展示的大量代码看起来让人觉得胆战心惊，那也不必过于担心：本章之后的几章将对本章介绍的内容做进一步的解释，在阅读完本章并继续阅读后续章节时，你将会对本章介绍的内容有更加深入的了解。</p><br><h3 id="21chitchat">2.1　ChitChat 简介</h3><br><p>网上论坛无处不在，它们是互联网上最受欢迎的应用之一，与旧式的电子公告栏（BBS）、新闻组（Usenet）和电子邮件一脉相承。雅虎公司和 Google 公司的群组（Groups）都非常流行，雅虎报告称，他们总共拥有1000万个群组以及1.15亿个群组成员，其中每个群组都拥有一个自己的论坛；而全球最具人气的网上论坛之一——Gaia 在线——则拥有2300万注册用户以及接近230亿张帖子，并且这些帖子的数量还在以每天上百万张的速度持续增长。尽管现在出现了诸如 Facebook 这样的社交网站，但论坛仍然是人们在网上进行交流时最为常用的手段之一。作为例子，图2-1展示了 GoogleGroups 的样子。</p><br><p><img src="https://images.gitbook.cn/ab30ced0-a47d-11e8-80dc-8d254ca863fe" alt="enter image description here"></p><br><p>图2-1　一个网上论坛示例：GoogleGroups 里面的 Go 编程语言论坛</p><br><p>从本质上来说，网上论坛就相当于一个任何人都可以通过发帖来进行对话的公告板，公告板上面可以包含已注册用户以及未注册的匿名用户。论坛上的对话称为帖子（thread），一个帖子通常包含了作者想要讨论的一个主题，而其他用户则可以通过回复这个帖子来参与对话。比较复杂的论坛一般都会按层级进行划分，在这些论坛里面，可能会有多个讨论特定类型主题的子论坛存在。大多数论坛都会由一个或多个拥有特殊权限的用户进行管理，这些拥有特殊权限的用户被称为版主（moderator）。</p><br><p>在本章中，我们将会开发一个名为 ChitChat 的简易网上论坛。为了让这个例子保持简单，我们只会为 ChitChat 实现网上论坛的关键特性：在这个论坛里面，用户可以注册账号，并在登录之后发表新帖子又或者回复已有的帖子；未注册用户可以查看帖子，但是无法发表帖子或是回复帖子。现在，让我们首先来思考一下如何设计 ChitChat 这个应用。</p><br><blockquote><br>  <p>关于本章展示的代码</p><br>  <p>跟本书的其他章节不一样，因为篇幅的关系，本章并不会展示 ChitChat 论坛的所有实现代码，但你可以在 GitHub 页面 <a href="https://github.com/sausheong/gwp" target="_blank" rel="noopener">https://github.com/sausheong/gwp</a> 找到这些代码。如果你打算在阅读本章的同时实际了解一下这个应用，那么这些完整的代码应该会对你有所帮助。</p><br></blockquote><br><h3 id="22">2.2　应用设计</h3><br><p>正如第1章所说，Web 应用的一般工作流程是客户端向服务器发送请求，然后服务器对客户端进行响应（如图2-2所示），ChitChat 应用的设计也遵循这一流程。</p><br><p><img src="https://images.gitbook.cn/b114ae70-a47d-11e8-8a5b-85d5618fe6ba" alt="enter image description here"></p><br><p>图2-2　Web 应用的一般工作流程，客户端向服务器发送请求，然后等待接收响应</p><br><p>ChitChat 的应用逻辑会被编码到服务器里面。服务器会向客户端提供 HTML 页面，并通过页面的超链接向客户端表明请求的格式以及被请求的数据，而客户端则会在发送请求时向服务器提供相应的数据，如图2-3所示。</p><br><p><img src="https://images.gitbook.cn/b6574500-a47d-11e8-8b4a-cf3651600922" alt="enter image description here"></p><br><p>图2-3　HTTP 请求的 URL 格式</p><br><p>请求的格式通常是由应用自行决定的，比如，ChitChat 的请求使用的是以下格式：<code>http://&lt;服务器&gt;&lt;处理器名&gt;?&lt;参数&gt;</code>。</p><br><p>服务器名（server name）是 ChitChat 服务器的名字，而处理器名（handler name）则是被调用的处理器的名字。处理器的名字是按层级进行划分的：位于名字最开头是被调用模块的名字，而之后跟着的则是被调用子模块的名字，以此类推，位于处理器名字最末尾的则是子模块中负责处理请求的处理器。比如，对<code>/thread/read</code>这个处理器名字来说，<code>thread</code>是被调用的模块，而<code>read</code>则是这个模块中负责读取帖子内容的处理器。</p><br><p>该应用的参数（parameter）会以 URL 查询的形式传递给处理器，而处理器则会根据这些参数对请求进行处理。比如说，假设客户端要向处理器传递帖子的唯一 ID，那么它可以将 URL 的参数部分设置成<code>id=123</code>，其中<code>123</code>就是帖子的唯一 ID。</p><br><p>如果<code>chitchat</code>就是 ChitChat 服务器的名字，那么根据上面介绍的 URL 格式规则，客户端发送给 ChitChat 服务器的 URL 可能会是这样的：<a href="http://chitchat/thread/read?id=123。" target="_blank" rel="noopener">http://chitchat/thread/read?id=123。</a></p><br><p>当请求到达服务器时，多路复用器（multiplexer）会对请求进行检查，并将请求重定向至正确的处理器进行处理。处理器在接收到多路复用器转发的请求之后，会从请求中取出相应的信息，并根据这些信息对请求进行处理。在请求处理完毕之后，处理器会将所得的数据传递给模板引擎，而模板引擎则会根据这些数据生成将要返回给客户端的 HTML，整个过程如图2-4所示。</p><br><p><img src="https://images.gitbook.cn/bc44c190-a47d-11e8-8b4a-cf3651600922" alt="enter image description here"></p><br><p>图2-4　服务器在典型 Web 应用中的工作流程</p><br><h3 id="23">2.3　数据模型</h3><br><p>绝大多数应用都需要以某种方式与数据打交道。对 ChitChat 来说，它的数据将被存储到关系式数据库 PostgreSQL 里面，并通过 SQL 与之交互。</p><br><p>ChitChat 的数据模型非常简单，只包含4种数据结构，它们分别是：</p><br><ul><br><li>User——表示论坛的用户信息；</li><br><li>Session——表示论坛用户当前的登录会话；</li><br><li>Thread——表示论坛里面的帖子，每一个帖子都记录了多个论坛用户之间的对话；</li><br><li>Post——表示用户在帖子里面添加的回复。</li><br></ul><br><p>以上这4种数据结构都会被映射到关系数据库里面，图2-5展示了这4种数据结构是如何与数据库交互的。</p><br><p>ChitChat 论坛允许用户在登录之后发布新帖子或者回复已有的帖子，未登录的用户可以阅读帖子，但是不能发布新帖子或者回复帖子。为了对应用进行简化，ChitChat 论坛没有设置版主这一职位，因此用户在发布新帖子或者添加新回复的时候不需要经过审核。</p><br><p><img src="https://images.gitbook.cn/c2d0a100-a47d-11e8-8a5b-85d5618fe6ba" alt="enter image description here"></p><br><p>图2-5　Web 应用访问数据存储系统的流程</p><br><p>在了解了 ChitChat 的设计方案之后，现在可以开始考虑具体的实现代码了。在开始学习 ChitChat 的实现代码之前，请注意，如果你在阅读本章展示的代码时遇到困难，又或者你是刚开始学习 Go 语言，那么为了更好地理解本章介绍的内容，你可以考虑先花些时间阅读一本 Go 语言的编程入门书，比如，由 William Kennedy、Brian Ketelsen 和 Erik St. Martin 撰写的《Go 语言实战》就是一个很不错的选择。</p><br><p>除此之外，在阅读本章时也请尽量保持耐性：本章只是从宏观的角度展示 Go Web 应用的样子，并没有对 Web 应用的细节作过多的解释，而是将这些细节留到之后的章节再进一步说明。在有需要的情况下，本章也会在介绍某种技术的同时，说明在哪一章可以找到这一技术的更多相关信息。</p><br><h3 id="24">2.4　请求的接收与处理</h3><br><p>请求的接收和处理是所有 Web 应用的核心。正如之前所说，Web 应用的工作流程如下。</p><br><p>（1）客户端将请求发送到服务器的一个 URL 上。</p><br><p>（2）服务器的多路复用器将接收到的请求重定向到正确的处理器，然后由该处理器对请求进行处理。</p><br><p>（3）处理器处理请求并执行必要的动作。</p><br><p>（4）处理器调用模板引擎，生成相应的 HTML 并将其返回给客户端。</p><br><p>让我们先从最基本的根 URL（<code>/</code>）来考虑 Web 应用是如何处理请求的：当我们在浏览器上输入地址<code><a href="http://localhost" target="_blank" rel="noopener">http://localhost</a></code>的时候，浏览器访问的就是应用的根 URL。在接下来的几个小节里面，我们将会看到 ChitChat 是如何处理发送至根 URL 的请求的，以及它又是如何通过动态地生成 HTML 来对请求进行响应的。</p><br><h4 id="241">2.4.1　多路复用器</h4><br><p>因为编译后的二进制 Go 应用总是以<code>main</code>函数作为执行的起点，所以我们在对 Go 应用进行介绍的时候也总是从包含<code>main</code>函数的主源码文件（main source code file）开始。ChitChat 应用的主源码文件为<code>main.go</code>，代码清单2-1展示了它的一个简化版本。</p><br><p>代码清单2-1　<code>main.go</code>文件中的<code>main</code>函数，函数中的代码经过了简化</p><br><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-title">import</span> <span class="hljs-params">(<br>　<span class="hljs-string">“net/http”</span><br>)</span><br><br>func <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><br>　mux := http.NewServeMux()<br>　files := http.FileServer(http.Dir(<span class="hljs-string">“/public”</span>))<br>　mux.Handle(<span class="hljs-string">“/static/“</span>, http.StripPrefix(<span class="hljs-string">“/static/“</span>, files))<br><br>　　mux.HandleFunc(<span class="hljs-string">“/“</span>, index)<br><br>　server := &amp;http.Server{<br>　　Addr: <span class="hljs-string">“0.0.0.0:8080”</span>,<br>　　Handler: mux,<br>　}<br>　server.ListenAndServe()<br>}<br></code></pre><br><p><code>main.go</code>中首先创建了一个多路复用器，然后通过一些代码将接收到的请求重定向到处理器。<code>net/http</code>标准库提供了一个默认的多路复用器，这个多路复用器可以通过调用<code>NewServeMux</code>函数来创建：</p><br><pre><code class="hljs makefile">mux := http.NewServeMux()<br></code></pre><br><p>为了将发送至根 URL 的请求重定向到处理器，程序使用了<code>HandleFunc</code>函数：</p><br><pre><code class="hljs perl">mux.HandleFunc(<span class="hljs-string">“/“</span>, <span class="hljs-keyword">index</span>)<br></code></pre><br><p><code>HandleFunc</code>函数接受一个 URL 和一个处理器的名字作为参数，并将针对给定 URL 的请求转发至指定的处理器进行处理，因此对上述调用来说，当有针对根 URL 的请求到达时，该请求就会被重定向到名为<code>index</code>的处理器函数。此外，因为所有处理器都接受一个<code>ResponseWriter</code>和一个指向<code>Request</code>结构的指针作为参数，并且所有请求参数都可以通过访问<code>Request</code>结构得到，所以程序并不需要向处理器显式地传入任何请求参数。</p><br><p>需要注意的是，前面的介绍模糊了处理器以及处理器函数之间的区别：我们刚开始谈论的是处理器，而现在谈论的却是处理器函数。这是有意而为之的——尽管处理器和处理器函数提供的最终结果是一样的，但它们实际上并不相同。本书的第3章将对处理器和处理器函数之间的区别做进一步的说明，但是现在让我们暂时先忘掉这件事，继续研究 ChitChat 应用的代码实现。</p><br><h4 id="242">2.4.2　服务静态文件</h4><br><p>除负责将请求重定向到相应的处理器之外，多路复用器还需要为静态文件提供服务。为了做到这一点，程序使用<code>FileServer</code>函数创建了一个能够为指定目录中的静态文件服务的处理器，并将这个处理器传递给了多路复用器的<code>Handle</code>函数。除此之外，程序还使用<code>StripPrefix</code>函数去移除请求 URL 中的指定前缀：</p><br><pre><code class="hljs nginx"><span class="hljs-attribute">files</span> := http.FileServer(http.Dir(<span class="hljs-string">“/public”</span>))<br>mux.Handle(<span class="hljs-string">“/static/“</span>, http.StripPrefix(<span class="hljs-string">“/static/“</span>, files))<br></code></pre><br><p>当服务器接收到一个以<code>/static/</code>开头的 URL 请求时，以上两行代码会移除 URL 中的<code>/static/</code>字符串，然后在<code>public</code>目录中查找被请求的文件。比如说，当服务器接收到一个针对文件<code><a href="http://localhost/static/css/bootstrap.min.css" target="_blank" rel="noopener">http://localhost/static/css/bootstrap.min.css</a></code>的请求时，它将会在<code>public</code>目录中查找以下文件：</p><br><pre><code class="hljs javascript">&lt;application root&gt;<span class="hljs-regexp">/css/</span>bootstrap.min.css<br></code></pre><br><p>当服务器成功地找到这个文件之后，会把它返回给客户端。</p><br><h4 id="243">2.4.3　创建处理器函数</h4><br><p>正如之前的小节所说，ChitChat 应用会通过<code>HandleFunc</code>函数把请求重定向到处理器函数。正如代码清单2-2所示，处理器函数实际上就是一个接受<code>ResponseWriter</code>和<code>Request</code>指针作为参数的 Go 函数。</p><br><p>代码清单2-2　<code>main.go</code>文件中的<code>index</code>处理器函数</p><br><pre><code class="hljs cpp"><span class="hljs-function">func <span class="hljs-title">index</span><span class="hljs-params">(w http.ResponseWriter, r <em>http.Request)</em></span> </span>{<br>　files := []<span class="hljs-built_in">string</span>{<span class="hljs-string">“templates/layout.html”</span>,<br>　　　　　　　　　　<span class="hljs-string">“templates/navbar.html”</span>,<br>　　　　　　　　　　<span class="hljs-string">“templates/index.html”</span>,}<br>　templates := <span class="hljs-keyword">template</span>.Must(<span class="hljs-keyword">template</span>.ParseFiles(files…))<br>　threads, err := data.Threads(); <span class="hljs-keyword">if</span> err == nil {<br>　　templates.ExecuteTemplate(w, <span class="hljs-string">“layout”</span>, threads)<br>　}<br>}<br></code></pre><br><p><code>index</code>函数负责生成 HTML 并将其写入<code>ResponseWriter</code>中。因为这个处理器函数会用到<code>html/template</code>标准库中的<code>Template</code>结构，所以包含这个函数的文件需要在文件的开头导入<code>html/template</code>库。之后的小节将对生成 HTML 的方法做进一步的介绍。</p><br><p>除了前面提到过的负责处理根 URL 请求的<code>index</code>处理器函数，<code>main.go</code>文件实际上还包含很多其他的处理器函数，如代码清单2-3所示。</p><br><p>代码清单2-3　ChitChat 应用的<code>main.go</code>源文件</p><br><pre><code class="hljs bash">package main<br><br>import (<br>　<span class="hljs-string">“net/http”</span><br>)<br><br>func <span class="hljs-function"><span class="hljs-title">main</span></span>() {<br><br>　mux := http.NewServeMux()<br>　files := http.FileServer(http.Dir(config.Static))<br>　mux.Handle(<span class="hljs-string">“/static/“</span>, http.StripPrefix(<span class="hljs-string">“/static/“</span>, files))<br><br>　mux.HandleFunc(<span class="hljs-string">“/“</span>, index)<br>　mux.HandleFunc(<span class="hljs-string">“/err”</span>, err)<br><br>　mux.HandleFunc(<span class="hljs-string">“/login”</span>, login)<br>　mux.HandleFunc(<span class="hljs-string">“/logout”</span>, <span class="hljs-built_in">logout</span>)<br>　mux.HandleFunc(<span class="hljs-string">“/signup”</span>, signup)<br>　mux.HandleFunc(<span class="hljs-string">“/signup_account”</span>, signupAccount)<br>　mux.HandleFunc(<span class="hljs-string">“/authenticate”</span>, authenticate)<br><br>　mux.HandleFunc(<span class="hljs-string">“/thread/new”</span>, newThread)<br>　mux.HandleFunc(<span class="hljs-string">“/thread/create”</span>, createThread)<br>　mux.HandleFunc(<span class="hljs-string">“/thread/post”</span>, postThread)<br>　mux.HandleFunc(<span class="hljs-string">“/thread/read”</span>, <span class="hljs-built_in">read</span>Thread)<br><br>　server := &amp;http.Server{<br>　　Addr:　　　　　 <span class="hljs-string">“0.0.0.0:8080”</span>,<br>　　Handler:　　　　mux,<br>　}<br>　server.ListenAndServe()<br>}<br></code></pre><br><p><code>main</code>函数中使用的这些处理器函数并没有在<code>main.go</code>文件中定义，它们的定义在其他文件里面，具体请参考 ChitChat 项目的完整源码。</p><br><p>为了在一个文件里面引用另一个文件中定义的函数，诸如 PHP、Ruby 和 Python 这样的语言要求用户编写代码去包含（include）被引用函数所在的文件，而另一些语言则要求用户在编译程序时使用特殊的链接（link）命令。</p><br><p>但是对 Go 语言来说，用户只需要把位于相同目录下的所有文件都设置成同一个包，那么这些文件就会与包中的其他文件分享彼此的定义。又或者，用户也可以把文件放到其他独立的包里面，然后通过导入（import）这些包来使用它们。比如，ChitChat 论坛就把连接数据库的代码放到了独立的包里面，我们很快就会看到这一点。</p><br><h4 id="244cookie">2.4.4　使用 cookie 进行访问控制</h4><br><p>跟其他很多 Web 应用一样，ChitChat 既拥有任何人都可以访问的公开页面，也拥有用户在登录账号之后才能看见的私人页面。</p><br><p>当一个用户成功登录以后，服务器必须在后续的请求中标示出这是一个已登录的用户。为了做到这一点，服务器会在响应的首部中写入一个 cookie，而客户端在接收这个 cookie 之后则会把它存储到浏览器里面。代码清单2-4展示了<code>authenticate</code>处理器函数的实现代码，这个函数定义在<code>route_auth.go</code>文件中，它的作用就是对用户的身份进行验证，并在验证成功之后向客户端返回一个 cookie。</p><br><p>代码清单2-4 <code> route_auth.go</code>文件中的<code>authenticate</code>处理器函数</p><br><pre><code class="hljs cpp"><span class="hljs-function">func <span class="hljs-title">authenticate</span><span class="hljs-params">(w http.ResponseWriter, r http.Request)</span> </span>{<br>　r.ParseForm()<br>　user, _ := data.UserByEmail(r.PostFormValue(<span class="hljs-string">“email”</span>))<br>　<span class="hljs-keyword">if</span> user.Password == data.Encrypt(r.PostFormValue(<span class="hljs-string">“password”</span>)) {<br>　　session := user.CreateSession()<br>　　cookie := http.Cookie{<br>　　　Name: <span class="hljs-string">“_cookie”</span>,<br>　　　Value: session.Uuid,<br>　　　HttpOnly: <span class="hljs-literal">true</span>,<br>　　}<br>　　http.SetCookie(w, &amp;cookie)<br>　　http.Redirect(w, r, <span class="hljs-string">“/“</span>, <span class="hljs-number">302</span>)<br>　} <span class="hljs-keyword">else</span> {<br>　　http.Redirect(w, r, <span class="hljs-string">“/login”</span>, <span class="hljs-number">302</span>)<br>　}<br>}<br></code></pre><br><p>注意，代码清单2-4中的<code>authenticate</code>函数使用了两个我们尚未介绍过的函数，一个是<code>data.Encrypt</code>，而另一个则是<code>data.UserbyEmail</code>。因为本节关注的是 ChitChat 论坛的访问控制机制而不是数据处理方法，所以本节将不会对这两个函数的实现细节进行解释，但这两个函数的名字已经很好地说明了它们各自的作用：<code>data.UserByEmail</code>函数通过给定的电子邮件地址获取与之对应的<code>User</code>结构，而<code>data.Encrypt</code>函数则用于加密给定的字符串。本章稍后将会对<code>data</code>包作更详细的介绍，但是在此之前，让我们回到对访问控制机制的讨论上来。</p><br><p>在验证用户身份的时候，程序必须先确保用户是真实存在的，并且提交给处理器的密码在加密之后跟存储在数据库里面的已加密用户密码完全一致。在核实了用户的身份之后，程序会使用<code>User</code>结构的<code>CreateSession</code>方法创建一个<code>Session</code>结构，该结构的定义如下：</p><br><pre><code class="hljs cpp">type Session <span class="hljs-keyword">struct</span> {<br>　Id　　　　<span class="hljs-keyword">int</span><br>　Uuid　　　<span class="hljs-built_in">string</span><br>　Email　　 <span class="hljs-built_in">string</span><br>　UserId　　<span class="hljs-keyword">int</span><br>　CreatedAt time.Time<br>}<br></code></pre><br><p><code>Session</code>结构中的<code>Email</code>字段用于存储用户的电子邮件地址，而<code>UserId</code>字段则用于记录用户表中存储用户信息的行的 ID。<code>Uuid</code>字段存储的是一个随机生成的唯一 ID，这个 ID 是实现会话机制的核心，服务器会通过 cookie 把这个 ID 存储到浏览器里面，并把<code>Session</code>结构中记录的各项信息存储到数据库中。</p><br><p>在创建了<code>Session</code>结构之后，程序又创建了<code>Cookie</code>结构：</p><br><pre><code class="hljs bash">cookie := http.Cookie{<br>　Name:　　　<span class="hljs-string">“_cookie”</span>,<br>　Value:　　 session.Uuid,<br>　HttpOnly:　<span class="hljs-literal">true</span>,<br>}<br></code></pre><br><p>cookie 的名字是随意设置的，而 cookie 的值则是将要被存储到浏览器里面的唯一 ID。因为程序没有给 cookie 设置过期时间，所以这个 cookie 就成了一个会话 cookie，它将在浏览器关闭时自动被移除。此外，程序将<code>HttpOnly</code>字段的值设置成了<code>true</code>，这意味着这个 cookie 只能通过 HTTP 或者 HTTPS 访问，但是却无法通过 JavaScript 等非 HTTP API 进行访问。</p><br><p>在设置好 cookie 之后，程序使用以下这行代码，将它添加到了响应的首部里面：</p><br><pre><code class="hljs css"><span class="hljs-selector-tag">http</span><span class="hljs-selector-class">.SetCookie</span>(<span class="hljs-selector-tag">writer</span>, &amp;<span class="hljs-selector-tag">cookie</span>)<br></code></pre><br><p>在将 cookie 存储到浏览器里面之后，程序接下来要做的就是在处理器函数里面检查当前访问的用户是否已经登录。为此，我们需要创建一个名为<code>session</code>的工具（utility）函数，并在各个处理器函数里面复用它。代码清单2-5展示了<code>session</code>函数的实现代码，跟其他工具函数一样，这个函数也是在<code>util.go</code>文件里面定义的。再提醒一下，虽然程序把工具函数的定义都放在了<code>util.go</code>文件里面，但是因为<code>util.go</code>文件也隶属于<code>main</code>包，所以这个文件里面定义的所有工具函数都可以直接在整个<code>main</code>包里面调用，而不必像<code>data.Encrypt</code>函数那样需要先引入包然后再调用。</p><br><p>代码清单2-5　<code>util.go</code>文件中的<code>session</code>工具函数</p><br><pre><code class="hljs cpp"><span class="hljs-function">func <span class="hljs-title">session</span><span class="hljs-params">(w http.ResponseWriter, r <em>http.Request)</em></span><span class="hljs-params">(sess data.Session, err<br>　error)</span></span>{<br>　cookie, err := r.Cookie(<span class="hljs-string">“_cookie”</span>)<br>　<span class="hljs-keyword">if</span> err == nil {<br>　　sess = data.Session{Uuid: cookie.Value}<br>　　<span class="hljs-keyword">if</span> ok, _ := sess.Check(); !ok {<br>　　　err = errors.New(<span class="hljs-string">“Invalid session”</span>)<br>　　}<br>　}<br>　<span class="hljs-keyword">return</span><br>}<br></code></pre><br><p>为了从请求中取出 cookie，<code>session</code>函数使用了以下代码：</p><br><pre><code class="hljs apache"><span class="hljs-attribute">cookie</span>, err := r.Cookie(<span class="hljs-string">“_cookie”</span>)<br></code></pre><br><p>如果 cookie 不存在，那么很明显用户并未登录；相反，如果 cookie 存在，那么<code>session</code>函数将继续进行第二项检查——访问数据库并核实会话的唯一 ID 是否存在。第二项检查是通过<code>data.Session</code>函数完成的，这个函数会从 cookie 中取出会话并调用后者的<code>Check</code>方法：</p><br><pre><code class="hljs php">sess = data.Session{Uuid: cookie.Value}<br><span class="hljs-keyword">if</span> ok, _ := sess.Check(); !ok {<br>　err = errors.<span class="hljs-keyword">New</span>(<span class="hljs-string">“Invalid session”</span>)<br>}<br></code></pre><br><p>在拥有了检查和识别已登录用户和未登录用户的能力之后，让我们来回顾一下之前展示的<code>index</code>处理器函数，代码清单2-6中被加粗的代码行展示了这个处理器函数是如何使用<code>session</code>函数的。</p><br><p>代码清单2-6　<code>index</code>处理器函数</p><br><pre><code class="hljs cpp"><span class="hljs-function">func <span class="hljs-title">index</span><span class="hljs-params">(w http.ResponseWriter, r http.Request)</span> </span>{<br>　threads, err := data.Threads(); <span class="hljs-keyword">if</span> err == nil {<br>　　, err := session(w, r)<br>　　public_tmpl_files := []<span class="hljs-built_in">string</span>{<span class="hljs-string">“templates/layout.html”</span>,<br>　　　　　　　　　　　　　　　　　<span class="hljs-string">“templates/public.navbar.html”</span>,<br>　　　　　　　　　　　　　　　　　<span class="hljs-string">“templates/index.html”</span>}<br>　　private_tmpl_files := []<span class="hljs-built_in">string</span>{<span class="hljs-string">“templates/layout.html”</span>,<br>　　　　　　　　　　　　　　　　　 <span class="hljs-string">“templates/private.navbar.html”</span>,<br>　　　　　　　　　　　　　　　　　 <span class="hljs-string">“templates/index.html”</span>}<br>　　var templates <em><span class="hljs-keyword">template</span>.Template<br>　　<span class="hljs-keyword">if</span> err != nil {<br>　　　templates = <span class="hljs-keyword">template</span>.Must(<span class="hljs-keyword">template</span>.Parse-<br>　Files(private_tmpl_files…))<br>　　} <span class="hljs-keyword">else</span> {<br>　　　templates = <span class="hljs-keyword">template</span>.Must(<span class="hljs-keyword">template</span>.ParseFiles(public_tmpl_files…))<br>　　}<br>　　templates.ExecuteTemplate(w, <span class="hljs-string">“layout”</span>, threads)<br>　}<br>}<br></em></code></pre><br><p>通过调用<code>session</code>函数可以取得一个存储了用户信息的<code>Session</code>结构，不过因为<code>index</code>函数目前并不需要这些信息，所以它使用空白标识符（blank identifier）（_）忽略了这一结构。<code>index</code>函数真正感兴趣的是<code>err</code>变量，程序会根据这个变量的值来判断用户是否已经登录，然后以此来选择是使用<code>public</code>导航条还是使用<code>private</code>导航条。</p><br><p>好的，关于 ChitChat 应用处理请求的方法就介绍到这里了。本章接下来会继续讨论如何为客户端生成 HTML，并完整地叙述之前没有说完的部分。</p><br><h3 id="25html">2.5　使用模板生成 HTML 响应</h3><br><p><code>index</code>处理器函数里面的大部分代码都是用来为客户端生成 HTML 的。首先，函数把每个需要用到的模板文件都放到了 Go 切片里面（这里展示的是私有页面的模板文件，公开页面的模板文件也是以同样方式进行组织的）：</p><br><pre><code class="hljs cpp">private_tmpl_files := []<span class="hljs-built_in">string</span>{<span class="hljs-string">“templates/layout.html”</span>,<br>　　　　　　　　　　　　　　　 <span class="hljs-string">“templates/private.navbar.html”</span>,<br>　　　　　　　　　　　　　　　 <span class="hljs-string">“templates/index.html”</span>}<br></code></pre><br><p>跟 Mustache 和 CTemplate 等其他模板引擎一样，切片指定的这3个 HTML 文件都包含了特定的嵌入命令，这些命令被称为动作（action），动作在 HTML 文件里面会被<code>{{</code>符号和<code>}}</code>符号包围。</p><br><p>接着，程序会调用<code>ParseFiles</code>函数对这些模板文件进行语法分析，并创建出相应的模板。为了捕捉语法分析过程中可能会产生的错误，程序使用了<code>Must</code>函数去包围<code>ParseFiles</code>函数的执行结果，这样当<code>ParseFiles</code>返回错误的时候，<code>Must</code>函数就会向用户返回相应的错误报告：</p><br><pre><code class="hljs cpp">templates := <span class="hljs-keyword">template</span>.Must(<span class="hljs-keyword">template</span>.ParseFiles(private_tmpl_files…))<br></code></pre><br><p>好的，关于模板文件的介绍已经足够多了，现在是时候来看看它们的庐山真面目了。</p><br><p>ChitChat 论坛的每个模板文件都定义了一个模板，这种做法并不是强制的，用户也可以在一个模板文件里面定义多个模板，但模板文件和模板一一对应的做法可以给开发带来方便，我们在之后就会看到这一点。代码清单2-7展示了<code>layout.html</code>模板文件的源代码，源代码中使用了<code>define</code>动作，这个动作通过文件开头的<code>{{ define "layout" }}</code>和文件末尾的<code>{{ end }}</code>，把被包围的文本块定义成了<code>layout</code>模板的一部分。</p><br><p>代码清单2-7　<code>layout.html</code>模板文件</p><br><pre><code class="hljs xml">{{ define "layout" }}<br><br><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">“en”</span>&gt;</span><br>　<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>　　<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">“utf-8”</span>&gt;</span><br>　　<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">“X-UA-Compatible”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">“IE=9”</span>&gt;</span><br>　　<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">“viewport”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">“width=device-width, initial-scale=1”</span>&gt;</span><br>　　<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>ChitChat<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>　　<span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">“/static/css/bootstrap.min.css”</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">“stylesheet”</span>&gt;</span><br>　　<span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">“/static/css/font-awesome.min.css”</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">“stylesheet”</span>&gt;</span><br>　<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>　<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>　　{{ template "navbar" . }}<br><br>　　<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">“container”</span>&gt;</span><br><br>　　　{{ template "content" . }}<br><br>　　<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-comment">&lt;!– /container –&gt;</span><br><br>　　<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">“/static/js/jquery-2.1.1.min.js”</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>　　<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">“/static/js/bootstrap.min.js”</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>　<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br>{{ end }}<br></code></pre><br><p>除了<code>define</code>动作之外，<code>layout.html</code>模板文件里面还包含了两个用于引用其他模板文件的<code>template</code>动作。跟在被引用模板名字之后的点（<code>.</code>）代表了传递给被引用模板的数据，比如<code>{{ template "navbar" . }}</code>语句除了会在语句出现的位置引入<code>navbar</code>模板之外，还会将传递给<code>layout</code>模板的数据传递给<code>navbar</code>模板。</p><br><p>代码清单2-8展示了<code>public.navbar.html</code>模板文件中的<code>navbar</code>模板，除了定义模板自身的<code>define</code>动作之外，这个模板没有包含其他动作（严格来说，模板也可以不包含任何动作）。</p><br><p>代码清单2-8　<code>public.navbar.html</code>模板文件</p><br><pre><code class="hljs xml">{{ define "navbar" }}<br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">“navbar navbar-default navbar-static-top”</span> <span class="hljs-attr">role</span>=<span class="hljs-string">“navigation”</span>&gt;</span><br>　<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">“container”</span>&gt;</span><br>　　<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">“navbar-header”</span>&gt;</span><br>　　　<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">“button”</span> <span class="hljs-attr">class</span>=<span class="hljs-string">“navbar-toggle collapsed”</span><br>　　　➥ <span class="hljs-attr">data-toggle</span>=<span class="hljs-string">“collapse”</span> <span class="hljs-attr">data-target</span>=<span class="hljs-string">“.navbar-collapse”</span>&gt;</span><br>　　　　<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">“sr-only”</span>&gt;</span>Toggle navigation<br>　　　　<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">“icon-bar”</span>&gt;</span><br>　　　　<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">“icon-bar”</span>&gt;</span><br>　　　　<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">“icon-bar”</span>&gt;</span><br>　　　<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>　　　<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">“navbar-brand”</span> <span class="hljs-attr">href</span>=<span class="hljs-string">“/“</span>&gt;</span><br>　　　　<span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">“fa fa-comments-o”</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br>　　　　ChitChat<br>　　　<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>　　<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>　　<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">“navbar-collapse collapse”</span>&gt;</span><br>　　　<span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">“nav navbar-nav”</span>&gt;</span><br>　　　　<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">“/“</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>　　　<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>　　　<span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">“nav navbar-nav navbar-right”</span>&gt;</span><br>　　　　<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">“/login”</span>&gt;</span>Login<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>　　　<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>　　<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>　<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>{{ end }}<br></code></pre><br><p>最后，让我们来看看定义在<code>index.html</code>模板文件中的<code>content</code>模板，代码清单2-9展示了这个模板的源代码。注意，尽管之前展示的两个模板都与模板文件拥有相同的名字，但实际上模板和模板文件分别拥有不同的名字也是可行的。</p><br><p>代码清单2-9　<code>index.html</code>模板文件</p><br><pre><code class="hljs javascript">{{ define <span class="hljs-string">"content"</span> }}<br><br>&lt;p <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">“lead”</span>&gt;<br>　<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">“/thread/new”</span>&gt;</span>Start a thread<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span> or join one below!<br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><br>{{ range . }}<br>　&lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">“panel panel-default”</span>&gt;<br>　　<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">“panel-heading”</span>&gt;</span><br>　　　<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">“lead”</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">“fa fa-comment-o”</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> {{ .Topic }}<br>　　<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>　　<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">“panel-body”</span>&gt;</span><br>　　　Started by {{ .User.Name }} - {{ .CreatedAtDate }} - {{ .NumReplies }}<br>　posts.<br>　　　<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">“pull-right”</span>&gt;</span><br>　　　　<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">“/thread/read?id={{.Uuid }}“</span>&gt;</span>Read more<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>　　　<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>　　<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>　<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>{{ end }}<br><br>{{ end }}<br></code></pre><br><p><code>index.html</code>文件里面的代码非常有趣，特别值得一提的是文件里面包含了几个以点号（<code>.</code>）开头的动作，比如<code>{{ .User.Name }}</code>和<code>{{ .CreatedAtDate }}</code>，这些动作的作用和之前展示过的<code>index</code>处理器函数有关：</p><br><pre><code class="hljs objectivec">threads, err := data.Threads(); <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> {<br>　templates.ExecuteTemplate(writer, <span class="hljs-string">“layout”</span>, threads)<br>}<br></code></pre><br><p>在以下这行代码中：</p><br><pre><code class="hljs apache"><span class="hljs-attribute">templates</span>.ExecuteTemplate(writer, <span class="hljs-string">“layout”</span>, threads)<br></code></pre><br><p>程序通过调用<code>ExecuteTemplate</code>函数，执行（execute）已经经过语法分析的<code>layout</code>模板。执行模板意味着把模板文件中的内容和来自其他渠道的数据进行合并，然后生成最终的 HTML 内容，具体过程如图2-6所示。</p><br><p><img src="https://images.gitbook.cn/e056c3d0-a47d-11e8-8b4a-cf3651600922" alt="enter image description here"></p><br><p>图2-6　模板引擎通过合并数据和模板来生成 HTML</p><br><p>程序之所以对<code>layout</code>模板而不是<code>navbar</code>模板或者<code>content</code>模板进行处理，是因为<code>layout</code>模板已经引用了其他两个模板，所以执行<code>layout</code>模板就会导致其他两个模板也被执行，由此产生出预期的 HTML。但是，如果程序只执行<code>navbar</code>模板或者<code>content</code>模板，那么程序最终只会产生出预期的 HTML 的一部分。</p><br><p>现在，你应该已经明白了，点号（<code>.</code>）代表的就是传入到模板里面的数据（实际上还不仅如此，接下来的小节会对这方面做进一步的说明）。图2-7展示了程序根据模板生成的 ChitChat 论坛的样子。</p><br><p><img src="https://images.gitbook.cn/e6c09c50-a47d-11e8-a2aa-0bd41466d20f" alt="enter image description here"></p><br><p>图2-7　ChitChat Web 应用示例的主页</p><br><h4 id>整理代码</h4><br><p>因为生成 HTML 的代码会被重复执行很多次，所以我们决定对这些代码进行一些整理，并将它们移到代码清单2-10所示的<code>generateHTML</code>函数里面。</p><br><p>代码清单2-10　<code>generateHTML</code>函数</p><br><pre><code class="hljs cpp"><span class="hljs-function">func <span class="hljs-title">generateHTML</span><span class="hljs-params">(w http.ResponseWriter, data interface{}, fn …<span class="hljs-built_in">string</span>)</span> </span>{<br>　var files []<span class="hljs-built_in">string</span><br>　<span class="hljs-keyword">for</span> _, file := range fn {<br>　　files = append(files, fmt.Sprintf(<span class="hljs-string">“templates/%s.html”</span>, file))<br>　}<br>　templates := <span class="hljs-keyword">template</span>.Must(<span class="hljs-keyword">template</span>.ParseFiles(files…))<br>　templates.ExecuteTemplate(writer, <span class="hljs-string">“layout”</span>, data)<br>}<br></code></pre><br><p><code>generateHTML</code>函数接受一个<code>ResponseWriter</code>、一些数据以及一系列模板文件作为参数，然后对给定的模板文件进行语法分析。<code>data</code>参数的类型为空接口类型（empty interface type），这意味着该参数可以接受任何类型的值作为输入。刚开始接触 Go 语言的人可能会觉得奇怪——Go 不是静态编程语言吗，它为什么能够使用没有类型限制的参数？</p><br><p>但实际上，Go 程序可以通过接口（interface）机制，巧妙地绕过静态编程语言的限制，并借此获得接受多种不同类型输入的能力。Go 语言中的接口由一系列方法构成，并且每个接口就是一种类型。一个空接口就是一个空集合，这意味着任何类型都可以成为一个空接口，也就是说任何类型的值都可以传递给函数作为参数。</p><br><p><code>generateHTML</code>函数的最后一个参数以3个点（<code>…</code>）开头，它表示<code>generateHTML</code>函数是一个可变参数函数（variadic function），这意味着这个函数可以在最后的可变参数中接受零个或任意多个值作为参数。<code>generateHTML</code>函数对可变参数的支持使我们可以同时将任意多个模板文件传递给该函数。在 Go 语言里面，可变参数必须是可变参数函数的最后一个参数。</p><br><p>在实现了<code>generateHTML</code>函数之后，让我们回过头来，继续对<code>index</code>处理器函数进行整理。代码清单2-11展示了经过整理之后的<code>index</code>处理器函数，现在它看上去更整洁了。</p><br><p>代码清单2-11　<code>index</code>处理器函数的最终版本</p><br><pre><code class="hljs objectivec">func index(writer http.ResponseWriter, request http.Request) {<br>　threads, err := data.Threads(); <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> {<br>　　_, err := session(writer, request)<br>　　<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {<br>　　　generateHTML(writer, threads, <span class="hljs-string">“layout”</span>, <span class="hljs-string">“public.navbar”</span>, <span class="hljs-string">“index”</span>)<br>　　} <span class="hljs-keyword">else</span> {<br>　　　generateHTML(writer, threads, <span class="hljs-string">“layout”</span>, <span class="hljs-string">“private.navbar”</span>, <span class="hljs-string">“index”</span>)<br>　　}<br>　}<br>}<br></code></pre><br><p>在这一节中，我们学习了很多关于模板的基础知识，之后的第5章将对模板做更详细的介绍。但是在此之前，让我们先来了解一下 ChitChat 应用使用的数据源（data source），并借此了解一下 ChitChat 应用的数据是如何与模板一同生成最终的 HTML 的。</p><br><h3 id="26postgresql">2.6　安装 PostgreSQL</h3><br><p>在本章以及后续几章中，每当遇到需要访问关系数据库的场景，我们都会使用 PostgreSQL。在开始使用 PostgreSQL 之前，我们首先需要学习的是如何安装并运行 PostgreSQL，以及如何创建本章所需的数据库。</p><br><h4 id="261linuxfreebsd">2.6.1　在 Linux 或 FreeBSD 系统上安装</h4><br><p><a href="http://www.postgresql.org/download" target="_blank" rel="noopener">www.postgresql.org/download</a> 为各种不同版本的 Linux 和 FreeBSD 都提供了预编译的二进制安装包，用户只需要下载其中一个安装包，然后根据指示进行安装就可以了。比如说，通过执行以下命令，我们可以在 Ubuntu 发行版上安装 Postgres：</p><br><pre><code class="hljs cs">sudo apt-<span class="hljs-keyword">get</span> install postgresql postgresql-contrib<br></code></pre><br><p>这条命令除了会安装<code>postgres</code>包之外，还会安装附加的工具包，并在安装完毕之后启动 PostgreSQL 数据库系统。</p><br><p>在默认情况下，Postgres 会创建一个名为<code>postgres</code>的用户，并将其用于连接服务器。为了操作方便，你也可以使用自己的名字创建一个 Postgres 账号。要做到这一点，首先需要登入 Postgres 账号：</p><br><pre><code class="hljs nginx"><span class="hljs-attribute">sudo</span> su postgres<br></code></pre><br><p>接着使用<code>createuser</code>命令创建一个 PostgreSQL 账号：</p><br><pre><code class="hljs nginx"><span class="hljs-attribute">createuser</span> –interactive<br></code></pre><br><p>最后，还需要使用<code>createdb</code>命令创建以你的账号名字命名的数据库：</p><br><pre><code class="hljs xml">createdb <span class="hljs-tag">&lt;<span class="hljs-name">YOUR</span> <span class="hljs-attr">ACCOUNT</span> <span class="hljs-attr">NAME</span>&gt;</span><br></code></pre><br><h4 id="262macosx">2.6.2　在 Mac OS X 系统上安装</h4><br><p>要在 Mac OS X 上安装 PostgreSQL，最简单的方法是使用 PostgresApp.com 提供的 Postgres 应用：你只需要把网站上提供的 zip 压缩包下载下来，解压它，然后把<code>Postgres.app</code>文件拖曳到自己的<code>Applications</code>文件夹里面就可以了。启动<code>Postgres.app</code>的方法跟启动其他 Mac OS X 应用的方法完全一样。<code>Postgres.app</code>在初次启动的时候会初始化一个新的数据库集群，并为自己创建一个数据库。因为命令行工具<code>psql</code>也包含在了<code>Postgres.app</code>里面，所以在设置好正确的路径之后，你就可以使用<code>psql</code>访问数据库了。设置路径的工作可以通过在你的<code>~/.profile</code>文件或者<code>~/.bashrc</code>文件中添加以下代码行来完成<a href="#anchor21" id="ac21"><sup>[1]</sup></a>：</p><br><pre><code class="hljs ruby">export PATH=$PATH<span class="hljs-symbol">:/Applications/Postgres</span>.app/Contents/Versions/<span class="hljs-number">9.4</span>/bin<br></code></pre><br><h4 id="263windows">2.6.3　在 Windows 系统上安装</h4><br><p>因为 Windows 系统上的很多 PostgreSQL 图形安装程序都会把一切安装步骤布置妥当，用户只需要进行相应的设置就可以了，所以在 Windows 系统上安装 PostgreSQL 也是非常简单和直观的。其中一个流行的安装程序是由 Enterprise DB 提供的：<a href="http://www.enterprisedb.com/products-" target="_blank" rel="noopener">www.enterprisedb.com/products-</a> services-training/pgdownload。</p><br><p>除了 PostgreSQL 数据库本身之外，安装包还会附带诸如 pgAdmin 等工具，以便用户通过这些工具进行后续的配置。</p><br><h3 id="27">2.7　连接数据库</h3><br><p>本章前面在展示 ChitChat 应用的设计方案时，曾经提到过 ChitChat 应用包含了4种数据结构。虽然把这4种数据结构放到主源码文件里面也是可以的，但更好的办法是把所有与数据相关的代码都放到另一个包里面——ChitChat 应用的<code>data</code>包也因此应运而生。</p><br><p>为了创建<code>data</code>包，我们首先需要创建一个名为<code>data</code>的子目录，并创建一个用于保存所有帖子相关代码的<code>thread.go</code>文件（在之后的小节里面，我们还会创建一个用于保存所有用户相关代码的<code>user.go</code>文件）。在此之后，每当程序需要用到<code>data</code>包的时候（比如处理器需要访问数据库的时候），程序都需要通过<code>import</code>语句导入这个包：</p><br><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> (<br>　<span class="hljs-string">“github.com/sausheong/gwp/Chapter_2_Go_ChitChat/chitchat/data”</span><br>)<br></code></pre><br><p>代码清单2-12展示了定义在<code>thread.go</code>文件里面的<code>Thread</code>结构，这个结构存储了与帖子有关的各种信息。</p><br><p>代码清单2-12　定义在<code>thread.go</code>文件里面的<code>Thread</code>结构</p><br><pre><code class="hljs cpp"><span class="hljs-function">package data<br><br><span class="hljs-title">import</span><span class="hljs-params">(<br>　<span class="hljs-string">“time”</span><br>)</span><br>type Thread <span class="hljs-keyword">struct</span> </span>{<br>　Id　　　　<span class="hljs-keyword">int</span><br>　Uuid　　　<span class="hljs-built_in">string</span><br>　Topic　　 <span class="hljs-built_in">string</span><br>　UserId　　<span class="hljs-keyword">int</span><br>　CreatedAt time.Time<br>}<br></code></pre><br><p>正如代码清单2-12中加粗显示的代码行所示，文件的包名现在是<code>data</code>而不再是<code>main</code>了，这个包就是前面小节中我们曾经见到过的<code>data</code>包。<code>data</code>包除了包含与数据库交互的结构和代码，还包含了一些与数据处理密切相关的函数。隶属于其他包的程序在引用<code>data</code>包中定义的函数、结构或者其他东西时，必须在被引用元素的名字前面显式地加上<code>data</code>这个包名。比如说，引用<code>Thread</code>结构就需要使用<code>data.Thread</code>这个名字，而不能仅仅使用<code>Thread</code>这个名字。</p><br><p><code>Thread</code>结构应该与创建关系数据库表<code>threads</code>时使用的数据定义语言（Data Definition Language，DDL）保持一致。因为<code>threads</code>表目前尚未存在，所以我们必须创建这个表以及容纳该表的数据库。创建<code>chitchat</code>数据库的工作可以通过执行以下命令来完成：</p><br><pre><code class="hljs nginx"><span class="hljs-attribute">createdb</span> chitchat<br></code></pre><br><p>在创建数据库之后，我们就可以通过代码清单2-13展示的<code>setup.sql</code>文件为 ChitChat 论坛创建相应的数据库表了。</p><br><p>代码清单2-13　用于在 PostgreSQL 里面创建数据库表的<code>setup.sql</code>文件</p><br><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">users</span> (<br>　<span class="hljs-keyword">id</span>　　　　 <span class="hljs-built_in">serial</span> primary <span class="hljs-keyword">key</span>,<br>　<span class="hljs-keyword">uuid</span>　　　 <span class="hljs-built_in">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span> <span class="hljs-keyword">unique</span>,<br>　<span class="hljs-keyword">name</span>　　　 <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>),<br>　email　　　<span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span> <span class="hljs-keyword">unique</span>,<br>　<span class="hljs-keyword">password</span>　 <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>,<br>　created_at <span class="hljs-keyword">timestamp</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span><br>);<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> sessions (<br>　<span class="hljs-keyword">id</span>　　　　 <span class="hljs-built_in">serial</span> primary <span class="hljs-keyword">key</span>,<br>　<span class="hljs-keyword">uuid</span>　　　 <span class="hljs-built_in">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span> <span class="hljs-keyword">unique</span>,<br>　email　　　<span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>),<br>　user_id　　<span class="hljs-built_in">integer</span> <span class="hljs-keyword">references</span> <span class="hljs-keyword">users</span>(<span class="hljs-keyword">id</span>),<br>　created_at <span class="hljs-keyword">timestamp</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span><br>);<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> threads (<br>　<span class="hljs-keyword">id</span>　　　　 <span class="hljs-built_in">serial</span> primary <span class="hljs-keyword">key</span>,<br>　<span class="hljs-keyword">uuid</span>　　　 <span class="hljs-built_in">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span> <span class="hljs-keyword">unique</span>,<br>　topic　　　<span class="hljs-built_in">text</span>,<br>　user_id　　<span class="hljs-built_in">integer</span> <span class="hljs-keyword">references</span> <span class="hljs-keyword">users</span>(<span class="hljs-keyword">id</span>),<br>　created_at <span class="hljs-keyword">timestamp</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span><br>);<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> posts (<br>　<span class="hljs-keyword">id</span>　　　　 <span class="hljs-built_in">serial</span> primary <span class="hljs-keyword">key</span>,<br>　<span class="hljs-keyword">uuid</span>　　　 <span class="hljs-built_in">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span> <span class="hljs-keyword">unique</span>,<br>　<span class="hljs-keyword">body</span>　　　 <span class="hljs-built_in">text</span>,<br>　user_id　　<span class="hljs-built_in">integer</span> <span class="hljs-keyword">references</span> <span class="hljs-keyword">users</span>(<span class="hljs-keyword">id</span>),<br>　thread_id　<span class="hljs-built_in">integer</span> <span class="hljs-keyword">references</span> threads(<span class="hljs-keyword">id</span>),<br>　created_at <span class="hljs-keyword">timestamp</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span><br>);<br></code></pre><br><p>运行这个脚本需要用到<code>psql</code>工具，正如上一节所说，这个工具通常会随着 PostgreSQL 一同安装，所以你只需要在终端里面执行以下命令就可以了：</p><br><pre><code class="hljs css"><span class="hljs-selector-tag">psql</span> –<span class="hljs-selector-tag">f</span> <span class="hljs-selector-tag">setup</span><span class="hljs-selector-class">.sql</span> –<span class="hljs-selector-tag">d</span> <span class="hljs-selector-tag">chitchat</span><br></code></pre><br><p>如果一切正常，那么以上命令将在<code>chitchat</code>数据库中创建出相应的表。在拥有了表之后，程序就必须考虑如何与数据库进行连接以及如何对表进行操作了。为此，程序创建了一个名为<code>Db</code>的全局变量，这个全局变量是一个指针，指向的是代表数据库连接池的<code>sql.DB</code>，而后续的代码则会使用这个<code>Db</code>变量来执行数据库查询操作。代码清单2-14展示了<code>Db</code>变量在<code>data.go</code>文件中的定义，此外还展示了一个用于在 Web 应用启动时对<code>Db</code>变量进行初始化的<code>init</code>函数。</p><br><p>代码清单2-14 <code>data.go</code>文件中的<code>Db</code>全局变量以及<code>init</code>函数</p><br><pre><code class="hljs cpp">Var Db <em>sql.<span class="hljs-function">DB<br><br>func <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>{<br>　var err error<br>　Db, err = sql.Open(<span class="hljs-string">“postgres”</span>, <span class="hljs-string">“dbname=chitchat sslmode=disable”</span>)<br>　<span class="hljs-keyword">if</span> err != nil {<br>　　<span class="hljs-built_in">log</span>.Fatal(err)<br>　}<br>　<span class="hljs-keyword">return</span><br>}<br></em></code></pre><br><p>现在程序已经拥有了结构、表以及一个指向数据库连接池的指针，接下来要考虑的是如何连接（connect）<code>Thread</code>结构和<code>threads</code>表。幸运的是，要做到这一点并不困难：跟 ChitChat 应用的其他部分一样，我们只需要创建能够在结构和数据库之间互动的函数就可以了。例如，为了从数据库里面取出所有帖子并将其返回给<code>index</code>处理器函数，我们可以使用<code>thread.go</code>文件中定义的<code>Threads</code>函数，代码清单2-15给出了这个函数的定义。</p><br><p>代码清单2-15 <code>threads.go</code>文件中定义的<code>Threads</code>函数</p><br><pre><code class="hljs ruby">func Threads() (threads []Thread, err error){<br>　rows, err <span class="hljs-symbol">:</span>= Db.Query(<span class="hljs-string">“SELECT id, uuid, topic, user_id, created_at FROM<br>　threads ORDER BY created_at DESC”</span>)<br>　<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {<br>　　<span class="hljs-keyword">return</span><br>　}<br>　<span class="hljs-keyword">for</span> rows.Next() {<br>　　th <span class="hljs-symbol">:</span>= Thread{}<br>　　<span class="hljs-keyword">if</span> err = rows.Scan(&amp;th.Id, &amp;th.Uuid, &amp;th.Topic, &amp;th.UserId,<br>　　➥&amp;th.CreatedAt); err != <span class="hljs-literal">nil</span> {<br>　　　<span class="hljs-keyword">return</span><br>　　}<br>　　threads = append(threads, th)<br>　}<br>　rows.Close()<br>　<span class="hljs-keyword">return</span><br>}<br></code></pre><br><p>简单来讲，<code>Threads</code>函数执行了以下工作：</p><br><p>（1）通过数据库连接池与数据库进行连接；</p><br><p>（2）向数据库发送一个 SQL 查询，这个查询将返回一个或多个行作为结果；</p><br><p>（3）遍历行，为每个行分别创建一个<code>Thread</code>结构，首先使用这个结构去存储行中记录的帖子数据，然后将存储了帖子数据的<code>Thread</code>结构追加到传入的<code>threads</code>切片里面；</p><br><p>（4）重复执行步骤3，直到查询返回的所有行都被遍历完毕为止。</p><br><p>本书的第6章将对数据库操作的细节做进一步的介绍。</p><br><p>在了解了如何将数据库表存储的帖子数据提取到<code>Thread</code>结构里面之后，我们接下来要考虑的就是如何在模板里面展示<code>Thread</code>结构存储的数据了。在代码清单2-9中展示的 index.html 模板文件，有这样一段代码：</p><br><pre><code class="hljs javascript">{{ range . }}<br>　&lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">“panel panel-default”</span>&gt;<br>　　<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">“panel-heading”</span>&gt;</span><br>　　　<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">“lead”</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">“fa fa-comment-o”</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> {{ .Topic }}<br>　　<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>　　<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">“panel-body”</span>&gt;</span><br>　　　Started by {{ .User.Name }} - {{ .CreatedAtDate }} - {{ .NumReplies }}<br>　posts.<br>　　　<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">“pull-right”</span>&gt;</span><br>　　　　<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">“/thread/read?id={{.Uuid }}“</span>&gt;</span>Read more<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>　　　<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>　　<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>　<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>{{ end }}<br></code></pre><br><p>正如之前所说，模板动作中的点号（<code>.</code>）代表传入模板的数据，它们会和模板一起生成最终的结果，而<code>{{ range . }}</code>中的<code>.</code>号代表的是程序在稍早之前通过<code>Threads</code>函数取得的<code>threads</code>变量，也就是一个由<code>Thread</code>结构组成的切片。</p><br><p><code>range</code>动作假设传入的数据要么是一个由结构组成的切片，要么是一个由结构组成的数组，这个动作会遍历传入的每个结构，而用户则可以通过字段名访问结构里面的字段，比如，动作<code>{{ .Topic }}</code>访问的是<code>Thread</code>结构的<code>Topic</code>字段。注意，在访问字段时必须在字段名的前面加上点号，并且字段名的首字母必须大写。</p><br><p>用户除可以在字段名的前面加上点号来访问结构中的字段以外，还可以通过相同的方法调用一种名为方法（method）的特殊函数。比如，在上面展示的代码中，<code>{{ .User.Name }}</code>、<code>{{ .CreatedAtDate }}</code>和<code>{{ .NumReplies }}</code>这些动作的作用就是调用结构中的同名方法，而不是访问结构中的字段。</p><br><p>方法是隶属于特定类型的函数，指针、接口以及包括结构在内的所有具名类型都可以拥有自己的方法。比如说，通过将函数与指向<code>Thread</code>结构的指针进行绑定，可以创建出一个针对<code>Thread</code>结构的方法，而传入方法里面的<code>Thread</code>结构则称为接收者（receiver）：方法可以访问接收者，也可以修改接收者。</p><br><p>作为例子，代码清单2-16展示了<code>NumReplies</code>方法的实现代码。</p><br><p>代码清单2-16 <code>thread.go</code>文件中的<code>NumReplies</code>方法</p><br><pre><code class="hljs objectivec">func (thread Thread) NumReplies() (count <span class="hljs-keyword">int</span>) {<br>　rows, err := Db.Query(<span class="hljs-string">“SELECT count(*) FROM posts where thread_id = $1”</span>,<br>　thread.Id)<br>　<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {<br>　　<span class="hljs-keyword">return</span><br>　}<br>　<span class="hljs-keyword">for</span> rows.Next() {<br>　　<span class="hljs-keyword">if</span> err = rows.Scan(&amp;count); err != <span class="hljs-literal">nil</span> {<br>　　　<span class="hljs-keyword">return</span><br>　　}<br>　}<br>　rows.Close()<br>　<span class="hljs-keyword">return</span><br>}<br></code></pre><br><p><code>NumReplies</code>方法首先打开一个指向数据库的连接，接着通过执行一条 SQL 查询来取得帖子的数量，并使用传入方法里面的<code>count</code>参数来记录这个值。最后，<code>NumReplies</code>方法返回帖子的数量作为方法的执行结果，而模板引擎则使用这个值去代替模板文件中出现的<code>{{ .NumReplies }}</code>动作。</p><br><p>通过为<code>User</code>、<code>Session</code>、<code>Thread</code>和<code>Post</code>这4种数据结构创建相应的函数和方法，ChitChat 最终在处理器函数和数据库之间构建起了一个数据层，以此来避免处理器函数直接对数据库进行访问，图2-8展示了这个数据层和数据库以及处理器函数之间的关系。虽然有很多库都可以达到同样的效果，但亲自构建数据层能够帮助我们学习如何对数据库进行基本的访问，并借此了解到实现这种访问并不困难，只需要用到一些简单直接的代码，这一点是非常有益的。</p><br><p><img src="https://images.gitbook.cn/f72cdd60-a47d-11e8-8b4a-cf3651600922" alt="enter image description here"></p><br><p>图2-8　通过结构模型连接数据库和处理器</p><br><h3 id="28">2.8　启动服务器</h3><br><p>在本章的最后，让我们来看一下 ChitChat 应用是如何启动服务器并将多路复用器与服务器进行绑定的。执行这一工作的代码是在<code>main.go</code>文件里面定义的：</p><br><pre><code class="hljs bash">server := &amp;http.Server{<br>　Addr:　　 <span class="hljs-string">“0.0.0.0:8080”</span>,<br>　Handler:　mux,<br>}<br>server.ListenAndServe()<br></code></pre><br><p>这段代码非常简单，它所做的就是创建一个<code>Server</code>结构，然后在这个结构上调用<code>ListenAndServe</code>方法，这样服务器就能够启动了。</p><br><p>现在，我们可以通过执行以下命令来编译并运行 ChitChat 应用：</p><br><pre><code class="hljs nginx"><span class="hljs-attribute">go</span> build<br></code></pre><br><p>这个命令会在当前目录以及<code>$GOPATH/bin</code>目录中创建一个名为<code>chitchat</code>的二进制可执行文件，它就是 ChitChat 应用的服务器。接着，我们可以通过执行以下命令来启动这个服务器：</p><br><pre><code class="hljs">./chitchat<br></code></pre><br><p>如果你已经按照之前所说的方法，在数据库里面创建了 ChitChat 应用所需的数据库表，那么现在你只需要访问 <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a> 并注册一个新账号，然后就可以使用自己的账号在论坛上发布新帖子了。</p><br><h3 id="29web">2.9　Web 应用运作流程回顾</h3><br><p>在本章的各节中，我们对一个 Go Web 应用的不同组成部分进行了初步的了解和观察。图2-9对整个应用的工作流程进行了介绍，其中包括：</p><br><p>（1）客户端向服务器发送请求；</p><br><p>（2）多路复用器接收到请求，并将其重定向到正确的处理器；</p><br><p>（3）处理器对请求进行处理；</p><br><p>（4）在需要访问数据库的情况下，处理器会使用一个或多个数据结构，这些数据结构都是根据数据库中的数据建模而来的；</p><br><p>（5）当处理器调用与数据结构有关的函数或者方法时，这些数据结构背后的模型会与数据库进行连接，并执行相应的操作；</p><br><p>（6）当请求处理完毕时，处理器会调用模板引擎，有时候还会向模板引擎传递一些通过模型获取到的数据；</p><br><p>（7）模板引擎会对模板文件进行语法分析并创建相应的模板，而这些模板又会与处理器传递的数据一起合并生成最终的 HTML；</p><br><p>（8）生成的 HTML 会作为响应的一部分回传至客户端。</p><br><p><img src="https://images.gitbook.cn/fdad9940-a47d-11e8-a2aa-0bd41466d20f" alt="enter image description here"></p><br><p>图2-9　Web 应用工作流程概览</p><br><p>主要的步骤大概就是这些。在接下来的几章中，我们会更加深入地学习这一工作流程，并进一步了解该流程涉及的各个组件。</p><br><h3 id="210">2.10　小结</h3><br><ul><br><li>请求的接收和处理是所有 Web 应用的核心。</li><br><li>多路复用器会将 HTTP 请求重定向到正确的处理器进行处理，针对静态文件的请求也是如此。</li><br><li>处理器函数是一种接受<code>ResponseWriter</code>和<code>Requeest</code>指针作为参数的 Go 函数。</li><br><li>cookie 可以用作一种访问控制机制。</li><br><li>对模板文件以及数据进行语法分析会产生相应的 HTML，这些 HTML 会被用作返回给浏览器的响应数据。</li><br><li>通过使用<code>sql</code>包以及相应的 SQL 语句，用户可以将数据持久地存储在关系数据库中。</li><br></ul><br><hr><br><p><a href="#note1">[1]</a> 在安装<code>Postgres.app</code>时，你可能需要根据<code>Postgres.app</code>的版本对路径的版本部分做相应的修改，比如，将其中的<code>9.4</code>修改为<code>9.5</code>或者<code>9.6</code>，诸如此类。——译者注</p></div></article><br></body><br></html>
  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#21chitchat"><span class="toc-number">1.</span> <span class="toc-text">2.1　ChitChat 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22"><span class="toc-number">2.</span> <span class="toc-text">2.2　应用设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23"><span class="toc-number">3.</span> <span class="toc-text">2.3　数据模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24"><span class="toc-number">4.</span> <span class="toc-text">2.4　请求的接收与处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#241"><span class="toc-number">4.1.</span> <span class="toc-text">2.4.1　多路复用器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#242"><span class="toc-number">4.2.</span> <span class="toc-text">2.4.2　服务静态文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#243"><span class="toc-number">4.3.</span> <span class="toc-text">2.4.3　创建处理器函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#244cookie"><span class="toc-number">4.4.</span> <span class="toc-text">2.4.4　使用 cookie 进行访问控制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25html"><span class="toc-number">5.</span> <span class="toc-text">2.5　使用模板生成 HTML 响应</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#"><span class="toc-number">5.1.</span> <span class="toc-text">整理代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26postgresql"><span class="toc-number">6.</span> <span class="toc-text">2.6　安装 PostgreSQL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#261linuxfreebsd"><span class="toc-number">6.1.</span> <span class="toc-text">2.6.1　在 Linux 或 FreeBSD 系统上安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#262macosx"><span class="toc-number">6.2.</span> <span class="toc-text">2.6.2　在 Mac OS X 系统上安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#263windows"><span class="toc-number">6.3.</span> <span class="toc-text">2.6.3　在 Windows 系统上安装</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27"><span class="toc-number">7.</span> <span class="toc-text">2.7　连接数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28"><span class="toc-number">8.</span> <span class="toc-text">2.8　启动服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29web"><span class="toc-number">9.</span> <span class="toc-text">2.9　Web 应用运作流程回顾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#210"><span class="toc-number">10.</span> <span class="toc-text">2.10　小结</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://logan_2019.github.io/go_web编程/chit_chat论坛/2019/10/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://logan_2019.github.io/go_web编程/chit_chat论坛/2019/10/&text=ChitChat"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://logan_2019.github.io/go_web编程/chit_chat论坛/2019/10/&title=ChitChat"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://logan_2019.github.io/go_web编程/chit_chat论坛/2019/10/&is_video=false&description=ChitChat"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=ChitChat&body=Check out this article: http://logan_2019.github.io/go_web编程/chit_chat论坛/2019/10/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://logan_2019.github.io/go_web编程/chit_chat论坛/2019/10/&title=ChitChat"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://logan_2019.github.io/go_web编程/chit_chat论坛/2019/10/&title=ChitChat"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://logan_2019.github.io/go_web编程/chit_chat论坛/2019/10/&title=ChitChat"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://logan_2019.github.io/go_web编程/chit_chat论坛/2019/10/&title=ChitChat"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://logan_2019.github.io/go_web编程/chit_chat论坛/2019/10/&name=ChitChat&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2019 Logan
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">首页</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

    <!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


</body>
</html>
