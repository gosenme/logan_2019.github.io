<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="09 只读变量09 手动内存分配和sync.Pool的性能差异09 只读变量切片主要是内存操作，除此之外和内存操作有关的内容。在Go语言里没有只读变量的概念，在有些语言有readonly就变成只读的了，这个功能很实用，不允许修改。有些时候我们不允许修改一些很关键的安全信息。除了不允许修改以外，可能还不允许对方看到。任何一段内存其实有四种状态，可读、可写、不可见、可执行。我们所谓的readonly变">
<meta property="og:type" content="article">
<meta property="og:title" content="重学 Go 语言：基础篇-46">
<meta property="og:url" content="http://logan_2019.github.io/重学Go/重学 Go 语言：基础篇-46/2019/11/index.html">
<meta property="og:site_name" content="OYJX">
<meta property="og:description" content="09 只读变量09 手动内存分配和sync.Pool的性能差异09 只读变量切片主要是内存操作，除此之外和内存操作有关的内容。在Go语言里没有只读变量的概念，在有些语言有readonly就变成只读的了，这个功能很实用，不允许修改。有些时候我们不允许修改一些很关键的安全信息。除了不允许修改以外，可能还不允许对方看到。任何一段内存其实有四种状态，可读、可写、不可见、可执行。我们所谓的readonly变">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-11-30T10:53:39.858Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="重学 Go 语言：基础篇-46">
<meta name="twitter:description" content="09 只读变量09 手动内存分配和sync.Pool的性能差异09 只读变量切片主要是内存操作，除此之外和内存操作有关的内容。在Go语言里没有只读变量的概念，在有些语言有readonly就变成只读的了，这个功能很实用，不允许修改。有些时候我们不允许修改一些很关键的安全信息。除了不允许修改以外，可能还不允许对方看到。任何一段内存其实有四种状态，可读、可写、不可见、可执行。我们所谓的readonly变">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>重学 Go 语言：基础篇-46</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">首页</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/重学Go/重学 Go 语言：基础篇-47/2019/11/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/重学Go/重学 Go 语言：基础篇-45/2019/11/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://logan_2019.github.io/重学Go/重学 Go 语言：基础篇-46/2019/11/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://logan_2019.github.io/重学Go/重学 Go 语言：基础篇-46/2019/11/&text=重学 Go 语言：基础篇-46"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://logan_2019.github.io/重学Go/重学 Go 语言：基础篇-46/2019/11/&title=重学 Go 语言：基础篇-46"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://logan_2019.github.io/重学Go/重学 Go 语言：基础篇-46/2019/11/&is_video=false&description=重学 Go 语言：基础篇-46"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=重学 Go 语言：基础篇-46&body=Check out this article: http://logan_2019.github.io/重学Go/重学 Go 语言：基础篇-46/2019/11/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://logan_2019.github.io/重学Go/重学 Go 语言：基础篇-46/2019/11/&title=重学 Go 语言：基础篇-46"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://logan_2019.github.io/重学Go/重学 Go 语言：基础篇-46/2019/11/&title=重学 Go 语言：基础篇-46"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://logan_2019.github.io/重学Go/重学 Go 语言：基础篇-46/2019/11/&title=重学 Go 语言：基础篇-46"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://logan_2019.github.io/重学Go/重学 Go 语言：基础篇-46/2019/11/&title=重学 Go 语言：基础篇-46"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://logan_2019.github.io/重学Go/重学 Go 语言：基础篇-46/2019/11/&name=重学 Go 语言：基础篇-46&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">1.</span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#09"><span class="toc-number">1.1.</span> <span class="toc-text">09 只读变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#09syncpool"><span class="toc-number">1.2.</span> <span class="toc-text">09 手动内存分配和sync.Pool的性能差异</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        重学 Go 语言：基础篇-46
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">OYJX</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2019-11-30T10:53:39.857Z" itemprop="datePublished">2019-11-30</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <article id="topicContainer" class="column_content"><h2 class="topic_title"></h2><div><p><div class="toc"><br><ul><br><li><ul><br><li><ul><br><li><a href="#09">09 只读变量</a></li><br><li><a href="#09syncpool">09 手动内存分配和sync.Pool的性能差异</a></li><br></ul><br></li><br></ul><br></li><br></ul><br></div><br></p><br><h3 id="09">09 只读变量</h3><br><p>切片主要是内存操作，除此之外和内存操作有关的内容。在Go语言里没有只读变量的概念，在有些语言有readonly就变成只读的了，这个功能很实用，不允许修改。有些时候我们不允许修改一些很关键的安全信息。除了不允许修改以外，可能还不允许对方看到。任何一段内存其实有四种状态，可读、可写、不可见、可执行。</p><br><p>我们所谓的readonly变量归根结底就是只读不允许写，很显然现有的功能我们是做不到这一点的。</p><br><p>一段虚拟地址空间，所有的变量、栈、堆、text段其实都是映射到虚拟地址空间上面的，然后通过mmu映射到物理内存上面去。那么我们能不能自己在虚拟地址空间上面映射一段内存，就是在GC以外的空间映射一段内存，自己来控制这段内存的读写权限，读写执行。如果把写权限关掉就变成只读的了。</p><br><p>我们自己在虚拟地址空间上开辟一段内存，自己管理这段内存，控制它是读、写、执行。所以我们需要用到系统调用。在Linux系统编程中有<code>mmap</code>函数，就是在虚拟空间上映射一段内存，PROT<em>READ读、PROT</em>WRITE写。MAP<em>ANONYMOUS匿名代表和文件不进行关联，就是在内存用用就可以了，例如可执行文件需要和内存某段映射起来，匿名的好处是没有文件开辟空间就可以了，另外MAP</em>PRIVATE代表私有的不跟别人共享。</p><br><p>Go封装了一些系统调用，<a href="https://golang.google.cn/pkg/syscall/" target="_blank" rel="noopener">https://golang.google.cn/pkg/syscall/</a> 从这里我们可以看到很多系统调用，如果不全还可以通过扩展包<a href="https://godoc.org/golang.org/x/sys/unix" target="_blank" rel="noopener">https://godoc.org/golang.org/x/sys/unix</a> 来找，这里面最全的，其中<a href="https://golang.google.cn/pkg/syscall/#Mmap。" target="_blank" rel="noopener">https://golang.google.cn/pkg/syscall/#Mmap。</a></p><br><p>首先我们需要开辟一段内存，开辟多大呢？我们说过对于操作系统来说都是按照页来管理的，在我们申请内存的时候最好以页为单位，当然这可能会有浪费。管理内存权限是按照页分配权限的，不能按照一页里面一个片段来分配，当然申请完了之后可以转换为数组存不同的数据，默认情况下<code>syscall.PROT_READ|syscall.PROT_WRITE</code>是可读写状态，<code>syscall.MAP_PRIVATE|syscall.MAP_ANON</code>私有和匿名的，拿回来返回的<code>m</code>实际上就是字节切片，有了字节切片我们可以把它转换成任何想用的类型，因为内存中所有东西都是字节。<code>syscall.Munmap</code>调用是把内存释放掉。</p><br><pre><code class="go language-go">func main() {<br>    m, err := syscall.Mmap(-1, 0, syscall.Getpagesize(), syscall.PROT_READ|syscall.PROT_WRITE, syscall.MAP_PRIVATE|syscall.MAP_ANON)<br><br>    if err != nil {<br>        log.Fatalln(err)<br>    }<br><br>    defer syscall.Munmap(m)<br>    //可以转换成任何方式来使用，比如转换成整数指针使用。<br>    p := (<em>int)(unsafe.Pointer(&amp;m[0]))<br>    //赋值
    </em>p = 100<br>    fmt.Printf(“%p: %v\n”, p, <em>p)<br><br>    //修改内存的权限为只读<br>    syscall.Mprotect(m, syscall.PROT_READ)<br>    //读没有问题<br>    fmt.Printf(“%p: %v\n”, p, </em>p)<br>    //只读权限后，下面操作就会出错，系统引发的错误信号<br>    <em>p = 200<br>    fmt.Printf(“%p: %v\n”, p, </em>p)<br><br>    //把写权限加上去<br>    syscall.Mprotect(m, syscall.PROT_READ|syscall.PROT_WRITE)<br><br>    <em>p = 200<br>    fmt.Printf(“%p: %v\n”, p, </em>p)<br><br>    //修改内存的权限为不可见<br>    syscall.Mprotect(m, syscall.PROT_NONE)<br>    //操作就会出错，系统引发的错误信号<br>    fmt.Printf(“%p: %v\n”, p, <em>p)<br>}<br></em></code></pre><br><p>显然我们除了语言本身提供的功能以外，我们还要适当的使用操作系统提供的一些功能，这个功能是超出语言本身的限制，多数语言都能支持这种系统调用。我们可以通过系统提供的功能做一些语言不具备的能力。</p><br><p>我们完全可以把一个函数的代码拷贝到这里，然后把指针转换为函数指针，然后就能执行这段函数代码，这样能做代码注入。有很多内存操作不见得非要限制于语言本身，利用读写和不可见其实可以做很多事情，有些时候我们需要在内存中保护一些敏感数据，比如有个库，用来验证用户的敏感信息，包含信用卡信息密码，这些信息从后台数据库读进来之后，这些信息理论上不想给别人访问的，因为对方通过扫描内存实际上可以找到这样的数据。只有我想要访问的时候打开，不想访问的时候关闭。从一定程度上提高内存中敏感数据的安全。</p><br><p>还有可能需要<code>mlock</code>函数把一段内存锁定，当一段内存长时间不用的话会被mmu交换到磁盘上，把内存中的数据交换到磁盘上是非常危险的，当你的数据交换到硬盘上，突然机器挂了，敏感数据是保存在磁盘交换文件中的，这个时候如果有人把磁盘拿走去扫描是能找出敏感数据的，因为磁盘交换文件是有格式的，只要了解这些格式就能把信息恢复出来。<code>mlock</code>函数可以把某段内存锁定物理内存里，不允许mmu交换到磁盘空间。</p><br><h3 id="09syncpool">09 手动内存分配和sync.Pool的性能差异</h3><br><p>sync.Pool利用了运行时内部机制提升了性能，大多数情况下足够用了，但是sync.Pool缺乏几个很关键的功能。接口只有两个方法，一个是取出来，一个是放进去。如果取的时候没有新的缓存对象，它就会调用New函数创建一个新的，除此之外没有任何的控制。这对于我们来说粒度有点粗，例如数据库的连接缓冲池，通常有这样几个开关，第一个最大打开的连接数，第二个最大空闲连接数。</p><br><p>第二个原因所有方法都是用的接口类型，把一个对象转换成一个接口类型有一定的性能损耗的。标准库提供是一种通用对象池，并不能明确的说我要用什么样的对象数据，所以它用接口是非常合理的。对于我们来说，我们自己去写一个缓存结构，我们很明确的知道我们需要缓存什么样的数据，可能是某个结构体。同时必须严格控制必须打开多少个，最少的时候要保留多少个空闲在里面，我自己控制这段逻辑的时候显然这个对象池其实就不够用。我们可能就需要数组实现一个。</p><br><p>还有个问题在于它在内部实现时候它是基于同步机制，这个同步机制对于我们来说是个黑盒子我们没有办法控制。我们可能需要自己控制这些东西，因为我们的逻辑一次取3个，经常有这样的做法，比如4个并发的操作，每个操作一次取3个。大家做数据库操作通常这样，很多时候做批操作，比如插入10条记录用批操作的方式去提交，这样比单次提交速度快很多。同样的，对对象池操作一次取多个，那么对于它内部来说你每次取都进行一次加锁解锁操作，对于我们来说可能性能不行，我自己控制比较好。我一次取三个只要加一次锁比加三次锁性能要高很多。</p><br><p>还有最后一个问题比较麻烦的，我们根本没法控制缓存的对象在垃圾回收的时候会不会被回收。</p><br><p>比如我们要缓存<code>Data</code>数据结构，我们创建一个对象池<code>&amp;sync.Pool</code>，必须传递个函数目的是当对象池没有的时候必须给我个函数，用函数创建新的对象。在这个函数加了一个跟踪的方法，类似于析构函数，如果这个对象一旦被垃圾回收了，打印信息知道被垃圾回收了。从对象池取四个对象出来，很显然取的时候因为对象池是没有的，所以它创建新的四次，接下来把新创建的加到切片中去。然后立即释放还给对象池。最后执行垃圾回收。</p><br><pre><code class="go language-go">type Data struct {<br>    x int<br>}<br><br>func newData() interface{} {<br>    fmt.Println(“new.”)<br><br>    d := new(Data)<br><br>    runtime.SetFinalizer(d, func(Data) {<br>        fmt.Println(“finalizer.”)<br>    })<br>    return d<br>}<br><br>func main() {<br>    pool := &amp;sync.Pool{<br>        New: newData,<br>    }<br><br>    var datas []<em>Data<br><br>    for i := 0; i &lt; 4; i++ {<br>        d := pool.Get().(</em>Data)<br>        println(d)<br>        datas = append(datas, d)<br>    }<br><br>    for _, d := range datas {<br>        pool.Put(d)<br>    }<br><br>    for {<br>        runtime.GC()<br>        time.Sleep(time.Second)<br>    }<br>}<br></code></pre><br><p>我们看到创建新的四个对象，一旦把它们还回对象池，垃圾回收就全部释放掉了，也就是说下一次需要重新创建。这样一来我们没有办法控制缓存池里面到底留下多少个对象，因为垃圾回收器会把所有空闲的对象全部干掉下次重新创建。为什么用缓冲池，其实有几个理由，一是对象频繁的使用，第二是创建对象要花费很大代价，比如创建数据库连接是要花费很大代价的。</p><br><p>我们可能基于<code>sync.Pool</code>做个包装，我们额外使用结构体引用它。<code>sync.Pool</code>有几个问题，一类型转换，二没有办法做细节控制，三没有办法阻止会被垃圾回收。标准库里面做些简单事情可以，但是性能要求比较高的场合并不适合用来使用。我们尽可能使用标准库，一旦标准库满足不了需求的时候我们就得自己去写，你就得控制所有的细节。</p><br><pre><code class="go language-go">type Pool struct{<br>    sync.Pool<br>    []idle //所有空闲对象使用这个引用确保不会被垃圾回收<br>    maxOpen<br>    maxIdle<br>}<br><br>// 可以控制一次取多少个出来，还避免了类型转换<br>func Get(n int) []*Data {<br><br>}<br></code></pre></div></article>
  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">1.</span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#09"><span class="toc-number">1.1.</span> <span class="toc-text">09 只读变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#09syncpool"><span class="toc-number">1.2.</span> <span class="toc-text">09 手动内存分配和sync.Pool的性能差异</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://logan_2019.github.io/重学Go/重学 Go 语言：基础篇-46/2019/11/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://logan_2019.github.io/重学Go/重学 Go 语言：基础篇-46/2019/11/&text=重学 Go 语言：基础篇-46"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://logan_2019.github.io/重学Go/重学 Go 语言：基础篇-46/2019/11/&title=重学 Go 语言：基础篇-46"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://logan_2019.github.io/重学Go/重学 Go 语言：基础篇-46/2019/11/&is_video=false&description=重学 Go 语言：基础篇-46"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=重学 Go 语言：基础篇-46&body=Check out this article: http://logan_2019.github.io/重学Go/重学 Go 语言：基础篇-46/2019/11/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://logan_2019.github.io/重学Go/重学 Go 语言：基础篇-46/2019/11/&title=重学 Go 语言：基础篇-46"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://logan_2019.github.io/重学Go/重学 Go 语言：基础篇-46/2019/11/&title=重学 Go 语言：基础篇-46"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://logan_2019.github.io/重学Go/重学 Go 语言：基础篇-46/2019/11/&title=重学 Go 语言：基础篇-46"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://logan_2019.github.io/重学Go/重学 Go 语言：基础篇-46/2019/11/&title=重学 Go 语言：基础篇-46"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://logan_2019.github.io/重学Go/重学 Go 语言：基础篇-46/2019/11/&name=重学 Go 语言：基础篇-46&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2019 Logan
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">首页</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

    <!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


</body>
</html>
