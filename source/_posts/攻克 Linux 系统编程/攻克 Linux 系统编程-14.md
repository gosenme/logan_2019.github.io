---
title: 攻克 Linux 系统编程-14
---
<article id="topicContainer" class="column_content"><h2 class="topic_title"></h2><div><p>本节课，我们要介绍几个对虚拟内存进行系统级控制的系统调用，合理使用它们，能极大地提高应用的执行效率，增强应用的安全性，主要包括以下几方面内容：</p>
<ul>
<li>内存映射</li>
<li>内存保护</li>
<li>内存锁定</li>
</ul>
<h3 id="131">13.1 内存映射</h3>
<h4 id="1311">13.1.1 概述</h4>
<p>内存映射的功能是在进程的内存映射表中建立一条新的映射表项，也就是分配一块新的虚拟内存给调用进程。并且，可以指定内存内容与某个文件内容相对应。</p>
<p>提供内存映射功能的系统调用是：</p>
<pre><code>void * mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
</code></pre>
<p>其中：</p>
<ul>
<li>参数 addr 指定期望的映射目标地址，如果给 addr 传递 NULL，则表示让内核选择一个合适的地址；</li>
<li>参数 length 指定要映射的数据的字节数，内核会把它对齐到内存页大小的下一个倍数；</li>
<li>参数 prot 指定地址映射之后的访问权限，它的取值可以是   PROT_NONE，或者 PROT_READ、PROT_WRITE、PROT_EXEC 几种值的任意组合；</li>
<li>参数 fd 指定要映射的文件；</li>
<li>参数 offset 指定映射内容在文件中的偏移量。</li>
</ul>
<p>flags 参数比较复杂，它指定执行内存映射时使用的操作选项，不同选项的组合适用于不同的应用场景。<strong>其中有两个选项是互斥并且是必选项。</strong></p>
<ul>
<li><p>MAP_PRIVATE：私有映射。在这种映射模式下，映射到内存中的内容会根据文件内容进行初始化，但是内存中内容的变化不会更新到磁盘文件中去，而且，映射建立之后，一旦应用对内存内容有更新，内核会使用写时拷贝技术为被修改的内存页创建新的副本。</p></li>
<li><p>MAP_SHARED：共享映射。在这种映射模式下，映射后内存内容的修改会更新到磁盘文件内，而且，如果有多个进程映射了同一个磁盘文件的相同区域，那么其中任意一个进程对内存内容的修改都会立即被其他进程可见。</p></li>
</ul>
<p>除了这两个互斥的必选项之外，还可以组合使用一些其他的操作选项，常见的比如有 MAP_ANONYMOUS（创建匿名映射）、MAP_FIXED（使用指定的固定地址执行映射）等，了解更多请读者自行查看帮助手册。</p>
<p>只罗列每种选项代表的含义可能不会让读者留下深刻的印象，下面我们<strong>结合具体的应用实例</strong>，具体<strong>看看每种情境下是如何组合使用每种选项的</strong>，以加深读者对常用操作选项的理解。</p>
<h4 id="1312io">13.1.2 优化下载服务器上的文件 I/O</h4>
<p><strong>mmap 最常见的应用就是优化文件的 I/O</strong>，它可以把一个文件的内容映射到虚拟内存中，使得后续所有对文件的 I/O 操作都转换为对内存地址的读写。</p>
<p>在《第 02 课：精细控制文件 I/O，编写更稳健的应用》中，我们介绍过内核会使用内核缓冲区来提高文件读写的效率，所以，在使用 read 和 write 系统调用读写文件时，数据其实经过了两次拷贝，一次是在存储设备与内核缓冲区之间，另一次是在内核缓冲区与应用层之间。</p>
<p>而使用 mmap 映射文件内容时，没有创建内核缓冲区，而是直接在虚拟内存地址与文件之间建立了关联，文件内容直接传输到应用层的内存分页上，减少了一次内存拷贝，因而提高了效率。</p>
<p>在下载服务器上，当收到下载请求之后，通常是打开文件，然后把文件内容依次以数据流的形式发送到对端。在这种使用模式下，用内存映射代替一般的文件读写，<strong>不仅可以省掉内核缓冲区占用的内存，而且在数据流的传递路径上，由于减少了一次数据拷贝，因此可以获得更高的处理效率。</strong></p>
<p><strong>要注意的是，这与使用直接 I/O 的方式是不同的</strong>。</p>
<ul>
<li>在直接 I/O 模式下，虽然同样不会创建内核缓冲区，但是每一次 read 操作都会引发一次真实的存储设备 I/O 操作。如果应用层没有正确设置每次读取的字节数，会造成严重的 I/O 效率问题。</li>
<li>使用内存映射之后，应用层就不需要在意每次读取的数据长度问题，只需要像使用内存数据一样，依次递增地址值，并读取内存内容就可以了，内核中的缺页中断处理会自动把文件内容以内存页为单位传输到应用层。</li>
</ul>
<p><strong>在这种场景下：我们需要用文件内容来初始化内存数据，通常并不需要修改映射文件的内容，直接使用私有映射（MAP_PRIVATE）标志就可以了。</strong></p>
<h4 id="1313io">13.1.3 优化内容频繁变化的文件的 I/O</h4>
<p>还有一类应用，它们同样需要使用文件的内容来初始化内存数据，而且，在程序运行的过程中，内存中的内容是经常变化的，内存中变化的内容，还需要反应到硬盘文件上进行永久性的保存。同时，文件的大小并不会发生变化，发生变化的只是文件中的内容。例如，各种虚拟机软件的虚拟硬盘文件。</p>
<p><strong>在这种模式下，就可以使用共享映射（MAP_SHARED）标志</strong>，文件内容映射到内存之后，对内存内容的更新会自动同步到磁盘文件上，从而既可以简化虚拟机逻辑，又能提高文件 I/O 的效率。</p>
<h4 id="1314">13.1.4 大块内存分配</h4>
<p>在 glibc 的内存分配函数 malloc 的内部，有时会<strong>使用 mmap 函数代替堆内存边界调整函数 brk。</strong></p>
<p>用 mmap 分配内存的<strong>好处在于，可以独立使用 munmap 高效地解除映射</strong>，映射解除后，应用占用的虚拟内存总量就会降下来。</p>
<p>而如果使用 brk 调整边界的方式，当释放的内存不在堆内存边界的时候，堆内存的最高水位线是降不下来的。</p>
<p>但是 mmap <strong>也有缺点，最大缺点就是系统开销比较大</strong>，因为需要经过内核，内核先要查找合适的映射地址，还会把分配的内存内容都置为 0，再返回给应用层。</p>
<p>所以，在 glibc 的设计中，<strong>只有生命周期比较长的大块内存才适合使用 mmap 进行分配</strong>。在最新的 glibc 实现中：</p>
<ul>
<li>超过 32 MB 的内存块会被认为是大内存块，且总是会使用 mmap 分配；</li>
<li>小于 128 KB 的内存申请，总是会在动态堆内存区进行分配；</li>
<li>大小在 128 KB 到 32 MB 之间的内存申请，会受到动态调整的分界水位线的影响，水位线之下的在动态堆内存区分配，高于水位线的用 mmap 分配，而水位线的调整时机，就是在 mmap 分配的内存区上执行 free 操作时。</li>
</ul>
<p>也就是说，同样是申请 1 MB 的堆内存，第一次申请时，malloc 会使用 mmap 的方式，一旦在该内存上执行了 free 操作，后续所有不大于 1 MB 的 malloc 操作都会在动态堆内存区内进行。</p>
<h4 id="1315">13.1.5 多进程间内存共享</h4>
<p>在执行内存映射时，<strong>使用 MAP_SHARED 选项</strong>，并关联到相同的磁盘文件，就<strong>可以创建在多个进程间共享的内存块。</strong></p>
<p>这样创建的映射内存与 IPC 的共享内存很相似，不同之处在于<strong>它会同时把内存中的更新保存到磁盘文件上，所以可以提供数据的持久化保存功能。</strong></p>
<p>如果要在父子进程之间共享内存块，而不需要数据持久化功能，还可以使用共享的匿名映射（MAP_SHARED | MAP_ANONYMOUS）。</p>
<p>与使用共享内存的方式相比，以这样的方式创建的共享内存块，不会显示在 IPC 的输出列表里，而且可以把共享范围严格限制在父子进程之间，因而更加适合有私密性要求的数据的共享。</p>
<h4 id="1316">13.1.6 将多个文件的内容映射到连续的内存</h4>
<p>flags 还有一个<strong>应用比较多的选项 MAP_FIXED</strong>，它表示把内存映射到某个指定的固定位置。使用这个选项，就可以<strong>把分布在多个文件，或者单个文件不同位置处的内容，映射到连续的内存地址处</strong>，如此处理之后就可以使后续的处理逻辑得以简化。</p>
<p>如果使用的是 MAP_SHARED 与 MAP_FIXED 组合的方式，还可以实现内存中更新的内容自动保存到相应文件的功能。</p>
<p>在使用 MAP_FIXED 选项时，通常会与匿名私有映射配合使用，也就是首先以如下方式让操作系统帮助我们选择一个与当前虚拟地址不冲突的映射地址：</p>
<pre><code>void * addr = mmap(NULL, length, prot_flag, MAP_PRIVATE | MAP_ANONYMOUS, 0);
</code></pre>
<p>然后以 addr 地址为基地址，在映射内存的相对位置上使用 MAP_FIXED 标记安排后续每块数据的映射位置。</p>
<h4 id="1317">13.1.7 注意事项</h4>
<p>内存映射功能强大，能同时简化应用逻辑和提高 I/O 性能。但是<strong>需要特别注意，映射后的内存地址是可以通过 mremap 系统调用修改的，如果有对映射内存内部数据的地址引用，需要用相对映射首地址的偏移量的形式来保存</strong>，否则，在映射地址修改之后，这些引用就会出错。</p>
<h3 id="132">13.2 内存保护</h3>
<p>内存保护系统调用的<strong>功能是修改一块虚拟内存区域上的访问权限</strong>，比如增加可执行权限，或者取消可修改权限等。该系统调用的接口定义为：</p>
<pre><code>int mprotect(void *addr, size_t length, int prot);
</code></pre>
<p>其中：</p>
<ul>
<li>addr 指定要修改的虚拟内存的首地址，它必须是内存页大小的整数倍；</li>
<li>length 指定要修改的虚拟内存区的长度，内核会把它向上舍入到内存分页大小的下一个整数倍；</li>
<li>prot 指定内存区域上新的访问权限，可以是 PROT_NONE，或者 PROT_READ、PROT_WRITE、PROT_EXEC 几种值的任意组合。</li>
</ul>
<p>内存保护系统调用在很多商业项目上有广泛的应用，比如，在一些电信产品中，会对配置数据进行特别地保护：</p>
<ul>
<li>大多数情况下都会把配置数据所在的内存区域设置为只读的权限；</li>
<li>然后为每项配置数据提供专用的修改接口，其实现中会首先计算要修改的配置数据所在的内存位置；</li>
<li>然后把包含目标位置的内存页的访问权限修改为 PROT_READ | PROT_WRITE，执行完配置数据更新之后，立即把内存的访问权限重置为 PROT_READ。</li>
</ul>
<p>这样，可以保证所有的配置数据只能通过指定的更新接口进行修改，而不会被意料之外的数组越界或者野指针错误而意外地修改。</p>
<p>如果真的有越界的访问落到了配置数据所在的内存区，系统会被一个 SegV 信号所终止，并且会把崩溃的现场保存到 core dump 文件中，开发者可以从中找出引发错误的元凶。</p>
<h3 id="133">13.3 内存锁定</h3>
<p>内存锁定的<strong>作用是使得指定区域的内存始终保持在物理内存中，而不会被交换到交换分区上。</strong></p>
<p>对锁定后的内存的访问，不会因为触发缺页中断而发生访问延迟，因此，<strong>把访问频率非常高的内存数据锁进内存，能提高程序的性能。</strong></p>
<p>另外，把包含敏感信息的内存块锁进内存还能在一定程度上提高程序的安全性。</p>
<p>曾经存在这样一种攻击方式，攻击者故意运行一个内存占用量很大的程序，使得其他正在运行的进程的部分内存页被交换到交换分区上，然后攻击者把磁盘的交换分区的内容转存下来，并在这些数据中去查找可能的敏感数据。</p>
<p>在包含敏感信息的内存页上使用内存锁定之后，至少可以防范这种类型的攻击。</p>
<h4 id="1331">13.3.1 锁定指定的内存段</h4>
<p>内存锁定系统调用的接口定义为：</p>
<pre><code>int mlock(void * addr, size_t length);
</code></pre>
<p>与其他的虚拟内存操作函数一样，它也是以内存页为单位执行操作的。</p>
<p>与之对应的，已经加锁的内存页可以通过如下的系统调用解锁：</p>
<pre><code>int munlock(void * addr, size_t length);
</code></pre>
<p><strong>解锁之后的内存页并不会立即从物理内存中释放，而只是标记后续可以被换出到交换分区了</strong>，具体被换出的时机，要取决于系统的负载，以及内核采用的换入换出策略。</p>
<h4 id="1332">13.3.2 锁定进程的所有内存页</h4>
<p>除了可以单独锁定指定的内存页，Linux 还<strong>提供了两个接口，控制整个进程的内存锁定行为</strong>：</p>
<pre><code>int mlockall(int flags);
int munlockall(void);
</code></pre>
<p>它们分别对调用进程的所有内存页执行锁定或解锁操作，锁定操作的参数 flags 可以取值 MCL_CURRENT 和 MCL_FUTURE 的任意组合，它们分别表示把进程当前使用的所有内存分页和未来动态分配的所有内存分页锁定到内存，控制的范围包括程序的代码段、数据段、内存映射、栈分配，以及堆分配的所有分页。</p>
<p>使用 mlockall(MCL_FUTURE) 之后，进程所有新分配的内存都会在分配完成之后就被映射到物理内存中，并且进程新分配的内存总量不会超过 RAM 的总容量，因此<strong>能使用的内存总量要比不使用锁定标记时要少，而且内存分配的性能会有轻微的降低，但是能提高后续内存使用时的效率。</strong></p>
<h3 id="134">13.4 总结</h3>
<p>在本节课中，我们<strong>详细讨论了几个功能强大的控制虚拟内存的系统调用</strong>，对它们的合理使用，不仅可以帮助读者<strong>简化应用的处理逻辑</strong>，同时还能<strong>让应用具有更好的 I/O 性能，以及更好的安全性</strong>。</p>
<h3 id="135">13.5 答疑与交流</h3>
<blockquote>
  <p><strong>为了方便与作者交流与学习，GitChat 编辑团队组织了一个《攻克 Linux 系统编程》读者交流群，添加小助手-伽利略微信：「GitChatty6」，回复关键字「208」给小助手-伽利略获取入群资格。</strong></p>
</blockquote></div></article>