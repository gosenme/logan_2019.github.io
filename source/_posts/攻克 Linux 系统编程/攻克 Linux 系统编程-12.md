---
title: 攻克 Linux 系统编程-12
---
<article id="topicContainer" class="column_content"><h2 class="topic_title"></h2><div><p>在互联网上运行的系统，安全性非常重要。对大多数的系统来说，验证登录用户的账号和密码是保护系统的第一道防线，本节课我们就来详细讨论一下 Linux 系统中账户密码的验证过程，主要包括以下几方面内容：</p>
<ul>
<li>Linux 验证登录用户的步骤；</li>
<li>Linux 对用户敏感账户信息的保护手段；</li>
<li>通过量化的计算让读者对 Linux 的安全性有直观的体会。</li>
</ul>
<h3 id="111linux">11.1 Linux 验证登录用户</h3>
<p>不管是本地登录，还是远程终端登录，都需要对登录的用户进行合法性检验，常见的用户验证方法有两种：用户名密码登录和证书登录。本节课我们只讨论用户名密码登录。</p>
<h4 id="1111">11.1.1 密码验证方法</h4>
<p>用户名密码验证的原理非常简单，就是对比一下输入与预设是否匹配，如果匹配，则登录成功，否则登录失败。</p>
<p>但是这里有个非常重要的问题，就是<strong>密码不可以明文保存</strong>。因为一旦系统被攻破，那么所有用户的密码信息就会完全被暴露。</p>
<p>在过去的 2018 年就发生过多起网站被攻破，明文密码被泄露的安全事件。现在每个人都会有那么几十个各个网站的账号，为了好记，很多人都会在不同的网站使用相同用户名和密码。所以，一旦让不法分子拿到用户在某个网站的明文账户信息，他就会用相同的账户去尝试登录其他的网站，这就叫撞库。所以，使用明文保存用户密码是一种对用户甚至对整个互联网行业都非常不负责任的做法。</p>
<p>同样的道理，使用加密方式保存密码也不行，因为如果加密被破解，加密秘钥被泄露，不法分子同样可以获取到用户的原始密码。</p>
<p><font color="#F39800">最正确的做法应该是使用单向的散列算法，这样即使散列后的密码被泄露，攻击者也需要可观的算力才能得到原始的明文密码。</font>这个可观的算力具体是多少，我们会在最后一节用数字来说明。</p>
<h4 id="1112">11.1.2 散列值计算</h4>
<p>Linux 中，用于计算密码散列值的函数是 crypt，函数原型为：</p>
<pre><code>char * crypt(const char * key, const char * salt);
</code></pre>
<p>其中：</p>
<ul>
<li>key 是用户输入的密码字符串；</li>
<li>salt 是椒盐噪声字符串。</li>
</ul>
<p>函数的返回值就是<strong>掺杂椒盐噪声的密码散列后的结果</strong>。</p>
<p>用户设置自己的登录密码后，保存在系统中的就应该是这个散列后的结果，用户登录时再次使用这个函数计算用户输入的密码的散列结果，并与保存的散列结果做比较即可验证用户合法性。</p>
<p>使用此系统调用，如果能拿到目标用户的密码散列结果，就可以编写一个账号密码暴力破解工具执行破解。需要注意的是，crypt 的返回结果是放在一块静态分配的内存区的，所以不能同时在多个线程中执行。</p>
<h3 id="112linux">11.2 Linux 对用户敏感信息的保护</h3>
<p>既然编写破解程序这么容易，所以 Linux 对账户信息的保护转换成了另外一个问题，如何保护密码散列后的结果不被轻易泄露。</p>
<h4 id="1121">11.2.1 访问权限</h4>
<p>在 Linux 中，账户和密码信息是分别保存在 /etc/passwd 和 /etc/shadow 这两个文件中的，查看一下这两个文件的访问权限：</p>
<pre><code># ll /etc/passwd
-rw-r--r-- 1 root root 2497 Jul 21  2018 /etc/passwd

# ll /etc/shadow
---------- 1 root root 1240 Jul 21  2018 /etc/shadow
</code></pre>
<p>可以看到：</p>
<ul>
<li>passwd 文件是所有用户都有权限读取的，但是只有 root 用户有权限修改；</li>
<li>shadow 文件对任何人都没有开启访问权限，因为 root 在系统中是可以做任何事情的，所以也就相当于只有 root 用户或以 root 权限运行的程序，才有权限访问 shadow 文件。</li>
</ul>
<p>所以，在 Linux 系统中，只有以 root 用户登录，才能拿到 shadow 文件回去执行暴力破解。</p>
<p>这就很尴尬了，如果已经能以 root 登录系统了，那也就不需要再破解密码了；而不去破解，又拿不到 root 登录权限。所以，想入侵 Linux 系统，<strong>只能绕路去想别的获取 root 权限的方法了</strong>，可以是利用有漏洞的应用或服务进行提权，或者是利用社会工程学手段让内部人员“交出”敏感信息。这都<strong>增加了入侵需要的成本</strong>。</p>
<h4 id="1122setuserid">11.2.2 Set-User-ID 程序</h4>
<p>文件权限控制是一道屏障，但是还有另外一个问题需要解决。</p>
<p>回想一下，Linux 中的任何登录用户都有权限使用 passwd 命令修改自己的登录密码，密码修改之后，程序需要把更新后的新密码的散列值更新到 shadow 文件中去。但是上面已经看到过，shadow 文件是只有 root 用户才有权限访问的，那么，以普通用户身份运行的 passwd 程序是如何修改 shadow 文件的内容的呢？</p>
<p>回答这个问题之前，我们先看一下 passwd 程序的权限设置：</p>
<pre><code># ll /bin/passwd
-rwsr-xr-x. 1 root root 27832 Jun  9  2014 /bin/passwd
</code></pre>
<p>可以看到，passwd 的所有者是 root，在代表所有者执行权限的位置上，用标志 s 代替了常见的可执行标志 x。实际上，该标志就标识这个程序是一个 Set-User-ID 程序，它会在运行时把有效用户 ID 设置为可执行文件的属主 ID，从而获得属主的权限。</p>
<p>也就是说，不管是哪个用户执行了 passwd 命令，都具有与 root 用户执行 passwd 时一样的文件访问权限，这个程序就像是普通用户与受保护的 shadow 文件之前的桥梁。<font color="#F39800">也因为这类程序的特殊地位，它们的安全性非常重要，需要非常小心地编写</font>。</p>
<p>用户自己编写的程序也可以在运行时修改用户 ID 和有效用户 ID，系统提供的系统调用为：</p>
<pre><code>int setuid(uid_t uid);
int seteuid(uid_t uid);
int setreuid(uid_t ruid, uid_t euid);
</code></pre>
<p>当 uid 设置为 0 时，就表示把用户设置为 root。更详细的信息请参考帮助手册。</p>
<h3 id="113">11.3 量化分析</h3>
<p>再坚固的防线也难免会从内部被瓦解，整个 Linux 系统的安全性取决于所有链条中最薄弱的那一环。虽然 Linux 对密码信息的保护煞费苦心，但是永远也无法保证队友会怎么样。下面我们就来计算一下假设散列后的密码信息被泄露，我们的系统会面临怎样的形势。</p>
<p>我们不去讨论数学上从散列结果反推原始密码的可能解法，只讨论散列算法是完美的单向函数的情况。在这种情况下，实际要计算的是暴力破解任意密码需要的计算量和存储量。</p>
<h4 id="1131">11.3.1 计算量</h4>
<p>密码设置中可用的字符包括数字、大小写字母和特殊符号，一共九十多个。</p>
<p>为了方便计算，我们只计算数量级，每位密码引入的复杂度是 $10^2$ 的量级，八位密码的复杂度就是 $10^{16}$ ，实测结果表明运算速度在百亿次每秒的个人计算机上，每秒可以做 $10^4$ 量级的散列计算，完成所有 $10^{16}$ 种密码的遍历计算需要 $10^{12}$ 秒，约等于三万年。</p>
<p>目前运算速度最高的超级计算机的运算速度已经达到了每秒亿亿次，等比例计算的话，每秒能够完成的散列计算数量应该在 $10^{11}$，完成所有 $10^{16}$ 种密码的遍历计算需要 $10^5$ 秒，不到三十个小时就可以计算完成。</p>
<p>同样是 8 位密码，如果只使用数字的话，复杂度会下降到 $10^8$，单台个人计算机和超级计算机的破解时间会分别下降为 3 小时和几毫秒之内；如果只使用大写或小写字母，则暴力破解时间会分别为一年左右和几秒钟之内。这就是为什么现代大多数系统要求密码最低 8 位，并且要求最少使用字母、数字和特殊符号中的两种的原因。因为在目前的硬件运算水平下，8 位混合密码可以保证破解的算力成本是一般个人和小规模团体无法承担的。</p>
<h4 id="1132">11.3.2 存储量</h4>
<p>读者可能会想，能不能把所有可能的密码的散列值预先计算出来，用散列值直接反向搜索出原始密码呢？这个思路确实是可行的，我们来计算一下存储所有密码的散列值需要的存储空间。</p>
<p>还是以 8 位混合密码为例，可能的密码排列有 $10^{16}$ 种，约等于 $2^{50}$，每个散列值按照压缩后占用 10 字节的存储空间算的话，一共需要 10 PB 的存储空间，也就是需要 2500 块 4 TB 容量的硬盘。这样的存储量，好像稍具规模的黑客组织都可以承担。</p>
<p>但是，这个结果是没有考虑 crypt 接口中的 salt 字段，也就是散列的椒盐噪声的。在最早的 Linux 系统中，椒盐噪声由两个字节组成，每个字节的取值范围是 [0-9][a-z][A-Z][./]，一共 64 种字符，所以 2 字节的噪声使得同一个密码的散列结果有 4096 种变体，所以，存储所有的散列结果其实需要 4096 * 2500 块 4TB 容量的硬盘，这个数字大约是 2018 年第四季度全球硬盘出货量的九分之一。这就不是一般规模的组织能够承受的了。</p>
<p>而且，现代 Linux 系统的散列噪声已经升级到了 8 个字节，即使把全世界目前的存储设备全部用上，也不足以存放所有密码散列结果的所有变体了。</p>
<h3 id="114">11.4 总结</h3>
<p>本节课详细<strong>解释了 Linux 系统中账户密码登录验证的详细步骤</strong>，并用量化的计算结果让读者对 Linux 的账号安全性有直观的感受。</p>
<p>希望通过本节课的学习，读者可以将这套成熟的账号密码管理方法借鉴到自己的系统中去，保护好自己的客户，也共同保护好整个互联网生态。</p>
<h3 id="115">11.5 答疑与交流</h3>
<blockquote>
  <p><strong>为了方便与作者交流与学习，GitChat 编辑团队组织了一个《攻克 Linux 系统编程》读者交流群，添加小助手-伽利略微信：「GitChatty6」，回复关键字「208」给小助手-伽利略获取入群资格。</strong></p>
</blockquote></div></article>