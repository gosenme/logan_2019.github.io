---
title: 前端开发核心知识进阶-40
---
<article />\n}\nelse if (目录抽象、边栏、广告、批注) {\n  return <aside />\n}\nelse if (含有附录、图片、代码、图形) {\n  return <figure />\n}\nelse if (含有多个标题或内容的区块) {\n return <section />\n}\nelse if (含有段落、语法意义) {\n  return <p /> || <address /> || <blockquote /> || <pre /> || ...\n}\nelse {\n  return <div />\n}\n```\n\n#### 语义化的发展和高级玩法\n\n说到语义化的发展，我这里指向重点提一个概念：Microformats，如果面试官问的语义化时，你能把这个概念搬出来，效果是非常好的。那什么是 Microformats 呢？\n\n> Microformats，翻译为微格式，是 HTML 标记某些实体的小模式，这些实体包括人、组织、事件、地点、博客、产品、评论、简历、食谱等。它们是在 HTML 中嵌套语义的简单协议，且能迅速地提供一套可被搜索引擎、聚合器等其他工具使用的 API。\n\n除了 hCard 和 hCalendar，有好几个库特别开发了微格式。\n\n是不是看的一脸懵逼？其实很简单，Microformats 的原理就是扩展 HTML 元素或者属性，来增强 HTML 的语义表达能力。\n\n我们来看一个案例：\n\n![enter image description here](https://images.gitbook.cn/4bd676c0-88e7-11e9-8115-8f03dd50b734)\n\nWikipedia 的页面中，给某一部分加上了 vCard 的 class，这是用来做什么的呢？\n\n![enter image description here](https://images.gitbook.cn/d8469cc0-88e7-11e9-b068-5302ecb579f2)\n\nGoogle 搜索引擎可以通过 Wikipedia 页面 vCard 这个 class，读取相关内容，在呈现搜索结果时，匹配展现出人物信息。从而语义化的 class，帮助了机器（搜索爬出）学习到更多信息，展现出了更好的结果页面。\n\nMicrodata 属于 WHATWG（网页超文本应用技术工作小组：Web Hypertext Application Technology Working） HTML 规范，它并不是标准，但这是一个很典型的语义化发展和应用尝试。\n\n### <font color=13aa6c>BFC 背后的布局问题</font>\n\nCSS 给人的感觉就是 simple，但是前端开发者一定深有体会：simple 并不意味着 easy。我们这里不一一列举各种 CSS “疑难杂症”，而是深入一个概念 —— BFC。BFC 是前端面试中的一个超级热点，今日头条某部门曾经就问过我：\n\n> 请解释一下 BFC 是什么？\n\n回答这个问题并不困难，但是我们可以继续追问：\n\n> BFC 会引起哪些布局现象？\n\n这一小节，我们通过对 BFC 的分析，也顺带回顾一下那些 CSS 常考的小细节。\n\n#### BFC 是什么\n\n简单来说，BFC 就是：\n\nBFC 是 Block Formatting Context 的简写，我们可以直接翻译成“块级格式化上下文”。它会创建一个特殊的区域，在这个区域中，只有 block box 参与布局。而 BFC 的一套特点和规则就规定了在这个特殊的区域中如何进行布局，如何进行定位，区域内元素的相互关系和相互作用。这个特殊的区域不受外界影响。\n\n上面提到了 block box 的概念，block box 是指 display 属性为 block、list-item、table 的元素。\n\n顺便插一个问题：那你还知道其他哪些 box 类型呢？\n\n相应地，我们有 inline box，它是指 display 属性为 inline、inline-block、inline-table 的元素。CSS3 规范中又加入了 run in box，这里我们不再展开。\n\n#### 如何形成 BFC \n\n那么什么样的情况会创建一个 BFC 呢？MDN 总结如下：\n\n- 根元素或其他包含它的元素\n- 浮动元素 (元素的 float 不是 none)\n- 绝对定位元素 (元素具有 position 为 absolute 或 fixed)\n- 内联块 (元素具有 display: inline-block)\n- 表格单元格 (元素具有 display: table-cell，HTML 表格单元格默认属性)\n- 表格标题 (元素具有 display: table-caption, HTML 表格标题默认属性)\n- 具有 overflow 且值不是 visible 的块元素\n- display: flow-root 的元素\n- column-span: all 的元素\n\n#### BFC 决定了什么\n\n我们上面谈到了 BFC 的一套规则，那么这些规则都有哪些呢？\n\n- 内部的 box 将会独占宽度，且在垂直方向，一个接一个排列\n- box 垂直方向的间距由 margin 属性决定，但是同一个 BFC 的两个相邻 box 的 margin 会出现边距折叠现象\n- 每个 box 水平方向上左边缘，与 BFC 左边缘相对齐，即使存在浮动也是如此\n- BFC 区域不会与浮动元素重叠，而是会依次排列\n- BFC 区域内是一个独立的渲染容器，容器内元素和  BFC 区域外元素不会形成任何干扰\n- 浮动元素的高度也参与到 BFC 高度的计算当中\n\n从这些规则中，我们至少能总结出一些关键要点，比如：\n\n- 边距折叠\n- 清除浮动\n- 自适应多栏布局\n\n这也是我选取 BFC 这个概念来剖析的原因，理解了 BFC，这些常见、常考知识点我们都可以融会贯通，具体来看下下面的场景。\n\n#### BFC 实战应用\n\n- 例题1\n\n给出如下代码：\n\n```\n<style>\n\tbody {\n\t    width: 600px;\n\t    position: relative;\n\t}\n\t\n\t.left {\n\t\twidth: 80px;\n\t\theight: 150px;\n\t\tfloat: left;\n\t\tbackground: blue;\n\t}\n\t\n\t.right {\n\t    height: 200px;\n\t    background: red;\n\t}\n</style>\n\n<body>\n    <div class=\"left\"></div>\n    <div class=\"right\"></div>\n</body>\n```\n\n我们得到布局如图：\n\n![enter image description here](https://images.gitbook.cn/04b9dab0-88e8-11e9-88f0-f1d5a1392b19)\n\n请在不修改已有内容情况下，加入样式，实现自适应（.left 宽度固定，.right 占满剩下宽度）两栏布局。\n\n我们来思考：根据 BFC 布局规则：“每个 box 水平方向上左边缘，与 BFC 左边缘相对齐。即使存在浮动也是如此”，因此 .left 和 .right 的左边相接触。出现如此布局结果并不意外。\n\n同时，再想想 BFC 布局规则：“BFC 区域不会与浮动元素重叠，而是会依次排列”，因此我们可以使 .right 形成 BFC，来实现自适应两栏布局。如何形成 BFC 前面已经做过介绍了，于是添加：\n\n```\n.right {\n    overflow: hidden;\n}\n```\n\n就可以得到：\n\n![enter image description here](https://images.gitbook.cn/a9bd6130-8915-11e9-b157-776f1929e232)\n\n当然，这种布局可以用更先进的 flex 或者 grid 手段解决，但是对于 BFC 这些 CSS 基础知识，同样要做到了然于胸。\n\n- 例题 2\n\n看代码：\n\n```\n<style>\n    .root {\n        border: 5px solid blue;\n        width: 300px;\n    }\n \n    .child {\n        border: 5px solid red;\n        width:100px;\n        height: 100px;\n        float: left;\n    }\n</style>\n<body>\n    <div class=\"root\">\n        <div class=\"child child1\"></div>\n        <div class=\"child child2\"></div>\n    </div>\n</body>\n```\n\n首先来回答第一个问：**.root 的高度是多少？**\n\n事实上，因为 .child 为浮动元素，因此造成了“高度塌陷”现象，.root 的高度为 0。\n\n<img src=\"https://images.gitbook.cn/ca790c80-8915-11e9-8115-8f03dd50b734\" width = \"70%\" />\n\n那么如何解决“高度塌陷”问题呢？\n\n想想 BFC 规则：“浮动元素的高度也参与到 BFC 高度的计算当中”，因此使 .root 形成 BFC，就能解决问题：\n\n```\n.root {\n    overflow: hidden;\n}\n```\n\n<img src=\"https://images.gitbook.cn/06df63e0-8916-11e9-8115-8f03dd50b734\" width = \"80%\" />\n\n我们看此时高度已经被你撑开了。\n\n- 例题 3\n\n代码：\n\n```\n<style>\n    p {\n        color: blue;\n        background: red;\n        width: 400px;\n        line-height: 100px;\n        text-align:center;\n        margin: 40px;\n    }\n</style>\n<body>\n    <p>paragraph 1</p>\n    <p>paragraph 2</p>\n</body>\n```\n\n首先回答问题：**两段之间的垂直距离为多少？** 想想 BFC 规则：“box 垂直方向的间距由 margin 属性决定，但是**同一个** BFC 的两个相邻 box 的 margin 会出现边距折叠现象”。事实上，因为边距折叠现象，答案为 40px。\n\n那么如何解决这个问题呢？\n\n最简单地，我们可以在 p 标签再包裹一个元素，并触发该元素形成一个BFC。那么这两个 p 标签，不再属于同一个 BFC，从而解决问题。\n\n```\n<style>\n    p {\n        color: blue;\n        background: red;\n        width: 400px;\n        line-height: 100px;\n        text-align:center;\n        margin: 40px;\n    }\n    .wrapper {\n    \toverflow: hidden\n    }\n</style>\n<body>\n    <p>paragraph 1</p>\n    <div class=\"wrapper\">\n    \t<p>paragraph 2</p>\n    </div>\n</body>\n```\n\n<img src=\"https://images.gitbook.cn/2f329240-8916-11e9-b157-776f1929e232\" width = \"50%\" />\n\n**总结**：我们通过分析 BFC 是什么、如何形成、布局规则，融会贯通了 CSS 当中很多关键问题。也许不少读者能够解决“边距折叠”、“多栏自适应”、“高度塌陷”等问题，但是并不能说出解决问题的原理。通过这一环节的学习，我们对 CSS 加深了理解，我更希望地是能够启发大家思考：我们到底应该如何对待 CSS、如何学习 CSS。\n\n### <font color=13aa6c>多种方式实现居中</font>\n\n“实现居中”也是一道必考题。参考代码：\n\n```\n<style>\n.wp {\n    border: 1px solid red;\n    width: 300px;\n    height: 300px;\n}\n\n.box {\n    background: green;    \n}\n\n.box .fixed-size {\n    width: 100px;\n    height: 100px;\n}\n</style>\n\n<body>\n\t<div class=\"wp\">\n\t   <div class=\"box fixed-size\">text</div>\n\t</div>\n</body>\n```\n\n如图：\n\n<img src=\"https://images.gitbook.cn/5c895260-8916-11e9-b157-776f1929e232\" width = \"50%\" />\n\n如何让绿色的块水平垂直居中呢？\n\n总结一下：\n\n#### 仅适用于居中元素定宽高\n\n- absolute + 负 margin\n\n```\n.wp {\n    position: relative;\n}\n.box {\n    position: absolute;;\n    top: 50%;\n    left: 50%;\n    margin-left: -50px;\n    margin-top: -50px;\n}\n```\n\n绝对定位的百分比是相对于父元素的宽高，我们设置：\n\n```\ntop: 50%;\nleft: 50%;\n```\n\n使得元素偏移后，在修正元素自身宽高的一半即可：\n\n```\nmargin-left: -50px;\nmargin-top: -50px;\n```\n\n这其实是一个简单的数学几何运算。\n\n- absolute + margin auto\n\n```\n.wp {\n    position: relative;\n}\n.box {\n    position: absolute;;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    margin: auto;\n}\n```\n\n这种方式将设置各个方向的距离都是 0，此时配合 margin 为 auto，就可以在各个方向上居中了。\n\n- absolute + calc\n\n```\n.root {\n    position: relative;\n}\n.textBox {\n    position: absolute;;\n    top: calc(50% - 50px);\n    left: calc(50% - 50px);\n}\n```\n\n此种方法和第一种类似，不再展开。\n\n#### 居中元素不定宽高\n\n对于剧中元素不定宽高的情况：\n\n```\n<style>\n.wp {\n    border: 1px solid red;\n    width: 300px;\n    height: 300px;\n}\n\n.box {\n    background: green;    \n}\n</style>\n\n<body>\n\t<div class=\"wp\">\n\t   <div class=\"box \">text</div>\n\t</div>\n</body>\n```\n\n我们依然也有很多方法。\n\n- absolute + transform\n\n不定宽高时，利用 CSS3 新增的 transform，transform 的 translate 属性也可以设置百分比，这个百分比是相对于自身的宽和高，因此可以将 translate 设置为 ﹣50%：\n\n```\n.wp {\n    position: relative;\n}\n.box {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n}\n```\n\n原理和第一种方法也类似。\n\n- lineheight\n\n把 box 设置为行内元素，通过 text-align 也可以做到水平居中，同时通过 vertical-align 做到垂直方向上的居中，代码如下：\n\n```\n.wp {\n    line-height: 300px;\n    text-align: center;\n    font-size: 0px;\n}\n.box {\n    font-size: 16px;\n    display: inline-block;\n    vertical-align: middle;\n    line-height: initial;\n    text-align: left; /* 修正文字 */\n}\n```\n\n这个方法充分利用了行内 / 块级元素的特点。\n\n- table\n\n其实历史上 table 经常被用来做页面布局，这么做的缺点是会增加很多冗余代码，并且性能也不友好。不过处理居中问题，它可是能手：\n\n```\n<table>\n    <tbody>\n        <tr>\n            <td class=\"wp\">\n                <div class=\"box\">test</div>\n            </td>\n        </tr>\n    </tbody>\n</table>\n\n.wp {\n    text-align: center;\n}\n.box {\n    display: inline-block;\n}\n```\n\n- css-table\n\n如何使用 table 布局的特性效果，但是不采用 table 元素呢？答案是 css-table：\n\n```\n.wp {\n    display: table-cell;\n    text-align: center;\n    vertical-align: middle;\n}\n.box {\n    display: inline-block;\n}\n```\n\n我们使用了 display: table-cell，同时和 table 布局相比，减少了很多冗余代码。\n\n- flex\n\nflex 是非常现代的布局方案，只需几行代码就可以优雅地做到居中：\n\n```\n.wp {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n```\n\n- grid\n\ngrid 布局非常超前，虽然兼容性不好，但是能力超强：\n\n```\n.wp {\n    display: grid;\n}\n.box {\n    align-self: center;\n    justify-self: center;\n}\n```\n\n我们总结一下：\n\n- PC 端有兼容性要求，宽高固定，推荐 absolute + 负 margin\n- PC 端有兼容要求，宽高不固定，推荐 css-table\n- PC 端无兼容性要求，推荐 flex\n- 移动端推荐使用 flex\n\n最后整理一个列表：\n\n<img src=\"https://images.gitbook.cn/8cce31c0-8916-11e9-88f0-f1d5a1392b19\" width = \"75%\" />\n\n### <font color=13aa6c>总结</font>\n\nHTML 和 CSS 面试中考察较少，但是如果答的不好，将是致命性的。同时工作中，如果这方面知识存在短板，往往会造成不必要的效率消耗。我们应该正视前端领域这两个离不开的“面子工程”，为了更好的面试结果，更为了自己的技能。\n\n### <font color=13aa6c>分享交流</font>\n\n阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。**你的分享不仅帮助他人，更会提升自己。**\n\n你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。\n","pdfUrl":"","reader":"","duration":"","title":"前端面试离不开的“面子工程”","column":"5c91c813968b1d64b1e08fde","isNotification":false,"htmlContent":"<p>我们都知道前端开发中的“三驾马车”：HTML + CSS + JavaScript。从难易程度、受关注程度上来讲，显然 JavaScript 始终处于核心地位。但是这并不意味着 HTML 和 CSS 不重要，如果你轻视它们，那么也许会在工作开发中、甚至面试中吃亏。</p>\n<p>作为多年的面试官，我的考察重点无疑是 JavaScript，但在面试过程中，每次也总是会“蜻蜓点水”下，这足以了解候选者对待 HTML 和 CSS 的态度以及了解程度。其实事实上，HTML 和 CSS 也有很多有趣的内容，下面就让我们在复习重点知识的同时，了解一些前沿用法。</p>\n<p>这一讲，我挑选出了 HTML 和 CSS 几个关键概念，不去力求“面面俱到”，但希望给大家带来新的启发。</p>\n<p>相关知识点如下：</p>\n<img src=\"https://images.gitbook.cn/db85d420-88e5-11e9-b068-5302ecb579f2\" width=500>\n<h3><a id=\"font_color13aa6c_HTML_font_10\"></a><font color=13aa6c>如何理解 HTML 语义化</font></h3>\n<p>HTML 语义化——这个概念其实诞生了挺长时间，我经常发现在面试 JD（Job Description） 中出现要求候选者“了解 HTML 语义化”、“对 HTML 语义化有深刻认知”的需求。对于这么一句 JD 范式标配，如果面试官真的问起，该如何回答呢？</p>\n<h4><a id=\"_14\"></a>语义化是什么、为什么、怎么做</h4>\n<p>简单来说，HTML 语义化就是：</p>\n<blockquote>\n<p>根据结构化的内容，选择合适的标签。</p>\n</blockquote>\n<p>那么为什么要做到语义化呢？</p>\n<p>直观上很好理解，“合适的标签”是内容表达的高度概括，这样浏览器爬虫或者任何机器在读取 HTML 时，都能更好地理解，进而解析效率更高。这样带来的收益如下：</p>\n<ul>\n<li>有利于 SEO</li>\n<li>开发维护体验更好</li>\n<li>用户体验更好（如使用 alt 标签用于解释图片信息）</li>\n<li>更好的 accessibility，方便任何设备解析（如盲人阅读器）</li>\n</ul>\n<p>那么如何做到语义化呢？</p>\n<p>其实很简单，这就要求我们实时跟进、学习并使用语义化标签。这里我帮大家总结了一些典型的 HTML 标签，并进行分类。</p>\n<p><img src=\"https://images.gitbook.cn/2aa65430-88e6-11e9-8115-8f03dd50b734\" alt=\"enter image description here\" /></p>\n<p>我将 HTML 标签分为 9 大类别，每一种类别都包含有语义化的标签内容，小图如下：</p>\n<p><img src=\"https://images.gitbook.cn/50392a10-88e6-11e9-b157-776f1929e232\" alt=\"enter image description here\" /></p>\n<p><img src=\"https://images.gitbook.cn/78d71d10-88e6-11e9-88f0-f1d5a1392b19\" alt=\"enter image description here\" /></p>\n<img src=\"https://images.gitbook.cn/ef3dc850-88e6-11e9-8115-8f03dd50b734\" width = \"60%\" />\n<p>了解了这些语义化的标签，我们就可以按照“适合内容与否”，进行使用。关于选取标准，我也简单总结了一下，抽象成代码表达为：</p>\n<pre><code class=\"lang-\">if (导航) {\n  return &lt;nav /&gt;\n}\nelse if (文稿内容、博客内容、评论内容...包含标题元素的内容) {\n  return &lt;article /&gt;\n}\nelse if (目录抽象、边栏、广告、批注) {\n  return &lt;aside /&gt;\n}\nelse if (含有附录、图片、代码、图形) {\n  return &lt;figure /&gt;\n}\nelse if (含有多个标题或内容的区块) {\n return &lt;section /&gt;\n}\nelse if (含有段落、语法意义) {\n  return &lt;p /&gt; || &lt;address /&gt; || &lt;blockquote /&gt; || &lt;pre /&gt; || ...\n}\nelse {\n  return &lt;div /&gt;\n}\n</code></pre>\n<h4><a id=\"_69\"></a>语义化的发展和高级玩法</h4>\n<p>说到语义化的发展，我这里指向重点提一个概念：Microformats，如果面试官问的语义化时，你能把这个概念搬出来，效果是非常好的。那什么是 Microformats 呢？</p>\n<blockquote>\n<p>Microformats，翻译为微格式，是 HTML 标记某些实体的小模式，这些实体包括人、组织、事件、地点、博客、产品、评论、简历、食谱等。它们是在 HTML 中嵌套语义的简单协议，且能迅速地提供一套可被搜索引擎、聚合器等其他工具使用的 API。</p>\n</blockquote>\n<p>除了 hCard 和 hCalendar，有好几个库特别开发了微格式。</p>\n<p>是不是看的一脸懵逼？其实很简单，Microformats 的原理就是扩展 HTML 元素或者属性，来增强 HTML 的语义表达能力。</p>\n<p>我们来看一个案例：</p>\n<p><img src=\"https://images.gitbook.cn/4bd676c0-88e7-11e9-8115-8f03dd50b734\" alt=\"enter image description here\" /></p>\n<p>Wikipedia 的页面中，给某一部分加上了 vCard 的 class，这是用来做什么的呢？</p>\n<p><img src=\"https://images.gitbook.cn/d8469cc0-88e7-11e9-b068-5302ecb579f2\" alt=\"enter image description here\" /></p>\n<p>Google 搜索引擎可以通过 Wikipedia 页面 vCard 这个 class，读取相关内容，在呈现搜索结果时，匹配展现出人物信息。从而语义化的 class，帮助了机器（搜索爬出）学习到更多信息，展现出了更好的结果页面。</p>\n<p>Microdata 属于 WHATWG（网页超文本应用技术工作小组：Web Hypertext Application Technology Working） HTML 规范，它并不是标准，但这是一个很典型的语义化发展和应用尝试。</p>\n<h3><a id=\"font_color13aa6cBFC_font_91\"></a><font color=13aa6c>BFC 背后的布局问题</font></h3>\n<p>CSS 给人的感觉就是 simple，但是前端开发者一定深有体会：simple 并不意味着 easy。我们这里不一一列举各种 CSS “疑难杂症”，而是深入一个概念 —— BFC。BFC 是前端面试中的一个超级热点，今日头条某部门曾经就问过我：</p>\n<blockquote>\n<p>请解释一下 BFC 是什么？</p>\n</blockquote>\n<p>回答这个问题并不困难，但是我们可以继续追问：</p>\n<blockquote>\n<p>BFC 会引起哪些布局现象？</p>\n</blockquote>\n<p>这一小节，我们通过对 BFC 的分析，也顺带回顾一下那些 CSS 常考的小细节。</p>\n<h4><a id=\"BFC__103\"></a>BFC 是什么</h4>\n<p>简单来说，BFC 就是：</p>\n<p>BFC 是 Block Formatting Context 的简写，我们可以直接翻译成“块级格式化上下文”。它会创建一个特殊的区域，在这个区域中，只有 block box 参与布局。而 BFC 的一套特点和规则就规定了在这个特殊的区域中如何进行布局，如何进行定位，区域内元素的相互关系和相互作用。这个特殊的区域不受外界影响。</p>\n<p>上面提到了 block box 的概念，block box 是指 display 属性为 block、list-item、table 的元素。</p>\n<p>顺便插一个问题：那你还知道其他哪些 box 类型呢？</p>\n<p>相应地，我们有 inline box，它是指 display 属性为 inline、inline-block、inline-table 的元素。CSS3 规范中又加入了 run in box，这里我们不再展开。</p>\n<h4><a id=\"_BFC_115\"></a>如何形成 BFC</h4>\n<p>那么什么样的情况会创建一个 BFC 呢？MDN 总结如下：</p>\n<ul>\n<li>根元素或其他包含它的元素</li>\n<li>浮动元素 (元素的 float 不是 none)</li>\n<li>绝对定位元素 (元素具有 position 为 absolute 或 fixed)</li>\n<li>内联块 (元素具有 display: inline-block)</li>\n<li>表格单元格 (元素具有 display: table-cell，HTML 表格单元格默认属性)</li>\n<li>表格标题 (元素具有 display: table-caption, HTML 表格标题默认属性)</li>\n<li>具有 overflow 且值不是 visible 的块元素</li>\n<li>display: flow-root 的元素</li>\n<li>column-span: all 的元素</li>\n</ul>\n<h4><a id=\"BFC__129\"></a>BFC 决定了什么</h4>\n<p>我们上面谈到了 BFC 的一套规则，那么这些规则都有哪些呢？</p>\n<ul>\n<li>内部的 box 将会独占宽度，且在垂直方向，一个接一个排列</li>\n<li>box 垂直方向的间距由 margin 属性决定，但是同一个 BFC 的两个相邻 box 的 margin 会出现边距折叠现象</li>\n<li>每个 box 水平方向上左边缘，与 BFC 左边缘相对齐，即使存在浮动也是如此</li>\n<li>BFC 区域不会与浮动元素重叠，而是会依次排列</li>\n<li>BFC 区域内是一个独立的渲染容器，容器内元素和  BFC 区域外元素不会形成任何干扰</li>\n<li>浮动元素的高度也参与到 BFC 高度的计算当中</li>\n</ul>\n<p>从这些规则中，我们至少能总结出一些关键要点，比如：</p>\n<ul>\n<li>边距折叠</li>\n<li>清除浮动</li>\n<li>自适应多栏布局</li>\n</ul>\n<p>这也是我选取 BFC 这个概念来剖析的原因，理解了 BFC，这些常见、常考知识点我们都可以融会贯通，具体来看下下面的场景。</p>\n<h4><a id=\"BFC__148\"></a>BFC 实战应用</h4>\n<ul>\n<li>例题1</li>\n</ul>\n<p>给出如下代码：</p>\n<pre><code class=\"lang-\">&lt;style&gt;\n\tbody {\n\t    width: 600px;\n\t    position: relative;\n\t}\n\t\n\t.left {\n\t\twidth: 80px;\n\t\theight: 150px;\n\t\tfloat: left;\n\t\tbackground: blue;\n\t}\n\t\n\t.right {\n\t    height: 200px;\n\t    background: red;\n\t}\n&lt;/style&gt;\n\n&lt;body&gt;\n    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;\n&lt;/body&gt;\n</code></pre>\n<p>我们得到布局如图：</p>\n<p><img src=\"https://images.gitbook.cn/04b9dab0-88e8-11e9-88f0-f1d5a1392b19\" alt=\"enter image description here\" /></p>\n<p>请在不修改已有内容情况下，加入样式，实现自适应（.left 宽度固定，.right 占满剩下宽度）两栏布局。</p>\n<p>我们来思考：根据 BFC 布局规则：“每个 box 水平方向上左边缘，与 BFC 左边缘相对齐。即使存在浮动也是如此”，因此 .left 和 .right 的左边相接触。出现如此布局结果并不意外。</p>\n<p>同时，再想想 BFC 布局规则：“BFC 区域不会与浮动元素重叠，而是会依次排列”，因此我们可以使 .right 形成 BFC，来实现自适应两栏布局。如何形成 BFC 前面已经做过介绍了，于是添加：</p>\n<pre><code class=\"lang-\">.right {\n    overflow: hidden;\n}\n</code></pre>\n<p>就可以得到：</p>\n<p><img src=\"https://images.gitbook.cn/a9bd6130-8915-11e9-b157-776f1929e232\" alt=\"enter image description here\" /></p>\n<p>当然，这种布局可以用更先进的 flex 或者 grid 手段解决，但是对于 BFC 这些 CSS 基础知识，同样要做到了然于胸。</p>\n<ul>\n<li>例题 2</li>\n</ul>\n<p>看代码：</p>\n<pre><code class=\"lang-\">&lt;style&gt;\n    .root {\n        border: 5px solid blue;\n        width: 300px;\n    }\n \n    .child {\n        border: 5px solid red;\n        width:100px;\n        height: 100px;\n        float: left;\n    }\n&lt;/style&gt;\n&lt;body&gt;\n    &lt;div class=&quot;root&quot;&gt;\n        &lt;div class=&quot;child child1&quot;&gt;&lt;/div&gt;\n        &lt;div class=&quot;child child2&quot;&gt;&lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n</code></pre>\n<p>首先来回答第一个问：<strong>.root 的高度是多少？</strong></p>\n<p>事实上，因为 .child 为浮动元素，因此造成了“高度塌陷”现象，.root 的高度为 0。</p>\n<img src=\"https://images.gitbook.cn/ca790c80-8915-11e9-8115-8f03dd50b734\" width = \"70%\" />\n<p>那么如何解决“高度塌陷”问题呢？</p>\n<p>想想 BFC 规则：“浮动元素的高度也参与到 BFC 高度的计算当中”，因此使 .root 形成 BFC，就能解决问题：</p>\n<pre><code class=\"lang-\">.root {\n    overflow: hidden;\n}\n</code></pre>\n<img src=\"https://images.gitbook.cn/06df63e0-8916-11e9-8115-8f03dd50b734\" width = \"80%\" />\n<p>我们看此时高度已经被你撑开了。</p>\n<ul>\n<li>例题 3</li>\n</ul>\n<p>代码：</p>\n<pre><code class=\"lang-\">&lt;style&gt;\n    p {\n        color: blue;\n        background: red;\n        width: 400px;\n        line-height: 100px;\n        text-align:center;\n        margin: 40px;\n    }\n&lt;/style&gt;\n&lt;body&gt;\n    &lt;p&gt;paragraph 1&lt;/p&gt;\n    &lt;p&gt;paragraph 2&lt;/p&gt;\n&lt;/body&gt;\n</code></pre>\n<p>首先回答问题：<strong>两段之间的垂直距离为多少？</strong> 想想 BFC 规则：“box 垂直方向的间距由 margin 属性决定，但是<strong>同一个</strong> BFC 的两个相邻 box 的 margin 会出现边距折叠现象”。事实上，因为边距折叠现象，答案为 40px。</p>\n<p>那么如何解决这个问题呢？</p>\n<p>最简单地，我们可以在 p 标签再包裹一个元素，并触发该元素形成一个BFC。那么这两个 p 标签，不再属于同一个 BFC，从而解决问题。</p>\n<pre><code class=\"lang-\">&lt;style&gt;\n    p {\n        color: blue;\n        background: red;\n        width: 400px;\n        line-height: 100px;\n        text-align:center;\n        margin: 40px;\n    }\n    .wrapper {\n    \toverflow: hidden\n    }\n&lt;/style&gt;\n&lt;body&gt;\n    &lt;p&gt;paragraph 1&lt;/p&gt;\n    &lt;div class=&quot;wrapper&quot;&gt;\n    \t&lt;p&gt;paragraph 2&lt;/p&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n</code></pre>\n<img src=\"https://images.gitbook.cn/2f329240-8916-11e9-b157-776f1929e232\" width = \"50%\" />\n<p><strong>总结</strong>：我们通过分析 BFC 是什么、如何形成、布局规则，融会贯通了 CSS 当中很多关键问题。也许不少读者能够解决“边距折叠”、“多栏自适应”、“高度塌陷”等问题，但是并不能说出解决问题的原理。通过这一环节的学习，我们对 CSS 加深了理解，我更希望地是能够启发大家思考：我们到底应该如何对待 CSS、如何学习 CSS。</p>\n<h3><a id=\"font_color13aa6cfont_301\"></a><font color=13aa6c>多种方式实现居中</font></h3>\n<p>“实现居中”也是一道必考题。参考代码：</p>\n<pre><code class=\"lang-\">&lt;style&gt;\n.wp {\n    border: 1px solid red;\n    width: 300px;\n    height: 300px;\n}\n\n.box {\n    background: green;    \n}\n\n.box .fixed-size {\n    width: 100px;\n    height: 100px;\n}\n&lt;/style&gt;\n\n&lt;body&gt;\n\t&lt;div class=&quot;wp&quot;&gt;\n\t   &lt;div class=&quot;box fixed-size&quot;&gt;text&lt;/div&gt;\n\t&lt;/div&gt;\n&lt;/body&gt;\n</code></pre>\n<p>如图：</p>\n<img src=\"https://images.gitbook.cn/5c895260-8916-11e9-b157-776f1929e232\" width = \"50%\" />\n<p>如何让绿色的块水平垂直居中呢？</p>\n<p>总结一下：</p>\n<h4><a id=\"_338\"></a>仅适用于居中元素定宽高</h4>\n<ul>\n<li>absolute + 负 margin</li>\n</ul>\n<pre><code class=\"lang-\">.wp {\n    position: relative;\n}\n.box {\n    position: absolute;;\n    top: 50%;\n    left: 50%;\n    margin-left: -50px;\n    margin-top: -50px;\n}\n</code></pre>\n<p>绝对定位的百分比是相对于父元素的宽高，我们设置：</p>\n<pre><code class=\"lang-\">top: 50%;\nleft: 50%;\n</code></pre>\n<p>使得元素偏移后，在修正元素自身宽高的一半即可：</p>\n<pre><code class=\"lang-\">margin-left: -50px;\nmargin-top: -50px;\n</code></pre>\n<p>这其实是一个简单的数学几何运算。</p>\n<ul>\n<li>absolute + margin auto</li>\n</ul>\n<pre><code class=\"lang-\">.wp {\n    position: relative;\n}\n.box {\n    position: absolute;;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    margin: auto;\n}\n</code></pre>\n<p>这种方式将设置各个方向的距离都是 0，此时配合 margin 为 auto，就可以在各个方向上居中了。</p>\n<ul>\n<li>absolute + calc</li>\n</ul>\n<pre><code class=\"lang-\">.root {\n    position: relative;\n}\n.textBox {\n    position: absolute;;\n    top: calc(50% - 50px);\n    left: calc(50% - 50px);\n}\n</code></pre>\n<p>此种方法和第一种类似，不再展开。</p>\n<h4><a id=\"_404\"></a>居中元素不定宽高</h4>\n<p>对于剧中元素不定宽高的情况：</p>\n<pre><code class=\"lang-\">&lt;style&gt;\n.wp {\n    border: 1px solid red;\n    width: 300px;\n    height: 300px;\n}\n\n.box {\n    background: green;    \n}\n&lt;/style&gt;\n\n&lt;body&gt;\n\t&lt;div class=&quot;wp&quot;&gt;\n\t   &lt;div class=&quot;box &quot;&gt;text&lt;/div&gt;\n\t&lt;/div&gt;\n&lt;/body&gt;\n</code></pre>\n<p>我们依然也有很多方法。</p>\n<ul>\n<li>absolute + transform</li>\n</ul>\n<p>不定宽高时，利用 CSS3 新增的 transform，transform 的 translate 属性也可以设置百分比，这个百分比是相对于自身的宽和高，因此可以将 translate 设置为 ﹣50%：</p>\n<pre><code class=\"lang-\">.wp {\n    position: relative;\n}\n.box {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n}\n</code></pre>\n<p>原理和第一种方法也类似。</p>\n<ul>\n<li>lineheight</li>\n</ul>\n<p>把 box 设置为行内元素，通过 text-align 也可以做到水平居中，同时通过 vertical-align 做到垂直方向上的居中，代码如下：</p>\n<pre><code class=\"lang-\">.wp {\n    line-height: 300px;\n    text-align: center;\n    font-size: 0px;\n}\n.box {\n    font-size: 16px;\n    display: inline-block;\n    vertical-align: middle;\n    line-height: initial;\n    text-align: left; /* 修正文字 */\n}\n</code></pre>\n<p>这个方法充分利用了行内 / 块级元素的特点。</p>\n<ul>\n<li>table</li>\n</ul>\n<p>其实历史上 table 经常被用来做页面布局，这么做的缺点是会增加很多冗余代码，并且性能也不友好。不过处理居中问题，它可是能手：</p>\n<pre><code class=\"lang-\">&lt;table&gt;\n    &lt;tbody&gt;\n        &lt;tr&gt;\n            &lt;td class=&quot;wp&quot;&gt;\n                &lt;div class=&quot;box&quot;&gt;test&lt;/div&gt;\n            &lt;/td&gt;\n        &lt;/tr&gt;\n    &lt;/tbody&gt;\n&lt;/table&gt;\n\n.wp {\n    text-align: center;\n}\n.box {\n    display: inline-block;\n}\n</code></pre>\n<ul>\n<li>css-table</li>\n</ul>\n<p>如何使用 table 布局的特性效果，但是不采用 table 元素呢？答案是 css-table：</p>\n<pre><code class=\"lang-\">.wp {\n    display: table-cell;\n    text-align: center;\n    vertical-align: middle;\n}\n.box {\n    display: inline-block;\n}\n</code></pre>\n<p>我们使用了 display: table-cell，同时和 table 布局相比，减少了很多冗余代码。</p>\n<ul>\n<li>flex</li>\n</ul>\n<p>flex 是非常现代的布局方案，只需几行代码就可以优雅地做到居中：</p>\n<pre><code class=\"lang-\">.wp {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n</code></pre>\n<ul>\n<li>grid</li>\n</ul>\n<p>grid 布局非常超前，虽然兼容性不好，但是能力超强：</p>\n<pre><code class=\"lang-\">.wp {\n    display: grid;\n}\n.box {\n    align-self: center;\n    justify-self: center;\n}\n</code></pre>\n<p>我们总结一下：</p>\n<ul>\n<li>PC 端有兼容性要求，宽高固定，推荐 absolute + 负 margin</li>\n<li>PC 端有兼容要求，宽高不固定，推荐 css-table</li>\n<li>PC 端无兼容性要求，推荐 flex</li>\n<li>移动端推荐使用 flex</li>\n</ul>\n<p>最后整理一个列表：</p>\n<img src=\"https://images.gitbook.cn/8cce31c0-8916-11e9-88f0-f1d5a1392b19\" width = \"75%\" />\n<h3><a id=\"font_color13aa6cfont_546\"></a><font color=13aa6c>总结</font></h3>\n<p>HTML 和 CSS 面试中考察较少，但是如果答的不好，将是致命性的。同时工作中，如果这方面知识存在短板，往往会造成不必要的效率消耗。我们应该正视前端领域这两个离不开的“面子工程”，为了更好的面试结果，更为了自己的技能。</p>\n<h3><a id=\"font_color13aa6cfont_550\"></a><font color=13aa6c>分享交流</font></h3>\n<p>阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。<strong>你的分享不仅帮助他人，更会提升自己。</strong></p>\n<p>你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。</p>\n","readingStatistics":126,"createdAt":"2019-04-21T04:00:53.203Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":13,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FoThASW9dVEPMEo9nP-zaOfbKyLZ"},{"_id":"5cbbef07bbbba80861a35c21","communication_start_time":null,"type":1,"audioPath":"","abstract":"","content":"通过前面的课程介绍，我们认识到了 JavaScript 语言的飞速发展。其实 HTML 和 CSS 也不断“要求着”进步，本节课程我们就来了解一下发展中的 HTML 和 CSS。之所以叫做“进击的”，是因为确实有很多新的特性非常实用且具有变革精神。\n\n相关知识点如下：\n\n<img src=\"https://images.gitbook.cn/1c028dd0-8fdb-11e9-9c86-a1bad3faf0f2\" width=500>\n\n其中，除了罗列一些热点面试题目以外，我们将重点分析 CSS 变量和 CSS Modules，我认为这两个概念代表了未来的发展方向。当下来看，也有必要根据情况，融合到成熟的项目中，加以应用。因此这方面的内容除了基本理论，我都会给出实战案例和构建流程。\n\n### <font color=13aa6c>进击的 HTML</font>\n\n我们再来看看 HTML 的历史和规范常识。HTML 规范是 W3C 与 WHATWG 合作共同产出的，HTML5 因此也不例外。其中：\n\n- W3C 指 World Wide Web Consortium\n- WHATWG 指 Web Hypertext Application Technology Working Group\n\n说好听了是“合作产出”，但其实更像是“HTML5 有两套规范”。但话说天下大势合久必分，分久必合，如今（就在前几天，2018.5.29）它们又表示将会开发单一版本的 HTML 规范。\n\n那么 HTML5 给开发者提供了哪些便利呢？简单列举有：\n\n- 用于绘画的 canvas 元素\n- 用于媒介播放的 video 和 audio 元素\n- 对本地离线存储更好的支持（localStorage、sessionStorage）\n- 新的语义化标签（article、footer、header、nav、section...)\n- 新的表单控件（calendar、date、time、email、url、search...)\n\n除了这些常规的之外，还有：\n\n- 给汉字加拼音\n\n```\n<ruby> \n\t前端开发核心知识进阶\n\t<rt>\n\t\tqianduankaifahexinzhishijinjie\n\t</rt> \n</ruby>\n```\n\n<img src=\"https://images.gitbook.cn/2853de80-8fd2-11e9-afed-87af38460e36\" width = \"70%\" />\n\n- 展开收起组件\n\n简单几行代码：\n\n```\n<details>\n  <summary>前端开发核心知识进阶</summary>\n前端领域，入门相对简单，可是想要“更上一层楼”却难上加难，也就是我们常说的“职业天花板较低”，君不见——市场上高级/资深前端工程师凤毛麟角。这当然未必完全是坏事，一旦突破瓶颈，在技能上脱颖而出，便是更广阔的空间。那么，如何从夯实基础到突破瓶颈？\n</details>\n```\n\n就可以实现：\n\n<img src=\"https://images.gitbook.cn/649e4970-8fd2-11e9-afed-87af38460e36\" width = \"80%\" />\n\n上图为“收起”效果。\n\n<img src=\"https://images.gitbook.cn/dc7b6810-8fd2-11e9-8b34-c732c3ec276d\" width = \"80%\" />\n\n上图为“展开”效果。\n\n以往要实现这样的内容，我们都必须依靠 JavaScript 实现。现在来看，HTML 也变得更加具有“可交互性”。\n\n- 原生进度条和度量\n\nprogress 标签显示进度：\n\n![enter image description here](https://images.gitbook.cn/08358f30-8fd3-11e9-9c86-a1bad3faf0f2)\n\n值得一提的是：progress 不适合用来表示度量衡，如果想表示度量衡，我们应该使用 meter 标签代替。这又是什么标签？\n\n其实 HTML5 新带来的标签多种多样，感兴趣的读者可以自行了解，我们这里不再用更多篇幅介绍。\n\n### <font color=13aa6c>不可忽视的 Web components</font>\n\n事实上，Web components 的概念在几年前也已经提出，貌似一直没有发展的“如火如荼”，这里我为什么又单独拿出来讲呢？\n\n我并不想赘述 Web components 的基础概念，但是我认为，作为“更高阶”的前端工程师，要时刻保持技术视野和信息广度。在框架带来的“组件化”、“生命周期化”这些统治级别的概念下，对比并结合 Web components，我认为是可以深入研究的一个课题方向。我总结一下 Web components 的特殊点或者优点：\n\n- 原生规范，无需框架\n\n这条优点的后半句话是：“但是继承且具备了框架的优点”，在新的 Web components 规范中，我们会发现组件生命周期的概念、slot 概念、模版概念（类比 JSX 或者 Vue template），再结合本来就已经存在的组件化，shadow dom，扩展原生元素的能力，我认为 Web components 还是具备了较好的发展前景。\n\n- 原生使用，无需编译\n\n想想现有的一系列框架，不论是 Vue 还是 React，都需要进行编译。而 Web components 因为原生，会得到浏览器的天然支持，自然就可以免去编译构建过程。\n\n- 真正的 CSS scope\n\nWeb components 实现了真正的 CSS scope，做到了样式隔离。这一点读者可以对比我们下面即将介绍的 CSS Modules。真正的 CSS scope 对于项目的可维护性至关重要。\n\n进击的 HTML 和 CSS 带来了进击的 Web components 概念。通过这个案例，我更想建议读者：真正的高级工程师，不仅仅要理解 this、熟练掌握各种基础（当然这是前提），更要有技术嗅觉，对新的解决方案能够理解，并进行对比，面向“未来”编程。\n\n### <font color=13aa6c>移动端 H5 注意事项总结</font>\n\nHTML5 因为其强大先进的能力，毫无疑问打来了一场开发的变革。在国内，体现最明显的就是各种 H5 移动页面。\n\n因为移动端的碎片化现象，以及技术落地的成熟度尚浅，造成了不少问题，那么移动端开发 H5 有哪些坑以及小技巧呢？\n\n这里列举一些典型情况，目的在于梳理和整理，不再一一详解。具体信息社区上都可以找到，感兴趣的读者可以另行学习。\n\n- 打电话发短信写邮件的小技巧\n\n这些技巧都和 a 标签相关，其中打电话：\n\n```\n<a href=\"tel: 110\">打电话给警察局</a>\n```\n \n发短信：\n\n```\n<a href=\"sms: 110\">发短信给警察局</a>\n```\n \n写邮件依赖“mailto”：\n\n```\n<a href=\"mailto: 110@govn.com\">发邮件给警察局</a>\n```\n\n我们设置可以添加抄送：\n\n```\n<a href=\"mailto: 110@govn.com?cc=baba@family.com\">发邮件给警察局，并抄送给我爸爸</a>\n```\n\n除了抄送，也可以私密发送：\n\n```\n<a href=\"mailto: 110@govn.com?cc=baba@family.com&bcc=mama@family.com\">发邮件给警察局，并抄送给我爸爸，密送给我妈妈</a >\n```\n\n群发也可以：\n\n```\n<a href=\"mailto: 110@govn.com; 120@govn.com\">发邮件给警察局，以及 120 急救</a>\n```\n\n既然都支持群发了，那么定义主题和内容也不在话下：\n\n```\n<a href=\"mailto: 110@govn.com?subject=SOS\">发邮件给警察局，并添加救命主题</a>\n```\n\n包含内容用 body 体现：\n\n```\n<a href=\"mailto: 110@govn.com?subject=SOS&body=快来救我\">发邮件给警察局，并添加救命主题和内容</a>\n```\n\n内容也是支持插入图片和链接的，这里不再一一列举。\n\n- 移动端 300 毫秒点击延迟以及点击穿透现象\n\n这是由于历史原因造成的，一般解决手段为禁止混用 touch 和 click，或者增加一层“透明”蒙层，也可以通过延迟上层元素消失来实现。\n\n- 点击元素禁止产生背景或边框\n\n一般可以使用：\n\n```\n-webkit-tap-highlight-color: rgba(0,0,0,0); \n```\n\n属性进行禁用。\n\n- 禁止长按链接与图片弹出菜单\n\n一般可以使用：\n\n```\n-webkit-touch-callout: none;\n```\n\n- 禁止用户选中文字\n\n```\n-webkit-user-select:none; \nuser-select: none;\n```\n\n- 取消 input 输入时，英文首字母的默认大写\n\n```\n<input autocapitalize=\"off\" autocorrect=\"off\" />\n```\n\niOS 有效。\n\n- 语音和视频自动播放\n\n自动播放是一个很麻烦的话题。不同浏览器内核支持自动播放的情况不一样，甚至 webkit 内核对于自动播放的策略也一直在调整当中。自动播放有时候也带着条件：比如设置静音等。\n\n具体信息更新可以参考：[New video Policies for iOS](https://webkit.org/blog/6784/new-video-policies-for-ios/)。\n\n一般我们设置自动播放的回退策略是用户触摸屏幕时进行的播放：\n\n```\n// JS 绑定自动播放（操作 window 时，播放音乐）\n$(window).on(&apos;touchstart&apos;, () => {\n    video.play()\n})\n\n// 微信环境\ndocument.addEventListener(\"WeixinJSBridgeReady\", () => {\n    video.play()\n}, false)\n```\n\n- 视频全屏播放\n\n为了使视频全屏播放，我们一般设置：\n\n```\n<video x-webkit-airplay=\"true\" webkit-playsinline=\"true\" preload=\"auto\" autoplay src=\"\"></video>\n```\n\n但是最终情况还是要受到浏览器引擎实现的影响。\n\n- 开启硬件加速\n\n在做动画时，为了达到更好的性能效果，我们往往会选用硬件加速。一般手段为：\n\n```\ntransform: translate3d(0,0,0);\n```\n\n- fixed 定位问题\n\n这个问题主要体现在 iOS 端，比如软键盘弹出时，某些情况下，会影响 fixed 元素定位；配合使用 transform、translate 时，某些情况下，也会影响 fixed 元素定位。一般解决方案是模拟 fixed 定位，或者使用 iScroll 库。\n\n- 怎么让 Chrome 支持小于 12px 的文字？\n\n一般通过：\n\n```\n-webkit-text-size-adjust:none;\n```\n\n实现。\n \n### <font color=13aa6c>HTML5 和 CSS3 其他面试问题整理</font>\n\n关于 HTML5 和 CSS3 的面试问题都并不困难，往往都是属于“是否听说过”、“用过哪些”，这种知道即可的问题，不会太有“深度”。这里我们总结一下关于 HTML5 和 CSS3 新特性的问题，答案也比较容易找到，这里仅做梳理，不再进行展开。如果有疑问的读者，欢迎在读者群中讨论。\n\n- link 和 @import 的区别\n- CSS3 新增选择符有哪些\n- CSS 如何定义权重规则\n- 如何使用纯 CSS 创建一个三角形\n- CSS3 如何写出一个旋转的立方体\n- localStorage 和 cookies 的区别是什么\n- 如何实现浏览器内多个标签页之间的通信\n- 渐进增强和优雅降级概念区别是什么\n- 如何实现 CSS3 动画\n\n这些内容比较基本，和进阶关系不大，我们不过多纠结。\n\n### <font color=13aa6c>CSS 变量和主题切换优雅实现</font>\n\nCSS 变量或者 CSS 自定义属性一直以来是一个值得关注的方向。我们前端没必要去“叫嚣” CSS + HTML 是否图灵完备，但是 CSS 变量时代确实已经到来。注意这里所说的不是 CSS 预处理器（类似 Less，Sass）中的变量，而是实实在在的原生支持特性。\n\n#### 什么是 CSS 变量\n\n什么是 CSS 变量呢？我们直接来看实例，有代码：\n\n```\nbody {\n  background: white;\n  color: #555;\n}\n\na, a:link {\n  color: #639A67;\n}\na:hover {\n  color: #205D67;\n}\n```\n\n如果我们借助 CSS 变量，定义：\n\n```\n:root {\n  --bg: white;\n  --text-color: #555;\n  --link-color: #639A67;\n  --link-hover: #205D67;\n}\n```\n\n之后，上述代码可以直接简化为：\n\n```\nbody {\n  background: var(--bg);\n  color: var(--text-color);\n}\n\na, a:link {\n  color: var(--link-color);\n}\na:hover {\n  color: var(--link-hover);\n}\n```\n\n这个很好理解，在任何语言中，变量是个好东西：它可以降低维护成本，甚至实现更好的性能。\n\nCSS 变量语法也很简单：我们使用`--变量名`的方式定义变量，使用`var(--变量名)`的方式消费变量。\n\n更多 CSS 变量的基础内容可以访问：[使用 CSS 变量](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Using_CSS_custom_properties)。\n\n值得一提的是，CSS 变量的兼容性“出乎意料”的好：\n\n![enter image description here](https://images.gitbook.cn/e8d70d70-8fd3-11e9-8b34-c732c3ec276d)\n\n我就在自己的项目中大范围使用了 CSS 变量，在 html 根节点下，定义 :root ：\n\n![enter image description here](https://images.gitbook.cn/15260510-8fd5-11e9-b9c8-7fcc2264bbb1)\n\n除了简单应用变量，我们能玩出哪些更高级的用法呢？\n\n#### 使用 CSS 变量实现主题切换\n\n一键切换主题，以往实现方式较为复杂。借助 CSS 变量，一切变得容易起来。\n\n仍然以开头：\n\n```\n:root {\n  --bg: white;\n  --text-color: #555;\n  --link-color: #639A67;\n  --link-hover: #205D67;\n}\n```\n\n为例，我们再定义一个 .pink-theme 对应粉色主题：\n\n```\n.pink-theme {\n  --bg: hotpink;\n  --text-color: white;\n  --link-color: #B793E6;\n  --link-hover: #3532A7;\n}\n```\n\n这样一来，在切换主题时，就变得和 toggle class 一样简单。\n\n```\nconst toggleBtn = document.querySelector(&apos;.toggle-theme&apos;)\n\ntoggleBtn.addEventListener(&apos;click&apos;, e => {\n  e.preventDefault()\n\n  if (document.body.classList.contains(&apos;pink-theme&apos;)) {\n\t // 当前主题为粉色主题，需要移除 pink-theme class\n    document.body.classList.remove(&apos;pink-theme&apos;)\n\n    toggle.innerText = &apos;切换正常主题色&apos;\n  } else {\n    document.body.classList.add(&apos;pink-theme&apos;)\n    toggle.innerText = &apos;切换为粉色少女主题&apos;\n  }\n})\n```\n\n同时，我们可以将“进击的 CSS”和“进击的 HTML”相结合，利用 localStorage 实现主题的保存：\n\n```\nconst toggleBtn = document.querySelector(&apos;.toggle-theme&apos;)\n\nif (localStorage.getItem(&apos;pinkTheme&apos;)) {\n  document.body.classList.add(&apos;pink-theme&apos;)\n  toggle.innerText = &apos;切换为粉色少女主题&apos;\n}\n\ntoggleBtn.addEventListener(&apos;click&apos;, e => {\n  e.preventDefault()\n\n  if (document.body.classList.contains(&apos;pink-theme&apos;)) {\n\t // 当前主题为粉色主题，需要移除 pink-theme class\n    document.body.classList.remove(&apos;pink-theme&apos;)\n\n    toggle.innerText = &apos;切换正常主题色&apos;\n    localStorage.removeItem(&apos;pinkTheme&apos;)\n  } else {\n    document.body.classList.add(&apos;pink-theme&apos;)\n    toggle.innerText = &apos;切换为粉色少女主题&apos;\n    localStorage.setItem(&apos;pinkTheme&apos;, true)\n  }\n})\n```\n\n非常的简单直观，我认为这将会成为 CSS 发展的一个不可避免的趋势。\n\n### <font color=13aa6c>CSS Modules 理论和实战</font>\n\n我做面试官时，对 CSS 的考察除了基础布局和经验以外，非常喜欢问 CSS 工程相关的题目，比如：\n\n> 如何维护大型项目的 z-index\n\n比如，\n\n> 如何维护 CSS 选择器和样式之间的冲突\n\n这个环节我们就来谈谈 CSS Modules，看看这个方案是否能让“CSS 冲突成为历史”。\n\n#### 什么是 CSS Modules \n\nCSS Modules 是指：\n\n> 项目中所有 class 名称默认都是局部起作用的。\n\n其实，CSS Modules 并不是一个官方规范，更不是浏览器的机制。它依赖我们的项目构建过程，因此实现往往需要借助 Webpack。借助 Webpack 或者其他构建工具的帮助，可以将 class 的名字唯一化，从而实现局部作用。\n\n这么说可能比较抽象，我们来看一个例子：\n\n```\n<div class=\"test\">This is a test</div>\n```\n\n对应的样式表为：\n\n```\n.test {\n  color: red;\n}\n```\n\n再经过编译构建之后，对应的 HTML 和 CSS 分别为：\n\n```\n<div class=\"_style_test_309571057\">\n  This is a test\n</div>\n```\n\n```\n._style_test_309571057 {\n\tcolor: red;\n}\n```\n\n其中 class 名是动态生成的，全项目唯一的。因此通过命名规范的唯一性，达到了避免样式冲突的目的。\n\n仔细想来，这样的解决方案似乎有一个问题：如何实现样式复用？因为生成了全局唯一的 class 名，那么我们如何像传统方式那样实现样式复用呢？\n\n从原理上想，全局唯一的 class 是在构建过程中，如果能给在构建过程进行标识，表示该 class 将被复用，就可以解决问题了。这样的方式，就依靠 composes 关键字实现。我们来看案例：\n\n样式表 style.css 文件中：\n\n```\n.common {\n  color: red;\n}\n\n.test {\n  composes: common;\n  font-size: 18px;\n}\n```\n\n注意我们使用了 composes 关键字，在 .test 中关联了 .common 样式。\n\n对于 HTML 文件：\n\nimport style from \"./style.css\";\n\n```\n<div class=\"${style.test}\">\n\tThis is a test\n</div>\n```\n\n进行编译构建后：\n\n```\n<div class=\"_style__test_0980340 _style__common_404840\">\n\tThis is a test\n</div>\n```\n\n我们看 div 的 class 被加进了 \\_style\\__common\\_404840，这样就实现了复用样式。\n\n明白了道理，我们该如何应用 CSS Modules 呢？\n\n#### CSS Modules 实战\n\n实战应用 CSS Modules，我将会选取 Webpack 构建一个项目，一步一步进行分析讲解。因为主题并不是“如何配置 Webpack”，因此一些 Webpack 基础不再赘述，同时为了简化问题，我们不进行其他 Webpack（比如 dev server）配置。\n\n- Step 1：创建项目\n\n```\nnpm init --y\n```\n\n此时生成 package.json 如下：\n\n```\n{\n  \"name\": \"css-modules\",\n  \"version\": \"1.0.0\",\n  \"description\": \"README.md\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\"\n}\n```\n\n- Step 2：创建必要文件\n\n```\nmkdir src\ntouch index.html\n```\n\n在 ./src 文件夹中，创建：index.js：\n\n```\nimport bluestyle from &apos;./style.css&apos;;\nimport greenstyle from &apos;./app.css&apos;;\n\nlet html = `\n<h2 class=\"${bluestyle.my_css_selector}\">I should be displayed in blue.</h2>\n<br/>\n<h2 class=\"${greenstyle.my_css_selector}\">I should be displayed in green.</h2> \n`;\ndocument.write(html);\n```\n\n以及 style.css：\n\n```\n.my_css_selector {\n\tcolor: blue;\n}\n```\n\n和 app.css：\n\n```\n.my_css_selector {\n\tcolor: green;\n}\n```\n\n在这两个样式文件中，我们使用了相同的 class 名。\n\n- Step 3：安装依赖\n\n接下来我们按照 webpack、webpack-cli、babel 全家桶（babel-core、babel-loader、abel-preset-env）和相应的 loaders：css-loader、style-loader 以及 extract-text-webpack-plugin 插件。\n\n这些依赖项具体是做什么的这里不再赘述，有不了解的读者可以自行 Google 学习。另外，强烈建议安装版本遵循：\n\n```\n\"babel-core\": \"^6.26.3\",\n\"babel-loader\": \"^7.1.4\",\n\"babel-preset-env\": \"^1.6.1\",\n\"css-loader\": \"^0.28.11\",\n\"extract-text-webpack-plugin\": \"^4.0.0-beta.0\",\n\"style-loader\": \"^0.21.0\",\n\"webpack\": \"^4.1.0\",\n\"webpack-cli\": \"^3.1.1\"\n```\n\n否则会出现类似 webpack 版本和 extract-text-webpack-plugin 不兼容等依赖版本问题。\n\n正常流程下来，我们 package.json 如下：\n\n```\n{\n  \"name\": \"css-modules\",\n  \"version\": \"1.0.0\",\n  \"description\": \"README.md\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"babel-core\": \"^6.26.3\",\n    \"babel-loader\": \"^7.1.4\",\n    \"babel-preset-env\": \"^1.6.1\",\n    \"css-loader\": \"^0.28.11\",\n    \"extract-text-webpack-plugin\": \"^4.0.0-beta.0\",\n    \"style-loader\": \"^0.21.0\",\n    \"webpack\": \"^4.1.0\",\n    \"webpack-cli\": \"^3.1.1\"\n  }\n}\n```\n\n- Step 4：编写 webpack 配置\n\n创建 webpack 配置文件：\n\n```\ntouch webpack.config.js\n```\n\n并编写：\n\n```\nvar ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);\n\nmodule.exports = {\n\tentry: &apos;./src&apos;,\n\toutput: {\n\t\tpath: __dirname + &apos;/build&apos;,\n\t\tfilename: &apos;bundle.js&apos;\n\t},\n\tmodule: {\n\t\trules: [\n\t\t\t{\n\t\t\t\ttest: /\\.js/,\n\t\t\t\tloader: &apos;babel-loader&apos;,\n\t\t\t\tinclude: __dirname + &apos;/src&apos;\n\t\t\t},\n\t\t\t{\n\t\t\t\ttest: /\\.css/,\n\t\t\t\tloader: ExtractTextPlugin.extract(\"css-loader?modules&importLoaders=1&localIdentName=[name]__[local]__[hash:base64:5]\")\n\t\t\t}\n\t\t]\n\t},\n\tplugins: [\n\t\tnew ExtractTextPlugin(\"styles.css\")\n\t]\n}\n```\n\n我们使用了 extract-text-webpack-plugin 插件，并定义入口为 ./src 目录，产出为 `__dirname + &apos;/build&apos;` 目录。对后缀名为 css 的文件使用 css-loader 解析，产出为 styles.css 文件并在 index.html 中使用。\n\n注意我们看对于 css-loader，设置了 modules 参数，进行了 css modules 处理。\n\n- Step 4：编写 npm script 并运行\n\n还差一步，我们将 package.json 中的 script 命令改为：\n\n```\n\"scripts\": {\n\t\"start\": \"webpack --mode development\"\n},\n```\n\n便是运行 webpack，此时 package.json 内容为：\n\n```\n{\n  \"name\": \"css-modules\",\n  \"version\": \"1.0.0\",\n  \"description\": \"README.md\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"start\": \"webpack --mode development\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"babel-core\": \"^6.26.3\",\n    \"babel-loader\": \"^7.1.4\",\n    \"babel-preset-env\": \"^1.6.1\",\n    \"css-loader\": \"^0.28.11\",\n    \"extract-text-webpack-plugin\": \"^4.0.0-beta.0\",\n    \"style-loader\": \"^0.21.0\",\n    \"webpack\": \"^4.1.0\",\n    \"webpack-cli\": \"^3.1.1\"\n  }\n}\n```\n\n运行 npm start，得到产出，打开页面会发现：\n\n如图，已经在编译过程中完成了 css module 处理。\n\n![enter image description here](https://images.gitbook.cn/bf6eefd0-8fd7-11e9-b9c8-7fcc2264bbb1)\n\n### <font color=13aa6c>总结</font>\n\n本节课程我们既有“大面儿”上的梳理，也有关键点的“实战”深入。有趣实用的标签和属性、移动端 H5 注意事项总结、HTML5 和 CSS3 面试题梳理，这三块内容旨在将碎片化的知识点以“记事本”式的排列；Web components 更多给大家带来对新技术的思考和总结；CSS 变量、CSS Module 是我认为最有发展潜力、最有实用价值、最能马上落地实现的解决方案。\n\nHTML 和 CSS 向来被忽视，但是涉及到项目组织和构建，涉及到新技术的调研和决断，我们切不可含糊。\n\n### <font color=13aa6c>分享交流</font>\n\n阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。**你的分享不仅帮助他人，更会提升自己。**\n\n你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。\n\n>**为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。**","pdfUrl":"","reader":"","duration":"","title":"进击的 CSS 和 HTML","column":"5c91c813968b1d64b1e08fde","isNotification":false,"htmlContent":"<p>通过前面的课程介绍，我们认识到了 JavaScript 语言的飞速发展。其实 HTML 和 CSS 也不断“要求着”进步，本节课程我们就来了解一下发展中的 HTML 和 CSS。之所以叫做“进击的”，是因为确实有很多新的特性非常实用且具有变革精神。</p>\n<p>相关知识点如下：</p>\n<img src=\"https://images.gitbook.cn/1c028dd0-8fdb-11e9-9c86-a1bad3faf0f2\" width=500>\n<p>其中，除了罗列一些热点面试题目以外，我们将重点分析 CSS 变量和 CSS Modules，我认为这两个概念代表了未来的发展方向。当下来看，也有必要根据情况，融合到成熟的项目中，加以应用。因此这方面的内容除了基本理论，我都会给出实战案例和构建流程。</p>\n<h3><a id=\"font_color13aa6c_HTMLfont_8\"></a><font color=13aa6c>进击的 HTML</font></h3>\n<p>我们再来看看 HTML 的历史和规范常识。HTML 规范是 W3C 与 WHATWG 合作共同产出的，HTML5 因此也不例外。其中：</p>\n<ul>\n<li>W3C 指 World Wide Web Consortium</li>\n<li>WHATWG 指 Web Hypertext Application Technology Working Group</li>\n</ul>\n<p>说好听了是“合作产出”，但其实更像是“HTML5 有两套规范”。但话说天下大势合久必分，分久必合，如今（就在前几天，2018.5.29）它们又表示将会开发单一版本的 HTML 规范。</p>\n<p>那么 HTML5 给开发者提供了哪些便利呢？简单列举有：</p>\n<ul>\n<li>用于绘画的 canvas 元素</li>\n<li>用于媒介播放的 video 和 audio 元素</li>\n<li>对本地离线存储更好的支持（localStorage、sessionStorage）</li>\n<li>新的语义化标签（article、footer、header、nav、section…)</li>\n<li>新的表单控件（calendar、date、time、email、url、search…)</li>\n</ul>\n<p>除了这些常规的之外，还有：</p>\n<ul>\n<li>给汉字加拼音</li>\n</ul>\n<pre><code class=\"lang-\">&lt;ruby&gt; \n\t前端开发核心知识进阶\n\t&lt;rt&gt;\n\t\tqianduankaifahexinzhishijinjie\n\t&lt;/rt&gt; \n&lt;/ruby&gt;\n</code></pre>\n<img src=\"https://images.gitbook.cn/2853de80-8fd2-11e9-afed-87af38460e36\" width = \"70%\" />\n<ul>\n<li>展开收起组件</li>\n</ul>\n<p>简单几行代码：</p>\n<pre><code class=\"lang-\">&lt;details&gt;\n  &lt;summary&gt;前端开发核心知识进阶&lt;/summary&gt;\n前端领域，入门相对简单，可是想要“更上一层楼”却难上加难，也就是我们常说的“职业天花板较低”，君不见——市场上高级/资深前端工程师凤毛麟角。这当然未必完全是坏事，一旦突破瓶颈，在技能上脱颖而出，便是更广阔的空间。那么，如何从夯实基础到突破瓶颈？\n&lt;/details&gt;\n</code></pre>\n<p>就可以实现：</p>\n<img src=\"https://images.gitbook.cn/649e4970-8fd2-11e9-afed-87af38460e36\" width = \"80%\" />\n<p>上图为“收起”效果。</p>\n<img src=\"https://images.gitbook.cn/dc7b6810-8fd2-11e9-8b34-c732c3ec276d\" width = \"80%\" />\n<p>上图为“展开”效果。</p>\n<p>以往要实现这样的内容，我们都必须依靠 JavaScript 实现。现在来看，HTML 也变得更加具有“可交互性”。</p>\n<ul>\n<li>原生进度条和度量</li>\n</ul>\n<p>progress 标签显示进度：</p>\n<p><img src=\"https://images.gitbook.cn/08358f30-8fd3-11e9-9c86-a1bad3faf0f2\" alt=\"enter image description here\" /></p>\n<p>值得一提的是：progress 不适合用来表示度量衡，如果想表示度量衡，我们应该使用 meter 标签代替。这又是什么标签？</p>\n<p>其实 HTML5 新带来的标签多种多样，感兴趣的读者可以自行了解，我们这里不再用更多篇幅介绍。</p>\n<h3><a id=\"font_color13aa6c_Web_componentsfont_73\"></a><font color=13aa6c>不可忽视的 Web components</font></h3>\n<p>事实上，Web components 的概念在几年前也已经提出，貌似一直没有发展的“如火如荼”，这里我为什么又单独拿出来讲呢？</p>\n<p>我并不想赘述 Web components 的基础概念，但是我认为，作为“更高阶”的前端工程师，要时刻保持技术视野和信息广度。在框架带来的“组件化”、“生命周期化”这些统治级别的概念下，对比并结合 Web components，我认为是可以深入研究的一个课题方向。我总结一下 Web components 的特殊点或者优点：</p>\n<ul>\n<li>原生规范，无需框架</li>\n</ul>\n<p>这条优点的后半句话是：“但是继承且具备了框架的优点”，在新的 Web components 规范中，我们会发现组件生命周期的概念、slot 概念、模版概念（类比 JSX 或者 Vue template），再结合本来就已经存在的组件化，shadow dom，扩展原生元素的能力，我认为 Web components 还是具备了较好的发展前景。</p>\n<ul>\n<li>原生使用，无需编译</li>\n</ul>\n<p>想想现有的一系列框架，不论是 Vue 还是 React，都需要进行编译。而 Web components 因为原生，会得到浏览器的天然支持，自然就可以免去编译构建过程。</p>\n<ul>\n<li>真正的 CSS scope</li>\n</ul>\n<p>Web components 实现了真正的 CSS scope，做到了样式隔离。这一点读者可以对比我们下面即将介绍的 CSS Modules。真正的 CSS scope 对于项目的可维护性至关重要。</p>\n<p>进击的 HTML 和 CSS 带来了进击的 Web components 概念。通过这个案例，我更想建议读者：真正的高级工程师，不仅仅要理解 this、熟练掌握各种基础（当然这是前提），更要有技术嗅觉，对新的解决方案能够理解，并进行对比，面向“未来”编程。</p>\n<h3><a id=\"font_color13aa6c_H5_font_93\"></a><font color=13aa6c>移动端 H5 注意事项总结</font></h3>\n<p>HTML5 因为其强大先进的能力，毫无疑问打来了一场开发的变革。在国内，体现最明显的就是各种 H5 移动页面。</p>\n<p>因为移动端的碎片化现象，以及技术落地的成熟度尚浅，造成了不少问题，那么移动端开发 H5 有哪些坑以及小技巧呢？</p>\n<p>这里列举一些典型情况，目的在于梳理和整理，不再一一详解。具体信息社区上都可以找到，感兴趣的读者可以另行学习。</p>\n<ul>\n<li>打电话发短信写邮件的小技巧</li>\n</ul>\n<p>这些技巧都和 a 标签相关，其中打电话：</p>\n<pre><code class=\"lang-\">&lt;a href=&quot;tel: 110&quot;&gt;打电话给警察局&lt;/a&gt;\n</code></pre>\n<p>发短信：</p>\n<pre><code class=\"lang-\">&lt;a href=&quot;sms: 110&quot;&gt;发短信给警察局&lt;/a&gt;\n</code></pre>\n<p>写邮件依赖“mailto”：</p>\n<pre><code class=\"lang-\">&lt;a href=&quot;mailto: 110@govn.com&quot;&gt;发邮件给警察局&lt;/a&gt;\n</code></pre>\n<p>我们设置可以添加抄送：</p>\n<pre><code class=\"lang-\">&lt;a href=&quot;mailto: 110@govn.com?cc=baba@family.com&quot;&gt;发邮件给警察局，并抄送给我爸爸&lt;/a&gt;\n</code></pre>\n<p>除了抄送，也可以私密发送：</p>\n<pre><code class=\"lang-\">&lt;a href=&quot;mailto: 110@govn.com?cc=baba@family.com&amp;bcc=mama@family.com&quot;&gt;发邮件给警察局，并抄送给我爸爸，密送给我妈妈&lt;/a &gt;\n</code></pre>\n<p>群发也可以：</p>\n<pre><code class=\"lang-\">&lt;a href=&quot;mailto: 110@govn.com; 120@govn.com&quot;&gt;发邮件给警察局，以及 120 急救&lt;/a&gt;\n</code></pre>\n<p>既然都支持群发了，那么定义主题和内容也不在话下：</p>\n<pre><code class=\"lang-\">&lt;a href=&quot;mailto: 110@govn.com?subject=SOS&quot;&gt;发邮件给警察局，并添加救命主题&lt;/a&gt;\n</code></pre>\n<p>包含内容用 body 体现：</p>\n<pre><code class=\"lang-\">&lt;a href=&quot;mailto: 110@govn.com?subject=SOS&amp;body=快来救我&quot;&gt;发邮件给警察局，并添加救命主题和内容&lt;/a&gt;\n</code></pre>\n<p>内容也是支持插入图片和链接的，这里不再一一列举。</p>\n<ul>\n<li>移动端 300 毫秒点击延迟以及点击穿透现象</li>\n</ul>\n<p>这是由于历史原因造成的，一般解决手段为禁止混用 touch 和 click，或者增加一层“透明”蒙层，也可以通过延迟上层元素消失来实现。</p>\n<ul>\n<li>点击元素禁止产生背景或边框</li>\n</ul>\n<p>一般可以使用：</p>\n<pre><code class=\"lang-\">-webkit-tap-highlight-color: rgba(0,0,0,0); \n</code></pre>\n<p>属性进行禁用。</p>\n<ul>\n<li>禁止长按链接与图片弹出菜单</li>\n</ul>\n<p>一般可以使用：</p>\n<pre><code class=\"lang-\">-webkit-touch-callout: none;\n</code></pre>\n<ul>\n<li>禁止用户选中文字</li>\n</ul>\n<pre><code class=\"lang-\">-webkit-user-select:none; \nuser-select: none;\n</code></pre>\n<ul>\n<li>取消 input 输入时，英文首字母的默认大写</li>\n</ul>\n<pre><code class=\"lang-\">&lt;input autocapitalize=&quot;off&quot; autocorrect=&quot;off&quot; /&gt;\n</code></pre>\n<p>iOS 有效。</p>\n<ul>\n<li>语音和视频自动播放</li>\n</ul>\n<p>自动播放是一个很麻烦的话题。不同浏览器内核支持自动播放的情况不一样，甚至 webkit 内核对于自动播放的策略也一直在调整当中。自动播放有时候也带着条件：比如设置静音等。</p>\n<p>具体信息更新可以参考：<a href=\"https://webkit.org/blog/6784/new-video-policies-for-ios/\" target=\"_blank\">New video Policies for iOS</a>。</p>\n<p>一般我们设置自动播放的回退策略是用户触摸屏幕时进行的播放：</p>\n<pre><code class=\"lang-\">// JS 绑定自动播放（操作 window 时，播放音乐）\n$(window).on(&apos;touchstart&apos;, () =&gt; {\n    video.play()\n})\n\n// 微信环境\ndocument.addEventListener(&quot;WeixinJSBridgeReady&quot;, () =&gt; {\n    video.play()\n}, false)\n</code></pre>\n<ul>\n<li>视频全屏播放</li>\n</ul>\n<p>为了使视频全屏播放，我们一般设置：</p>\n<pre><code class=\"lang-\">&lt;video x-webkit-airplay=&quot;true&quot; webkit-playsinline=&quot;true&quot; preload=&quot;auto&quot; autoplay src=&quot;&quot;&gt;&lt;/video&gt;\n</code></pre>\n<p>但是最终情况还是要受到浏览器引擎实现的影响。</p>\n<ul>\n<li>开启硬件加速</li>\n</ul>\n<p>在做动画时，为了达到更好的性能效果，我们往往会选用硬件加速。一般手段为：</p>\n<pre><code class=\"lang-\">transform: translate3d(0,0,0);\n</code></pre>\n<ul>\n<li>fixed 定位问题</li>\n</ul>\n<p>这个问题主要体现在 iOS 端，比如软键盘弹出时，某些情况下，会影响 fixed 元素定位；配合使用 transform、translate 时，某些情况下，也会影响 fixed 元素定位。一般解决方案是模拟 fixed 定位，或者使用 iScroll 库。</p>\n<ul>\n<li>怎么让 Chrome 支持小于 12px 的文字？</li>\n</ul>\n<p>一般通过：</p>\n<pre><code class=\"lang-\">-webkit-text-size-adjust:none;\n</code></pre>\n<p>实现。</p>\n<h3><a id=\"font_color13aa6cHTML5__CSS3_font_242\"></a><font color=13aa6c>HTML5 和 CSS3 其他面试问题整理</font></h3>\n<p>关于 HTML5 和 CSS3 的面试问题都并不困难，往往都是属于“是否听说过”、“用过哪些”，这种知道即可的问题，不会太有“深度”。这里我们总结一下关于 HTML5 和 CSS3 新特性的问题，答案也比较容易找到，这里仅做梳理，不再进行展开。如果有疑问的读者，欢迎在读者群中讨论。</p>\n<ul>\n<li>link 和 @import 的区别</li>\n<li>CSS3 新增选择符有哪些</li>\n<li>CSS 如何定义权重规则</li>\n<li>如何使用纯 CSS 创建一个三角形</li>\n<li>CSS3 如何写出一个旋转的立方体</li>\n<li>localStorage 和 cookies 的区别是什么</li>\n<li>如何实现浏览器内多个标签页之间的通信</li>\n<li>渐进增强和优雅降级概念区别是什么</li>\n<li>如何实现 CSS3 动画</li>\n</ul>\n<p>这些内容比较基本，和进阶关系不大，我们不过多纠结。</p>\n<h3><a id=\"font_color13aa6cCSS_font_258\"></a><font color=13aa6c>CSS 变量和主题切换优雅实现</font></h3>\n<p>CSS 变量或者 CSS 自定义属性一直以来是一个值得关注的方向。我们前端没必要去“叫嚣” CSS + HTML 是否图灵完备，但是 CSS 变量时代确实已经到来。注意这里所说的不是 CSS 预处理器（类似 Less，Sass）中的变量，而是实实在在的原生支持特性。</p>\n<h4><a id=\"_CSS__262\"></a>什么是 CSS 变量</h4>\n<p>什么是 CSS 变量呢？我们直接来看实例，有代码：</p>\n<pre><code class=\"lang-\">body {\n  background: white;\n  color: #555;\n}\n\na, a:link {\n  color: #639A67;\n}\na:hover {\n  color: #205D67;\n}\n</code></pre>\n<p>如果我们借助 CSS 变量，定义：</p>\n<pre><code class=\"lang-\">:root {\n  --bg: white;\n  --text-color: #555;\n  --link-color: #639A67;\n  --link-hover: #205D67;\n}\n</code></pre>\n<p>之后，上述代码可以直接简化为：</p>\n<pre><code class=\"lang-\">body {\n  background: var(--bg);\n  color: var(--text-color);\n}\n\na, a:link {\n  color: var(--link-color);\n}\na:hover {\n  color: var(--link-hover);\n}\n</code></pre>\n<p>这个很好理解，在任何语言中，变量是个好东西：它可以降低维护成本，甚至实现更好的性能。</p>\n<p>CSS 变量语法也很简单：我们使用<code>--变量名</code>的方式定义变量，使用<code>var(--变量名)</code>的方式消费变量。</p>\n<p>更多 CSS 变量的基础内容可以访问：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/Using_CSS_custom_properties\" target=\"_blank\">使用 CSS 变量</a>。</p>\n<p>值得一提的是，CSS 变量的兼容性“出乎意料”的好：</p>\n<p><img src=\"https://images.gitbook.cn/e8d70d70-8fd3-11e9-8b34-c732c3ec276d\" alt=\"enter image description here\" /></p>\n<p>我就在自己的项目中大范围使用了 CSS 变量，在 html 根节点下，定义 :root ：</p>\n<p><img src=\"https://images.gitbook.cn/15260510-8fd5-11e9-b9c8-7fcc2264bbb1\" alt=\"enter image description here\" /></p>\n<p>除了简单应用变量，我们能玩出哪些更高级的用法呢？</p>\n<h4><a id=\"_CSS__323\"></a>使用 CSS 变量实现主题切换</h4>\n<p>一键切换主题，以往实现方式较为复杂。借助 CSS 变量，一切变得容易起来。</p>\n<p>仍然以开头：</p>\n<pre><code class=\"lang-\">:root {\n  --bg: white;\n  --text-color: #555;\n  --link-color: #639A67;\n  --link-hover: #205D67;\n}\n</code></pre>\n<p>为例，我们再定义一个 .pink-theme 对应粉色主题：</p>\n<pre><code class=\"lang-\">.pink-theme {\n  --bg: hotpink;\n  --text-color: white;\n  --link-color: #B793E6;\n  --link-hover: #3532A7;\n}\n</code></pre>\n<p>这样一来，在切换主题时，就变得和 toggle class 一样简单。</p>\n<pre><code class=\"lang-\">const toggleBtn = document.querySelector(&apos;.toggle-theme&apos;)\n\ntoggleBtn.addEventListener(&apos;click&apos;, e =&gt; {\n  e.preventDefault()\n\n  if (document.body.classList.contains(&apos;pink-theme&apos;)) {\n\t // 当前主题为粉色主题，需要移除 pink-theme class\n    document.body.classList.remove(&apos;pink-theme&apos;)\n\n    toggle.innerText = &apos;切换正常主题色&apos;\n  } else {\n    document.body.classList.add(&apos;pink-theme&apos;)\n    toggle.innerText = &apos;切换为粉色少女主题&apos;\n  }\n})\n</code></pre>\n<p>同时，我们可以将“进击的 CSS”和“进击的 HTML”相结合，利用 localStorage 实现主题的保存：</p>\n<pre><code class=\"lang-\">const toggleBtn = document.querySelector(&apos;.toggle-theme&apos;)\n\nif (localStorage.getItem(&apos;pinkTheme&apos;)) {\n  document.body.classList.add(&apos;pink-theme&apos;)\n  toggle.innerText = &apos;切换为粉色少女主题&apos;\n}\n\ntoggleBtn.addEventListener(&apos;click&apos;, e =&gt; {\n  e.preventDefault()\n\n  if (document.body.classList.contains(&apos;pink-theme&apos;)) {\n\t // 当前主题为粉色主题，需要移除 pink-theme class\n    document.body.classList.remove(&apos;pink-theme&apos;)\n\n    toggle.innerText = &apos;切换正常主题色&apos;\n    localStorage.removeItem(&apos;pinkTheme&apos;)\n  } else {\n    document.body.classList.add(&apos;pink-theme&apos;)\n    toggle.innerText = &apos;切换为粉色少女主题&apos;\n    localStorage.setItem(&apos;pinkTheme&apos;, true)\n  }\n})\n</code></pre>\n<p>非常的简单直观，我认为这将会成为 CSS 发展的一个不可避免的趋势。</p>\n<h3><a id=\"font_color13aa6cCSS_Modules_font_398\"></a><font color=13aa6c>CSS Modules 理论和实战</font></h3>\n<p>我做面试官时，对 CSS 的考察除了基础布局和经验以外，非常喜欢问 CSS 工程相关的题目，比如：</p>\n<blockquote>\n<p>如何维护大型项目的 z-index</p>\n</blockquote>\n<p>比如，</p>\n<blockquote>\n<p>如何维护 CSS 选择器和样式之间的冲突</p>\n</blockquote>\n<p>这个环节我们就来谈谈 CSS Modules，看看这个方案是否能让“CSS 冲突成为历史”。</p>\n<h4><a id=\"_CSS_Modules_410\"></a>什么是 CSS Modules</h4>\n<p>CSS Modules 是指：</p>\n<blockquote>\n<p>项目中所有 class 名称默认都是局部起作用的。</p>\n</blockquote>\n<p>其实，CSS Modules 并不是一个官方规范，更不是浏览器的机制。它依赖我们的项目构建过程，因此实现往往需要借助 Webpack。借助 Webpack 或者其他构建工具的帮助，可以将 class 的名字唯一化，从而实现局部作用。</p>\n<p>这么说可能比较抽象，我们来看一个例子：</p>\n<pre><code class=\"lang-\">&lt;div class=&quot;test&quot;&gt;This is a test&lt;/div&gt;\n</code></pre>\n<p>对应的样式表为：</p>\n<pre><code class=\"lang-\">.test {\n  color: red;\n}\n</code></pre>\n<p>再经过编译构建之后，对应的 HTML 和 CSS 分别为：</p>\n<pre><code class=\"lang-\">&lt;div class=&quot;_style_test_309571057&quot;&gt;\n  This is a test\n&lt;/div&gt;\n</code></pre>\n<pre><code class=\"lang-\">._style_test_309571057 {\n\tcolor: red;\n}\n</code></pre>\n<p>其中 class 名是动态生成的，全项目唯一的。因此通过命名规范的唯一性，达到了避免样式冲突的目的。</p>\n<p>仔细想来，这样的解决方案似乎有一个问题：如何实现样式复用？因为生成了全局唯一的 class 名，那么我们如何像传统方式那样实现样式复用呢？</p>\n<p>从原理上想，全局唯一的 class 是在构建过程中，如果能给在构建过程进行标识，表示该 class 将被复用，就可以解决问题了。这样的方式，就依靠 composes 关键字实现。我们来看案例：</p>\n<p>样式表 style.css 文件中：</p>\n<pre><code class=\"lang-\">.common {\n  color: red;\n}\n\n.test {\n  composes: common;\n  font-size: 18px;\n}\n</code></pre>\n<p>注意我们使用了 composes 关键字，在 .test 中关联了 .common 样式。</p>\n<p>对于 HTML 文件：</p>\n<p>import style from “./style.css”;</p>\n<pre><code class=\"lang-\">&lt;div class=&quot;${style.test}&quot;&gt;\n\tThis is a test\n&lt;/div&gt;\n</code></pre>\n<p>进行编译构建后：</p>\n<pre><code class=\"lang-\">&lt;div class=&quot;_style__test_0980340 _style__common_404840&quot;&gt;\n\tThis is a test\n&lt;/div&gt;\n</code></pre>\n<p>我们看 div 的 class 被加进了 _style__common_404840，这样就实现了复用样式。</p>\n<p>明白了道理，我们该如何应用 CSS Modules 呢？</p>\n<h4><a id=\"CSS_Modules__489\"></a>CSS Modules 实战</h4>\n<p>实战应用 CSS Modules，我将会选取 Webpack 构建一个项目，一步一步进行分析讲解。因为主题并不是“如何配置 Webpack”，因此一些 Webpack 基础不再赘述，同时为了简化问题，我们不进行其他 Webpack（比如 dev server）配置。</p>\n<ul>\n<li>Step 1：创建项目</li>\n</ul>\n<pre><code class=\"lang-\">npm init --y\n</code></pre>\n<p>此时生成 package.json 如下：</p>\n<pre><code class=\"lang-\">{\n  &quot;name&quot;: &quot;css-modules&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;README.md&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: {\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  },\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;&quot;,\n  &quot;license&quot;: &quot;ISC&quot;\n}\n</code></pre>\n<ul>\n<li>Step 2：创建必要文件</li>\n</ul>\n<pre><code class=\"lang-\">mkdir src\ntouch index.html\n</code></pre>\n<p>在 ./src 文件夹中，创建：index.js：</p>\n<pre><code class=\"lang-\">import bluestyle from &apos;./style.css&apos;;\nimport greenstyle from &apos;./app.css&apos;;\n\nlet html = `\n&lt;h2 class=&quot;${bluestyle.my_css_selector}&quot;&gt;I should be displayed in blue.&lt;/h2&gt;\n&lt;br/&gt;\n&lt;h2 class=&quot;${greenstyle.my_css_selector}&quot;&gt;I should be displayed in green.&lt;/h2&gt; \n`;\ndocument.write(html);\n</code></pre>\n<p>以及 style.css：</p>\n<pre><code class=\"lang-\">.my_css_selector {\n\tcolor: blue;\n}\n</code></pre>\n<p>和 app.css：</p>\n<pre><code class=\"lang-\">.my_css_selector {\n\tcolor: green;\n}\n</code></pre>\n<p>在这两个样式文件中，我们使用了相同的 class 名。</p>\n<ul>\n<li>Step 3：安装依赖</li>\n</ul>\n<p>接下来我们按照 webpack、webpack-cli、babel 全家桶（babel-core、babel-loader、abel-preset-env）和相应的 loaders：css-loader、style-loader 以及 extract-text-webpack-plugin 插件。</p>\n<p>这些依赖项具体是做什么的这里不再赘述，有不了解的读者可以自行 Google 学习。另外，强烈建议安装版本遵循：</p>\n<pre><code class=\"lang-\">&quot;babel-core&quot;: &quot;^6.26.3&quot;,\n&quot;babel-loader&quot;: &quot;^7.1.4&quot;,\n&quot;babel-preset-env&quot;: &quot;^1.6.1&quot;,\n&quot;css-loader&quot;: &quot;^0.28.11&quot;,\n&quot;extract-text-webpack-plugin&quot;: &quot;^4.0.0-beta.0&quot;,\n&quot;style-loader&quot;: &quot;^0.21.0&quot;,\n&quot;webpack&quot;: &quot;^4.1.0&quot;,\n&quot;webpack-cli&quot;: &quot;^3.1.1&quot;\n</code></pre>\n<p>否则会出现类似 webpack 版本和 extract-text-webpack-plugin 不兼容等依赖版本问题。</p>\n<p>正常流程下来，我们 package.json 如下：</p>\n<pre><code class=\"lang-\">{\n  &quot;name&quot;: &quot;css-modules&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;README.md&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: {\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  },\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;devDependencies&quot;: {\n    &quot;babel-core&quot;: &quot;^6.26.3&quot;,\n    &quot;babel-loader&quot;: &quot;^7.1.4&quot;,\n    &quot;babel-preset-env&quot;: &quot;^1.6.1&quot;,\n    &quot;css-loader&quot;: &quot;^0.28.11&quot;,\n    &quot;extract-text-webpack-plugin&quot;: &quot;^4.0.0-beta.0&quot;,\n    &quot;style-loader&quot;: &quot;^0.21.0&quot;,\n    &quot;webpack&quot;: &quot;^4.1.0&quot;,\n    &quot;webpack-cli&quot;: &quot;^3.1.1&quot;\n  }\n}\n</code></pre>\n<ul>\n<li>Step 4：编写 webpack 配置</li>\n</ul>\n<p>创建 webpack 配置文件：</p>\n<pre><code class=\"lang-\">touch webpack.config.js\n</code></pre>\n<p>并编写：</p>\n<pre><code class=\"lang-\">var ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);\n\nmodule.exports = {\n\tentry: &apos;./src&apos;,\n\toutput: {\n\t\tpath: __dirname + &apos;/build&apos;,\n\t\tfilename: &apos;bundle.js&apos;\n\t},\n\tmodule: {\n\t\trules: [\n\t\t\t{\n\t\t\t\ttest: /\\.js/,\n\t\t\t\tloader: &apos;babel-loader&apos;,\n\t\t\t\tinclude: __dirname + &apos;/src&apos;\n\t\t\t},\n\t\t\t{\n\t\t\t\ttest: /\\.css/,\n\t\t\t\tloader: ExtractTextPlugin.extract(&quot;css-loader?modules&amp;importLoaders=1&amp;localIdentName=[name]__[local]__[hash:base64:5]&quot;)\n\t\t\t}\n\t\t]\n\t},\n\tplugins: [\n\t\tnew ExtractTextPlugin(&quot;styles.css&quot;)\n\t]\n}\n</code></pre>\n<p>我们使用了 extract-text-webpack-plugin 插件，并定义入口为 ./src 目录，产出为 <code>__dirname + &apos;/build&apos;</code> 目录。对后缀名为 css 的文件使用 css-loader 解析，产出为 styles.css 文件并在 index.html 中使用。</p>\n<p>注意我们看对于 css-loader，设置了 modules 参数，进行了 css modules 处理。</p>\n<ul>\n<li>Step 4：编写 npm script 并运行</li>\n</ul>\n<p>还差一步，我们将 package.json 中的 script 命令改为：</p>\n<pre><code class=\"lang-\">&quot;scripts&quot;: {\n\t&quot;start&quot;: &quot;webpack --mode development&quot;\n},\n</code></pre>\n<p>便是运行 webpack，此时 package.json 内容为：</p>\n<pre><code class=\"lang-\">{\n  &quot;name&quot;: &quot;css-modules&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;README.md&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: {\n    &quot;start&quot;: &quot;webpack --mode development&quot;\n  },\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;devDependencies&quot;: {\n    &quot;babel-core&quot;: &quot;^6.26.3&quot;,\n    &quot;babel-loader&quot;: &quot;^7.1.4&quot;,\n    &quot;babel-preset-env&quot;: &quot;^1.6.1&quot;,\n    &quot;css-loader&quot;: &quot;^0.28.11&quot;,\n    &quot;extract-text-webpack-plugin&quot;: &quot;^4.0.0-beta.0&quot;,\n    &quot;style-loader&quot;: &quot;^0.21.0&quot;,\n    &quot;webpack&quot;: &quot;^4.1.0&quot;,\n    &quot;webpack-cli&quot;: &quot;^3.1.1&quot;\n  }\n}\n</code></pre>\n<p>运行 npm start，得到产出，打开页面会发现：</p>\n<p>如图，已经在编译过程中完成了 css module 处理。</p>\n<p><img src=\"https://images.gitbook.cn/bf6eefd0-8fd7-11e9-b9c8-7fcc2264bbb1\" alt=\"enter image description here\" /></p>\n<h3><a id=\"font_color13aa6cfont_686\"></a><font color=13aa6c>总结</font></h3>\n<p>本节课程我们既有“大面儿”上的梳理，也有关键点的“实战”深入。有趣实用的标签和属性、移动端 H5 注意事项总结、HTML5 和 CSS3 面试题梳理，这三块内容旨在将碎片化的知识点以“记事本”式的排列；Web components 更多给大家带来对新技术的思考和总结；CSS 变量、CSS Module 是我认为最有发展潜力、最有实用价值、最能马上落地实现的解决方案。</p>\n<p>HTML 和 CSS 向来被忽视，但是涉及到项目组织和构建，涉及到新技术的调研和决断，我们切不可含糊。</p>\n<h3><a id=\"font_color13aa6cfont_692\"></a><font color=13aa6c>分享交流</font></h3>\n<p>阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。<strong>你的分享不仅帮助他人，更会提升自己。</strong></p>\n<p>你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。</p>\n<blockquote>\n<p><strong>为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。</strong></p>\n</blockquote>\n","readingStatistics":102,"createdAt":"2019-04-21T04:18:15.835Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":14,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FoThASW9dVEPMEo9nP-zaOfbKyLZ"},{"_id":"5cbbef3bbbbba80861a35c22","communication_start_time":null,"type":1,"audioPath":"","abstract":"","content":"响应式这个概念曾经非常流行，但从发展来看，似乎“响应式”布局不再是一个必不可少的话题。究其原因我认为主要有以下几点：\n\n- 公司研发人力越来越充足，PC 端、移动端可以实现两套布局，分项目维护\n- 响应式布局适配越来越简单\n\n但是我们仍然不能对这个概念“掉以轻心”，因为响应式布局仍然有其存在的价值：移动端碎片化的现象将会无限期存在；前端也必然进入物联网，任何设备界面的响应布局将会成为关键挑战。除此之外，响应式布局也体现了 CSS 的灵活和发展。\n\n本讲我们就来深入这个话题，相关知识点如下：\n\n<img src=\"https://images.gitbook.cn/3dd287e0-90a2-11e9-8b34-c732c3ec276d\" width = \"70%\" />\n\n### <font color=13aa6c>上帝视角——响应式布局适配方案</font>\n\n我们首先来梳理一下响应式布局的几种典型方案：\n\n- 传统 float 浮动布局\n- 相对单位布局\n- 媒体查询\n- 基于相对单位 rem 的 flexible 布局\n- flex 布局\n- grid 布局\n- 借助 JavaScript\n\n其中“传统 float 浮动布局”已经在「第3-1课：前端面试离不开的“面子工程”」中有所体现（多栏自适应），这种实现方式比较传统，且能力较弱。\n\n相对单位布局比较容易理解，梳理 CSS 中的相对单位有：\n\n- em\n- rem\n- vh、vw、vmin、vmax \n- %\n- calc() \n\n重点是理解这些相对单位的使用规范，“到底是相对于谁”（注意，这也是一个很重要的面试考点），比如：\n\n- em 相对于当前元素或当前元素继承来的字体的宽度，但是每个字母或汉字的宽度有可能是不一样的，那么一般来说，就是一个大写字母 M 的宽度（事实上，规范中有一个 x-height 概念，建议取 X 的高度，但并没有推荐绝对的计算执行标准，还需要看浏览器的实现，也有的地方采用 O 的高度）；一个非常容易出错的点在于：很多同学会认为 em 相对于父元素的字体大小，但是实际上取决于应用在什么 CSS 属性上。对于 font-size 来说，em 相对于父元素的字体大小；line-height 中，em 却相对于自身字体的大小。\n- rem 相对于根节点（html）的字体大小，根节点一个大写字母 M 的宽度（同上）。\n\n这两个单位在响应式布局中非常重要，我们后续在真实线上适配案例中就能发现，以 rem 为核心，诞生了淘宝的 flexible 响应式布局的方案。\n\n- vw 相对于视口宽度，100vw 就相当于一个视口宽度\n- vh 同理，1vh 表示视口高度的 1/100，100vh 就是一个视口高度\n- vmin 相对于视口的宽度或高度中较小的那个，也就是 1vw 和 1vh 取最小（Math.min(1vw, 1vh)）；vmax 相对于视口的宽度或高度中较大的那个，（Math.max(1vw, 1vh)）\n- % 的相对对象我们专门挑出来在后续的环节中介绍\n- calc 也是一个响应式布局神器，它使得 CSS 有了运算的能力：\n\n```\nwidth: calc(100vw - 80px)\n```\n\n除了相对单位以外，媒体查询（Media Query）以及 flex、grid 布局也都比较好理解。相关内容都容易找到，这里插播一下借助 JavaScript 实现响应式布局的案例，结合上一讲“进击的 HTML 和 CSS”中的 CSS 变量，往往也能简化很多问题：\n\n```\np {\n\theight: var(--test-height);\n}\n\nfunction changePHeight (height)\n    document.documentElement.style.setProperty(&apos;--test-height&apos;, `${height}px);\n}\n```\n\n其实总结下来，这也是一道非常常见的面试题：“你如何实现自适应？如何做到响应式？”，想必大家已经有所了解了。\n\n事实上，所有的响应式布局手段都不是单一的，上述方法搭配使用，效果更明显，也更加简单可行。\n\n下面我们通过分析线上案例（淘宝 + 网易），来了解真实环境下的解决方案。\n\n### <font color=13aa6c>真实线上适配案例分析</font>\n\n在进入分析前，我们先罗列一下其他关于响应式布局的概念：\n\n- 屏幕分辨率\n- 像素\n- PPI（Pixel Per Inch）：每英寸包括的像素数\n- DPI（Dot Per Inch）：即每英寸包括的点数\n- 设备独立像素\n- 设备像素比（dpr）\n- Meta Viewport\n\n不同设备的物理像素尺寸等信息可以参考：[Device Metrics](https://material.io/tools/devices/)。\n\n这些内容都可以在社区上了解到，这里重点分析移动端页面的处理方案。\n\n首先，淘宝通过设置：\n\n```\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover\">\n```\n\n![enter image description here](https://images.gitbook.cn/cd1cd750-909f-11e9-afed-87af38460e36)\n\n禁用了用户缩放功能，使页面宽度和设备宽度对齐，一般这种操作也是移动端的响应式适配的标配。\n\n我们观察在页面根节点 HTML 元素上，显式设置了 font-size：\n\n![enter image description here](https://images.gitbook.cn/eebf6030-909f-11e9-8b34-c732c3ec276d)\n\n并且进行试验，当改变浏览器大小时，html 的 font-size 会动态变化。这样不难理解，\n采用 rem 作为相对单位的长宽数值，都会随着 resize 事件进行变化（因为 html 的 font-size 动态变化）。我们在其页面当中，不难找到这样的代码：\n\n![enter image description here](https://images.gitbook.cn/0c3a3860-90a0-11e9-afed-87af38460e36)\n\n我将其复制并美化出来，得到：\n\n```\n!function(e, t) {\n\tvar n = t.documentElement,\n\t\td = e.devicePixelRatio || 1;\n\n\tfunction i() {\n\t\tvar e = n.clientWidth / 3.75;\n\t\tn.style.fontSize = e + \"px\"\n\t}\n\tif (function e() {\n\t\tt.body ? t.body.style.fontSize = \"16px\" : t.addEventListener(\"DOMContentLoaded\", e)\n\t}(), i(), e.addEventListener(\"resize\", i), e.addEventListener(\"pageshow\", function(e) {\n\t\te.persisted && i()\n\t}), 2 <= d) {\n\t\tvar o = t.createElement(\"body\"),\n\t\t\ta = t.createElement(\"div\");\n\t\ta.style.border = \".5px solid transparent\", o.appendChild(a), n.appendChild(o), 1 === a.offsetHeight && n.classList.add(\"hairlines\"), n.removeChild(o)\n\t}\n}(window, document)\n```\n\n核心逻辑不难理解，这是一个 IIFE，在 DOMContentLoaded、resize、pageshow 事件触发时，进行对 html 的 font-size 值设定，计算方式：\n\n```\nfont-size = document.documentElement.clientWidth / 3.75\n```\n\n为什么这么计算呢？我可以肯定的是：淘宝的工程师是按照设计 375px 的视觉稿完成的。在 375px 视觉稿下，html 的 font-size 为 100，那么如果宽度是 75px 的元素，就可以设置为 0.75rem（100 * 0.75 = 75px）；当设备宽度为 414px（iPhone8 plus）时，我们想让上述元素的宽度等比例自适应到 82.8px（75 * 414 / 375），那么在 CSS 样式为 0.74rem 不变的前提下，想计算得到 82.8px，只需 HTML font-size 变为：110.4px  即可（110.4 * 0.75 = 82.8）。那么反向过来，这个 110.4 的计算公式就是：\n\n```\ndocument.documentElement.clientWidth / 3.75\n```\n\n当然淘宝实现响应式布局除了依靠 rem 以外，还大量运用了 flex 布局，比如页面中最复杂的布局区块：\n\n![enter image description here](https://images.gitbook.cn/2c80dac0-90a0-11e9-9c86-a1bad3faf0f2)\n\n实现较为简单。\n\n整套解决方案淘宝开源出来，叫做 flexible 布局。其实读到这里，你已经理解了这个解决方案的核心原理。\n\n我们再来看看网易的做法，大体类似：\n\n![enter image description here](https://images.gitbook.cn/52412940-90a0-11e9-9c86-a1bad3faf0f2)\n\n同样采用了 rem 布局，但区别是网易并没有 JavaScript 介入计算 html 的 font-size，而是通过媒体查询和 calc 手段，“枚举”了不同设备下不同的 HTML font-size 值。\n\n在其页面中，较为复杂的头部 slider 组件中：\n\n![enter image description here](https://images.gitbook.cn/9427bc70-90a0-11e9-9c86-a1bad3faf0f2)\n\nslider 宽度明显是 JavaScript 获取设备宽度后动态赋值的（图中为 414px），而高度采用了 rem 布局： 3.7 rem = 55.3px(calc(13.33333333vw) * 3.7)\n\n总结一下，响应式布局并没有那么困难，我们需要掌握最基本的处理手段，在实际场景中综合运用多种套路即可实现最大限度的灵活。\n\n### <font color=13aa6c>Bootstrap 栅格实现思路</font>\n\nBootrap 栅格化是一个非常“伟大”的实现，我们在使用 Bootrap 布局时，可以通过添加类的方法，轻松实现栅格化，流式布局。\n\n我们选取代表性的 BS4 官网范例，可以[在线参考](http://v4.bootcss.com/examples/dashboard/#)，或者参看以下截图，在宽屏幕下，我们看到：\n\n<img src=\"https://images.gitbook.cn/bfe31c10-90a0-11e9-8b34-c732c3ec276d\" width = \"50%\" />\n\n当屏幕宽度小于 576px 时候，我们有：\n\n<img src=\"https://images.gitbook.cn/dc19b470-90a0-11e9-9c86-a1bad3faf0f2\" width = \"35%\" />\n\n对应代码：\n\n```\n<div class=\"col-6 col-sm-3\">\n    ...\n</div>\n<div class=\"col-6 col-sm-3\">\n    ...\n</div>\n<div class=\"col-6 col-sm-3\">\n    ...\n</div>\n<div class=\"col-6 col-sm-3\">\n    ...\n</div>\n```\n\n.col-6 class 样式在源码里面可以简单归纳（不完全）为：\n\n```\n.col-6 {\n    -webkit-box-flex: 0;\n    -webkit-flex: 0 0 50%;\n    -ms-flex: 0 0 50%;\n    flex: 0 0 50%;\n    max-width: 50%;\n}\n```\n\n.col-sm-3 class 在源码里面可以归纳为：\n\n```\n.col-sm-3 {\n    -webkit-box-flex: 0;\n    -webkit-flex: 0 0 25%;\n        -ms-flex: 0 0 25%;\n            flex: 0 0 25%;\n    max-width: 25%;\n}\n```\n\n我们看到，代码里设置了两个 class：col-6 col-sm-3 进行样式声明。\n\n从上面样式代码里看到类似 `flex: 0 0 25%` 的声明，为了理解它，我们从 flex 属性入手：flex 属性是 flex-grow、flex-shrink 和 flex-basis 的简写（类似 backgroud 是很多背景属性的简写一样），它的默认值为 0 1 auto，后两个属性可选。语法格式如下：\n\n```\n.item {\n    flex: none | [ <&apos;flex-grow&apos;> <&apos;flex-shrink&apos;>? || <&apos;flex-basis&apos;> ]\n}\n```\n\n- flex-grow：属性定义项目的放大比例，默认为 0。我们看到 Bootstrap 代码里这个值一直为 0，即如果存在剩余空间，也不放大。\n- flex-shrink：属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。\n- flex-basis：属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。\n\n浏览器根据这个属性，计算主轴是否有多余空间，它可以设为跟 width 或 height 属性一样的值（比如 350px），则项目将占据固定空间。\n\nBootstrap 这里对 flex 设置为比例值，这也是响应式自然而然实现的基础。\n\n但是我们想，很明显 col-6 col-sm-3 的样式属性是有冲突的，那么他们是如何做到“和平共处”交替发挥作用的呢？\n\n事实上：\n\n- 在屏幕宽度大于 576px 时候，会发现 .col-sm-3 并没有起作用，这时候起作用的是 .col-6。\n\n我们在源码里发现 .col-sm-* 的样式声明全部在\n\n```\n @media (min-width: 576px) {...} \n```\n \n的媒体查询中，这就保证了在 576px 宽度以上的屏幕，只有在媒体查询之外的 .col-* 样式声明发挥了作用。\n\n- 在屏幕宽度小于 576px 时候，命中媒体查询，命中 .col-sm-3 的样式声明。它的优先级一定大于 .col-6（媒体查询优先级高），这时候就保证了移动端的样式“占上风”。\n\n再结合 col-6 col-sm-3  的样式声明，我们可以简单总结一下：Bootstrap 主要是通过百分比宽度（max-width: 50%; max-width: 25%;），以及 flex 属性，再加上媒体查询，“三管齐下”实现了栅格化布局的主体。\n\n当然整个过程实现还有很多其他细节，我也一直认为 Bootstrap 的源码是管理大型样式项目的优秀典范，有兴趣的读者可以参阅源码进行了解。\n\n### <font color=13aa6c>横屏适配以及其他细节问题</font>\n\n很多 H5 页面中，我们要区分横屏和竖屏，在不同屏幕下要显示不同的布局，所以我们需要检测在不同的场景下给定不同的样式。通常使用 JavaScript 检查：\n\n```\nwindow.addEventListener(\"resize\", () => {\n    if (window.orientation === 180 || window.orientation === 0) { \n        console.log(&apos;竖屏&apos;)\n    };\n    if (window.orientation === 90 || window.orientation === -90 ){ \n        console.log(&apos;横屏&apos;)\n    }  \n})\n```\n \n我们同样可以使用纯 CSS 来实现不同场景下的布局：\n\n```\n@media screen and (orientation: portrait) {\n  /*竖屏样式代码*/\n} \n@media screen and (orientation: landscape) {\n  /*横屏样式代码.*/\n}\n```\n\n同时这里我们在总结一下其他常见的响应式布局话题：\n\n- 1px 问题\n- 适配 iPhoneX 齐刘海\n- 图片自适应\n\n这些问题都可以轻松找到解决思路，我们不再详细给出。\n\n### <font color=13aa6c>面试题：% 相对于谁</font>\n\n在之前的课程《前端面试必不可少的“面子工程”》中我们讲解了实现水平垂直居中的几种方式。其中absolute + transform 方案：\n\n```\n.wp {\n    position: relative;\n}\n.box {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n}\n```\n\n我们用到了不止一处 % 单位。事实上，上述代码中的 % 还真代表着不一样的计算规则。第一处 50% 是指 .wrap 相对定位元素宽度和高度的  50%，而 transform 中的 50% 是指自身元素的宽高的一半。\n\n那么在 CSS 中，这个常见的 % 单位有着什么样的规则呢？这也是一道很好的面试题目，我们在这一部分进行梳理。\n\n- position: absolute 中的 %\n\n对于设置绝对定位 position absolute 的元素，我们可以使用 left right 表示其偏移量，我们把这个元素的祖先元素中第一个存在定位属性的元素成为参照物元素，其中的 % 是相对于参照物的，left 相对于参照物的 width，top 相对于这个参照物的 height。\n\n- position: relative 中的 %\n\n对于设置相对定位 position relative 的元素，% 的数值是相对与自身的，left 相对于自己的 width，top 相对于自己的 height。\n\n- position: fixed 中的 %\n\n对于设置固定定位 position fixed 的元素，% 的数值是相对于视口的，left 相对于视口的 width，top 相对于视口的 height。\n\n- margin 和 padding 的 %\n\nmargin 和 padding 当中的 % 非常特殊，它是相对于父元素的宽度。没错，margin-top: 30%，相当于父元素宽度的 30%\n\n- border-radius 的 %\n\n想想我们经常对一个正方形元素设置：\n\n```\nborder-radius: 50%\n```\n\n得到一个圆形，因此不难发现这里的 % 也是相对于自身宽高的。\n\n- background-size 的 %\n\nbackground-size 的百分比和 border-radius 一样，也是相对于自身的宽高。\n\n- transform： translate\n\ntransform 的 translate 属性 % 是相对于自身的宽高，这也是我们上述代码能够实现居中的原因。\n\n- text-indent 的 %\n\ntext-indent 这个属性可以设置首行缩进，当使用 % 时，它是相对于父元素的 width。\n\n- font-size 的 %\n\n相对于父元素的字体大小。\n\n- line-height 的 %\n\nline-height 设置行高时，如果单位为 %，则相对于该元素的 font-size 数值。\n\n这些就是我们常见的使用 % 的情况，还是很灵活多变的，具体细节都可以在 CSS 规范中找到。要求开发者的是了解常见的以及特殊的 % 场景。\n\n### <font color=13aa6c>深入：flex 布局和传统 float 布局性能对比</font>\n\n最后这部分，让我们来深入一个关于性能的话题：\n\n> flex 布局对性能的影响主要体现在哪方面？\n\n这个问题比较“偏门”，很多读者在平时应该没有想过。这里指出来的目的是开拓思路，让我们更加合理地认识 CSS 布局。\n\n我们先思考一下 **flex 布局对性能到底有什么影响，或者有多大影响。**\n\n**首先性能问题一定是一个相对概念**，flex 布局相比正常的 block layout（non-float）性能开销一定更大。事实上，block layout 永远都是 **single-pass**，算法进行布局，而 flex 布局却总会激发 **multi-pass codepaths** 算法布局。比如常用的 flex-align: stretch 通常都是 2-pass，这是无可争议且难以避免的短板，天生基因决定。（关于 single-pass 和 multi-pass codepaths，图形学算法问题这里不再展开，读者了解 single-pass 成本更低即可）\n\n口说无凭，我们来做一个对比，display: table VS display: flex。\n\n这里重复 1000 次这样的 DOM：\n\n```\n<div class=\"wrap\">\n    <div class=\"cell description\">Item Description</div>\n    <div class=\"cell add\">Add</div>\n    <div class=\"cell remove\">Remove</div>\n</div>\n```\n\n分别使用 flex 和 table 布局，并采用 [Navigation Timing API](https://link.zhihu.com/?target=http%3A//www.w3.org/TR/navigation-timing/) 进行布局速度测量。代码如下：\n\n```\n<script type=\"text/javascript\">\n    ;(function TimeThisMother() {\n        window.onload = function(){\n            setTimeout(function(){\n            var t = performance.timing;\n                alert(\"Speed of selection is: \" + (t.loadEventEnd - t.responseEnd) + \" milliseconds\");\n            }, 0);\n        };\n    })();\n</script>\n\n```\n\n得到结果：\n\n* flex 布局：Speed of selection is: 248 milliseconds；\n* table 布局：Speed of selection is: 282 milliseconds。\n\nflex 布局要比 table 布局似乎更快。\n\n曾经一个名叫 Chris Coyier 的开发者，实现了这样一个 flex 布局生成器。\n\n![enter image description here](https://images.gitbook.cn/16a75430-90a1-11e9-afed-87af38460e36)\n\n注意右上角的滑动条，越向右滑，页面不同颜色区块越多（截图上滚动条已经很短了，证明页面已经很长，布局区块很多），在如此大规模全面使用 flex 布局下，页面丝毫没有任何卡顿。\n\n如上图，打开 Chrome Dev Tools > Timeline，单击 record 按钮，滑动滑块并停止。我们得到瀑布流紫色部分，显示性能效果良好。\n\n当然这样的“模拟”距离真实场景也许较远，不排除如果页面中存在很多图片就会使得性能开销激增，可能使用 flex 某些属性也会付出昂贵的代价。但是一般场景使用，我认为没有必要去担心 flex 布局性能问题，至少它比别的方案靠谱（先不论兼容性）。\n\n**读者可以去 codepen 进行体验：**\n\n[Generate a Crapload of Flexbox​codepen.io![图标](https://images.gitbook.cn/4107b7b0-90a1-11e9-8b34-c732c3ec276d)](https://link.zhihu.com/?target=https%3A//codepen.io/chriscoyier/pen/LGmkn) \n\n最后，需要格外提出的是：**新版 flex 布局一般比旧版布局模型更快，同样也比基于浮动的布局模型更快。**\n\n这里来特殊对比一下 flex 布局和浮动布局在性能上的表现。\n\n下图显示了在 1,300 个框上使用浮动的布局开销。\n\n![enter image description here](https://images.gitbook.cn/581b0150-90a1-11e9-8b34-c732c3ec276d)\n\n我们更新此示例以使用 flex，则出现不同的情况：\n\n![enter image description here](https://images.gitbook.cn/71f58140-90a1-11e9-9c86-a1bad3faf0f2)\n\n很明显，对于相同数量的元素和相同的视觉外观，flex 布局的时间要少得多（本例中分别为 3.5 毫秒和 14 毫秒）。对比来源：[developers.google.com](https://link.zhihu.com/?target=http%3A//developers.google.com/)。\n\n**最后，布局性能的开销，一般直接考虑如下因素：**\n\n* 需要布局的元素数量\n* 布局的复杂性\n\n相对地，**对于布局性能建议主要有：**\n\n* 应尽可能避免触发布局（layout／reflow）\n* 避免强制同步布局和布局抖动\n\n这些面就更大了，我们会在页面性能优化课程中继续这个话题。这里通过结论，想告诉大家的是：不论什么样的布局，在性能上一般很难成为瓶颈。同时另一方面，CSS 看似简单，却也和性能息息相关。\n\n### <font color=13aa6c>总结</font>\n\n这一讲我们分析了实现响应式布局的常用手段，并结合实际案例加以剖析；同时讨论了布局方案对于页面性能的影响。到此为止，HTML 和 CSS 相关的内容终于告一段落了，读者应该能有一个清晰的认识：\n\n- HTML 和 CSS 很重要\n- HTML 和 CSS 如果不花心思，也不好学\n\n但是关于 HTML 和 CSS 我们更应该注重实战，也许可以暂时不用“系统化”地去了解，但是遇见一个案例，就去攻克一个案例，慢慢地，你也能成为 HTML 和 CSS 专家！\n\n### <font color=13aa6c>分享交流</font>\n\n阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。**你的分享不仅帮助他人，更会提升自己。**\n\n你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。\n\n>**为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。**","pdfUrl":"","reader":"","duration":"","title":"响应式布局和 Bootstrap 的实现分析","column":"5c91c813968b1d64b1e08fde","isNotification":false,"htmlContent":"<p>响应式这个概念曾经非常流行，但从发展来看，似乎“响应式”布局不再是一个必不可少的话题。究其原因我认为主要有以下几点：</p>\n<ul>\n<li>公司研发人力越来越充足，PC 端、移动端可以实现两套布局，分项目维护</li>\n<li>响应式布局适配越来越简单</li>\n</ul>\n<p>但是我们仍然不能对这个概念“掉以轻心”，因为响应式布局仍然有其存在的价值：移动端碎片化的现象将会无限期存在；前端也必然进入物联网，任何设备界面的响应布局将会成为关键挑战。除此之外，响应式布局也体现了 CSS 的灵活和发展。</p>\n<p>本讲我们就来深入这个话题，相关知识点如下：</p>\n<img src=\"https://images.gitbook.cn/3dd287e0-90a2-11e9-8b34-c732c3ec276d\" width = \"70%\" />\n<h3><a id=\"font_color13aa6cfont_11\"></a><font color=13aa6c>上帝视角——响应式布局适配方案</font></h3>\n<p>我们首先来梳理一下响应式布局的几种典型方案：</p>\n<ul>\n<li>传统 float 浮动布局</li>\n<li>相对单位布局</li>\n<li>媒体查询</li>\n<li>基于相对单位 rem 的 flexible 布局</li>\n<li>flex 布局</li>\n<li>grid 布局</li>\n<li>借助 JavaScript</li>\n</ul>\n<p>其中“传统 float 浮动布局”已经在「第3-1课：前端面试离不开的“面子工程”」中有所体现（多栏自适应），这种实现方式比较传统，且能力较弱。</p>\n<p>相对单位布局比较容易理解，梳理 CSS 中的相对单位有：</p>\n<ul>\n<li>em</li>\n<li>rem</li>\n<li>vh、vw、vmin、vmax</li>\n<li>%</li>\n<li>calc()</li>\n</ul>\n<p>重点是理解这些相对单位的使用规范，“到底是相对于谁”（注意，这也是一个很重要的面试考点），比如：</p>\n<ul>\n<li>em 相对于当前元素或当前元素继承来的字体的宽度，但是每个字母或汉字的宽度有可能是不一样的，那么一般来说，就是一个大写字母 M 的宽度（事实上，规范中有一个 x-height 概念，建议取 X 的高度，但并没有推荐绝对的计算执行标准，还需要看浏览器的实现，也有的地方采用 O 的高度）；一个非常容易出错的点在于：很多同学会认为 em 相对于父元素的字体大小，但是实际上取决于应用在什么 CSS 属性上。对于 font-size 来说，em 相对于父元素的字体大小；line-height 中，em 却相对于自身字体的大小。</li>\n<li>rem 相对于根节点（html）的字体大小，根节点一个大写字母 M 的宽度（同上）。</li>\n</ul>\n<p>这两个单位在响应式布局中非常重要，我们后续在真实线上适配案例中就能发现，以 rem 为核心，诞生了淘宝的 flexible 响应式布局的方案。</p>\n<ul>\n<li>vw 相对于视口宽度，100vw 就相当于一个视口宽度</li>\n<li>vh 同理，1vh 表示视口高度的 1/100，100vh 就是一个视口高度</li>\n<li>vmin 相对于视口的宽度或高度中较小的那个，也就是 1vw 和 1vh 取最小（Math.min(1vw, 1vh)）；vmax 相对于视口的宽度或高度中较大的那个，（Math.max(1vw, 1vh)）</li>\n<li>% 的相对对象我们专门挑出来在后续的环节中介绍</li>\n<li>calc 也是一个响应式布局神器，它使得 CSS 有了运算的能力：</li>\n</ul>\n<pre><code class=\"lang-\">width: calc(100vw - 80px)\n</code></pre>\n<p>除了相对单位以外，媒体查询（Media Query）以及 flex、grid 布局也都比较好理解。相关内容都容易找到，这里插播一下借助 JavaScript 实现响应式布局的案例，结合上一讲“进击的 HTML 和 CSS”中的 CSS 变量，往往也能简化很多问题：</p>\n<pre><code class=\"lang-\">p {\n\theight: var(--test-height);\n}\n\nfunction changePHeight (height)\n    document.documentElement.style.setProperty(&apos;--test-height&apos;, `${height}px);\n}\n</code></pre>\n<p>其实总结下来，这也是一道非常常见的面试题：“你如何实现自适应？如何做到响应式？”，想必大家已经有所了解了。</p>\n<p>事实上，所有的响应式布局手段都不是单一的，上述方法搭配使用，效果更明显，也更加简单可行。</p>\n<p>下面我们通过分析线上案例（淘宝 + 网易），来了解真实环境下的解决方案。</p>\n<h3><a id=\"font_color13aa6cfont_68\"></a><font color=13aa6c>真实线上适配案例分析</font></h3>\n<p>在进入分析前，我们先罗列一下其他关于响应式布局的概念：</p>\n<ul>\n<li>屏幕分辨率</li>\n<li>像素</li>\n<li>PPI（Pixel Per Inch）：每英寸包括的像素数</li>\n<li>DPI（Dot Per Inch）：即每英寸包括的点数</li>\n<li>设备独立像素</li>\n<li>设备像素比（dpr）</li>\n<li>Meta Viewport</li>\n</ul>\n<p>不同设备的物理像素尺寸等信息可以参考：<a href=\"https://material.io/tools/devices/\" target=\"_blank\">Device Metrics</a>。</p>\n<p>这些内容都可以在社区上了解到，这里重点分析移动端页面的处理方案。</p>\n<p>首先，淘宝通过设置：</p>\n<pre><code class=\"lang-\">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover&quot;&gt;\n</code></pre>\n<p><img src=\"https://images.gitbook.cn/cd1cd750-909f-11e9-afed-87af38460e36\" alt=\"enter image description here\" /></p>\n<p>禁用了用户缩放功能，使页面宽度和设备宽度对齐，一般这种操作也是移动端的响应式适配的标配。</p>\n<p>我们观察在页面根节点 HTML 元素上，显式设置了 font-size：</p>\n<p><img src=\"https://images.gitbook.cn/eebf6030-909f-11e9-8b34-c732c3ec276d\" alt=\"enter image description here\" /></p>\n<p>并且进行试验，当改变浏览器大小时，html 的 font-size 会动态变化。这样不难理解，<br />\n采用 rem 作为相对单位的长宽数值，都会随着 resize 事件进行变化（因为 html 的 font-size 动态变化）。我们在其页面当中，不难找到这样的代码：</p>\n<p><img src=\"https://images.gitbook.cn/0c3a3860-90a0-11e9-afed-87af38460e36\" alt=\"enter image description here\" /></p>\n<p>我将其复制并美化出来，得到：</p>\n<pre><code class=\"lang-\">!function(e, t) {\n\tvar n = t.documentElement,\n\t\td = e.devicePixelRatio || 1;\n\n\tfunction i() {\n\t\tvar e = n.clientWidth / 3.75;\n\t\tn.style.fontSize = e + &quot;px&quot;\n\t}\n\tif (function e() {\n\t\tt.body ? t.body.style.fontSize = &quot;16px&quot; : t.addEventListener(&quot;DOMContentLoaded&quot;, e)\n\t}(), i(), e.addEventListener(&quot;resize&quot;, i), e.addEventListener(&quot;pageshow&quot;, function(e) {\n\t\te.persisted &amp;&amp; i()\n\t}), 2 &lt;= d) {\n\t\tvar o = t.createElement(&quot;body&quot;),\n\t\t\ta = t.createElement(&quot;div&quot;);\n\t\ta.style.border = &quot;.5px solid transparent&quot;, o.appendChild(a), n.appendChild(o), 1 === a.offsetHeight &amp;&amp; n.classList.add(&quot;hairlines&quot;), n.removeChild(o)\n\t}\n}(window, document)\n</code></pre>\n<p>核心逻辑不难理解，这是一个 IIFE，在 DOMContentLoaded、resize、pageshow 事件触发时，进行对 html 的 font-size 值设定，计算方式：</p>\n<pre><code class=\"lang-\">font-size = document.documentElement.clientWidth / 3.75\n</code></pre>\n<p>为什么这么计算呢？我可以肯定的是：淘宝的工程师是按照设计 375px 的视觉稿完成的。在 375px 视觉稿下，html 的 font-size 为 100，那么如果宽度是 75px 的元素，就可以设置为 0.75rem（100 * 0.75 = 75px）；当设备宽度为 414px（iPhone8 plus）时，我们想让上述元素的宽度等比例自适应到 82.8px（75 * 414 / 375），那么在 CSS 样式为 0.74rem 不变的前提下，想计算得到 82.8px，只需 HTML font-size 变为：110.4px  即可（110.4 * 0.75 = 82.8）。那么反向过来，这个 110.4 的计算公式就是：</p>\n<pre><code class=\"lang-\">document.documentElement.clientWidth / 3.75\n</code></pre>\n<p>当然淘宝实现响应式布局除了依靠 rem 以外，还大量运用了 flex 布局，比如页面中最复杂的布局区块：</p>\n<p><img src=\"https://images.gitbook.cn/2c80dac0-90a0-11e9-9c86-a1bad3faf0f2\" alt=\"enter image description here\" /></p>\n<p>实现较为简单。</p>\n<p>整套解决方案淘宝开源出来，叫做 flexible 布局。其实读到这里，你已经理解了这个解决方案的核心原理。</p>\n<p>我们再来看看网易的做法，大体类似：</p>\n<p><img src=\"https://images.gitbook.cn/52412940-90a0-11e9-9c86-a1bad3faf0f2\" alt=\"enter image description here\" /></p>\n<p>同样采用了 rem 布局，但区别是网易并没有 JavaScript 介入计算 html 的 font-size，而是通过媒体查询和 calc 手段，“枚举”了不同设备下不同的 HTML font-size 值。</p>\n<p>在其页面中，较为复杂的头部 slider 组件中：</p>\n<p><img src=\"https://images.gitbook.cn/9427bc70-90a0-11e9-9c86-a1bad3faf0f2\" alt=\"enter image description here\" /></p>\n<p>slider 宽度明显是 JavaScript 获取设备宽度后动态赋值的（图中为 414px），而高度采用了 rem 布局： 3.7 rem = 55.3px(calc(13.33333333vw) * 3.7)</p>\n<p>总结一下，响应式布局并没有那么困难，我们需要掌握最基本的处理手段，在实际场景中综合运用多种套路即可实现最大限度的灵活。</p>\n<h3><a id=\"font_color13aa6cBootstrap_font_160\"></a><font color=13aa6c>Bootstrap 栅格实现思路</font></h3>\n<p>Bootrap 栅格化是一个非常“伟大”的实现，我们在使用 Bootrap 布局时，可以通过添加类的方法，轻松实现栅格化，流式布局。</p>\n<p>我们选取代表性的 BS4 官网范例，可以<a href=\"http://v4.bootcss.com/examples/dashboard/#\" target=\"_blank\">在线参考</a>，或者参看以下截图，在宽屏幕下，我们看到：</p>\n<img src=\"https://images.gitbook.cn/bfe31c10-90a0-11e9-8b34-c732c3ec276d\" width = \"50%\" />\n<p>当屏幕宽度小于 576px 时候，我们有：</p>\n<img src=\"https://images.gitbook.cn/dc19b470-90a0-11e9-9c86-a1bad3faf0f2\" width = \"35%\" />\n<p>对应代码：</p>\n<pre><code class=\"lang-\">&lt;div class=&quot;col-6 col-sm-3&quot;&gt;\n    ...\n&lt;/div&gt;\n&lt;div class=&quot;col-6 col-sm-3&quot;&gt;\n    ...\n&lt;/div&gt;\n&lt;div class=&quot;col-6 col-sm-3&quot;&gt;\n    ...\n&lt;/div&gt;\n&lt;div class=&quot;col-6 col-sm-3&quot;&gt;\n    ...\n&lt;/div&gt;\n</code></pre>\n<p>.col-6 class 样式在源码里面可以简单归纳（不完全）为：</p>\n<pre><code class=\"lang-\">.col-6 {\n    -webkit-box-flex: 0;\n    -webkit-flex: 0 0 50%;\n    -ms-flex: 0 0 50%;\n    flex: 0 0 50%;\n    max-width: 50%;\n}\n</code></pre>\n<p>.col-sm-3 class 在源码里面可以归纳为：</p>\n<pre><code class=\"lang-\">.col-sm-3 {\n    -webkit-box-flex: 0;\n    -webkit-flex: 0 0 25%;\n        -ms-flex: 0 0 25%;\n            flex: 0 0 25%;\n    max-width: 25%;\n}\n</code></pre>\n<p>我们看到，代码里设置了两个 class：col-6 col-sm-3 进行样式声明。</p>\n<p>从上面样式代码里看到类似 <code>flex: 0 0 25%</code> 的声明，为了理解它，我们从 flex 属性入手：flex 属性是 flex-grow、flex-shrink 和 flex-basis 的简写（类似 backgroud 是很多背景属性的简写一样），它的默认值为 0 1 auto，后两个属性可选。语法格式如下：</p>\n<pre><code class=\"lang-\">.item {\n    flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]\n}\n</code></pre>\n<ul>\n<li>flex-grow：属性定义项目的放大比例，默认为 0。我们看到 Bootstrap 代码里这个值一直为 0，即如果存在剩余空间，也不放大。</li>\n<li>flex-shrink：属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。</li>\n<li>flex-basis：属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。</li>\n</ul>\n<p>浏览器根据这个属性，计算主轴是否有多余空间，它可以设为跟 width 或 height 属性一样的值（比如 350px），则项目将占据固定空间。</p>\n<p>Bootstrap 这里对 flex 设置为比例值，这也是响应式自然而然实现的基础。</p>\n<p>但是我们想，很明显 col-6 col-sm-3 的样式属性是有冲突的，那么他们是如何做到“和平共处”交替发挥作用的呢？</p>\n<p>事实上：</p>\n<ul>\n<li>在屏幕宽度大于 576px 时候，会发现 .col-sm-3 并没有起作用，这时候起作用的是 .col-6。</li>\n</ul>\n<p>我们在源码里发现 .col-sm-* 的样式声明全部在</p>\n<pre><code class=\"lang-\"> @media (min-width: 576px) {...} \n</code></pre>\n<p>的媒体查询中，这就保证了在 576px 宽度以上的屏幕，只有在媒体查询之外的 .col-* 样式声明发挥了作用。</p>\n<ul>\n<li>在屏幕宽度小于 576px 时候，命中媒体查询，命中 .col-sm-3 的样式声明。它的优先级一定大于 .col-6（媒体查询优先级高），这时候就保证了移动端的样式“占上风”。</li>\n</ul>\n<p>再结合 col-6 col-sm-3  的样式声明，我们可以简单总结一下：Bootstrap 主要是通过百分比宽度（max-width: 50%; max-width: 25%;），以及 flex 属性，再加上媒体查询，“三管齐下”实现了栅格化布局的主体。</p>\n<p>当然整个过程实现还有很多其他细节，我也一直认为 Bootstrap 的源码是管理大型样式项目的优秀典范，有兴趣的读者可以参阅源码进行了解。</p>\n<h3><a id=\"font_color13aa6cfont_251\"></a><font color=13aa6c>横屏适配以及其他细节问题</font></h3>\n<p>很多 H5 页面中，我们要区分横屏和竖屏，在不同屏幕下要显示不同的布局，所以我们需要检测在不同的场景下给定不同的样式。通常使用 JavaScript 检查：</p>\n<pre><code class=\"lang-\">window.addEventListener(&quot;resize&quot;, () =&gt; {\n    if (window.orientation === 180 || window.orientation === 0) { \n        console.log(&apos;竖屏&apos;)\n    };\n    if (window.orientation === 90 || window.orientation === -90 ){ \n        console.log(&apos;横屏&apos;)\n    }  \n})\n</code></pre>\n<p>我们同样可以使用纯 CSS 来实现不同场景下的布局：</p>\n<pre><code class=\"lang-\">@media screen and (orientation: portrait) {\n  /*竖屏样式代码*/\n} \n@media screen and (orientation: landscape) {\n  /*横屏样式代码.*/\n}\n</code></pre>\n<p>同时这里我们在总结一下其他常见的响应式布局话题：</p>\n<ul>\n<li>1px 问题</li>\n<li>适配 iPhoneX 齐刘海</li>\n<li>图片自适应</li>\n</ul>\n<p>这些问题都可以轻松找到解决思路，我们不再详细给出。</p>\n<h3><a id=\"font_color13aa6c_font_285\"></a><font color=13aa6c>面试题：% 相对于谁</font></h3>\n<p>在之前的课程《前端面试必不可少的“面子工程”》中我们讲解了实现水平垂直居中的几种方式。其中absolute + transform 方案：</p>\n<pre><code class=\"lang-\">.wp {\n    position: relative;\n}\n.box {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n}\n</code></pre>\n<p>我们用到了不止一处 % 单位。事实上，上述代码中的 % 还真代表着不一样的计算规则。第一处 50% 是指 .wrap 相对定位元素宽度和高度的  50%，而 transform 中的 50% 是指自身元素的宽高的一半。</p>\n<p>那么在 CSS 中，这个常见的 % 单位有着什么样的规则呢？这也是一道很好的面试题目，我们在这一部分进行梳理。</p>\n<ul>\n<li>position: absolute 中的 %</li>\n</ul>\n<p>对于设置绝对定位 position absolute 的元素，我们可以使用 left right 表示其偏移量，我们把这个元素的祖先元素中第一个存在定位属性的元素成为参照物元素，其中的 % 是相对于参照物的，left 相对于参照物的 width，top 相对于这个参照物的 height。</p>\n<ul>\n<li>position: relative 中的 %</li>\n</ul>\n<p>对于设置相对定位 position relative 的元素，% 的数值是相对与自身的，left 相对于自己的 width，top 相对于自己的 height。</p>\n<ul>\n<li>position: fixed 中的 %</li>\n</ul>\n<p>对于设置固定定位 position fixed 的元素，% 的数值是相对于视口的，left 相对于视口的 width，top 相对于视口的 height。</p>\n<ul>\n<li>margin 和 padding 的 %</li>\n</ul>\n<p>margin 和 padding 当中的 % 非常特殊，它是相对于父元素的宽度。没错，margin-top: 30%，相当于父元素宽度的 30%</p>\n<ul>\n<li>border-radius 的 %</li>\n</ul>\n<p>想想我们经常对一个正方形元素设置：</p>\n<pre><code class=\"lang-\">border-radius: 50%\n</code></pre>\n<p>得到一个圆形，因此不难发现这里的 % 也是相对于自身宽高的。</p>\n<ul>\n<li>background-size 的 %</li>\n</ul>\n<p>background-size 的百分比和 border-radius 一样，也是相对于自身的宽高。</p>\n<ul>\n<li>transform： translate</li>\n</ul>\n<p>transform 的 translate 属性 % 是相对于自身的宽高，这也是我们上述代码能够实现居中的原因。</p>\n<ul>\n<li>text-indent 的 %</li>\n</ul>\n<p>text-indent 这个属性可以设置首行缩进，当使用 % 时，它是相对于父元素的 width。</p>\n<ul>\n<li>font-size 的 %</li>\n</ul>\n<p>相对于父元素的字体大小。</p>\n<ul>\n<li>line-height 的 %</li>\n</ul>\n<p>line-height 设置行高时，如果单位为 %，则相对于该元素的 font-size 数值。</p>\n<p>这些就是我们常见的使用 % 的情况，还是很灵活多变的，具体细节都可以在 CSS 规范中找到。要求开发者的是了解常见的以及特殊的 % 场景。</p>\n<h3><a id=\"font_color13aa6cflex__float_font_353\"></a><font color=13aa6c>深入：flex 布局和传统 float 布局性能对比</font></h3>\n<p>最后这部分，让我们来深入一个关于性能的话题：</p>\n<blockquote>\n<p>flex 布局对性能的影响主要体现在哪方面？</p>\n</blockquote>\n<p>这个问题比较“偏门”，很多读者在平时应该没有想过。这里指出来的目的是开拓思路，让我们更加合理地认识 CSS 布局。</p>\n<p>我们先思考一下 <strong>flex 布局对性能到底有什么影响，或者有多大影响。</strong></p>\n<p><strong>首先性能问题一定是一个相对概念</strong>，flex 布局相比正常的 block layout（non-float）性能开销一定更大。事实上，block layout 永远都是 <strong>single-pass</strong>，算法进行布局，而 flex 布局却总会激发 <strong>multi-pass codepaths</strong> 算法布局。比如常用的 flex-align: stretch 通常都是 2-pass，这是无可争议且难以避免的短板，天生基因决定。（关于 single-pass 和 multi-pass codepaths，图形学算法问题这里不再展开，读者了解 single-pass 成本更低即可）</p>\n<p>口说无凭，我们来做一个对比，display: table VS display: flex。</p>\n<p>这里重复 1000 次这样的 DOM：</p>\n<pre><code class=\"lang-\">&lt;div class=&quot;wrap&quot;&gt;\n    &lt;div class=&quot;cell description&quot;&gt;Item Description&lt;/div&gt;\n    &lt;div class=&quot;cell add&quot;&gt;Add&lt;/div&gt;\n    &lt;div class=&quot;cell remove&quot;&gt;Remove&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<p>分别使用 flex 和 table 布局，并采用 <a href=\"https://link.zhihu.com/?target=http%3A//www.w3.org/TR/navigation-timing/\" target=\"_blank\">Navigation Timing API</a> 进行布局速度测量。代码如下：</p>\n<pre><code class=\"lang-\">&lt;script type=&quot;text/javascript&quot;&gt;\n    ;(function TimeThisMother() {\n        window.onload = function(){\n            setTimeout(function(){\n            var t = performance.timing;\n                alert(&quot;Speed of selection is: &quot; + (t.loadEventEnd - t.responseEnd) + &quot; milliseconds&quot;);\n            }, 0);\n        };\n    })();\n&lt;/script&gt;\n\n</code></pre>\n<p>得到结果：</p>\n<ul>\n<li>flex 布局：Speed of selection is: 248 milliseconds；</li>\n<li>table 布局：Speed of selection is: 282 milliseconds。</li>\n</ul>\n<p>flex 布局要比 table 布局似乎更快。</p>\n<p>曾经一个名叫 Chris Coyier 的开发者，实现了这样一个 flex 布局生成器。</p>\n<p><img src=\"https://images.gitbook.cn/16a75430-90a1-11e9-afed-87af38460e36\" alt=\"enter image description here\" /></p>\n<p>注意右上角的滑动条，越向右滑，页面不同颜色区块越多（截图上滚动条已经很短了，证明页面已经很长，布局区块很多），在如此大规模全面使用 flex 布局下，页面丝毫没有任何卡顿。</p>\n<p>如上图，打开 Chrome Dev Tools &gt; Timeline，单击 record 按钮，滑动滑块并停止。我们得到瀑布流紫色部分，显示性能效果良好。</p>\n<p>当然这样的“模拟”距离真实场景也许较远，不排除如果页面中存在很多图片就会使得性能开销激增，可能使用 flex 某些属性也会付出昂贵的代价。但是一般场景使用，我认为没有必要去担心 flex 布局性能问题，至少它比别的方案靠谱（先不论兼容性）。</p>\n<p><strong>读者可以去 codepen 进行体验：</strong></p>\n<p><a href=\"https://link.zhihu.com/?target=https%3A//codepen.io/chriscoyier/pen/LGmkn\" target=\"_blank\">Generate a Crapload of Flexbox​codepen.io<img src=\"https://images.gitbook.cn/4107b7b0-90a1-11e9-8b34-c732c3ec276d\" alt=\"图标\" /></a></p>\n<p>最后，需要格外提出的是：<strong>新版 flex 布局一般比旧版布局模型更快，同样也比基于浮动的布局模型更快。</strong></p>\n<p>这里来特殊对比一下 flex 布局和浮动布局在性能上的表现。</p>\n<p>下图显示了在 1,300 个框上使用浮动的布局开销。</p>\n<p><img src=\"https://images.gitbook.cn/581b0150-90a1-11e9-8b34-c732c3ec276d\" alt=\"enter image description here\" /></p>\n<p>我们更新此示例以使用 flex，则出现不同的情况：</p>\n<p><img src=\"https://images.gitbook.cn/71f58140-90a1-11e9-9c86-a1bad3faf0f2\" alt=\"enter image description here\" /></p>\n<p>很明显，对于相同数量的元素和相同的视觉外观，flex 布局的时间要少得多（本例中分别为 3.5 毫秒和 14 毫秒）。对比来源：<a href=\"https://link.zhihu.com/?target=http%3A//developers.google.com/\" target=\"_blank\">developers.google.com</a>。</p>\n<p><strong>最后，布局性能的开销，一般直接考虑如下因素：</strong></p>\n<ul>\n<li>需要布局的元素数量</li>\n<li>布局的复杂性</li>\n</ul>\n<p>相对地，<strong>对于布局性能建议主要有：</strong></p>\n<ul>\n<li>应尽可能避免触发布局（layout／reflow）</li>\n<li>避免强制同步布局和布局抖动</li>\n</ul>\n<p>这些面就更大了，我们会在页面性能优化课程中继续这个话题。这里通过结论，想告诉大家的是：不论什么样的布局，在性能上一般很难成为瓶颈。同时另一方面，CSS 看似简单，却也和性能息息相关。</p>\n<h3><a id=\"font_color13aa6cfont_440\"></a><font color=13aa6c>总结</font></h3>\n<p>这一讲我们分析了实现响应式布局的常用手段，并结合实际案例加以剖析；同时讨论了布局方案对于页面性能的影响。到此为止，HTML 和 CSS 相关的内容终于告一段落了，读者应该能有一个清晰的认识：</p>\n<ul>\n<li>HTML 和 CSS 很重要</li>\n<li>HTML 和 CSS 如果不花心思，也不好学</li>\n</ul>\n<p>但是关于 HTML 和 CSS 我们更应该注重实战，也许可以暂时不用“系统化”地去了解，但是遇见一个案例，就去攻克一个案例，慢慢地，你也能成为 HTML 和 CSS 专家！</p>\n<h3><a id=\"font_color13aa6cfont_449\"></a><font color=13aa6c>分享交流</font></h3>\n<p>阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。<strong>你的分享不仅帮助他人，更会提升自己。</strong></p>\n<p>你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。</p>\n<blockquote>\n<p><strong>为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。</strong></p>\n</blockquote>\n","readingStatistics":88,"createdAt":"2019-04-21T04:19:07.522Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":15,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FoThASW9dVEPMEo9nP-zaOfbKyLZ"},{"_id":"5cbbef7cbbbba80861a35c23","communication_start_time":null,"type":1,"audioPath":"","abstract":"","content":"框架在任何一种语言编程范畴中都扮演了举足轻重的地位，前端尤是如此。目前流行的前端框架三驾马车：Angular、React 和 Vue，它们各有特点和受众，都值得开发者认真思考和学习。那么我们在精力有限的情况下，如何做到“触类旁通”、如何提取框架共性、提高学习和应用效率呢？\n\n我们这一讲就来剖析这些框架的特点和本质，介绍如何学习并使用这些框架，进而了解前端框架的真谛。\n\n相关知识点如下：\n\n<img src=\"https://images.gitbook.cn/ff71bef0-9234-11e9-b195-bf69c03485a0\" width=500>\n\n我把现代框架的关键词进行提炼，掌握这些关键词，是我们学习的重要环节。这些关键词有：双向绑定、依赖收集、发布订阅模式、MVVM / MVC、虚拟 DOM、虚拟 DOM diff、模版编译等。\n\n### <font color=13aa6c>响应式框架基本原理</font>\n\n我们不再赘述响应式或数据双向绑定的基本概念，这里直接思考其行为：直观上，数据在变化时，不再需要开发者去手动更新视图，而视图会根据变化的数据“自动”进行更新。想完成这个过程，我们需要：\n\n- 收集视图依赖了哪些数据\n- 感知被依赖数据的变化\n- 数据变化时，自动“通知”需要更新的视图部分，并进行更新\n\n道理很简单，这个思考过程换成对应的技术概念就是：\n\n- 依赖收集\n- 数据劫持 / 数据代理\n- 发布订阅模式\n\n接下来，我们一步步拆解。\n\n#### 数据劫持与代理\n\n感知数据变化的方法很直接，就是进行数据劫持或数据代理。我们往往通过 Object.defineProperty 实现。这个方法可以定义数据的 getter 和 setter，具体用法不再赘述。下面来看一个场景：\n\n```\nlet data = {\n  stage: &apos;GitChat&apos;,\n  course: {\n    title: &apos;前端开发进阶&apos;,\n    author: &apos;Lucas&apos;,\n    publishTime: &apos;2018 年 5 月&apos;\n  }\n}\n\nObject.keys(data).forEach(key => {\n  let currentValue = data[key]\n\n  Object.defineProperty(data, key, {\n    enumerable: true,\n    configurable: false,\n    get() {\n      console.log(`getting ${key} value now, getting value is:`, currentValue)\n      return currentValue\n    },\n    set(newValue) {\n      currentValue = newValue\n      console.log(`setting ${key} value now, setting value is`, currentValue)\n    }\n  })\n}) \n```\n\n这段代码对 data 数据的 getter 和 setter 进行定义拦截，当我们读取或者改变 data 的值时：\n\n```\ndata.course\n\n// getting course value now, getting value is: {title: \"前端开发进阶\", author: \"Lucas\", publishTime: \"2018 年 5 月\"}\n```\n\n```\ndata.course = &apos;前端开发进阶2&apos;\n// setting course value now, setting value is 前端开发进阶2\n```\n\n但是这种实现有一个问题，例如：\n\n```\ndata.course.title = &apos;前端开发进阶2&apos;\n\n// getting course value now, getting value is: {title: \"前端开发进阶\", author: \"Lucas\", publishTime: \"2018 年 5 月\"}\n```\n\n只会有 getting course value now, getting value is: {title: \"前端开发进阶\", author: \"Lucas\", publishTime: \"2018 年 5 月\"} 的输出，这是因为我们尝试读取了 data.course 信息。但是修改 data.course.title 的信息并没有打印出来。\n\n出现这个问题的原因是因为我们的实现代码只进行了一层 Object.defineProperty，或者说只对 data 的第一层属性进行了 Object.defineProperty，对于嵌套的引用类型数据结构：data.course，我们同样应该进行拦截。\n\n为了达到深层拦截的目的，将 Object.defineProperty 的逻辑抽象为 observe 函数，并改用递归实现：\n\n```\nlet data = {\n  stage: &apos;GitChat&apos;,\n  course: {\n    title: &apos;前端开发进阶&apos;,\n    author: &apos;Lucas&apos;,\n    publishTime: &apos;2018 年 5 月&apos;\n  }\n}\n\nconst observe = data => {\n  if (!data || typeof data !== &apos;object&apos;) {\n      return\n  }\n  Object.keys(data).forEach(key => {\n    let currentValue = data[key]\n\n    observe(currentValue)\n\n    Object.defineProperty(data, key, {\n      enumerable: true,\n      configurable: false,\n      get() {\n        console.log(`getting ${key} value now, getting value is:`, currentValue)\n        return currentValue\n      },\n      set(newValue) {\n        currentValue = newValue\n        console.log(`setting ${key} value now, setting value is`, currentValue)\n      }\n    })\n  }) \n}\n\nobserve(data)\n```\n\n这样一来，就实现了深层数据拦截：\n\n```\ndata.course.title = &apos;前端开发进阶2&apos;\n\n// getting course value now, getting value is: {// ...}\n// setting title value now, setting value is 前端开发进阶2\n```\n\n请注意，我们在 set 代理中，并没有对 newValue 再次递归进行 observe(newValue)。也就是说，如果赋值是一个引用类型：\n\n```\ndata.course.title = {\n\ttitle: &apos;前端开发进阶2&apos;\n}\n```\n\n无法实现对 data.course.title 数据的观察。这里为了简化学习成本，默认修改的数值符合语义，都是基本类型。\n\n在尝试对 data.course.title 赋值时，首先会读取 data.course，因此输出：getting course value now, getting value is: {// ...}，赋值后，触发 data.course.title 的 setter，输出：setting title value now, setting value is 前端开发进阶2。\n\n因此我们总结出：对数据进行拦截并不复杂，这也是很多框架实现的第一步。\n\n#### 监听数组变化\n\n如果上述数据中某一项变为数组：\n\n```\nlet data = {\n  stage: &apos;GitChat&apos;,\n  course: {\n    title: &apos;前端开发进阶&apos;,\n    author: [&apos;Lucas&apos;, &apos;Ronaldo&apos;],\n    publishTime: &apos;2018 年 5 月&apos;\n  }\n}\n\nconst observe = data => {\n  if (!data || typeof data !== &apos;object&apos;) {\n      return\n  }\n  Object.keys(data).forEach(key => {\n    let currentValue = data[key]\n\n    observe(currentValue)\n\n    Object.defineProperty(data, key, {\n      enumerable: true,\n      configurable: false,\n      get() {\n        console.log(`getting ${key} value now, getting value is:`, currentValue)\n        return currentValue\n      },\n      set(newValue) {\n        currentValue = newValue\n        console.log(`setting ${key} value now, setting value is`, currentValue)\n      }\n    })\n  }) \n}\n\nobserve(data)\n\n\ndata.course.author.push(&apos;Messi&apos;)\n// getting course value now, getting value is: {//...}\n// getting author value now, getting value is: (2) [(...), (...)]\n```\n\n我们只监听到了 data.course 以及 data.course.author 的读取，而数组 push 行为并没有被拦截。这是因为 Array.prototype 上挂载的方法并不能触发 data.course.author 属性值的 setter，由于这并不属于做赋值操作，而是 push API 调用操作。然而对于框架实现来说，这显然是不满足要求的，当数组变化时我们应该也有所感知。\n\nVue 同样存在这样的问题，它的解决方法是：将数组的常用方法进行重写，进而覆盖掉原生的数组方法，重写之后的数组方法需要能够被拦截。\n\n实现逻辑如下：\n\n```\nconst arrExtend = Object.create(Array.prototype)\nconst arrMethods = [\n  &apos;push&apos;,\n  &apos;pop&apos;,\n  &apos;shift&apos;,\n  &apos;unshift&apos;,\n  &apos;splice&apos;,\n  &apos;sort&apos;,\n  &apos;reverse&apos;\n]\n\narrMethods.forEach(method => {\n  const oldMethod = Array.prototype[method]\n  const newMethod = function(...args) {\n    oldMethod.apply(this, args)\n    console.log(`${method} 方法被执行了`)\n  }\n  arrExtend[method] = newMethod\n})\n```\n\n对于数组原生的 7 个方法：\n\n- push\n- pop\n- shift\n- unshift\n- splice\n- sort\n- reverse\n\n进行重写，核心操作还是调用原生方法：oldMethod.apply(this, args)，除此之外可以在调用 oldMethod.apply(this, args) 前后加入我们需要的任何逻辑。示例代码中加入了一行 console.log。使用时：\n\n```\nArray.prototype = Object.assign(Array.prototype, arrExtend)\n\nlet array = [1, 2, 3]\narray.push(4)\n// push 方法被执行了\n```\n\n对应我们的代码：\n\n```\nconst arrExtend = Object.create(Array.prototype)\nconst arrMethods = [\n  &apos;push&apos;,\n  &apos;pop&apos;,\n  &apos;shift&apos;,\n  &apos;unshift&apos;,\n  &apos;splice&apos;,\n  &apos;sort&apos;,\n  &apos;reverse&apos;\n]\n\narrMethods.forEach(method => {\n  const oldMethod = Array.prototype[method]\n  const newMethod = function(...args) {\n    oldMethod.apply(this, args)\n    console.log(`${method} 方法被执行了`)\n  }\n  arrExtend[method] = newMethod\n})\n\nArray.prototype = Object.assign(Array.prototype, arrExtend)\n\n\nlet data = {\n  stage: &apos;GitChat&apos;,\n  course: {\n    title: &apos;前端开发进阶&apos;,\n    author: [&apos;Lucas&apos;, &apos;Ronaldo&apos;],\n    publishTime: &apos;2018 年 5 月&apos;\n  }\n}\n\nconst observe = data => {\n  if (!data || typeof data !== &apos;object&apos;) {\n      return\n  }\n  Object.keys(data).forEach(key => {\n    let currentValue = data[key]\n\n    observe(currentValue)\n\n    Object.defineProperty(data, key, {\n      enumerable: true,\n      configurable: false,\n      get() {\n        console.log(`getting ${key} value now, getting value is:`, currentValue)\n        return currentValue\n      },\n      set(newValue) {\n        currentValue = newValue\n        console.log(`setting ${key} value now, setting value is`, currentValue)\n      }\n    })\n  }) \n}\n\nobserve(data)\n\ndata.course.author.push(&apos;Messi&apos;)\n```\n\n将会输出：\n\n```\ngetting course value now, getting value is: {//...}\ngetting author value now, getting value is: (2) [(...), (...)]\n// push 方法被执行了\n```\n\n这种 monkey patch 本质是重写原生方法，这天生不是很安全，也很不优雅，能有更好的实现吗？\n\n答案是有的，使用 ES Next 的新特性——Proxy，之前也介绍过，它可以完成对数据的代理。\n\n那么这两种方式有何区别呢？请继续阅读。\n\n#### Object.defineProperty VS Proxy\n\n我们首先尝试使用 Proxy 来完成代码重构：\n\n```\nlet data = {\n  stage: &apos;GitChat&apos;,\n  course: {\n    title: &apos;前端开发进阶&apos;,\n    author: [&apos;Lucas&apos;],\n    publishTime: &apos;2018 年 5 月&apos;\n  }\n}\n\nconst observe = data => {\n  if (!data || Object.prototype.toString.call(data) !== &apos;[object Object]&apos;) {\n      return\n  }\n\n  Object.keys(data).forEach(key => {\n    let currentValue = data[key]\n    // 事实上 proxy 也可以对函数类型进行代理。这里只对承载数据类型的 object 进行处理，读者了解即可。\n    if (typeof currentValue === &apos;object&apos;) {\n      observe(currentValue)\n      data[key] = new Proxy(currentValue, {\n        set(target, property, value, receiver) {\n          // 因为数组的 push 会引起 length 属性的变化，所以 push 之后会触发两次 set 操作，我们只需要保留一次即可，property 为 length 时，忽略\n          if (property !== &apos;length&apos;) {\n            console.log(`setting ${key} value now, setting value is`, currentValue)\n          }\n          return Reflect.set(target, property, value, receiver)\n        }\n      })\n    }\n    else {\n      Object.defineProperty(data, key, {\n        enumerable: true,\n        configurable: false,\n        get() {\n          console.log(`getting ${key} value now, getting value is:`, currentValue)\n          return currentValue\n        },\n        set(newValue) {\n          currentValue = newValue\n          console.log(`setting ${key} value now, setting value is`, currentValue)\n        }\n      })\n    }\n  }) \n}\n\nobserve(data)\n```\n\n此时对数组进行操作：\n\n```\ndata.course.author.push(&apos;messi&apos;)\n// setting author value now, setting value is [\"Lucas\"]\n```\n\n已经符合我们的需求了。注意这里在使用 Proxy 进行代理时，并没有对 getter 进行代理，因此上述代码的输出结果并不像之前使用 Object.defineProperty 那样也会有 getting value 输出。\n\n整体实现并不难理解，需要读者了解最基本的 Proxy 知识。简单总结一下，对于数据键值为基本类型的情况，我们使用 Object.defineProperty；对于键值为对象类型的情况，继续递归调用 observe 方法，并通过 Proxy 返回的新对象对 data[key] 重新赋值，这个新值的 getter 和 setter 已经被添加了代理。\n\n了解了 Proxy 实现之后，我们对 Proxy 实现数据代理和 Object.defineProperty 实现数据拦截进行对比，会发现：\n\n- Object.defineProperty 不能监听数组的变化，需要进行数组方法的重写\n- Object.defineProperty 必须遍历对象的每个属性，且对于嵌套结构需要深层遍历\n- Proxy 的代理是针对整个对象的，而不是对象的某个属性，因此不同于 Object.defineProperty 的必须遍历对象每个属性，Proxy 只需要做一层代理就可以监听同级结构下的所有属性变化，当然对于深层结构，递归还是需要进行的\n- Proxy 支持代理数组的变化\n- Proxy 的第二个参数除了 set 和 get 以外，可以有 13 种拦截方法，比起 Object.defineProperty() 更加强大，这里不再一一列举\n- Proxy 性能将会被底层持续优化，而 Object.defineProperty 已经不再是优化重点\n\n### <font color=13aa6c>模版编译原理介绍</font>\n\n到此，我们了解了如何监听数据的变化，那么下一步呢？以类 Vue 框架为例，我们看看一个典型的用法：\n\n```\n<body>\n  <div id=\"app\">\n    <h1>{{stage}} 平台课程：{{course.title}}</h1>\n    <p>{{course.title}} 是 {{course.author}} 发布的课程</p>\n    <p>发布时间为 {{course.publishTime}} </p>\n  </div>\n  \n  <script>\n    let vue = new Vue({ \n      ele: &apos;#app&apos;, \n      data: {\n        stage: &apos;GitChat&apos;,\n        course: {\n          title: &apos;前端开发进阶&apos;,\n          author: &apos;Lucas&apos;,\n          publishTime: &apos;2018 年 5 月&apos;\n        },\n      }\n    })\n  </script>\n</body>\n```\n\n其中模版变量使用了 {{}} 的表达方式输出模版变量。最终输出的 HTML 内容应该被合适的数据进行填充替换，因此还需要一步编译过程，该过程任何框架或类库中都是相通的，比如 React 中的 JSX，也是编译为 React.createElement，并在生成虚拟 DOM 时进行数据填充。\n\n我们这里简化过程，将模版内容：\n\n```\n<div id=\"app\">\n\t<h1>{{stage}} 平台课程：{{course.title}}</h1>\n\t<p>{{course.title}} 是 {{course.author}} 发布的课程</p>\n\t<p>发布时间为 {{course.publishTime}} </p>\n</div>\n```\n\n输出为真实 HTML 即可。\n\n#### 模版编译实现\n\n一提到这样的“模版编译”过程，很多开发者都会想到词法分析，也许都会感到头大。其实原理很简单，就是使用正则 + 遍历，有时也需要一些算法知识，我们来看现在的场景，只需要对 #app 节点下内容进行替换，通过正则识别出模版变量，获取对应的数据即可：\n\n```\ncompile(document.querySelector(&apos;#app&apos;), data)\n\nfunction compile(el, data) {\n  let fragment = document.createDocumentFragment()\n\n  while (child = el.firstChild) {\n    fragment.appendChild(child)\n  }\n\n  // 对 el 里面的内容进行替换\n  function replace(fragment) {\n    Array.from(fragment.childNodes).forEach(node => {\n      let textContent = node.textContent\n      let reg = /\\{\\{(.*?)\\}\\}/g\n\n      if (node.nodeType === 3 && reg.test(textContent)) {\n\t\t const nodeTextContent = node.textContent\n        const replaceText = () => {\n        \tnode.textContent = nodeTextContent.replace(reg, (matched, placeholder) => {\n        \t\treturn placeholder.split(&apos;.&apos;).reduce((prev, key) => {\n        \t\t\treturn prev[key]\n        \t\t}, data)\n        \t\n        \t})\n        }\n        \n        replaceText()\n      }\n\n      // 如果还有子节点，继续递归 replace\n      if (node.childNodes && node.childNodes.length) {\n        replace(node)\n      }\n    })\n  }\n\n  replace(fragment)\n\n  el.appendChild(fragment)\n  return el\n}\n``` \n\n代码分析：我们使用 fragment 变量储存生成的真实 HTML 节点内容。通过 replace 方法对 {{变量}} 进行数据替换，同时 {{变量}} 的表达只会出现在 nodeType === 3 的文本类型节点中，因此对于符合 `node.nodeType === 3 && reg.test(textContent)` 条件的情况，进行数据获取和填充。我们借助字符串 replace 方法第二个参数进行一次性替换，此时对于形如 {{data.course.title}} 的深层数据，通过 reduce 方法，获得正确的值。\n\n因为 DOM 结构可能是多层的，所以对存在子节点的节点，依然使用递归进行 replace 替换。\n\n这个编译过程比较简单，没有考虑到边界情况，只是单纯完成模版变量到真实 DOM 的转换，读者只需体会简单道理即可。\n\n#### 双向绑定实现\n\n上述实现是单向的，数据变化引起了视图变化，那么如果页面中存在一个输入框，如何触发数据变化呢？比如：\n\n```\n<input v-model=\"inputData\" type = \"text\" >\n```\n\n我们需要在模版编译中，对于存在 v-model 属性的 node 进行事件监听，在输入框输入时，改变 v-model 属性值对应的数据即可（这里为 inputData），增加 compile 中的 replace 方法逻辑，对于 node.nodeType === 1 的 DOM 类型，伪代码如下：\n\n```\nfunction replace(el, data) {\n  // 省略...\n  if (node.nodeType === 1) {\n\n    let attributesArray = node.attributes\n\n    Array.from(attributesArray).forEach(attr => {\n      let attributeName = attr.name\n      let attributeValue = attr.value\n\n      if (name.includes(&apos;v-&apos;)) {\n        node.value = data[attributeValue]\n      }\n\n      node.addEventListener(&apos;input&apos;, e => {\n        let newVal = e.target.value\n        data[attributeValue] = newVal\n        // ...\n        // 更改数据源，触发 setter\n        // ...\n      })\n    })\n\n  }\n\n  if (node.childNodes && node.childNodes.length) {\n    replace(node)\n  }\n}\n```\n\n### <font color=13aa6c>发布订阅模式简单应用</font>\n\n作为前端开发人员，我们对于所谓的“事件驱动”理念——即“事件发布订阅模式（Pub/Sub 模式）”一定再熟悉不过了。这种模式在 JavaScript 里面有与生俱来的基因：我们可以认为 JavaScript 本身就是事件驱动型语言，比如，应用中对一个 button 进行了事件绑定，用户点击之后就会触发按钮上面的 click 事件。这是因为此时有特定程序正在监听这个事件，随之触发了相关的处理程序。\n\n这个模式的一个好处之一在于能够解耦，实现“高内聚、低耦合”的理念。这种模式对于我们框架的设计同样也不可或缺。请思考：通过前面内容的学习，我们了解了如何监听数据的变化。如果最终想实现响应式 MVVM，或所谓的双向绑定，那么还需要根据这个数据变化作出相应的视图更新。这个逻辑和我们在页面中对 button 绑定事件处理函数是多么相近。\n\n那么这样一个“熟悉的”模式应该怎么实现呢，又该如何在框架中具体应用呢？看代码：\n\n```\nclass Notify {\n  constructor() {\n    this.subscribers = []\n  }\n  add(handler) {\n    this.subscribers.push(handler)\n  }\n  emit() {\n    this.subscribers.forEach(subscriber => subscriber())\n  }\n}\n```\n\n使用：\n\n```\nlet notify = new Notify()\n\nnotify.add(() => {\n\tconsole.log(&apos;emit here&apos;)\n})\n\nnotify.emit()\n// emit here\n```\n\n这就是一个简单实现的“事件发布订阅模式”，当然代码只是启发思路，真实应用还比较“粗糙”，没有进行事件名设置，APIs 也并不丰富，但完全能够说明问题了。其实读者翻看 Vue 源码，也能了解 Vue 中的发布订阅模式很简单。\n\n### <font color=13aa6c>MVVM 融会贯通</font>\n\n回顾一下前面的基本内容：数据拦截和代理、发布订阅模式、模版编译，那么如何根据这些概念实现一个 MVVM 框架呢？其实不管是 Vue 还是其他类库或框架，其解决思想都是建立在前文所述概念之上的。\n\n我们来进行串联，整个过程是：首先对数据进行深度拦截或代理，对每一个属性的 getter 和 setter 进行“加工”，该“加工”具体做些什么后面马上会有说明。在模版初次编译时，解析指令（如 v-model），并进行依赖收集（{{变量}}），订阅数据的变化。\n\n这里的依赖收集过程具体指：当调用 compiler 中的 replace 方法时，我们会读取数据进行模版变量的替换，这时候“读取数据时”需要做一个标记，用来表示“我依赖这一项数据”，因此我要订阅这个属性值的变化。Vue 中定义一个 Watcher 类来表示观察订阅依赖。这就实现了整套流程，换个思路再复述一遍：我们知道模版编译过程中会读取数据，进而触发数据源属性值的 getter，因此上面所说的数据代理的“加工”就是在数据监听的 getter 中记录这个依赖，同时在 setter 触发数据变化时，执行依赖对应的相关操作，最终触发模版中数据的变化。\n\n我们抽象成流程图来理解：\n\n![enter image description here](https://images.gitbook.cn/02926aa0-925b-11e9-a0f8-2d0a45937cae)\n\n这也是 Vue 框架（类库）的基本架构图。由此看出，Vue 的实现，或者大部分 MVVM 的实现，就是我们本节课程介绍的概念组合应用。\n\n关于框架的对比剖析，更多话题我们留在《第 4-7 课：从框架和类库，我们该学到什么》一课中介绍。\n\n### <font color=13aa6c>揭秘虚拟 DOM</font>\n\n我们来看现代框架中另一个重头戏——虚拟 DOM。虚拟 DOM 这个概念其实并没有那么新，甚至在前端三大框架问世之前，虚拟 DOM 就已经存在了，只不过 React 创造性的应用了虚拟 DOM，为前端发展带来了变革。Vue 2.0 也很快跟进，使得虚拟 DOM 彻底成为现代框架的重要基因。简单来说，虚拟 DOM 就是用数据结构表示 DOM 结构，它并没有真实 append 到 DOM 上，因此称之为“虚拟”。\n\n应用虚拟 DOM 的收益也很直观：操作数据结构远比和浏览器交互去操作 DOM 快很多。请读者准确理解这句话：操作数据结构是指改变对象（虚拟 DOM），这个过程比修改真实 DOM 快很多。但虚拟 DOM 也最终是要挂载到浏览器上成为真实 DOM 节点，因此使用虚拟 DOM 并不能使得操作 DOM 的数量减少，但能够精确地获取最小的、最必要的操作 DOM 的集合。\n\n这样一来，我们抽象表示 DOM，每次通过 DOM diff 计算出视图前后更新的最小差异，再去把最小差异应用到真实 DOM 上的做法，无疑更为可靠，性能更有保障。\n\n那我们该如何表示虚拟 DOM 呢？又该如何产出虚拟 DOM 呢？\n\n直观上我们看这样一段 DOM 结构：\n\n```\n<ul id=\"chapterList\">\n  <li class=\"chapter\">chapter1</li>\n  <li class=\"chapter\">chapter2</li>\n  <li class=\"chapter\">chapter3</li>\n</ul>\n```\n\n如果用 JavaScript 来表示，我们采用对象结构：\n\n```\nconst chapterListVirtualDom = {\n  tagName: &apos;ul&apos;,\n  attributes: {\n    id: &apos;chapterList&apos;\n  },\n  children: [\n    { tagName: &apos;li&apos;, attributes: { class: &apos;chapter&apos; }, children: [&apos;chapter1&apos;] },\n    { tagName: &apos;li&apos;, attributes: { class: &apos;chapter&apos; }, children: [&apos;chapter2&apos;] },\n    { tagName: &apos;li&apos;, attributes: { class: &apos;chapter&apos; }, children: [&apos;chapter3&apos;] },\n  ]\n}\n```\n\n很好理解：tagName 表示虚拟 DOM 对应的真实 DOM 标签类型；attributes 是一个对象，表示真实 DOM 节点上所有的属性；children 对应真实 DOM 的 childNodes，其中 childNodes 每一项又是类似的结构。\n\n我们来实现一个虚拟 DOM 生成类，用于生产虚拟 DOM：\n\n```\nclass Element {\n  constructor(tagName, attributes = {}, children = []) {\n    this.tagName = tagName\n    this.attributes = attributes\n    this.children = children\n  }\n}\n\nfunction element(tagName, attributes, children) {\n  return new Element(tagName, attributes, children)\n}\n```\n\n上述虚拟 DOM 就可以这样生成：\n\n```\nconst chapterListVirtualDom = element(&apos;ul&apos;, { id: &apos;list&apos; }, [\n  element(&apos;li&apos;, { class: &apos;chapter&apos; }, [&apos;chapter1&apos;]),\n  element(&apos;li&apos;, { class: &apos;chapter&apos; }, [&apos;chapter2&apos;]),\n  element(&apos;li&apos;, { class: &apos;chapter&apos; }, [&apos;chapter3&apos;])\n])\n```\n\n如图：\n\n![enter image description here](https://images.gitbook.cn/23d3e7c0-925b-11e9-a0f8-2d0a45937cae)\n\n是不是很简单？我们继续完成虚拟 DOM 向真实 DOM 节点的生成。首先实现一个 setAttribute 方法，后续的代码都将使用 setAttribute 方法来对 DOM 节点进行属性设置。\n\n```\nconst setAttribute = (node, key, value) => {\n  switch (key) {\n    case &apos;style&apos;:\n      node.style.cssText = value\n      break\n    case &apos;value&apos;:\n      let tagName = node.tagName || &apos;&apos;\n      tagName = tagName.toLowerCase()\n      if (\n        tagName === &apos;input&apos; || tagName === &apos;textarea&apos;\n      ) {\n        node.value = value\n      } else {\n        // 如果节点不是 input 或者 textarea, 则使用 setAttribute 去设置属性\n        node.setAttribute(key, value)\n      }\n      break\n    default:\n      node.setAttribute(key, value)\n      break\n  }\n}\n```\n\nElement 类中加入 render 原型方法，该方法的目的是根据虚拟 DOM 生成真实 DOM 片段：\n\n```\nclass Element {\n  constructor(tagName, attributes = {}, children = []) {\n    this.tagName = tagName\n    this.attributes = attributes\n    this.children = children\n  }\n\n  render () {\n    let element = document.createElement(this.tagName)\n    let attributes = this.attributes\n\n\t for (let key in attributes) {\n\t    setAttribute(element, key, attributes[key])\n\t }\n\n    let children = this.children\n\n    children.forEach(child => {\n      let childElement = child instanceof Element\n        ? child.render() // 若 child 也是虚拟节点，递归进行\n        : document.createTextNode(child)  // 若是字符串，直接创建文本节点\n      element.appendChild(childElement)\n    })\n\n    return element\n  }\n}\n\nfunction element (tagName, attributes, children) {\n  return new Element(tagName, attributes, children)\n}\n```\n\n实现也不困难，我们借助工具方法：setAttribute 进行属性的创建；对 children 每一项类型进行判断，如果是 Element 实例，进行递归调用 child 的 render 方法；直到遇见文本节点类型，进行内容渲染。\n\n有了真实的 DOM 节点片段，我们趁热打铁，将真实的 DOM 节点渲染到浏览器上，实现 renderDOM 方法：\n\n```\nconst renderDom = (element, target) => {\n  target.appendChild(element)\n}\n```\n\n执行代码：\n\n```\nconst setAttribute = (node, key, value) => {\n  switch (key) {\n    case &apos;style&apos;:\n      node.style.cssText = value\n      break\n    case &apos;value&apos;:\n      let tagName = node.tagName || &apos;&apos;\n      tagName = tagName.toLowerCase()\n      if (\n        tagName === &apos;input&apos; || tagName === &apos;textarea&apos;\n      ) {\n        node.value = value\n      } else {\n        // 如果节点不是 input 或者 textarea，则使用 setAttribute 去设置属性\n        node.setAttribute(key, value)\n      }\n      break\n    default:\n      node.setAttribute(key, value)\n      break\n  }\n}\n\nclass Element {\n  constructor(tagName, attributes = {}, children = []) {\n    this.tagName = tagName\n    this.attributes = attributes\n    this.children = children\n  }\n\n  render () {\n    let element = document.createElement(this.tagName)\n    let attributes = this.attributes\n\n\t for (let key in attributes) {\n\t    setAttribute(element, key, attributes[key])\n\t }\n\n    let children = this.children\n\n    children.forEach(child => {\n      let childElement = child instanceof Element\n        ? child.render() // 若 child 也是虚拟节点，递归进行\n        : document.createTextNode(child)  // 若是字符串，直接创建文本节点\n      element.appendChild(childElement)\n    })\n\n    return element\n  }\n}\n\nfunction element (tagName, attributes, children) {\n  return new Element(tagName, attributes, children)\n}\n\nconst renderDom = (element, target) => {\n  target.appendChild(element)\n}\n\nconst chapterListVirtualDom = element(&apos;ul&apos;, { id: &apos;list&apos; }, [\n  element(&apos;li&apos;, { class: &apos;chapter&apos; }, [&apos;chapter1&apos;]),\n  element(&apos;li&apos;, { class: &apos;chapter&apos; }, [&apos;chapter2&apos;]),\n  element(&apos;li&apos;, { class: &apos;chapter&apos; }, [&apos;chapter3&apos;])\n])\n\nconst dom = chapterListVirtualDom.render()\n\nrenderDom(dom, document.body)\n```\n\n得到如图：\n\n![enter image description here](https://images.gitbook.cn/43b5d4e0-925b-11e9-a8e5-21b5567b38f4)\n\n#### 虚拟 DOM diff\n\n有了上述基础，我们可以产出一份虚拟 DOM，并渲染在浏览器中。当用户在特定操作后，会产出新的一份虚拟 DOM，如何得出前后两份虚拟 DOM 的差异，并交给浏览器需要更新的结果呢？这就涉及到 DOM diff 的过程。\n\n直观上，因为虚拟 DOM 是个树形结构，所以我们需要对两份虚拟 DOM 进行递归比较，将变化存储在一个变量 patches 中：\n\n```\nconst diff = (oldVirtualDom, newVirtualDom) => {\n    let patches = {}\n\n    // 递归树，比较后的结果放到 patches\n    walkToDiff(oldVirtualDom, newVirtualDom, 0, patches)\n\n\t // 返回 diff 结果 \n    return patches\n}\n```\n\nwalkToDiff 前两个参数是两个需要比较的虚拟 DOM 对象；第三个参数记录 nodeIndex，在删除节点时使用，初始为 0；第四个参数是一个闭包变量，记录 diff 结果：\n\n```\nlet initialIndex = 0\n\nconst walkToDiff = (oldVirtualDom, newVirtualDom, index, patches) => {\n  let diffResult = []\n\n  // 如果 newVirtualDom 不存在，说明该节点被移除，我们将 type 为 REMOVE 的对象推进 diffResult 变量，并记录 index\n  if (!newVirtualDom) {\n    diffResult.push({\n      type: &apos;REMOVE&apos;,\n      index\n    })\n  }\n  // 如果新旧节点都是文本节点，是字符串\n  else if (typeof oldVirtualDom === &apos;string&apos; && typeof newVirtualDom === &apos;string&apos;) {\n    // 比较文本是否相同，如果不同则记录新的结果\n    if (oldVirtualDom !== newVirtualDom) {\n      diffResult.push({\n        type: &apos;MODIFY_TEXT&apos;,\n        data: newVirtualDom,\n        index\n      })\n    }\n  }\n  // 如果新旧节点类型相同\n  else if (oldVirtualDom.tagName === newVirtualDom.tagName) {\n    // 比较属性是否相同\n    let diffAttributeResult = {}\n\n    for (let key in oldVirtualDom) {\n      if (oldVirtualDom[key] !== newVirtualDom[key]) {\n        diffAttributeResult[key] = newVirtualDom[key]\n      }\n    }\n\n    for (let key in newVirtualDom) {\n      // 旧节点不存在的新属性\n      if (!oldVirtualDom.hasOwnProperty(key)) {\n          diffAttributeResult[key] = newVirtualDom[key]\n      }\n    }\n\n    if (Object.keys(diffAttributeResult).length > 0) {\n        diffResult.push({ \n          type: &apos;MODIFY_ATTRIBUTES&apos;, \n          diffAttributeResult \n        })\n    }\n    \n    // 如果有子节点，遍历子节点\n    oldVirtualDom.children.forEach((child, index) => {\n      walkToDiff(child, newVirtualDom.children[index], ++initialIndex, patches)\n    })\n  }\n  // else 说明节点类型不同，被直接替换了，我们直接将新的结果 push\n  else {\n    diffResult.push({ \n      type: &apos;REPLACE&apos;, \n      newVirtualDom\n    })\n  }\n\n  if (!oldVirtualDom) {\n    diffResult.push({ \n      type: &apos;REPLACE&apos;, \n      newVirtualDom\n    })\n  }\n\n  if (diffResult.length) {\n    patches[index] = diffResult\n  }\n}\n```\n\n我们最后将所有代码放在一起：\n\n```\nconst setAttribute = (node, key, value) => {\n  switch (key) {\n    case &apos;style&apos;:\n      node.style.cssText = value\n      break\n    case &apos;value&apos;:\n      let tagName = node.tagName || &apos;&apos;\n      tagName = tagName.toLowerCase()\n      if (\n        tagName === &apos;input&apos; || tagName === &apos;textarea&apos;\n      ) {\n        node.value = value\n      } else {\n        // 如果节点不是 input 或者 textarea，则使用 setAttribute 去设置属性\n        node.setAttribute(key, value)\n      }\n      break\n    default:\n      node.setAttribute(key, value)\n      break\n  }\n}\n\nclass Element {\n  constructor(tagName, attributes = {}, children = []) {\n    this.tagName = tagName\n    this.attributes = attributes\n    this.children = children\n  }\n\n  render () {\n    let element = document.createElement(this.tagName)\n    let attributes = this.attributes\n\n\t for (let key in attributes) {\n\t    setAttribute(element, key, attributes[key])\n\t }\n\n    let children = this.children\n\n    children.forEach(child => {\n      let childElement = child instanceof Element\n        ? child.render() // 若 child 也是虚拟节点，递归进行\n        : document.createTextNode(child)  // 若是字符串，直接创建文本节点\n      element.appendChild(childElement)\n    })\n\n    return element\n  }\n}\n\nfunction element (tagName, attributes, children) {\n  return new Element(tagName, attributes, children)\n}\n\nconst renderDom = (element, target) => {\n  target.appendChild(element)\n}\n\nconst diff = (oldVirtualDom, newVirtualDom) => {\n  let patches = {}\n\n  // 递归树 比较后的结果放到 patches\n  walkToDiff(oldVirtualDom, newVirtualDom, 0, patches)\n\n  return patches\n}\n\nlet initialIndex = 0\n\nconst walkToDiff = (oldVirtualDom, newVirtualDom, index, patches) => {\n  let diffResult = []\n\n  // 如果 newVirtualDom 不存在，说明该节点被移除，我们将 type 为 REMOVE 的对象推进 diffResult 变量，并记录 index\n  if (!newVirtualDom) {\n    diffResult.push({\n      type: &apos;REMOVE&apos;,\n      index\n    })\n  }\n  // 如果新旧节点都是文本节点，是字符串\n  else if (typeof oldVirtualDom === &apos;string&apos; && typeof newVirtualDom === &apos;string&apos;) {\n    // 比较文本是否相同，如果不同则记录新的结果\n    if (oldVirtualDom !== newVirtualDom) {\n      diffResult.push({\n        type: &apos;MODIFY_TEXT&apos;,\n        data: newVirtualDom,\n        index\n      })\n    }\n  }\n  // 如果新旧节点类型相同\n  else if (oldVirtualDom.tagName === newVirtualDom.tagName) {\n    // 比较属性是否相同\n    let diffAttributeResult = {}\n\n    for (let key in oldVirtualDom) {\n      if (oldVirtualDom[key] !== newVirtualDom[key]) {\n        diffAttributeResult[key] = newVirtualDom[key]\n      }\n    }\n\n    for (let key in newVirtualDom) {\n      // 旧节点不存在的新属性\n      if (!oldVirtualDom.hasOwnProperty(key)) {\n          diffAttributeResult[key] = newVirtualDom[key]\n      }\n    }\n\n    if (Object.keys(diffAttributeResult).length > 0) {\n        diffResult.push({ \n          type: &apos;MODIFY_ATTRIBUTES&apos;, \n          diffAttributeResult \n        })\n    }\n    \n    // 如果有子节点，遍历子节点\n    oldVirtualDom.children.forEach((child, index) => {\n      walkToDiff(child, newVirtualDom.children[index], ++initialIndex, patches)\n    })\n  }\n  // else 说明节点类型不同，被直接替换了，我们直接将新的结果 push\n  else {\n    diffResult.push({ \n      type: &apos;REPLACE&apos;, \n      newVirtualDom\n    })\n  }\n\n  if (!oldVirtualDom) {\n    diffResult.push({ \n      type: &apos;REPLACE&apos;, \n      newVirtualDom\n    })\n  }\n\n  if (diffResult.length) {\n    patches[index] = diffResult\n  }\n}\n```\n\n我们对 diff 进行测试：\n\n```\nconst chapterListVirtualDom = element(&apos;ul&apos;, { id: &apos;list&apos; }, [\n  element(&apos;li&apos;, { class: &apos;chapter&apos; }, [&apos;chapter1&apos;]),\n  element(&apos;li&apos;, { class: &apos;chapter&apos; }, [&apos;chapter2&apos;]),\n  element(&apos;li&apos;, { class: &apos;chapter&apos; }, [&apos;chapter3&apos;])\n])\n\nconst chapterListVirtualDom1 = element(&apos;ul&apos;, { id: &apos;list2&apos; }, [\n  element(&apos;li&apos;, { class: &apos;chapter2&apos; }, [&apos;chapter4&apos;]),\n  element(&apos;li&apos;, { class: &apos;chapter2&apos; }, [&apos;chapter5&apos;]),\n  element(&apos;li&apos;, { class: &apos;chapter2&apos; }, [&apos;chapter6&apos;])\n])\n\ndiff(chapterListVirtualDom, chapterListVirtualDom1)\n```\n\n得到如图 diff 数组：\n\n<img src=\"https://images.gitbook.cn/6f1e0b70-925b-11e9-a0f8-2d0a45937cae\" width = \"80%\" />\n\n#### 最小化差异应用\n\n大功告成之前，我们来看看都做了哪些事情：通过 Element class 生成了虚拟 DOM，通过 diff 方法对任意两个虚拟 DOM 进行比对，得到差异。那么这个差异如何更新到现有的 DOM 节点中呢？看上去需要一个 patch 方法来完成：\n\n```\nconst patch = (node, patches) => {\n  let walker = { index: 0 }\n  walk(node, walker, patches)\n}\n```\n\npatch 方法接受一个真实的 DOM 节点，它是现有的浏览器中需要进行更新的 DOM 节点，同时接受一个最小化差异集合，该集合对接 diff 方法返回的结果。在 patch 方法内部，我们调用了 walk 函数：\n\n```\nconst walk = (node, walker, patches) => {\n  let currentPatch = patches[walker.index]\n\n  let childNodes = node.childNodes\n\n  childNodes.forEach(child => {\n    walker.index++\n    walk(child, walker, patches)\n  })\n\n  if (currentPatch) {\n    doPatch(node, currentPatch)\n  }\n}\n```\n\nwalk 进行自身递归，对于当前节点的差异调用 doPatch 方法进行更新：\n\n```\nconst doPatch = (node, patches) => {\n  patches.forEach(patch => {\n    switch (patch.type) {\n      case &apos;MODIFY_ATTRIBUTES&apos;:\n        const attributes = patch.diffAttributeResult.attributes\n        for (let key in attributes) {\n            if (node.nodeType !== 1) return\n            const value = attributes[key]\n            if (value) {\n              setAttribute(node, key, value)\n            } else {\n              node.removeAttribute(key)\n            }\n        }\n        break\n      case &apos;MODIFY_TEXT&apos;:\n        node.textContent = patch.data\n        break\n      case &apos;REPLACE&apos;:\n        let newNode = (patch.newNode instanceof Element) ? render(patch.newNode) : document.createTextNode(patch.newNode)\n        node.parentNode.replaceChild(newNode, node)\n        break\n      case &apos;REMOVE&apos;:\n        node.parentNode.removeChild(node)\n        break\n      default:\n        break\n    }\n  })\n}\n```\n\ndoPatch 对四种类型的 diff 进行处理，最终进行测试：\n\n```\nvar element = chapterListVirtualDom.render()\nrenderDom(element, document.body)\n\nconst patches = diff(chapterListVirtualDom, chapterListVirtualDom1)\n\npatch(element, patches)\n```\n\n全部代码放在一起：\n\n```\nconst setAttribute = (node, key, value) => {\n  switch (key) {\n    case &apos;style&apos;:\n      node.style.cssText = value\n      break\n    case &apos;value&apos;:\n      let tagName = node.tagName || &apos;&apos;\n      tagName = tagName.toLowerCase()\n      if (\n        tagName === &apos;input&apos; || tagName === &apos;textarea&apos;\n      ) {\n        node.value = value\n      } else {\n        // 如果节点不是 input 或者 textarea, 则使用 setAttribute 去设置属性\n        node.setAttribute(key, value)\n      }\n      break\n    default:\n      node.setAttribute(key, value)\n      break\n  }\n}\n\nclass Element {\n  constructor(tagName, attributes = {}, children = []) {\n    this.tagName = tagName\n    this.attributes = attributes\n    this.children = children\n  }\n\n  render () {\n    let element = document.createElement(this.tagName)\n    let attributes = this.attributes\n\n     for (let key in attributes) {\n        setAttribute(element, key, attributes[key])\n     }\n\n    let children = this.children\n\n    children.forEach(child => {\n      let childElement = child instanceof Element\n        ? child.render() // 若 child 也是虚拟节点，递归进行\n        : document.createTextNode(child)  // 若是字符串，直接创建文本节点\n      element.appendChild(childElement)\n    })\n\n    return element\n  }\n}\n\nfunction element (tagName, attributes, children) {\n  return new Element(tagName, attributes, children)\n}\n\nconst renderDom = (element, target) => {\n  target.appendChild(element)\n}\n\nconst diff = (oldVirtualDom, newVirtualDom) => {\n  let patches = {}\n\n  // 递归树 比较后的结果放到 patches\n  walkToDiff(oldVirtualDom, newVirtualDom, 0, patches)\n\n  return patches\n}\n\nlet initialIndex = 0\n\nconst walkToDiff = (oldVirtualDom, newVirtualDom, index, patches) => {\n  let diffResult = []\n\n  // 如果 newVirtualDom 不存在，说明该节点被移除，我们将 type 为 REMOVE 的对象推进 diffResult 变量，并记录 index\n  if (!newVirtualDom) {\n    diffResult.push({\n      type: &apos;REMOVE&apos;,\n      index\n    })\n  }\n  // 如果新旧节点都是文本节点，是字符串\n  else if (typeof oldVirtualDom === &apos;string&apos; && typeof newVirtualDom === &apos;string&apos;) {\n    // 比较文本是否相同，如果不同则记录新的结果\n    if (oldVirtualDom !== newVirtualDom) {\n      diffResult.push({\n        type: &apos;MODIFY_TEXT&apos;,\n        data: newVirtualDom,\n        index\n      })\n    }\n  }\n  // 如果新旧节点类型相同\n  else if (oldVirtualDom.tagName === newVirtualDom.tagName) {\n    // 比较属性是否相同\n    let diffAttributeResult = {}\n\n    for (let key in oldVirtualDom) {\n      if (oldVirtualDom[key] !== newVirtualDom[key]) {\n        diffAttributeResult[key] = newVirtualDom[key]\n      }\n    }\n\n    for (let key in newVirtualDom) {\n      // 旧节点不存在的新属性\n      if (!oldVirtualDom.hasOwnProperty(key)) {\n          diffAttributeResult[key] = newVirtualDom[key]\n      }\n    }\n\n    if (Object.keys(diffAttributeResult).length > 0) {\n        diffResult.push({ \n          type: &apos;MODIFY_ATTRIBUTES&apos;, \n          diffAttributeResult \n        })\n    }\n    \n    // 如果有子节点，遍历子节点\n    oldVirtualDom.children.forEach((child, index) => {\n      walkToDiff(child, newVirtualDom.children[index], ++initialIndex, patches)\n    })\n  }\n  // else 说明节点类型不同，被直接替换了，我们直接将新的结果 push\n  else {\n    diffResult.push({ \n      type: &apos;REPLACE&apos;, \n      newVirtualDom\n    })\n  }\n\n  if (!oldVirtualDom) {\n    diffResult.push({ \n      type: &apos;REPLACE&apos;, \n      newVirtualDom\n    })\n  }\n\n  if (diffResult.length) {\n    patches[index] = diffResult\n  }\n}\n\nconst chapterListVirtualDom = element(&apos;ul&apos;, { id: &apos;list&apos; }, [\n  element(&apos;li&apos;, { class: &apos;chapter&apos; }, [&apos;chapter1&apos;]),\n  element(&apos;li&apos;, { class: &apos;chapter&apos; }, [&apos;chapter2&apos;]),\n  element(&apos;li&apos;, { class: &apos;chapter&apos; }, [&apos;chapter3&apos;])\n])\n\nconst chapterListVirtualDom1 = element(&apos;ul&apos;, { id: &apos;list2&apos; }, [\n  element(&apos;li&apos;, { class: &apos;chapter2&apos; }, [&apos;chapter4&apos;]),\n  element(&apos;li&apos;, { class: &apos;chapter2&apos; }, [&apos;chapter5&apos;]),\n  element(&apos;li&apos;, { class: &apos;chapter2&apos; }, [&apos;chapter6&apos;])\n])\n\nconst patch = (node, patches) => {\n  let walker = { index: 0 }\n  walk(node, walker, patches)\n}\n\nconst walk = (node, walker, patches) => {\n  let currentPatch = patches[walker.index]\n\n  let childNodes = node.childNodes\n\n  childNodes.forEach(child => {\n    walker.index++\n    walk(child, walker, patches)\n  })\n\n  if (currentPatch) {\n    doPatch(node, currentPatch)\n  }\n}\n\nconst doPatch = (node, patches) => {\n  patches.forEach(patch => {\n    switch (patch.type) {\n      case &apos;MODIFY_ATTRIBUTES&apos;:\n        const attributes = patch.diffAttributeResult.attributes\n        for (let key in attributes) {\n            if (node.nodeType !== 1) return\n            const value = attributes[key]\n            if (value) {\n              setAttribute(node, key, value)\n            } else {\n              node.removeAttribute(key)\n            }\n        }\n        break\n      case &apos;MODIFY_TEXT&apos;:\n        node.textContent = patch.data\n        break\n      case &apos;REPLACE&apos;:\n        let newNode = (patch.newNode instanceof Element) ? render(patch.newNode) : document.createTextNode(patch.newNode)\n        node.parentNode.replaceChild(newNode, node)\n        break\n      case &apos;REMOVE&apos;:\n        node.parentNode.removeChild(node)\n        break\n      default:\n        break\n    }\n  })\n}\n```\n\n先执行：\n\n```\nvar element = chapterListVirtualDom.render()\nrenderDom(element, document.body)\n```\n\n再执行：\n\n```\nconst patches = diff(chapterListVirtualDom, chapterListVirtualDom1)\n\npatch(element, patches)\n```\n\n生成结果符合预期。\n\n短短不到两百行代码，就实现了虚拟 DOM 思想的全部流程。当然其中还有一些优化手段，一些边界情况并没有进行特别处理，但是我们去翻看一些著名的虚拟 DOM 库：snabbdom、etch 等，其实现思想和上述教例完全一致。\n\n### <font color=13aa6c>总结</font>\n\n现代框架无疑极大程度上解放了前端生产力，其设计思想相互借鉴，存在非常多的共性。本讲我们通过分析前端框架中的共性，梳理概念原理，希望达到“任何一种框架变得不再神秘”的目的。掌握了这些基本思想，我们不仅能触类旁通，更快地上手框架，更能学习进阶，吸取优秀框架的精华。\n\n### <font color=13aa6c>分享交流</font>\n\n阅读文章过程中有任何疑问可随时跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。**你的分享不仅帮助他人，更会提升自己。**\n\n你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。\n\n>**为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。**","pdfUrl":"","reader":"","duration":"","title":"触类旁通多种框架","column":"5c91c813968b1d64b1e08fde","isNotification":false,"htmlContent":"<p>框架在任何一种语言编程范畴中都扮演了举足轻重的地位，前端尤是如此。目前流行的前端框架三驾马车：Angular、React 和 Vue，它们各有特点和受众，都值得开发者认真思考和学习。那么我们在精力有限的情况下，如何做到“触类旁通”、如何提取框架共性、提高学习和应用效率呢？</p>\n<p>我们这一讲就来剖析这些框架的特点和本质，介绍如何学习并使用这些框架，进而了解前端框架的真谛。</p>\n<p>相关知识点如下：</p>\n<img src=\"https://images.gitbook.cn/ff71bef0-9234-11e9-b195-bf69c03485a0\" width=500>\n<p>我把现代框架的关键词进行提炼，掌握这些关键词，是我们学习的重要环节。这些关键词有：双向绑定、依赖收集、发布订阅模式、MVVM / MVC、虚拟 DOM、虚拟 DOM diff、模版编译等。</p>\n<h3><a id=\"font_color13aa6cfont_10\"></a><font color=13aa6c>响应式框架基本原理</font></h3>\n<p>我们不再赘述响应式或数据双向绑定的基本概念，这里直接思考其行为：直观上，数据在变化时，不再需要开发者去手动更新视图，而视图会根据变化的数据“自动”进行更新。想完成这个过程，我们需要：</p>\n<ul>\n<li>收集视图依赖了哪些数据</li>\n<li>感知被依赖数据的变化</li>\n<li>数据变化时，自动“通知”需要更新的视图部分，并进行更新</li>\n</ul>\n<p>道理很简单，这个思考过程换成对应的技术概念就是：</p>\n<ul>\n<li>依赖收集</li>\n<li>数据劫持 / 数据代理</li>\n<li>发布订阅模式</li>\n</ul>\n<p>接下来，我们一步步拆解。</p>\n<h4><a id=\"_26\"></a>数据劫持与代理</h4>\n<p>感知数据变化的方法很直接，就是进行数据劫持或数据代理。我们往往通过 Object.defineProperty 实现。这个方法可以定义数据的 getter 和 setter，具体用法不再赘述。下面来看一个场景：</p>\n<pre><code class=\"lang-\">let data = {\n  stage: &apos;GitChat&apos;,\n  course: {\n    title: &apos;前端开发进阶&apos;,\n    author: &apos;Lucas&apos;,\n    publishTime: &apos;2018 年 5 月&apos;\n  }\n}\n\nObject.keys(data).forEach(key =&gt; {\n  let currentValue = data[key]\n\n  Object.defineProperty(data, key, {\n    enumerable: true,\n    configurable: false,\n    get() {\n      console.log(`getting ${key} value now, getting value is:`, currentValue)\n      return currentValue\n    },\n    set(newValue) {\n      currentValue = newValue\n      console.log(`setting ${key} value now, setting value is`, currentValue)\n    }\n  })\n}) \n</code></pre>\n<p>这段代码对 data 数据的 getter 和 setter 进行定义拦截，当我们读取或者改变 data 的值时：</p>\n<pre><code class=\"lang-\">data.course\n\n// getting course value now, getting value is: {title: &quot;前端开发进阶&quot;, author: &quot;Lucas&quot;, publishTime: &quot;2018 年 5 月&quot;}\n</code></pre>\n<pre><code class=\"lang-\">data.course = &apos;前端开发进阶2&apos;\n// setting course value now, setting value is 前端开发进阶2\n</code></pre>\n<p>但是这种实现有一个问题，例如：</p>\n<pre><code class=\"lang-\">data.course.title = &apos;前端开发进阶2&apos;\n\n// getting course value now, getting value is: {title: &quot;前端开发进阶&quot;, author: &quot;Lucas&quot;, publishTime: &quot;2018 年 5 月&quot;}\n</code></pre>\n<p>只会有 getting course value now, getting value is: {title: “前端开发进阶”, author: “Lucas”, publishTime: “2018 年 5 月”} 的输出，这是因为我们尝试读取了 data.course 信息。但是修改 data.course.title 的信息并没有打印出来。</p>\n<p>出现这个问题的原因是因为我们的实现代码只进行了一层 Object.defineProperty，或者说只对 data 的第一层属性进行了 Object.defineProperty，对于嵌套的引用类型数据结构：data.course，我们同样应该进行拦截。</p>\n<p>为了达到深层拦截的目的，将 Object.defineProperty 的逻辑抽象为 observe 函数，并改用递归实现：</p>\n<pre><code class=\"lang-\">let data = {\n  stage: &apos;GitChat&apos;,\n  course: {\n    title: &apos;前端开发进阶&apos;,\n    author: &apos;Lucas&apos;,\n    publishTime: &apos;2018 年 5 月&apos;\n  }\n}\n\nconst observe = data =&gt; {\n  if (!data || typeof data !== &apos;object&apos;) {\n      return\n  }\n  Object.keys(data).forEach(key =&gt; {\n    let currentValue = data[key]\n\n    observe(currentValue)\n\n    Object.defineProperty(data, key, {\n      enumerable: true,\n      configurable: false,\n      get() {\n        console.log(`getting ${key} value now, getting value is:`, currentValue)\n        return currentValue\n      },\n      set(newValue) {\n        currentValue = newValue\n        console.log(`setting ${key} value now, setting value is`, currentValue)\n      }\n    })\n  }) \n}\n\nobserve(data)\n</code></pre>\n<p>这样一来，就实现了深层数据拦截：</p>\n<pre><code class=\"lang-\">data.course.title = &apos;前端开发进阶2&apos;\n\n// getting course value now, getting value is: {// ...}\n// setting title value now, setting value is 前端开发进阶2\n</code></pre>\n<p>请注意，我们在 set 代理中，并没有对 newValue 再次递归进行 observe(newValue)。也就是说，如果赋值是一个引用类型：</p>\n<pre><code class=\"lang-\">data.course.title = {\n\ttitle: &apos;前端开发进阶2&apos;\n}\n</code></pre>\n<p>无法实现对 data.course.title 数据的观察。这里为了简化学习成本，默认修改的数值符合语义，都是基本类型。</p>\n<p>在尝试对 data.course.title 赋值时，首先会读取 data.course，因此输出：getting course value now, getting value is: {// …}，赋值后，触发 data.course.title 的 setter，输出：setting title value now, setting value is 前端开发进阶2。</p>\n<p>因此我们总结出：对数据进行拦截并不复杂，这也是很多框架实现的第一步。</p>\n<h4><a id=\"_145\"></a>监听数组变化</h4>\n<p>如果上述数据中某一项变为数组：</p>\n<pre><code class=\"lang-\">let data = {\n  stage: &apos;GitChat&apos;,\n  course: {\n    title: &apos;前端开发进阶&apos;,\n    author: [&apos;Lucas&apos;, &apos;Ronaldo&apos;],\n    publishTime: &apos;2018 年 5 月&apos;\n  }\n}\n\nconst observe = data =&gt; {\n  if (!data || typeof data !== &apos;object&apos;) {\n      return\n  }\n  Object.keys(data).forEach(key =&gt; {\n    let currentValue = data[key]\n\n    observe(currentValue)\n\n    Object.defineProperty(data, key, {\n      enumerable: true,\n      configurable: false,\n      get() {\n        console.log(`getting ${key} value now, getting value is:`, currentValue)\n        return currentValue\n      },\n      set(newValue) {\n        currentValue = newValue\n        console.log(`setting ${key} value now, setting value is`, currentValue)\n      }\n    })\n  }) \n}\n\nobserve(data)\n\n\ndata.course.author.push(&apos;Messi&apos;)\n// getting course value now, getting value is: {//...}\n// getting author value now, getting value is: (2) [(...), (...)]\n</code></pre>\n<p>我们只监听到了 data.course 以及 data.course.author 的读取，而数组 push 行为并没有被拦截。这是因为 Array.prototype 上挂载的方法并不能触发 data.course.author 属性值的 setter，由于这并不属于做赋值操作，而是 push API 调用操作。然而对于框架实现来说，这显然是不满足要求的，当数组变化时我们应该也有所感知。</p>\n<p>Vue 同样存在这样的问题，它的解决方法是：将数组的常用方法进行重写，进而覆盖掉原生的数组方法，重写之后的数组方法需要能够被拦截。</p>\n<p>实现逻辑如下：</p>\n<pre><code class=\"lang-\">const arrExtend = Object.create(Array.prototype)\nconst arrMethods = [\n  &apos;push&apos;,\n  &apos;pop&apos;,\n  &apos;shift&apos;,\n  &apos;unshift&apos;,\n  &apos;splice&apos;,\n  &apos;sort&apos;,\n  &apos;reverse&apos;\n]\n\narrMethods.forEach(method =&gt; {\n  const oldMethod = Array.prototype[method]\n  const newMethod = function(...args) {\n    oldMethod.apply(this, args)\n    console.log(`${method} 方法被执行了`)\n  }\n  arrExtend[method] = newMethod\n})\n</code></pre>\n<p>对于数组原生的 7 个方法：</p>\n<ul>\n<li>push</li>\n<li>pop</li>\n<li>shift</li>\n<li>unshift</li>\n<li>splice</li>\n<li>sort</li>\n<li>reverse</li>\n</ul>\n<p>进行重写，核心操作还是调用原生方法：oldMethod.apply(this, args)，除此之外可以在调用 oldMethod.apply(this, args) 前后加入我们需要的任何逻辑。示例代码中加入了一行 console.log。使用时：</p>\n<pre><code class=\"lang-\">Array.prototype = Object.assign(Array.prototype, arrExtend)\n\nlet array = [1, 2, 3]\narray.push(4)\n// push 方法被执行了\n</code></pre>\n<p>对应我们的代码：</p>\n<pre><code class=\"lang-\">const arrExtend = Object.create(Array.prototype)\nconst arrMethods = [\n  &apos;push&apos;,\n  &apos;pop&apos;,\n  &apos;shift&apos;,\n  &apos;unshift&apos;,\n  &apos;splice&apos;,\n  &apos;sort&apos;,\n  &apos;reverse&apos;\n]\n\narrMethods.forEach(method =&gt; {\n  const oldMethod = Array.prototype[method]\n  const newMethod = function(...args) {\n    oldMethod.apply(this, args)\n    console.log(`${method} 方法被执行了`)\n  }\n  arrExtend[method] = newMethod\n})\n\nArray.prototype = Object.assign(Array.prototype, arrExtend)\n\n\nlet data = {\n  stage: &apos;GitChat&apos;,\n  course: {\n    title: &apos;前端开发进阶&apos;,\n    author: [&apos;Lucas&apos;, &apos;Ronaldo&apos;],\n    publishTime: &apos;2018 年 5 月&apos;\n  }\n}\n\nconst observe = data =&gt; {\n  if (!data || typeof data !== &apos;object&apos;) {\n      return\n  }\n  Object.keys(data).forEach(key =&gt; {\n    let currentValue = data[key]\n\n    observe(currentValue)\n\n    Object.defineProperty(data, key, {\n      enumerable: true,\n      configurable: false,\n      get() {\n        console.log(`getting ${key} value now, getting value is:`, currentValue)\n        return currentValue\n      },\n      set(newValue) {\n        currentValue = newValue\n        console.log(`setting ${key} value now, setting value is`, currentValue)\n      }\n    })\n  }) \n}\n\nobserve(data)\n\ndata.course.author.push(&apos;Messi&apos;)\n</code></pre>\n<p>将会输出：</p>\n<pre><code class=\"lang-\">getting course value now, getting value is: {//...}\ngetting author value now, getting value is: (2) [(...), (...)]\n// push 方法被执行了\n</code></pre>\n<p>这种 monkey patch 本质是重写原生方法，这天生不是很安全，也很不优雅，能有更好的实现吗？</p>\n<p>答案是有的，使用 ES Next 的新特性——Proxy，之前也介绍过，它可以完成对数据的代理。</p>\n<p>那么这两种方式有何区别呢？请继续阅读。</p>\n<h4><a id=\"ObjectdefineProperty_VS_Proxy_317\"></a>Object.defineProperty VS Proxy</h4>\n<p>我们首先尝试使用 Proxy 来完成代码重构：</p>\n<pre><code class=\"lang-\">let data = {\n  stage: &apos;GitChat&apos;,\n  course: {\n    title: &apos;前端开发进阶&apos;,\n    author: [&apos;Lucas&apos;],\n    publishTime: &apos;2018 年 5 月&apos;\n  }\n}\n\nconst observe = data =&gt; {\n  if (!data || Object.prototype.toString.call(data) !== &apos;[object Object]&apos;) {\n      return\n  }\n\n  Object.keys(data).forEach(key =&gt; {\n    let currentValue = data[key]\n    // 事实上 proxy 也可以对函数类型进行代理。这里只对承载数据类型的 object 进行处理，读者了解即可。\n    if (typeof currentValue === &apos;object&apos;) {\n      observe(currentValue)\n      data[key] = new Proxy(currentValue, {\n        set(target, property, value, receiver) {\n          // 因为数组的 push 会引起 length 属性的变化，所以 push 之后会触发两次 set 操作，我们只需要保留一次即可，property 为 length 时，忽略\n          if (property !== &apos;length&apos;) {\n            console.log(`setting ${key} value now, setting value is`, currentValue)\n          }\n          return Reflect.set(target, property, value, receiver)\n        }\n      })\n    }\n    else {\n      Object.defineProperty(data, key, {\n        enumerable: true,\n        configurable: false,\n        get() {\n          console.log(`getting ${key} value now, getting value is:`, currentValue)\n          return currentValue\n        },\n        set(newValue) {\n          currentValue = newValue\n          console.log(`setting ${key} value now, setting value is`, currentValue)\n        }\n      })\n    }\n  }) \n}\n\nobserve(data)\n</code></pre>\n<p>此时对数组进行操作：</p>\n<pre><code class=\"lang-\">data.course.author.push(&apos;messi&apos;)\n// setting author value now, setting value is [&quot;Lucas&quot;]\n</code></pre>\n<p>已经符合我们的需求了。注意这里在使用 Proxy 进行代理时，并没有对 getter 进行代理，因此上述代码的输出结果并不像之前使用 Object.defineProperty 那样也会有 getting value 输出。</p>\n<p>整体实现并不难理解，需要读者了解最基本的 Proxy 知识。简单总结一下，对于数据键值为基本类型的情况，我们使用 Object.defineProperty；对于键值为对象类型的情况，继续递归调用 observe 方法，并通过 Proxy 返回的新对象对 data[key] 重新赋值，这个新值的 getter 和 setter 已经被添加了代理。</p>\n<p>了解了 Proxy 实现之后，我们对 Proxy 实现数据代理和 Object.defineProperty 实现数据拦截进行对比，会发现：</p>\n<ul>\n<li>Object.defineProperty 不能监听数组的变化，需要进行数组方法的重写</li>\n<li>Object.defineProperty 必须遍历对象的每个属性，且对于嵌套结构需要深层遍历</li>\n<li>Proxy 的代理是针对整个对象的，而不是对象的某个属性，因此不同于 Object.defineProperty 的必须遍历对象每个属性，Proxy 只需要做一层代理就可以监听同级结构下的所有属性变化，当然对于深层结构，递归还是需要进行的</li>\n<li>Proxy 支持代理数组的变化</li>\n<li>Proxy 的第二个参数除了 set 和 get 以外，可以有 13 种拦截方法，比起 Object.defineProperty() 更加强大，这里不再一一列举</li>\n<li>Proxy 性能将会被底层持续优化，而 Object.defineProperty 已经不再是优化重点</li>\n</ul>\n<h3><a id=\"font_color13aa6cfont_391\"></a><font color=13aa6c>模版编译原理介绍</font></h3>\n<p>到此，我们了解了如何监听数据的变化，那么下一步呢？以类 Vue 框架为例，我们看看一个典型的用法：</p>\n<pre><code class=\"lang-\">&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;h1&gt;{{stage}} 平台课程：{{course.title}}&lt;/h1&gt;\n    &lt;p&gt;{{course.title}} 是 {{course.author}} 发布的课程&lt;/p&gt;\n    &lt;p&gt;发布时间为 {{course.publishTime}} &lt;/p&gt;\n  &lt;/div&gt;\n  \n  &lt;script&gt;\n    let vue = new Vue({ \n      ele: &apos;#app&apos;, \n      data: {\n        stage: &apos;GitChat&apos;,\n        course: {\n          title: &apos;前端开发进阶&apos;,\n          author: &apos;Lucas&apos;,\n          publishTime: &apos;2018 年 5 月&apos;\n        },\n      }\n    })\n  &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<p>其中模版变量使用了 {{}} 的表达方式输出模版变量。最终输出的 HTML 内容应该被合适的数据进行填充替换，因此还需要一步编译过程，该过程任何框架或类库中都是相通的，比如 React 中的 JSX，也是编译为 React.createElement，并在生成虚拟 DOM 时进行数据填充。</p>\n<p>我们这里简化过程，将模版内容：</p>\n<pre><code class=\"lang-\">&lt;div id=&quot;app&quot;&gt;\n\t&lt;h1&gt;{{stage}} 平台课程：{{course.title}}&lt;/h1&gt;\n\t&lt;p&gt;{{course.title}} 是 {{course.author}} 发布的课程&lt;/p&gt;\n\t&lt;p&gt;发布时间为 {{course.publishTime}} &lt;/p&gt;\n&lt;/div&gt;\n</code></pre>\n<p>输出为真实 HTML 即可。</p>\n<h4><a id=\"_433\"></a>模版编译实现</h4>\n<p>一提到这样的“模版编译”过程，很多开发者都会想到词法分析，也许都会感到头大。其实原理很简单，就是使用正则 + 遍历，有时也需要一些算法知识，我们来看现在的场景，只需要对 #app 节点下内容进行替换，通过正则识别出模版变量，获取对应的数据即可：</p>\n<pre><code class=\"lang-\">compile(document.querySelector(&apos;#app&apos;), data)\n\nfunction compile(el, data) {\n  let fragment = document.createDocumentFragment()\n\n  while (child = el.firstChild) {\n    fragment.appendChild(child)\n  }\n\n  // 对 el 里面的内容进行替换\n  function replace(fragment) {\n    Array.from(fragment.childNodes).forEach(node =&gt; {\n      let textContent = node.textContent\n      let reg = /\\{\\{(.*?)\\}\\}/g\n\n      if (node.nodeType === 3 &amp;&amp; reg.test(textContent)) {\n\t\t const nodeTextContent = node.textContent\n        const replaceText = () =&gt; {\n        \tnode.textContent = nodeTextContent.replace(reg, (matched, placeholder) =&gt; {\n        \t\treturn placeholder.split(&apos;.&apos;).reduce((prev, key) =&gt; {\n        \t\t\treturn prev[key]\n        \t\t}, data)\n        \t\n        \t})\n        }\n        \n        replaceText()\n      }\n\n      // 如果还有子节点，继续递归 replace\n      if (node.childNodes &amp;&amp; node.childNodes.length) {\n        replace(node)\n      }\n    })\n  }\n\n  replace(fragment)\n\n  el.appendChild(fragment)\n  return el\n}\n</code></pre>\n<p>代码分析：我们使用 fragment 变量储存生成的真实 HTML 节点内容。通过 replace 方法对 {{变量}} 进行数据替换，同时 {{变量}} 的表达只会出现在 nodeType === 3 的文本类型节点中，因此对于符合 <code>node.nodeType === 3 &amp;&amp; reg.test(textContent)</code> 条件的情况，进行数据获取和填充。我们借助字符串 replace 方法第二个参数进行一次性替换，此时对于形如 {{data.course.title}} 的深层数据，通过 reduce 方法，获得正确的值。</p>\n<p>因为 DOM 结构可能是多层的，所以对存在子节点的节点，依然使用递归进行 replace 替换。</p>\n<p>这个编译过程比较简单，没有考虑到边界情况，只是单纯完成模版变量到真实 DOM 的转换，读者只需体会简单道理即可。</p>\n<h4><a id=\"_487\"></a>双向绑定实现</h4>\n<p>上述实现是单向的，数据变化引起了视图变化，那么如果页面中存在一个输入框，如何触发数据变化呢？比如：</p>\n<pre><code class=\"lang-\">&lt;input v-model=&quot;inputData&quot; type = &quot;text&quot; &gt;\n</code></pre>\n<p>我们需要在模版编译中，对于存在 v-model 属性的 node 进行事件监听，在输入框输入时，改变 v-model 属性值对应的数据即可（这里为 inputData），增加 compile 中的 replace 方法逻辑，对于 node.nodeType === 1 的 DOM 类型，伪代码如下：</p>\n<pre><code class=\"lang-\">function replace(el, data) {\n  // 省略...\n  if (node.nodeType === 1) {\n\n    let attributesArray = node.attributes\n\n    Array.from(attributesArray).forEach(attr =&gt; {\n      let attributeName = attr.name\n      let attributeValue = attr.value\n\n      if (name.includes(&apos;v-&apos;)) {\n        node.value = data[attributeValue]\n      }\n\n      node.addEventListener(&apos;input&apos;, e =&gt; {\n        let newVal = e.target.value\n        data[attributeValue] = newVal\n        // ...\n        // 更改数据源，触发 setter\n        // ...\n      })\n    })\n\n  }\n\n  if (node.childNodes &amp;&amp; node.childNodes.length) {\n    replace(node)\n  }\n}\n</code></pre>\n<h3><a id=\"font_color13aa6cfont_529\"></a><font color=13aa6c>发布订阅模式简单应用</font></h3>\n<p>作为前端开发人员，我们对于所谓的“事件驱动”理念——即“事件发布订阅模式（Pub/Sub 模式）”一定再熟悉不过了。这种模式在 JavaScript 里面有与生俱来的基因：我们可以认为 JavaScript 本身就是事件驱动型语言，比如，应用中对一个 button 进行了事件绑定，用户点击之后就会触发按钮上面的 click 事件。这是因为此时有特定程序正在监听这个事件，随之触发了相关的处理程序。</p>\n<p>这个模式的一个好处之一在于能够解耦，实现“高内聚、低耦合”的理念。这种模式对于我们框架的设计同样也不可或缺。请思考：通过前面内容的学习，我们了解了如何监听数据的变化。如果最终想实现响应式 MVVM，或所谓的双向绑定，那么还需要根据这个数据变化作出相应的视图更新。这个逻辑和我们在页面中对 button 绑定事件处理函数是多么相近。</p>\n<p>那么这样一个“熟悉的”模式应该怎么实现呢，又该如何在框架中具体应用呢？看代码：</p>\n<pre><code class=\"lang-\">class Notify {\n  constructor() {\n    this.subscribers = []\n  }\n  add(handler) {\n    this.subscribers.push(handler)\n  }\n  emit() {\n    this.subscribers.forEach(subscriber =&gt; subscriber())\n  }\n}\n</code></pre>\n<p>使用：</p>\n<pre><code class=\"lang-\">let notify = new Notify()\n\nnotify.add(() =&gt; {\n\tconsole.log(&apos;emit here&apos;)\n})\n\nnotify.emit()\n// emit here\n</code></pre>\n<p>这就是一个简单实现的“事件发布订阅模式”，当然代码只是启发思路，真实应用还比较“粗糙”，没有进行事件名设置，APIs 也并不丰富，但完全能够说明问题了。其实读者翻看 Vue 源码，也能了解 Vue 中的发布订阅模式很简单。</p>\n<h3><a id=\"font_color13aa6cMVVM_font_566\"></a><font color=13aa6c>MVVM 融会贯通</font></h3>\n<p>回顾一下前面的基本内容：数据拦截和代理、发布订阅模式、模版编译，那么如何根据这些概念实现一个 MVVM 框架呢？其实不管是 Vue 还是其他类库或框架，其解决思想都是建立在前文所述概念之上的。</p>\n<p>我们来进行串联，整个过程是：首先对数据进行深度拦截或代理，对每一个属性的 getter 和 setter 进行“加工”，该“加工”具体做些什么后面马上会有说明。在模版初次编译时，解析指令（如 v-model），并进行依赖收集（{{变量}}），订阅数据的变化。</p>\n<p>这里的依赖收集过程具体指：当调用 compiler 中的 replace 方法时，我们会读取数据进行模版变量的替换，这时候“读取数据时”需要做一个标记，用来表示“我依赖这一项数据”，因此我要订阅这个属性值的变化。Vue 中定义一个 Watcher 类来表示观察订阅依赖。这就实现了整套流程，换个思路再复述一遍：我们知道模版编译过程中会读取数据，进而触发数据源属性值的 getter，因此上面所说的数据代理的“加工”就是在数据监听的 getter 中记录这个依赖，同时在 setter 触发数据变化时，执行依赖对应的相关操作，最终触发模版中数据的变化。</p>\n<p>我们抽象成流程图来理解：</p>\n<p><img src=\"https://images.gitbook.cn/02926aa0-925b-11e9-a0f8-2d0a45937cae\" alt=\"enter image description here\" /></p>\n<p>这也是 Vue 框架（类库）的基本架构图。由此看出，Vue 的实现，或者大部分 MVVM 的实现，就是我们本节课程介绍的概念组合应用。</p>\n<p>关于框架的对比剖析，更多话题我们留在《第 4-7 课：从框架和类库，我们该学到什么》一课中介绍。</p>\n<h3><a id=\"font_color13aa6c_DOMfont_582\"></a><font color=13aa6c>揭秘虚拟 DOM</font></h3>\n<p>我们来看现代框架中另一个重头戏——虚拟 DOM。虚拟 DOM 这个概念其实并没有那么新，甚至在前端三大框架问世之前，虚拟 DOM 就已经存在了，只不过 React 创造性的应用了虚拟 DOM，为前端发展带来了变革。Vue 2.0 也很快跟进，使得虚拟 DOM 彻底成为现代框架的重要基因。简单来说，虚拟 DOM 就是用数据结构表示 DOM 结构，它并没有真实 append 到 DOM 上，因此称之为“虚拟”。</p>\n<p>应用虚拟 DOM 的收益也很直观：操作数据结构远比和浏览器交互去操作 DOM 快很多。请读者准确理解这句话：操作数据结构是指改变对象（虚拟 DOM），这个过程比修改真实 DOM 快很多。但虚拟 DOM 也最终是要挂载到浏览器上成为真实 DOM 节点，因此使用虚拟 DOM 并不能使得操作 DOM 的数量减少，但能够精确地获取最小的、最必要的操作 DOM 的集合。</p>\n<p>这样一来，我们抽象表示 DOM，每次通过 DOM diff 计算出视图前后更新的最小差异，再去把最小差异应用到真实 DOM 上的做法，无疑更为可靠，性能更有保障。</p>\n<p>那我们该如何表示虚拟 DOM 呢？又该如何产出虚拟 DOM 呢？</p>\n<p>直观上我们看这样一段 DOM 结构：</p>\n<pre><code class=\"lang-\">&lt;ul id=&quot;chapterList&quot;&gt;\n  &lt;li class=&quot;chapter&quot;&gt;chapter1&lt;/li&gt;\n  &lt;li class=&quot;chapter&quot;&gt;chapter2&lt;/li&gt;\n  &lt;li class=&quot;chapter&quot;&gt;chapter3&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<p>如果用 JavaScript 来表示，我们采用对象结构：</p>\n<pre><code class=\"lang-\">const chapterListVirtualDom = {\n  tagName: &apos;ul&apos;,\n  attributes: {\n    id: &apos;chapterList&apos;\n  },\n  children: [\n    { tagName: &apos;li&apos;, attributes: { class: &apos;chapter&apos; }, children: [&apos;chapter1&apos;] },\n    { tagName: &apos;li&apos;, attributes: { class: &apos;chapter&apos; }, children: [&apos;chapter2&apos;] },\n    { tagName: &apos;li&apos;, attributes: { class: &apos;chapter&apos; }, children: [&apos;chapter3&apos;] },\n  ]\n}\n</code></pre>\n<p>很好理解：tagName 表示虚拟 DOM 对应的真实 DOM 标签类型；attributes 是一个对象，表示真实 DOM 节点上所有的属性；children 对应真实 DOM 的 childNodes，其中 childNodes 每一项又是类似的结构。</p>\n<p>我们来实现一个虚拟 DOM 生成类，用于生产虚拟 DOM：</p>\n<pre><code class=\"lang-\">class Element {\n  constructor(tagName, attributes = {}, children = []) {\n    this.tagName = tagName\n    this.attributes = attributes\n    this.children = children\n  }\n}\n\nfunction element(tagName, attributes, children) {\n  return new Element(tagName, attributes, children)\n}\n</code></pre>\n<p>上述虚拟 DOM 就可以这样生成：</p>\n<pre><code class=\"lang-\">const chapterListVirtualDom = element(&apos;ul&apos;, { id: &apos;list&apos; }, [\n  element(&apos;li&apos;, { class: &apos;chapter&apos; }, [&apos;chapter1&apos;]),\n  element(&apos;li&apos;, { class: &apos;chapter&apos; }, [&apos;chapter2&apos;]),\n  element(&apos;li&apos;, { class: &apos;chapter&apos; }, [&apos;chapter3&apos;])\n])\n</code></pre>\n<p>如图：</p>\n<p><img src=\"https://images.gitbook.cn/23d3e7c0-925b-11e9-a0f8-2d0a45937cae\" alt=\"enter image description here\" /></p>\n<p>是不是很简单？我们继续完成虚拟 DOM 向真实 DOM 节点的生成。首先实现一个 setAttribute 方法，后续的代码都将使用 setAttribute 方法来对 DOM 节点进行属性设置。</p>\n<pre><code class=\"lang-\">const setAttribute = (node, key, value) =&gt; {\n  switch (key) {\n    case &apos;style&apos;:\n      node.style.cssText = value\n      break\n    case &apos;value&apos;:\n      let tagName = node.tagName || &apos;&apos;\n      tagName = tagName.toLowerCase()\n      if (\n        tagName === &apos;input&apos; || tagName === &apos;textarea&apos;\n      ) {\n        node.value = value\n      } else {\n        // 如果节点不是 input 或者 textarea, 则使用 setAttribute 去设置属性\n        node.setAttribute(key, value)\n      }\n      break\n    default:\n      node.setAttribute(key, value)\n      break\n  }\n}\n</code></pre>\n<p>Element 类中加入 render 原型方法，该方法的目的是根据虚拟 DOM 生成真实 DOM 片段：</p>\n<pre><code class=\"lang-\">class Element {\n  constructor(tagName, attributes = {}, children = []) {\n    this.tagName = tagName\n    this.attributes = attributes\n    this.children = children\n  }\n\n  render () {\n    let element = document.createElement(this.tagName)\n    let attributes = this.attributes\n\n\t for (let key in attributes) {\n\t    setAttribute(element, key, attributes[key])\n\t }\n\n    let children = this.children\n\n    children.forEach(child =&gt; {\n      let childElement = child instanceof Element\n        ? child.render() // 若 child 也是虚拟节点，递归进行\n        : document.createTextNode(child)  // 若是字符串，直接创建文本节点\n      element.appendChild(childElement)\n    })\n\n    return element\n  }\n}\n\nfunction element (tagName, attributes, children) {\n  return new Element(tagName, attributes, children)\n}\n</code></pre>\n<p>实现也不困难，我们借助工具方法：setAttribute 进行属性的创建；对 children 每一项类型进行判断，如果是 Element 实例，进行递归调用 child 的 render 方法；直到遇见文本节点类型，进行内容渲染。</p>\n<p>有了真实的 DOM 节点片段，我们趁热打铁，将真实的 DOM 节点渲染到浏览器上，实现 renderDOM 方法：</p>\n<pre><code class=\"lang-\">const renderDom = (element, target) =&gt; {\n  target.appendChild(element)\n}\n</code></pre>\n<p>执行代码：</p>\n<pre><code class=\"lang-\">const setAttribute = (node, key, value) =&gt; {\n  switch (key) {\n    case &apos;style&apos;:\n      node.style.cssText = value\n      break\n    case &apos;value&apos;:\n      let tagName = node.tagName || &apos;&apos;\n      tagName = tagName.toLowerCase()\n      if (\n        tagName === &apos;input&apos; || tagName === &apos;textarea&apos;\n      ) {\n        node.value = value\n      } else {\n        // 如果节点不是 input 或者 textarea，则使用 setAttribute 去设置属性\n        node.setAttribute(key, value)\n      }\n      break\n    default:\n      node.setAttribute(key, value)\n      break\n  }\n}\n\nclass Element {\n  constructor(tagName, attributes = {}, children = []) {\n    this.tagName = tagName\n    this.attributes = attributes\n    this.children = children\n  }\n\n  render () {\n    let element = document.createElement(this.tagName)\n    let attributes = this.attributes\n\n\t for (let key in attributes) {\n\t    setAttribute(element, key, attributes[key])\n\t }\n\n    let children = this.children\n\n    children.forEach(child =&gt; {\n      let childElement = child instanceof Element\n        ? child.render() // 若 child 也是虚拟节点，递归进行\n        : document.createTextNode(child)  // 若是字符串，直接创建文本节点\n      element.appendChild(childElement)\n    })\n\n    return element\n  }\n}\n\nfunction element (tagName, attributes, children) {\n  return new Element(tagName, attributes, children)\n}\n\nconst renderDom = (element, target) =&gt; {\n  target.appendChild(element)\n}\n\nconst chapterListVirtualDom = element(&apos;ul&apos;, { id: &apos;list&apos; }, [\n  element(&apos;li&apos;, { class: &apos;chapter&apos; }, [&apos;chapter1&apos;]),\n  element(&apos;li&apos;, { class: &apos;chapter&apos; }, [&apos;chapter2&apos;]),\n  element(&apos;li&apos;, { class: &apos;chapter&apos; }, [&apos;chapter3&apos;])\n])\n\nconst dom = chapterListVirtualDom.render()\n\nrenderDom(dom, document.body)\n</code></pre>\n<p>得到如图：</p>\n<p><img src=\"https://images.gitbook.cn/43b5d4e0-925b-11e9-a8e5-21b5567b38f4\" alt=\"enter image description here\" /></p>\n<h4><a id=\"_DOM_diff_800\"></a>虚拟 DOM diff</h4>\n<p>有了上述基础，我们可以产出一份虚拟 DOM，并渲染在浏览器中。当用户在特定操作后，会产出新的一份虚拟 DOM，如何得出前后两份虚拟 DOM 的差异，并交给浏览器需要更新的结果呢？这就涉及到 DOM diff 的过程。</p>\n<p>直观上，因为虚拟 DOM 是个树形结构，所以我们需要对两份虚拟 DOM 进行递归比较，将变化存储在一个变量 patches 中：</p>\n<pre><code class=\"lang-\">const diff = (oldVirtualDom, newVirtualDom) =&gt; {\n    let patches = {}\n\n    // 递归树，比较后的结果放到 patches\n    walkToDiff(oldVirtualDom, newVirtualDom, 0, patches)\n\n\t // 返回 diff 结果 \n    return patches\n}\n</code></pre>\n<p>walkToDiff 前两个参数是两个需要比较的虚拟 DOM 对象；第三个参数记录 nodeIndex，在删除节点时使用，初始为 0；第四个参数是一个闭包变量，记录 diff 结果：</p>\n<pre><code class=\"lang-\">let initialIndex = 0\n\nconst walkToDiff = (oldVirtualDom, newVirtualDom, index, patches) =&gt; {\n  let diffResult = []\n\n  // 如果 newVirtualDom 不存在，说明该节点被移除，我们将 type 为 REMOVE 的对象推进 diffResult 变量，并记录 index\n  if (!newVirtualDom) {\n    diffResult.push({\n      type: &apos;REMOVE&apos;,\n      index\n    })\n  }\n  // 如果新旧节点都是文本节点，是字符串\n  else if (typeof oldVirtualDom === &apos;string&apos; &amp;&amp; typeof newVirtualDom === &apos;string&apos;) {\n    // 比较文本是否相同，如果不同则记录新的结果\n    if (oldVirtualDom !== newVirtualDom) {\n      diffResult.push({\n        type: &apos;MODIFY_TEXT&apos;,\n        data: newVirtualDom,\n        index\n      })\n    }\n  }\n  // 如果新旧节点类型相同\n  else if (oldVirtualDom.tagName === newVirtualDom.tagName) {\n    // 比较属性是否相同\n    let diffAttributeResult = {}\n\n    for (let key in oldVirtualDom) {\n      if (oldVirtualDom[key] !== newVirtualDom[key]) {\n        diffAttributeResult[key] = newVirtualDom[key]\n      }\n    }\n\n    for (let key in newVirtualDom) {\n      // 旧节点不存在的新属性\n      if (!oldVirtualDom.hasOwnProperty(key)) {\n          diffAttributeResult[key] = newVirtualDom[key]\n      }\n    }\n\n    if (Object.keys(diffAttributeResult).length &gt; 0) {\n        diffResult.push({ \n          type: &apos;MODIFY_ATTRIBUTES&apos;, \n          diffAttributeResult \n        })\n    }\n    \n    // 如果有子节点，遍历子节点\n    oldVirtualDom.children.forEach((child, index) =&gt; {\n      walkToDiff(child, newVirtualDom.children[index], ++initialIndex, patches)\n    })\n  }\n  // else 说明节点类型不同，被直接替换了，我们直接将新的结果 push\n  else {\n    diffResult.push({ \n      type: &apos;REPLACE&apos;, \n      newVirtualDom\n    })\n  }\n\n  if (!oldVirtualDom) {\n    diffResult.push({ \n      type: &apos;REPLACE&apos;, \n      newVirtualDom\n    })\n  }\n\n  if (diffResult.length) {\n    patches[index] = diffResult\n  }\n}\n</code></pre>\n<p>我们最后将所有代码放在一起：</p>\n<pre><code class=\"lang-\">const setAttribute = (node, key, value) =&gt; {\n  switch (key) {\n    case &apos;style&apos;:\n      node.style.cssText = value\n      break\n    case &apos;value&apos;:\n      let tagName = node.tagName || &apos;&apos;\n      tagName = tagName.toLowerCase()\n      if (\n        tagName === &apos;input&apos; || tagName === &apos;textarea&apos;\n      ) {\n        node.value = value\n      } else {\n        // 如果节点不是 input 或者 textarea，则使用 setAttribute 去设置属性\n        node.setAttribute(key, value)\n      }\n      break\n    default:\n      node.setAttribute(key, value)\n      break\n  }\n}\n\nclass Element {\n  constructor(tagName, attributes = {}, children = []) {\n    this.tagName = tagName\n    this.attributes = attributes\n    this.children = children\n  }\n\n  render () {\n    let element = document.createElement(this.tagName)\n    let attributes = this.attributes\n\n\t for (let key in attributes) {\n\t    setAttribute(element, key, attributes[key])\n\t }\n\n    let children = this.children\n\n    children.forEach(child =&gt; {\n      let childElement = child instanceof Element\n        ? child.render() // 若 child 也是虚拟节点，递归进行\n        : document.createTextNode(child)  // 若是字符串，直接创建文本节点\n      element.appendChild(childElement)\n    })\n\n    return element\n  }\n}\n\nfunction element (tagName, attributes, children) {\n  return new Element(tagName, attributes, children)\n}\n\nconst renderDom = (element, target) =&gt; {\n  target.appendChild(element)\n}\n\nconst diff = (oldVirtualDom, newVirtualDom) =&gt; {\n  let patches = {}\n\n  // 递归树 比较后的结果放到 patches\n  walkToDiff(oldVirtualDom, newVirtualDom, 0, patches)\n\n  return patches\n}\n\nlet initialIndex = 0\n\nconst walkToDiff = (oldVirtualDom, newVirtualDom, index, patches) =&gt; {\n  let diffResult = []\n\n  // 如果 newVirtualDom 不存在，说明该节点被移除，我们将 type 为 REMOVE 的对象推进 diffResult 变量，并记录 index\n  if (!newVirtualDom) {\n    diffResult.push({\n      type: &apos;REMOVE&apos;,\n      index\n    })\n  }\n  // 如果新旧节点都是文本节点，是字符串\n  else if (typeof oldVirtualDom === &apos;string&apos; &amp;&amp; typeof newVirtualDom === &apos;string&apos;) {\n    // 比较文本是否相同，如果不同则记录新的结果\n    if (oldVirtualDom !== newVirtualDom) {\n      diffResult.push({\n        type: &apos;MODIFY_TEXT&apos;,\n        data: newVirtualDom,\n        index\n      })\n    }\n  }\n  // 如果新旧节点类型相同\n  else if (oldVirtualDom.tagName === newVirtualDom.tagName) {\n    // 比较属性是否相同\n    let diffAttributeResult = {}\n\n    for (let key in oldVirtualDom) {\n      if (oldVirtualDom[key] !== newVirtualDom[key]) {\n        diffAttributeResult[key] = newVirtualDom[key]\n      }\n    }\n\n    for (let key in newVirtualDom) {\n      // 旧节点不存在的新属性\n      if (!oldVirtualDom.hasOwnProperty(key)) {\n          diffAttributeResult[key] = newVirtualDom[key]\n      }\n    }\n\n    if (Object.keys(diffAttributeResult).length &gt; 0) {\n        diffResult.push({ \n          type: &apos;MODIFY_ATTRIBUTES&apos;, \n          diffAttributeResult \n        })\n    }\n    \n    // 如果有子节点，遍历子节点\n    oldVirtualDom.children.forEach((child, index) =&gt; {\n      walkToDiff(child, newVirtualDom.children[index], ++initialIndex, patches)\n    })\n  }\n  // else 说明节点类型不同，被直接替换了，我们直接将新的结果 push\n  else {\n    diffResult.push({ \n      type: &apos;REPLACE&apos;, \n      newVirtualDom\n    })\n  }\n\n  if (!oldVirtualDom) {\n    diffResult.push({ \n      type: &apos;REPLACE&apos;, \n      newVirtualDom\n    })\n  }\n\n  if (diffResult.length) {\n    patches[index] = diffResult\n  }\n}\n</code></pre>\n<p>我们对 diff 进行测试：</p>\n<pre><code class=\"lang-\">const chapterListVirtualDom = element(&apos;ul&apos;, { id: &apos;list&apos; }, [\n  element(&apos;li&apos;, { class: &apos;chapter&apos; }, [&apos;chapter1&apos;]),\n  element(&apos;li&apos;, { class: &apos;chapter&apos; }, [&apos;chapter2&apos;]),\n  element(&apos;li&apos;, { class: &apos;chapter&apos; }, [&apos;chapter3&apos;])\n])\n\nconst chapterListVirtualDom1 = element(&apos;ul&apos;, { id: &apos;list2&apos; }, [\n  element(&apos;li&apos;, { class: &apos;chapter2&apos; }, [&apos;chapter4&apos;]),\n  element(&apos;li&apos;, { class: &apos;chapter2&apos; }, [&apos;chapter5&apos;]),\n  element(&apos;li&apos;, { class: &apos;chapter2&apos; }, [&apos;chapter6&apos;])\n])\n\ndiff(chapterListVirtualDom, chapterListVirtualDom1)\n</code></pre>\n<p>得到如图 diff 数组：</p>\n<img src=\"https://images.gitbook.cn/6f1e0b70-925b-11e9-a0f8-2d0a45937cae\" width = \"80%\" />\n<h4><a id=\"_1062\"></a>最小化差异应用</h4>\n<p>大功告成之前，我们来看看都做了哪些事情：通过 Element class 生成了虚拟 DOM，通过 diff 方法对任意两个虚拟 DOM 进行比对，得到差异。那么这个差异如何更新到现有的 DOM 节点中呢？看上去需要一个 patch 方法来完成：</p>\n<pre><code class=\"lang-\">const patch = (node, patches) =&gt; {\n  let walker = { index: 0 }\n  walk(node, walker, patches)\n}\n</code></pre>\n<p>patch 方法接受一个真实的 DOM 节点，它是现有的浏览器中需要进行更新的 DOM 节点，同时接受一个最小化差异集合，该集合对接 diff 方法返回的结果。在 patch 方法内部，我们调用了 walk 函数：</p>\n<pre><code class=\"lang-\">const walk = (node, walker, patches) =&gt; {\n  let currentPatch = patches[walker.index]\n\n  let childNodes = node.childNodes\n\n  childNodes.forEach(child =&gt; {\n    walker.index++\n    walk(child, walker, patches)\n  })\n\n  if (currentPatch) {\n    doPatch(node, currentPatch)\n  }\n}\n</code></pre>\n<p>walk 进行自身递归，对于当前节点的差异调用 doPatch 方法进行更新：</p>\n<pre><code class=\"lang-\">const doPatch = (node, patches) =&gt; {\n  patches.forEach(patch =&gt; {\n    switch (patch.type) {\n      case &apos;MODIFY_ATTRIBUTES&apos;:\n        const attributes = patch.diffAttributeResult.attributes\n        for (let key in attributes) {\n            if (node.nodeType !== 1) return\n            const value = attributes[key]\n            if (value) {\n              setAttribute(node, key, value)\n            } else {\n              node.removeAttribute(key)\n            }\n        }\n        break\n      case &apos;MODIFY_TEXT&apos;:\n        node.textContent = patch.data\n        break\n      case &apos;REPLACE&apos;:\n        let newNode = (patch.newNode instanceof Element) ? render(patch.newNode) : document.createTextNode(patch.newNode)\n        node.parentNode.replaceChild(newNode, node)\n        break\n      case &apos;REMOVE&apos;:\n        node.parentNode.removeChild(node)\n        break\n      default:\n        break\n    }\n  })\n}\n</code></pre>\n<p>doPatch 对四种类型的 diff 进行处理，最终进行测试：</p>\n<pre><code class=\"lang-\">var element = chapterListVirtualDom.render()\nrenderDom(element, document.body)\n\nconst patches = diff(chapterListVirtualDom, chapterListVirtualDom1)\n\npatch(element, patches)\n</code></pre>\n<p>全部代码放在一起：</p>\n<pre><code class=\"lang-\">const setAttribute = (node, key, value) =&gt; {\n  switch (key) {\n    case &apos;style&apos;:\n      node.style.cssText = value\n      break\n    case &apos;value&apos;:\n      let tagName = node.tagName || &apos;&apos;\n      tagName = tagName.toLowerCase()\n      if (\n        tagName === &apos;input&apos; || tagName === &apos;textarea&apos;\n      ) {\n        node.value = value\n      } else {\n        // 如果节点不是 input 或者 textarea, 则使用 setAttribute 去设置属性\n        node.setAttribute(key, value)\n      }\n      break\n    default:\n      node.setAttribute(key, value)\n      break\n  }\n}\n\nclass Element {\n  constructor(tagName, attributes = {}, children = []) {\n    this.tagName = tagName\n    this.attributes = attributes\n    this.children = children\n  }\n\n  render () {\n    let element = document.createElement(this.tagName)\n    let attributes = this.attributes\n\n     for (let key in attributes) {\n        setAttribute(element, key, attributes[key])\n     }\n\n    let children = this.children\n\n    children.forEach(child =&gt; {\n      let childElement = child instanceof Element\n        ? child.render() // 若 child 也是虚拟节点，递归进行\n        : document.createTextNode(child)  // 若是字符串，直接创建文本节点\n      element.appendChild(childElement)\n    })\n\n    return element\n  }\n}\n\nfunction element (tagName, attributes, children) {\n  return new Element(tagName, attributes, children)\n}\n\nconst renderDom = (element, target) =&gt; {\n  target.appendChild(element)\n}\n\nconst diff = (oldVirtualDom, newVirtualDom) =&gt; {\n  let patches = {}\n\n  // 递归树 比较后的结果放到 patches\n  walkToDiff(oldVirtualDom, newVirtualDom, 0, patches)\n\n  return patches\n}\n\nlet initialIndex = 0\n\nconst walkToDiff = (oldVirtualDom, newVirtualDom, index, patches) =&gt; {\n  let diffResult = []\n\n  // 如果 newVirtualDom 不存在，说明该节点被移除，我们将 type 为 REMOVE 的对象推进 diffResult 变量，并记录 index\n  if (!newVirtualDom) {\n    diffResult.push({\n      type: &apos;REMOVE&apos;,\n      index\n    })\n  }\n  // 如果新旧节点都是文本节点，是字符串\n  else if (typeof oldVirtualDom === &apos;string&apos; &amp;&amp; typeof newVirtualDom === &apos;string&apos;) {\n    // 比较文本是否相同，如果不同则记录新的结果\n    if (oldVirtualDom !== newVirtualDom) {\n      diffResult.push({\n        type: &apos;MODIFY_TEXT&apos;,\n        data: newVirtualDom,\n        index\n      })\n    }\n  }\n  // 如果新旧节点类型相同\n  else if (oldVirtualDom.tagName === newVirtualDom.tagName) {\n    // 比较属性是否相同\n    let diffAttributeResult = {}\n\n    for (let key in oldVirtualDom) {\n      if (oldVirtualDom[key] !== newVirtualDom[key]) {\n        diffAttributeResult[key] = newVirtualDom[key]\n      }\n    }\n\n    for (let key in newVirtualDom) {\n      // 旧节点不存在的新属性\n      if (!oldVirtualDom.hasOwnProperty(key)) {\n          diffAttributeResult[key] = newVirtualDom[key]\n      }\n    }\n\n    if (Object.keys(diffAttributeResult).length &gt; 0) {\n        diffResult.push({ \n          type: &apos;MODIFY_ATTRIBUTES&apos;, \n          diffAttributeResult \n        })\n    }\n    \n    // 如果有子节点，遍历子节点\n    oldVirtualDom.children.forEach((child, index) =&gt; {\n      walkToDiff(child, newVirtualDom.children[index], ++initialIndex, patches)\n    })\n  }\n  // else 说明节点类型不同，被直接替换了，我们直接将新的结果 push\n  else {\n    diffResult.push({ \n      type: &apos;REPLACE&apos;, \n      newVirtualDom\n    })\n  }\n\n  if (!oldVirtualDom) {\n    diffResult.push({ \n      type: &apos;REPLACE&apos;, \n      newVirtualDom\n    })\n  }\n\n  if (diffResult.length) {\n    patches[index] = diffResult\n  }\n}\n\nconst chapterListVirtualDom = element(&apos;ul&apos;, { id: &apos;list&apos; }, [\n  element(&apos;li&apos;, { class: &apos;chapter&apos; }, [&apos;chapter1&apos;]),\n  element(&apos;li&apos;, { class: &apos;chapter&apos; }, [&apos;chapter2&apos;]),\n  element(&apos;li&apos;, { class: &apos;chapter&apos; }, [&apos;chapter3&apos;])\n])\n\nconst chapterListVirtualDom1 = element(&apos;ul&apos;, { id: &apos;list2&apos; }, [\n  element(&apos;li&apos;, { class: &apos;chapter2&apos; }, [&apos;chapter4&apos;]),\n  element(&apos;li&apos;, { class: &apos;chapter2&apos; }, [&apos;chapter5&apos;]),\n  element(&apos;li&apos;, { class: &apos;chapter2&apos; }, [&apos;chapter6&apos;])\n])\n\nconst patch = (node, patches) =&gt; {\n  let walker = { index: 0 }\n  walk(node, walker, patches)\n}\n\nconst walk = (node, walker, patches) =&gt; {\n  let currentPatch = patches[walker.index]\n\n  let childNodes = node.childNodes\n\n  childNodes.forEach(child =&gt; {\n    walker.index++\n    walk(child, walker, patches)\n  })\n\n  if (currentPatch) {\n    doPatch(node, currentPatch)\n  }\n}\n\nconst doPatch = (node, patches) =&gt; {\n  patches.forEach(patch =&gt; {\n    switch (patch.type) {\n      case &apos;MODIFY_ATTRIBUTES&apos;:\n        const attributes = patch.diffAttributeResult.attributes\n        for (let key in attributes) {\n            if (node.nodeType !== 1) return\n            const value = attributes[key]\n            if (value) {\n              setAttribute(node, key, value)\n            } else {\n              node.removeAttribute(key)\n            }\n        }\n        break\n      case &apos;MODIFY_TEXT&apos;:\n        node.textContent = patch.data\n        break\n      case &apos;REPLACE&apos;:\n        let newNode = (patch.newNode instanceof Element) ? render(patch.newNode) : document.createTextNode(patch.newNode)\n        node.parentNode.replaceChild(newNode, node)\n        break\n      case &apos;REMOVE&apos;:\n        node.parentNode.removeChild(node)\n        break\n      default:\n        break\n    }\n  })\n}\n</code></pre>\n<p>先执行：</p>\n<pre><code class=\"lang-\">var element = chapterListVirtualDom.render()\nrenderDom(element, document.body)\n</code></pre>\n<p>再执行：</p>\n<pre><code class=\"lang-\">const patches = diff(chapterListVirtualDom, chapterListVirtualDom1)\n\npatch(element, patches)\n</code></pre>\n<p>生成结果符合预期。</p>\n<p>短短不到两百行代码，就实现了虚拟 DOM 思想的全部流程。当然其中还有一些优化手段，一些边界情况并没有进行特别处理，但是我们去翻看一些著名的虚拟 DOM 库：snabbdom、etch 等，其实现思想和上述教例完全一致。</p>\n<h3><a id=\"font_color13aa6cfont_1365\"></a><font color=13aa6c>总结</font></h3>\n<p>现代框架无疑极大程度上解放了前端生产力，其设计思想相互借鉴，存在非常多的共性。本讲我们通过分析前端框架中的共性，梳理概念原理，希望达到“任何一种框架变得不再神秘”的目的。掌握了这些基本思想，我们不仅能触类旁通，更快地上手框架，更能学习进阶，吸取优秀框架的精华。</p>\n<h3><a id=\"font_color13aa6cfont_1369\"></a><font color=13aa6c>分享交流</font></h3>\n<p>阅读文章过程中有任何疑问可随时跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。<strong>你的分享不仅帮助他人，更会提升自己。</strong></p>\n<p>你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。</p>\n<blockquote>\n<p><strong>为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。</strong></p>\n</blockquote>\n","readingStatistics":96,"createdAt":"2019-04-21T04:20:12.952Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":16,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FoThASW9dVEPMEo9nP-zaOfbKyLZ"},{"_id":"5cbbefcebbbba80861a35c29","communication_start_time":null,"type":1,"audioPath":"","abstract":"","content":"这一讲我们来重点解析一下 React，说 React 是前端中最受瞩目的框架其实并不夸张。React 推出之后，很快风靡业界，并且 React 倡导的多种思想也对其他框架（比如 Vue）有着广泛影响。\n\n据我观察，很多 React 开发者停留在“会使用”的阶段，而并没有在细节之处把握 React 精髓；我们可能对各种生命周期“了如指掌”，可能对“React 虚拟 DOM diff 算法”“对答如流”，可能对“单向数据流”“如数家珍”，可是你真的了解 React 吗？\n\n同时，现在 React 面试越来越“范式化”，除了实际动手写码的题目之外，其他相关面试题毫无新意，很容易被应试，很难考察开发者的 React 功底。\n\n对此，下面挑选出 React 中一些“不为人知”却又非常重要的点，为大家进行解析。在此过程中，通过剖析实现，读者可以更好、更深入地理解 React，掌握了这些内容，有可能在某些方向上比你的 React 面试官更有深度。\n\n相关知识点如下：\n\n![enter image description here](https://images.gitbook.cn/bfd2b840-97ba-11e9-af96-558c6e89b52c)\n\n### <font color=13aa6c>神奇的 JSX</font>\n\n其实 React 的“专利发明”并不多，比如虚拟 DOM、组件化思想并不是 Facebook 原创。但 JSX 是 React 真正的创造，我认为这是 React 最“伟大”的发明。\n\nJSX 是 React 的骨骼，它搭起了 React 应用的组件，是整个项目的组件框架基础。\n\n“不就是 HTML in JS”吗？有什么神奇之处呢？请继续阅读。\n\n#### JSX 就是丑陋的模版\n\n直观上看，JSX 是将 HTML 直接嵌入在了 JS 代码里面，这是刚开始接触 React 时，很多人最不能接受的设定。因为前端开发者被“表现和逻辑层分离”这种思想“洗脑”太久了：表现和逻辑耦合在一起，在某种程度上是一种混乱和困扰。\n\n但是从现在发展来看，JSX 完全符合“真香定律”：JSX 让前端实现真正意义上的组件化成为了可能。\n\n可能有读者认为 JSX 很简单，但是你真的理解它了吗？试着回答这么几个问题：\n\n> 如何在 JSX 中调试代码？\n\n> 为什么 JSX 中不能直接使用 if...else\n\n在回答这些问题之前，先来看看 JSX 是如何实现条件渲染的。\n\n#### JSX 多种姿势实现条件渲染\n\n很常见的一个场景：渲染一个列表。但是需要满足：列表为空数组时，显示空文案“Sorry，the list is empty”。同时列表数据可能通过网络获取，存在列表没有初始值为 null 的情况。\n\nJSX 实现这种条件渲染最简洁的手段就是三目运算符：\n\n```\nconst list = ({list}) => {\n  const isNull = !list\n  const isEmpty = !isNull && !list.length\n\n  return (\n    <div>\n    {\n      isNull\n      ? null\n      : (\n          isEmpty \n          ? <p>Sorry, the list is empty </p>\n          : <div>\n              {\n                list.map(item => <ListItem item={item} />)\n              }\n            </div>\n        )\n    }\n    </div>\n  )\n}\n```\n\n但是我们多加了几个状态：加上出现错误时，正在加载时的逻辑，三目运算符嵌套地狱可能就要出现了：\n\n```\nconst list = ({isLoading, list. error}) => {\n  return (\n    <div>\n    {\n      condition1\n      ? <Component1 />\n      : (\n          condition2 \n          ? <Component2 />\n          : (\n            condition3\n            ? <Component3 />\n            : <Component4 />\n          )\n        )\n    }\n    </div>\n  )\n}\n```\n\n如何破解这种嵌套呢？我们常用的手段是抽离出 render function：\n\n```\nconst getListContent = (isLoading, list, error) => {\n\tconsole.log(list)\n\tconsole.log(isLoading)\n\tconsole.log(error)\n   // ...\n   return ...\n}\n\nconst list = ({isLoading, list, error}) => {\n  return (\n    <div>\n      {\n        getListContent(isLoading, list, error)\n      }\n    </div>\n  )\n}\n```\n\n甚至使用 IIFE：\n\n```\nconst list = ({isLoading, list, error}) => {\n  return (\n    <div>\n      {\n        (() => {\n          console.log(list)\n          console.log(isLoading)\n          console.log(error)\n\n          if (error) {\n            return <span>Something is wrong!</span>\n          }\n          if (!error && isLoading) {\n            return <span>Loading...</span>\n          }\n          if (!error && !isLoading && !list.length) {\n            return <p>Sorry, the list is empty </p>\n          }\n          if (!error && !isLoading && list.length > 0) {\n            return <div>\n              {\n                list.map(item => <ListItem item={item} />)\n              }\n            </div>\n          }\n        })()\n      }\n    </div>\n  )\n}\n```\n\n这样一来就可以使用 console.log 进行简单调试了，也可以使用 if...else 进行条件渲染。\n\n再回到问题的本源：“为什么不能直接在 JSX 中使用 if...else，只能借用函数逻辑实现呢”？实际上，我们都知道 JSX 会被编译为 React.createElement。直白来说，React.createElement 的底层逻辑是无法运行 JavaScript 代码的，而它只能渲染一个结果。因此 JSX 中除了 JS 表达式，不能直接写 JavaScript 语法。准确来讲，JSX 只是函数调用和表达式的语法糖。\n\nReact 程序员天天都在使用 JSX，但并不是所有人都明白其背后原理的。\n\n#### JSX 的强大和灵活\n\n虽然 JSX 只是函数调用和表达式的语法糖，但是 JSX 仍然具有强大而灵活的能力。React 组件复用最流行的方式都是在 JSX 能力基础之上的，比如 HoC，比如 render prop 模式：\n\n```\nclass WindowWidth extends React.Component {\n  constructor() {\n    super()\n    this.state = {\n      width: 0\n    }\n  }\n\n  componentDidMount() {\n    this.setState(\n      {\n        width: window.innerWidth\n      },\n      window.addEventListener(&apos;resize&apos;, ({target}) => {\n        this.setState({\n          width: target.innerWidth\n        })\n      })\n    )\n  }\n\n  render() {\n    return this.props.children(this.state.width)\n  }\n}\n\n<WindowWidth>\n  {\n    width => (width > 800 ? <div>show</div> : null)\n  }\n<WindowWidth>\n```\n\n甚至，我们还可以让 JSX 具有 Vue template 的能力：\n\n```\nrender() {\n  const visible = true\n\n  return (\n    <div>\n      <div v-if={visible}>\n       content \n      </div>\n    </div>\n  )\n}\n\nrender() {\n  const list = [1, 2, 3, 4]\n\n  return (\n    <div>\n      <div v-for={item in list}>\n        {item}\n      </div>\n    </div>\n  )\n}\n```\n\n因为 JSX 总要进行一步编译，在这个编译过程中我们借助 AST（抽象语法树）对  v-if、v-for 进行处理即可。\n\n### <font color=13aa6c>你真的了解异步的 this.setState 吗？</font>\n\n绝大多数 React 开发者都知道 this.setState 是异步执行的，但是我会说“你这个结论是错误的！”，那么 this.setState 到底是异步执行还是同步执行？这是一个问题...... \n\n#### this.setState 全是异步执行吗？\n\nthis.setSate 这个 API，官方描述为：\n\n> setState() does not always immediately update the component. It may batch or defer the update until later. This makes reading this.state right after calling setState() a potential pitfall.\n\n既然用词是 may，那么说明 this.setState 一定不全是异步执行，也不全是同步执行的。所谓的“延迟更新”并不是针对所有情况。\n\n实际上， React 控制的事件处理过程，setState 不会同步更新 this.state。而在 React 控制之外的情况， setState 会同步更新 this.state。\n\n什么是 React 控制内外呢？举个例子：\n\n```\nonClick() {\n  this.setState({\n    count: this.state.count + 1\n  })\n}\n\ncomponentDidMount() {\n  document.querySelectorAll(&apos;#btn-raw&apos;)\n    .addEventListener(&apos;click&apos;, this.onClick)\n}\n\nrender() {\n  return (\n    <React.Fragment>\n      <button id=\"btn-raw\">\n        click out React\n      </button>\n\n      <button onClick={this.onClick}>\n        click in React\n      </button>\n    </React.Fragment>\n  )\n}\n```\n\nid 为 btn-raw 的 button 上绑定的事件，是在 componentDidMount 方法中通过 addEventListener 完成的，这是脱离于 React 事件之外的，因此它是同步更新的。反之，代码中第二个 button 所绑定的事件处理函数对应的 setState 是异步更新的。\n\n这样的设计也不难理解，通过“延迟更新”，可以达到更好的性能。\n\n#### this.setState promise 化\n\n官方提供了这种处理异步更新的方法。其中之一就是 setState 接受第二个参数，作为状态更新后的回调。但这无疑又带来了我们熟悉的 callback hell 问题。\n\n举一个场景，我们在开发一个 tabel，这个 table 类似 excel，当用户敲下回车键时，需要将光标移动到下一行，这是一个 setState 操作，然后马上进行聚焦，这又是一个 setState 操作。如果当前行就是最后一行，那用户敲下回车时，需要先创建一个新行，这是第一个 setState 操作，同时将光标移动到新的“最后一行”，这是第二个 setState 操作；在这个新行中进行聚焦，这是第三个 setState 操作。这些 setState 操作依赖于前一个 setState 的完成。\n\n面对这种场景，如果我们不想出现回调地狱的场景。常见的处理方式是利用生命周期方法，在 componentDidUpdate 中进行相关操作。第一次 setState 进行完后，在其触发的 componentDidUpdate 中进行第二次 setState，依此类推。\n\n但是这样存在的问题也很明显：逻辑过于分散。生命周期方法中有很多很难维护的“莫名其妙操作”，出现“面向生命周期编程”的情况。\n\n回到刚才问题，解决回调地狱其实是我们前端工程师的拿手好戏了，最直接的方案就是将 setState Promise 化：\n\n```\nconst setStatePromise = (me, state) => {\n  new Promise(resolve => {\n    me.setState(state, () => {\n      resolve()\n    })\n  })\n}\n```\n\n这只是 patch 做法，如果修改 React 源码的话，也不困难：\n\n![enter image description here](https://images.gitbook.cn/81a2a920-97d5-11e9-949b-a35e3e200084)\n\n### <font color=13aa6c>原生事件 VS React 合成事件</font>\n\n对 React 熟悉的读者可能知道：\n\n- React 中的事件机制并不是原生的那一套，事件没有绑定在原生 DOM 上 ，大多数事件绑定在 document 上（除了少数不会冒泡到 document 的事件，如 video 等)\n- 同时，触发的事件也是对原生事件的包装，并不是原生 event\n- 出于性能因素考虑，合成事件（syntheticEvent）是被池化的。这意味着合成事件对象将会被重用，在调用事件回调之后所有属性将会被废弃。这样做可以大大节省内存，而不会频繁的创建和销毁事件对象。\n\n这样的事件系统设计，无疑性能更加友好，但同时也带来了几个潜在现象。\n\n#### 现象1：异步访问事件对象\n\n我们不能以异步的方式访问合成事件对象：\n\n```\nfunction handleClick(e) {\n  console.log(e)\n\n  setTimeout(() => {\n    console.log(e)\n  }, 0)\n}\n```\n\n上述代码第二个 console.log 总将会输出 undefined。\n\n为此 React 也贴心的为我们准备了持久化合成事件的方法：\n\n```\nfunction handleClick(e) {\n  console.log(e)\n\n  e.persist()\n\n  setTimeout(() => {\n    console.log(e)\n  }, 0)\n}\n```\n\n#### 现象2：如何阻止冒泡\n\n在 React 中，直接使用 e.stopPropagation 不能阻止原生事件冒泡，因为事件早已经冒泡到了 document 上，React 此时才能够处理事件句柄。\n\n如代码：\n\n```\ncomponentDidMount() {\n  document.addEventListener(&apos;click&apos;, () => {\n    console.log(&apos;document click&apos;)\n  })\n}\n\nhandleClick = e => {\n  console.log(&apos;div click&apos;)\n  e.stopPropagation()\n}\n\nrender() {\n  return (\n    <div onClick={this.handleClick}>\n      click\n    </div>\n  )\n}\n```\n\n执行后会打印出 div click，之后是 document click。e.stopPropagation 是没有用的。\n\n但是 React 的合成事件还给使用原生事件留了一个口子，通过合成事件上的 nativeEvent 属性，我们还是可以访问原生事件。原生事件上的 stopImmediatePropagation 方法：除了能做到像 stopPropagation 一样阻止事件向父级冒泡之外，也能阻止当前元素剩余的、同类型事件的执行（第一个 click 触发时，调用 e.stopImmediatePropagtion 阻止当前元素第二个 click 事件的触发）。因此这一段代码：\n\n```\ncomponentDidMount() {\n  document.addEventListener(&apos;click&apos;, () => {\n    console.log(&apos;document click&apos;)\n  })\n}\n\nhandleClick = e => {\n  console.log(&apos;div click&apos;)\n  e.nativeEvent.stopImmediatePropagation()\n}\n\nrender() {\n  return (\n    <div onClick={this.handleClick}>\n      click\n    </div>\n  )\n}\n```\n\n只会打印出 div click。\n\n### <font color=13aa6c>请不要再背诵 Diff 算法了</font>\n\n很多开发者在面试中能“背诵”出 React DOM diff 算法的方式，熟悉那著名的“三个假设”（不了解的读者可先自行学习），可是你真的懂 Diff 算法吗？如果我是面试官，我问几个简单的问题，你是否还能招架得住？\n\n我们通过一个侧面来剖析 Diff 算法的细节。\n\n#### Element diff 的那些事儿\n \n我们都知道 React 把对比两个树的时间复杂度从 On 立方降低到大 On，三个假设也都老生常谈了。但是关于兄弟列表的 diff 细节，React 叫做 element diff，我们可以展开一下。\n\nReact 三个假设在对比 element 时，存在短板，于是需要开发者给每一个 element 通过提供 key ，这样 react 可以准确地发现新旧集合中的节点中相同节点，对于相同节点无需进行节点删除和创建，只需要将旧集合中节点的位置进行移动，更新为新集合中节点的位置。\n\n![enter image description here](https://images.gitbook.cn/c7a69520-97c7-11e9-ae77-f7748cb4d629)\n\n组件 1234，变为 2143，此时 React 给出的 diff 结果为 2，4 不做任何操作；1，3 进行移动操作即可。\n\n也就是元素在旧集合中的位置，相比新集合中的位置更靠后的话，那么它就不需要移动。当然这种 diff 听上去就并非完美无缺的。\n\n我们来看这么一种情况：\n\n![enter image description here](https://images.gitbook.cn/e69325c0-97c7-11e9-9465-a7e3d006cf60)\n\n实际只需对 4 执行移动操作，然而由于 4 在旧集合中的位置是最大的，导致其他节点全部移动，移动到 4 节点后面。\n\n这无疑是很愚蠢的，性能较差。针对这种情况，官方建议：\n\n> “在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作。”\n\n实际上很多类 React 类库（Inferno.js，Preact.js）都有了更优的 element diff 移动策略。\n \n#### 有 key 就一定“性能最优”吗？\n\n刚才提到，在进行 element diff 时：由于 key 的存在，react 可以准确地判断出该节点在新集合中是否存在，这极大地提高了element diff 效率。\n\n但是加了 key 一定要比没加 key 的性能更高吗？\n\n我们来看这个场景，集合 [1,2,3,4] 渲染成 4 组数字，注意仅仅是数字这么简单：\n\n```\n<div id=\"1\">1</div>\n<div id=\"2\">2</div>\n<div id=\"3\">3</div>\n<div id=\"4\">4</div>\n```\n\n当它变为 [2，1，4，5]：删除了 3，增加了 5，按照之前的算法，我们把 1 放到 2 后面，删除 3，再新增 5。整个操作移动了一次 dom 节点，删除和新增一共 2 处节点。\n\n由于 dom 节点的移动操作开销是比较昂贵的，其实对于这种简单的 node text 更改情况，我们不需要再进行类似的 element diff 过程，只需要更改 dom.textContent 即可。\n\n```\nconst startTime = performance.now()\n\n$(&apos;#1&apos;).textContent = 2\n$(&apos;#2&apos;).textContent = 1\n$(&apos;#3&apos;).textContent = 4\n$(&apos;#4&apos;).textContent = 5\n\nconsole.log(&apos;time consumed:&apos; performance.now() - startTime)\n```\n\n这么看，也许没有 key 的情况下要比有 key 的性能更好。\n\n### <font color=13aa6c>总结</font>\n\n这一讲，我们聚焦 React 当中那些“不为人知”的设计细节，这些设计细节却从不同角度体现了 React 的理念和思想。仔细想来，也许“我之前理解的 React 还是很肤浅”！实际上，任何一个类库或者框架，我们都不能停留在初级使用上，而更应该从使用的经验出发，深入细节，这样才能更好地理解框架，也能更快地自我提升。\n\n### <font color=13aa6c>分享交流</font>\n\n阅读文章过程中有任何疑问可随时跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。**你的分享不仅帮助他人，更会提升自己。**\n\n你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。\n\n>**为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。**","pdfUrl":"","reader":"","duration":"","title":"你真的懂 React 吗","column":"5c91c813968b1d64b1e08fde","isNotification":false,"htmlContent":"<p>这一讲我们来重点解析一下 React，说 React 是前端中最受瞩目的框架其实并不夸张。React 推出之后，很快风靡业界，并且 React 倡导的多种思想也对其他框架（比如 Vue）有着广泛影响。</p>\n<p>据我观察，很多 React 开发者停留在“会使用”的阶段，而并没有在细节之处把握 React 精髓；我们可能对各种生命周期“了如指掌”，可能对“React 虚拟 DOM diff 算法”“对答如流”，可能对“单向数据流”“如数家珍”，可是你真的了解 React 吗？</p>\n<p>同时，现在 React 面试越来越“范式化”，除了实际动手写码的题目之外，其他相关面试题毫无新意，很容易被应试，很难考察开发者的 React 功底。</p>\n<p>对此，下面挑选出 React 中一些“不为人知”却又非常重要的点，为大家进行解析。在此过程中，通过剖析实现，读者可以更好、更深入地理解 React，掌握了这些内容，有可能在某些方向上比你的 React 面试官更有深度。</p>\n<p>相关知识点如下：</p>\n<p><img src=\"https://images.gitbook.cn/bfd2b840-97ba-11e9-af96-558c6e89b52c\" alt=\"enter image description here\" /></p>\n<h3><a id=\"font_color13aa6c_JSXfont_12\"></a><font color=13aa6c>神奇的 JSX</font></h3>\n<p>其实 React 的“专利发明”并不多，比如虚拟 DOM、组件化思想并不是 Facebook 原创。但 JSX 是 React 真正的创造，我认为这是 React 最“伟大”的发明。</p>\n<p>JSX 是 React 的骨骼，它搭起了 React 应用的组件，是整个项目的组件框架基础。</p>\n<p>“不就是 HTML in JS”吗？有什么神奇之处呢？请继续阅读。</p>\n<h4><a id=\"JSX__20\"></a>JSX 就是丑陋的模版</h4>\n<p>直观上看，JSX 是将 HTML 直接嵌入在了 JS 代码里面，这是刚开始接触 React 时，很多人最不能接受的设定。因为前端开发者被“表现和逻辑层分离”这种思想“洗脑”太久了：表现和逻辑耦合在一起，在某种程度上是一种混乱和困扰。</p>\n<p>但是从现在发展来看，JSX 完全符合“真香定律”：JSX 让前端实现真正意义上的组件化成为了可能。</p>\n<p>可能有读者认为 JSX 很简单，但是你真的理解它了吗？试着回答这么几个问题：</p>\n<blockquote>\n<p>如何在 JSX 中调试代码？</p>\n</blockquote>\n<blockquote>\n<p>为什么 JSX 中不能直接使用 if…else</p>\n</blockquote>\n<p>在回答这些问题之前，先来看看 JSX 是如何实现条件渲染的。</p>\n<h4><a id=\"JSX__34\"></a>JSX 多种姿势实现条件渲染</h4>\n<p>很常见的一个场景：渲染一个列表。但是需要满足：列表为空数组时，显示空文案“Sorry，the list is empty”。同时列表数据可能通过网络获取，存在列表没有初始值为 null 的情况。</p>\n<p>JSX 实现这种条件渲染最简洁的手段就是三目运算符：</p>\n<pre><code class=\"lang-\">const list = ({list}) =&gt; {\n  const isNull = !list\n  const isEmpty = !isNull &amp;&amp; !list.length\n\n  return (\n    &lt;div&gt;\n    {\n      isNull\n      ? null\n      : (\n          isEmpty \n          ? &lt;p&gt;Sorry, the list is empty &lt;/p&gt;\n          : &lt;div&gt;\n              {\n                list.map(item =&gt; &lt;ListItem item={item} /&gt;)\n              }\n            &lt;/div&gt;\n        )\n    }\n    &lt;/div&gt;\n  )\n}\n</code></pre>\n<p>但是我们多加了几个状态：加上出现错误时，正在加载时的逻辑，三目运算符嵌套地狱可能就要出现了：</p>\n<pre><code class=\"lang-\">const list = ({isLoading, list. error}) =&gt; {\n  return (\n    &lt;div&gt;\n    {\n      condition1\n      ? &lt;Component1 /&gt;\n      : (\n          condition2 \n          ? &lt;Component2 /&gt;\n          : (\n            condition3\n            ? &lt;Component3 /&gt;\n            : &lt;Component4 /&gt;\n          )\n        )\n    }\n    &lt;/div&gt;\n  )\n}\n</code></pre>\n<p>如何破解这种嵌套呢？我们常用的手段是抽离出 render function：</p>\n<pre><code class=\"lang-\">const getListContent = (isLoading, list, error) =&gt; {\n\tconsole.log(list)\n\tconsole.log(isLoading)\n\tconsole.log(error)\n   // ...\n   return ...\n}\n\nconst list = ({isLoading, list, error}) =&gt; {\n  return (\n    &lt;div&gt;\n      {\n        getListContent(isLoading, list, error)\n      }\n    &lt;/div&gt;\n  )\n}\n</code></pre>\n<p>甚至使用 IIFE：</p>\n<pre><code class=\"lang-\">const list = ({isLoading, list, error}) =&gt; {\n  return (\n    &lt;div&gt;\n      {\n        (() =&gt; {\n          console.log(list)\n          console.log(isLoading)\n          console.log(error)\n\n          if (error) {\n            return &lt;span&gt;Something is wrong!&lt;/span&gt;\n          }\n          if (!error &amp;&amp; isLoading) {\n            return &lt;span&gt;Loading...&lt;/span&gt;\n          }\n          if (!error &amp;&amp; !isLoading &amp;&amp; !list.length) {\n            return &lt;p&gt;Sorry, the list is empty &lt;/p&gt;\n          }\n          if (!error &amp;&amp; !isLoading &amp;&amp; list.length &gt; 0) {\n            return &lt;div&gt;\n              {\n                list.map(item =&gt; &lt;ListItem item={item} /&gt;)\n              }\n            &lt;/div&gt;\n          }\n        })()\n      }\n    &lt;/div&gt;\n  )\n}\n</code></pre>\n<p>这样一来就可以使用 console.log 进行简单调试了，也可以使用 if…else 进行条件渲染。</p>\n<p>再回到问题的本源：“为什么不能直接在 JSX 中使用 if…else，只能借用函数逻辑实现呢”？实际上，我们都知道 JSX 会被编译为 React.createElement。直白来说，React.createElement 的底层逻辑是无法运行 JavaScript 代码的，而它只能渲染一个结果。因此 JSX 中除了 JS 表达式，不能直接写 JavaScript 语法。准确来讲，JSX 只是函数调用和表达式的语法糖。</p>\n<p>React 程序员天天都在使用 JSX，但并不是所有人都明白其背后原理的。</p>\n<h4><a id=\"JSX__152\"></a>JSX 的强大和灵活</h4>\n<p>虽然 JSX 只是函数调用和表达式的语法糖，但是 JSX 仍然具有强大而灵活的能力。React 组件复用最流行的方式都是在 JSX 能力基础之上的，比如 HoC，比如 render prop 模式：</p>\n<pre><code class=\"lang-\">class WindowWidth extends React.Component {\n  constructor() {\n    super()\n    this.state = {\n      width: 0\n    }\n  }\n\n  componentDidMount() {\n    this.setState(\n      {\n        width: window.innerWidth\n      },\n      window.addEventListener(&apos;resize&apos;, ({target}) =&gt; {\n        this.setState({\n          width: target.innerWidth\n        })\n      })\n    )\n  }\n\n  render() {\n    return this.props.children(this.state.width)\n  }\n}\n\n&lt;WindowWidth&gt;\n  {\n    width =&gt; (width &gt; 800 ? &lt;div&gt;show&lt;/div&gt; : null)\n  }\n&lt;WindowWidth&gt;\n</code></pre>\n<p>甚至，我们还可以让 JSX 具有 Vue template 的能力：</p>\n<pre><code class=\"lang-\">render() {\n  const visible = true\n\n  return (\n    &lt;div&gt;\n      &lt;div v-if={visible}&gt;\n       content \n      &lt;/div&gt;\n    &lt;/div&gt;\n  )\n}\n\nrender() {\n  const list = [1, 2, 3, 4]\n\n  return (\n    &lt;div&gt;\n      &lt;div v-for={item in list}&gt;\n        {item}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre>\n<p>因为 JSX 总要进行一步编译，在这个编译过程中我们借助 AST（抽象语法树）对  v-if、v-for 进行处理即可。</p>\n<h3><a id=\"font_color13aa6c_thissetState_font_220\"></a><font color=13aa6c>你真的了解异步的 this.setState 吗？</font></h3>\n<p>绝大多数 React 开发者都知道 this.setState 是异步执行的，但是我会说“你这个结论是错误的！”，那么 this.setState 到底是异步执行还是同步执行？这是一个问题…</p>\n<h4><a id=\"thissetState__224\"></a>this.setState 全是异步执行吗？</h4>\n<p>this.setSate 这个 API，官方描述为：</p>\n<blockquote>\n<p>setState() does not always immediately update the component. It may batch or defer the update until later. This makes reading this.state right after calling setState() a potential pitfall.</p>\n</blockquote>\n<p>既然用词是 may，那么说明 this.setState 一定不全是异步执行，也不全是同步执行的。所谓的“延迟更新”并不是针对所有情况。</p>\n<p>实际上， React 控制的事件处理过程，setState 不会同步更新 this.state。而在 React 控制之外的情况， setState 会同步更新 this.state。</p>\n<p>什么是 React 控制内外呢？举个例子：</p>\n<pre><code class=\"lang-\">onClick() {\n  this.setState({\n    count: this.state.count + 1\n  })\n}\n\ncomponentDidMount() {\n  document.querySelectorAll(&apos;#btn-raw&apos;)\n    .addEventListener(&apos;click&apos;, this.onClick)\n}\n\nrender() {\n  return (\n    &lt;React.Fragment&gt;\n      &lt;button id=&quot;btn-raw&quot;&gt;\n        click out React\n      &lt;/button&gt;\n\n      &lt;button onClick={this.onClick}&gt;\n        click in React\n      &lt;/button&gt;\n    &lt;/React.Fragment&gt;\n  )\n}\n</code></pre>\n<p>id 为 btn-raw 的 button 上绑定的事件，是在 componentDidMount 方法中通过 addEventListener 完成的，这是脱离于 React 事件之外的，因此它是同步更新的。反之，代码中第二个 button 所绑定的事件处理函数对应的 setState 是异步更新的。</p>\n<p>这样的设计也不难理解，通过“延迟更新”，可以达到更好的性能。</p>\n<h4><a id=\"thissetState_promise__267\"></a>this.setState promise 化</h4>\n<p>官方提供了这种处理异步更新的方法。其中之一就是 setState 接受第二个参数，作为状态更新后的回调。但这无疑又带来了我们熟悉的 callback hell 问题。</p>\n<p>举一个场景，我们在开发一个 tabel，这个 table 类似 excel，当用户敲下回车键时，需要将光标移动到下一行，这是一个 setState 操作，然后马上进行聚焦，这又是一个 setState 操作。如果当前行就是最后一行，那用户敲下回车时，需要先创建一个新行，这是第一个 setState 操作，同时将光标移动到新的“最后一行”，这是第二个 setState 操作；在这个新行中进行聚焦，这是第三个 setState 操作。这些 setState 操作依赖于前一个 setState 的完成。</p>\n<p>面对这种场景，如果我们不想出现回调地狱的场景。常见的处理方式是利用生命周期方法，在 componentDidUpdate 中进行相关操作。第一次 setState 进行完后，在其触发的 componentDidUpdate 中进行第二次 setState，依此类推。</p>\n<p>但是这样存在的问题也很明显：逻辑过于分散。生命周期方法中有很多很难维护的“莫名其妙操作”，出现“面向生命周期编程”的情况。</p>\n<p>回到刚才问题，解决回调地狱其实是我们前端工程师的拿手好戏了，最直接的方案就是将 setState Promise 化：</p>\n<pre><code class=\"lang-\">const setStatePromise = (me, state) =&gt; {\n  new Promise(resolve =&gt; {\n    me.setState(state, () =&gt; {\n      resolve()\n    })\n  })\n}\n</code></pre>\n<p>这只是 patch 做法，如果修改 React 源码的话，也不困难：</p>\n<p><img src=\"https://images.gitbook.cn/81a2a920-97d5-11e9-949b-a35e3e200084\" alt=\"enter image description here\" /></p>\n<h3><a id=\"font_color13aa6c_VS_React_font_293\"></a><font color=13aa6c>原生事件 VS React 合成事件</font></h3>\n<p>对 React 熟悉的读者可能知道：</p>\n<ul>\n<li>React 中的事件机制并不是原生的那一套，事件没有绑定在原生 DOM 上 ，大多数事件绑定在 document 上（除了少数不会冒泡到 document 的事件，如 video 等)</li>\n<li>同时，触发的事件也是对原生事件的包装，并不是原生 event</li>\n<li>出于性能因素考虑，合成事件（syntheticEvent）是被池化的。这意味着合成事件对象将会被重用，在调用事件回调之后所有属性将会被废弃。这样做可以大大节省内存，而不会频繁的创建和销毁事件对象。</li>\n</ul>\n<p>这样的事件系统设计，无疑性能更加友好，但同时也带来了几个潜在现象。</p>\n<h4><a id=\"1_303\"></a>现象1：异步访问事件对象</h4>\n<p>我们不能以异步的方式访问合成事件对象：</p>\n<pre><code class=\"lang-\">function handleClick(e) {\n  console.log(e)\n\n  setTimeout(() =&gt; {\n    console.log(e)\n  }, 0)\n}\n</code></pre>\n<p>上述代码第二个 console.log 总将会输出 undefined。</p>\n<p>为此 React 也贴心的为我们准备了持久化合成事件的方法：</p>\n<pre><code class=\"lang-\">function handleClick(e) {\n  console.log(e)\n\n  e.persist()\n\n  setTimeout(() =&gt; {\n    console.log(e)\n  }, 0)\n}\n</code></pre>\n<h4><a id=\"2_333\"></a>现象2：如何阻止冒泡</h4>\n<p>在 React 中，直接使用 e.stopPropagation 不能阻止原生事件冒泡，因为事件早已经冒泡到了 document 上，React 此时才能够处理事件句柄。</p>\n<p>如代码：</p>\n<pre><code class=\"lang-\">componentDidMount() {\n  document.addEventListener(&apos;click&apos;, () =&gt; {\n    console.log(&apos;document click&apos;)\n  })\n}\n\nhandleClick = e =&gt; {\n  console.log(&apos;div click&apos;)\n  e.stopPropagation()\n}\n\nrender() {\n  return (\n    &lt;div onClick={this.handleClick}&gt;\n      click\n    &lt;/div&gt;\n  )\n}\n</code></pre>\n<p>执行后会打印出 div click，之后是 document click。e.stopPropagation 是没有用的。</p>\n<p>但是 React 的合成事件还给使用原生事件留了一个口子，通过合成事件上的 nativeEvent 属性，我们还是可以访问原生事件。原生事件上的 stopImmediatePropagation 方法：除了能做到像 stopPropagation 一样阻止事件向父级冒泡之外，也能阻止当前元素剩余的、同类型事件的执行（第一个 click 触发时，调用 e.stopImmediatePropagtion 阻止当前元素第二个 click 事件的触发）。因此这一段代码：</p>\n<pre><code class=\"lang-\">componentDidMount() {\n  document.addEventListener(&apos;click&apos;, () =&gt; {\n    console.log(&apos;document click&apos;)\n  })\n}\n\nhandleClick = e =&gt; {\n  console.log(&apos;div click&apos;)\n  e.nativeEvent.stopImmediatePropagation()\n}\n\nrender() {\n  return (\n    &lt;div onClick={this.handleClick}&gt;\n      click\n    &lt;/div&gt;\n  )\n}\n</code></pre>\n<p>只会打印出 div click。</p>\n<h3><a id=\"font_color13aa6c_Diff_font_387\"></a><font color=13aa6c>请不要再背诵 Diff 算法了</font></h3>\n<p>很多开发者在面试中能“背诵”出 React DOM diff 算法的方式，熟悉那著名的“三个假设”（不了解的读者可先自行学习），可是你真的懂 Diff 算法吗？如果我是面试官，我问几个简单的问题，你是否还能招架得住？</p>\n<p>我们通过一个侧面来剖析 Diff 算法的细节。</p>\n<h4><a id=\"Element_diff__393\"></a>Element diff 的那些事儿</h4>\n<p>我们都知道 React 把对比两个树的时间复杂度从 On 立方降低到大 On，三个假设也都老生常谈了。但是关于兄弟列表的 diff 细节，React 叫做 element diff，我们可以展开一下。</p>\n<p>React 三个假设在对比 element 时，存在短板，于是需要开发者给每一个 element 通过提供 key ，这样 react 可以准确地发现新旧集合中的节点中相同节点，对于相同节点无需进行节点删除和创建，只需要将旧集合中节点的位置进行移动，更新为新集合中节点的位置。</p>\n<p><img src=\"https://images.gitbook.cn/c7a69520-97c7-11e9-ae77-f7748cb4d629\" alt=\"enter image description here\" /></p>\n<p>组件 1234，变为 2143，此时 React 给出的 diff 结果为 2，4 不做任何操作；1，3 进行移动操作即可。</p>\n<p>也就是元素在旧集合中的位置，相比新集合中的位置更靠后的话，那么它就不需要移动。当然这种 diff 听上去就并非完美无缺的。</p>\n<p>我们来看这么一种情况：</p>\n<p><img src=\"https://images.gitbook.cn/e69325c0-97c7-11e9-9465-a7e3d006cf60\" alt=\"enter image description here\" /></p>\n<p>实际只需对 4 执行移动操作，然而由于 4 在旧集合中的位置是最大的，导致其他节点全部移动，移动到 4 节点后面。</p>\n<p>这无疑是很愚蠢的，性能较差。针对这种情况，官方建议：</p>\n<blockquote>\n<p>“在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作。”</p>\n</blockquote>\n<p>实际上很多类 React 类库（Inferno.js，Preact.js）都有了更优的 element diff 移动策略。</p>\n<h4><a id=\"_key__417\"></a>有 key 就一定“性能最优”吗？</h4>\n<p>刚才提到，在进行 element diff 时：由于 key 的存在，react 可以准确地判断出该节点在新集合中是否存在，这极大地提高了element diff 效率。</p>\n<p>但是加了 key 一定要比没加 key 的性能更高吗？</p>\n<p>我们来看这个场景，集合 [1,2,3,4] 渲染成 4 组数字，注意仅仅是数字这么简单：</p>\n<pre><code class=\"lang-\">&lt;div id=&quot;1&quot;&gt;1&lt;/div&gt;\n&lt;div id=&quot;2&quot;&gt;2&lt;/div&gt;\n&lt;div id=&quot;3&quot;&gt;3&lt;/div&gt;\n&lt;div id=&quot;4&quot;&gt;4&lt;/div&gt;\n</code></pre>\n<p>当它变为 [2，1，4，5]：删除了 3，增加了 5，按照之前的算法，我们把 1 放到 2 后面，删除 3，再新增 5。整个操作移动了一次 dom 节点，删除和新增一共 2 处节点。</p>\n<p>由于 dom 节点的移动操作开销是比较昂贵的，其实对于这种简单的 node text 更改情况，我们不需要再进行类似的 element diff 过程，只需要更改 dom.textContent 即可。</p>\n<pre><code class=\"lang-\">const startTime = performance.now()\n\n$(&apos;#1&apos;).textContent = 2\n$(&apos;#2&apos;).textContent = 1\n$(&apos;#3&apos;).textContent = 4\n$(&apos;#4&apos;).textContent = 5\n\nconsole.log(&apos;time consumed:&apos; performance.now() - startTime)\n</code></pre>\n<p>这么看，也许没有 key 的情况下要比有 key 的性能更好。</p>\n<h3><a id=\"font_color13aa6cfont_449\"></a><font color=13aa6c>总结</font></h3>\n<p>这一讲，我们聚焦 React 当中那些“不为人知”的设计细节，这些设计细节却从不同角度体现了 React 的理念和思想。仔细想来，也许“我之前理解的 React 还是很肤浅”！实际上，任何一个类库或者框架，我们都不能停留在初级使用上，而更应该从使用的经验出发，深入细节，这样才能更好地理解框架，也能更快地自我提升。</p>\n<h3><a id=\"font_color13aa6cfont_453\"></a><font color=13aa6c>分享交流</font></h3>\n<p>阅读文章过程中有任何疑问可随时跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。<strong>你的分享不仅帮助他人，更会提升自己。</strong></p>\n<p>你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。</p>\n<blockquote>\n<p><strong>为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。</strong></p>\n</blockquote>\n","readingStatistics":91,"createdAt":"2019-04-21T04:21:34.403Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":17,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FoThASW9dVEPMEo9nP-zaOfbKyLZ"},{"_id":"5cbbeff4bbbba80861a35c2a","communication_start_time":null,"type":1,"audioPath":"","abstract":"","content":"组件不是 React 特有的概念，但是 React 将组件化的思想发扬光大，可谓用到了极致。良好的组件设计会是良好的应用开发基础，这一讲就让我们谈一谈组件设计的奥秘。\n\n相关知识点如下：\n\n<img src=\"https://images.gitbook.cn/684bbbb0-9983-11e9-ae98-dfdddc232198\" width=400>\n\n我们将以 React 组件为例，但是其中的设计思想具有共性，不管是其他框架还是原生 Web component 都将适用。\n\n### <font color=13aa6c>单一职责没那么简单</font>\n\n单一职责我们并不陌生，原则上讲，组件只应该做一件事情。但是对于应用来说，全部组件都拆散，只有单一职责并没有必要，反而增加了编写的繁琐程度。那什么时候需要拆分组件，保证单一职责呢？我认为如果一个功能集合有可能发生变化，那么就需要最大程度地保证单一职责。\n\n单一职责带来的最大好处就是在修改组件时，能够做到全在掌控下，不必担心对其他组件造成影响。举个例子：我们的组件需要通过网络请求获取数据并展示数据内容，这样一来潜在的功能集合改变就有：\n\n- 请求 API 地址发生变化\n- 请求返回数据格式变化\n- 开发者想更换网络请求第三方库，比如 jQuery.ajax 改成 axios\n- 更改请求数据逻辑\n\n再看一个例子：我们需要一个 table 组件，渲染一个 list，那么潜在更改的可能有：\n\n- 限制一次性渲染的 item 个数（只渲染前 10 个，剩下的懒加载）\n- 当数据列表为空时显示 “This list is empty”\n- 任何渲染逻辑的更改\n\n这个图很好地说明了问题：\n\n<img src=\"https://images.gitbook.cn/49f0c740-9984-11e9-9465-a7e3d006cf60\" width = \"45%\" />\n\n我们来实际看一个场景：\n\n```\nimport axios from &apos;axios&apos;\n\nclass Weather extends Component {  \n  constructor(props) {\n    super(props)\n    this.state = { temperature: &apos;N/A&apos;, windSpeed: &apos;N/A&apos; }\n  }\n\n  componentDidMount() {\n    axios.get(&apos;http://weather.com/api&apos;).then(response => {\n      const { current } = response.data\n      this.setState({\n        temperature: current.temperature,\n        windSpeed: current.windSpeed\n      })\n    })\n  }\n\n  render() {\n    const { temperature, windSpeed } = this.state\n    return (\n      <div className=\"weather\">\n        <div>Temperature: {temperature} °C</div>\n        <div>Wind: {windSpeed} km/h</div>\n      </div>\n    )\n  }\n}\n```\n\n这个组件很容易理解，并且看上去没什么大问题，但是并不符合单一职责。比如这个 Weather 组件将数据获取与渲染逻辑耦合在一起，如果数据请求有变化，就需要在 componentDidMount 生命周期中进行改动；如果展示天气的逻辑有变化，render 方法又需要变动。\n\n如果我们将这个组件拆分成：WeatherFetch 和 WeatherInfo 两个组件，这两个组件各自只做一件事情，保持单一职责：\n\n```\nimport axios from &apos;axios&apos;\nimport WeatherInfo from &apos;./weatherInfo&apos;\n\nclass WeatherFetch extends Component {  \n  constructor(props) {\n    super(props)\n    this.state = { temperature: &apos;N/A&apos;, windSpeed: &apos;N/A&apos; }\n  }\n\n  componentDidMount() {\n    axios.get(&apos;http://weather.com/api&apos;).then(response => {\n      const { current } = response.data\n      this.setState({\n        temperature: current.temperature,\n        windSpeed: current.windSpeed\n        })\n      })\n  }\n\n  render() {\n    const { temperature, windSpeed } = this.state\n    return (\n      <WeatherInfo temperature={temperature} windSpeed={windSpeed} />\n    )\n  }\n}\n```\n\n另一个文件中：\n\n```\nconst WeatherInfo = ({ temperature, windSpeed }) => \n  (\n    <div className=\"weather\">\n      <div>Temperature: {temperature} °C</div>\n      <div>Wind: {windSpeed} km/h</div>\n    </div>\n  )\n```\n\n如果我们想进行重构，使用 async/await 代替 Promise，只需要直接更改 WeatherFetch 组件：\n\n```\nclass WeatherFetch extends Component {  \n  // ...\n\n  async componentDidMount() {\n    const response = await axios.get(&apos;http://weather.com/api&apos;)\n    const { current } = response.data\n\n    this.setState({\n      temperature: current.temperature,\n      windSpeed: current.windSpeed\n      })\n    })\n  }\n\n  // ...\n}\n```\n\n而不会对 WeatherInfo 组件有任何影响。\n\n或者显示风速的逻辑从 Wind: 0 km/h 改为文字描述 Wind: 风平浪静，也只需要改动 WeatherInfo：\n\n```\nconst WeatherInfo = ({ temperature, windSpeed }) => {\n  const windInfo = windSpeed === 0 ? &apos;calm&apos; : `${windSpeed} km/h`\n  return (\n    <div className=\"weather\">\n      <div>Temperature: {temperature} °C</div>\n      <div>Wind: {windSpeed} km/h</div>\n    </div>\n  )\n}\n```\n\n这只是一个简单的例子，在真实项目中，保持组件的单一职责将会非常重要，甚至我们可以使用 HoC 强制组件的单一职责性。\n\n来思考这样的代码：\n\n```\nclass PersistentForm extends Component {  \n  constructor(props) {\n    super(props)\n    this.state = { inputValue: localStorage.getItem(&apos;inputValue&apos;) }\n    this.handleChange = this.handleChange.bind(this)\n    this.handleClick = this.handleClick.bind(this)\n  }\n\n  handleChange(event) {\n    this.setState({\n      inputValue: event.target.value\n    })\n  }\n\n  handleClick() {\n    localStorage.setItem(&apos;inputValue&apos;, this.state.inputValue)\n  }\n\n  render() {\n    const { inputValue } = this.state\n    return (\n      <div className=\"persistent-form\">\n        <input type=\"text\" value={inputValue} \n          onChange={this.handleChange}\n        /> \n        <button onClick={this.handleClick}>\n          Save to storage\n        </button>\n      </div>\n    )\n  }\n}\n```\n\n这是一个持久化存储的表单，我们将表单字段内容存储在 localStorage 中，这样不管是刷新页面还是重新进入页面，都会保存上一次点击提交时的内容。可惜 PersistentForm 组件也是包含了两部分职责：存储内容和渲染内容。\n\n这次我们的重构不再是简单的拆分组件，而是使用 HoC 来完成职责单一的实现：\n\n```\nclass PersistentForm extends Component {  \n  constructor(props) {\n    super(props)\n    this.state = { inputValue: props.initialValue }\n    this.handleChange = this.handleChange.bind(this)\n    this.handleClick = this.handleClick.bind(this)\n  }\n\n  handleChange(event) {\n    this.setState({\n      inputValue: event.target.value\n    })\n  }\n\n  handleClick() {\n    this.props.saveValue(this.state.inputValue)\n  }\n\n  render() {\n    const { inputValue } = this.state\n    return (\n      <div className=\"persistent-form\">\n        <input type=\"text\" value={inputValue} \n          onChange={this.handleChange}\n        /> \n        <button onClick={this.handleClick}>\n          Save to storage\n        </button>\n      </div>\n    )\n  }\n}\n```\n\n我们只是改变了两行代码，初始 state 不再直接读取 localStorage，而是由 this.props.initialValue 提供；handleClick 逻辑调用 this.props.saveValue，而不再直接操作 localStorage，this.props.saveValue 将会由 withPersistence 这个 HoC 提供：\n\n```\nfunction withPersistence(storageKey, storage) {  \n  return function(WrappedComponent) {\n    return class PersistentComponent extends Component {\n      constructor(props) {\n        super(props)\n        this.state = { initialValue: storage.getItem(storageKey) }\n      }\n\n      render() {\n         return (\n           <WrappedComponent\n             initialValue={this.state.initialValue}\n             saveValue={this.saveValue}\n             {...this.props}\n           />\n         );\n      }\n\n      saveValue(value) {\n        storage.setItem(storageKey, value)\n      }\n    }\n  }\n}\n```\n\n使用方式：\n\n```\nconst LocalStoragePersistentForm  \n  = withPersistence(&apos;key&apos;, localStorage)(PersistentForm)\n```\n\n这种方式是组件单一职责和组件复用的结合体现，其他组件当然也可以使用这个 HoC:\n\n```\nconst LocalStorageMyOtherForm  \n  = withPersistence(&apos;key&apos;, localStorage)(MyOtherForm)\n```\n\n存储和渲染职责解耦，我们便可以随时切换存储方式，比如切换为 sessionStorage 代替 localStorage：\n\n```\nconst SessionStoragePersistentForm  \n  = withPersistence(&apos;key&apos;, sessionStorage)(PersistentForm)\n```\n\n### <font color=13aa6c>组件通信和封装</font>\n\n另一个和组件职责单一相关的话题是组件的封装，封装又涉及到组件间的通信。因为我们知道，组件再封装，还是要和其他组件去交互通信的，那么当我们说封装时在说些什么呢？\n\n组件关联有紧耦合和松耦合之分，紧耦合是指两个或多个组件之间需要了解彼此的组件内设计，这样的情况是我们不想看到的，这破坏了组件的独立性，“牵一发动全身”。这么看来，松耦合带来的好处是很直接的：\n\n- 一处组件的改动完全独立，不影响其他组件\n- 更好的复用设计\n- 更好的可测试性\n\n我们直接来看场景代码，一个简单的计数器足以说明问题：\n\n```\nclass App extends Component {  \n  constructor(props) {\n    super(props)\n    this.state = { number: 0 }\n  }\n\n  render() {\n    return (\n      <div className=\"app\"> \n        <span className=\"number\">{this.state.number}</span>\n        <Controls parent={this} />\n      </div>\n    )\n  }\n}\n\nclass Controls extends Component {\n  updateNumber(toAdd) {\n    this.props.parent.setState(prevState => ({\n      number: prevState.number + toAdd       \n    }))\n  }\n\n  render() {\n    return (\n      <div className=\"controls\">\n        <button onClick={() => this.updateNumber(+1)}>\n          Increase\n        </button> \n        <button onClick={() => this.updateNumber(-1)}>\n          Decrease\n        </button>\n      </div>\n    )\n  }\n}\n```\n\n这样的组件实现问题很明显：App 组件不具有封装性，它将实例传给 Controls 组件，Controls 组件可以直接更改 App state 的内容。事实上，我们并不是不允许 Controls 组件修改 App 组件，只是 Controls 组件直接调用 App 组件的 setState 方法是不被建议的，因为 Controls 组件如果要调用 App 的 setState，就得需要知道 App 组件 state 的结构，需要感知 this.props.parent.state.number 等详情。\n\n\n同时上述代码也不利于测试，这个我们将在后面进行说明。那么该如何重构呢？我们应该用更加“含蓄”或者更加“粗暴、直接地”方式修改 number 值。秉承封装性：“只有组件自己知道自己的 state 结构”，将 updateNumber 迁移至 App 组件内：\n\n```\nclass App extends Component {  \n  constructor(props) {\n    super(props)\n    this.state = { number: 0 }\n  }\n\n  updateNumber(toAdd) {\n    this.setState(prevState => ({\n      number: prevState.number + toAdd       \n    }))\n  }\n\n  render() {\n    return (\n      <div className=\"app\"> \n        <span className=\"number\">{this.state.number}</span>\n        <Controls \n          onIncrease={() => this.updateNumber(+1)}\n          onDecrease={() => this.updateNumber(-1)} \n        />\n      </div>\n    )\n  }\n}\n\n\nconst Controls = ({ onIncrease, onDecrease }) => {  \n  return (\n    <div className=\"controls\">\n      <button onClick={onIncrease}>Increase</button> \n      <button onClick={onDecrease}>Decrease</button>\n    </div>\n  )\n}\n``` \n\n这样一来，Controls 组件就不需要再知道 App 组件的内部情况，实现了更好的复用性和可测试性，App 组件因此也具有了更好的封装性。\n\n### <font color=13aa6c>组合性是灵魂</font>\n\n如果说组件单一职责确定了如何拆分组件，封装性明确了组件如何组织，那么组合性就完成了整个应用的拼接。\n\nReact 具有天生的组合基因：\n\n<img src=\"https://images.gitbook.cn/85431690-9984-11e9-ae98-dfdddc232198\" width = \"80%\" />\n\n对应声明式代码：\n\n```\nconst app = (  \n  <Application>\n    <Header />\n    <Sidebar>\n      <Menu />\n    </Sidebar>\n    <Content>\n      <Article />\n    </Content>\n    <Footer />\n  </Application>\n)\n```\n\n如果两个组件 Composed1 和 Composed2 具有相同的逻辑，我们可以使用组合性进行拆分重组：\n\n```\nconst instance1 = (  \n  <Composed1>\n  \t// Composed1 逻辑\n  \t// 重复逻辑\n  </Composed1>\n)\nconst instance2 = (  \n  <Composed2>\n  \t// 重复逻辑\n  \t// Composed2 逻辑\n  </Composed2>\n)\n```\n\n重复逻辑提取为 Common 组件：\n\n```\nconst instance1 = (  \n  <Composed1>\n    <Logic1 />\n    <Common />\n  </Composed1>\n)\nconst instance2 = (  \n  <Composed2>\n    <Common />\n    <Logic2 />\n  </Composed2>\n)\n```\n\n另外一个典型应用就是 render prop 模式，这个我们前面已经介绍过，这里给出一个很简单的示例，具体不再展开：\n\n```\nconst ByDevice = ({ children: { mobile, other } }) => {  \n  return Utils.isMobile() ? mobile : other\n}\n\n<ByDevice>\n\t{{  \n\t  mobile: <div>Mobile detected!</div>,\n\t  other:  <div>Not a mobile device</div>\n\t}}\n</ByDevice>\n```\n\n### <font color=13aa6c>副作用和（准）纯组件</font>\n\n纯函数和非纯函数概念大家并不陌生，简单来说，通过函数参数能够唯一确定函数返回值的函数，我们称之为纯函数，反之就是有副作用的非纯函数。纯/非纯函数延伸到组件中，就是纯/非纯组件。\n\n在理想主义者眼中，最好的情况是应用组件全部由纯组件组成，这样对于组件的调试和强健性非常重要。但这只能是理想情况，在真实环境中，我们需要发送网络请求以获取数据（副作用，因为数据不固定，需要从网络获取），进行条件渲染等操作，如何最大限度地保证纯组件或者（准）纯组件呢？我们先来下一个定义：\n\n> （准）纯组件是渲染数据全部来自于 props，但是会产生副作用的组件\n\n从非纯组件中提取纯组件部分，是一个很常见有效的做法。\n\n```\nconst globalConfig = {  \n  siteName: &apos;Animals in Zoo&apos;\n}\n\nconst Header = ({ children }) => {  \n  const heading = \n    globalConfig.siteName ? <h1>{globalConfig.siteName}</h1> : null\n  return (\n     <div>\n       {heading}\n       {children}\n     </div>\n  );\n}\n```\n\n这个组件是典型的非纯组件，因为它依赖全局变量 siteName，可能渲染出：\n\n```\n<div>  \n  <h1>Animals in Zoo</h1>\n  Some content\n</div\n```\n\n或者：\n\n```\n<div>  \n  Some content\n</div>\n```\n\n在编写测试用例时，还需要考虑 globalConfig.siteName，使得逻辑更加复杂：\n\n```\nimport assert from &apos;assert&apos;\nimport { shallow } from &apos;enzyme&apos;\nimport { globalConfig } from &apos;./config&apos;\nimport Header from &apos;./Header&apos;\n\ndescribe(&apos;<Header />&apos;, function() {  \n  it(&apos;should render the heading&apos;, function() {\n    const wrapper = shallow(\n      <Header>Some content</Header>\n    )\n    assert(wrapper.contains(<h1>Animals in Zoo</h1>))\n  })\n\n  it(&apos;should not render the heading&apos;, function() {\n    // 改动全局变量\n    globalConfig.siteName = null\n    const wrapper = shallow(\n      <Header>Some content</Header>\n    )\n    assert(appWithHeading.find(&apos;h1&apos;).length === 0)\n  })\n})\n```\n\n在测试 Header 组件时，多了一种 case 不说，我们还需要手动改写全局变量的值。\n\n一个常用的优化方式是使全局变量作为 Header 的 props 出现，而不再是一个外部变量，那么函数式组件 Header 就完全依赖其参数：\n\n```\nconst Header = ({ children, siteName }) => {  \n  const heading = siteName ? <h1>{siteName}</h1> : null;\n  return (\n     <div className=\"header\">\n       {heading}\n       {children}\n     </div>\n  );\n}\n\nHeader.defaultProps = {  \n  siteName: globalConfig.siteName\n}\n```\n\n这样一来 Header 就成了纯组件，测试用例便可以简化为：\n\n```\nimport assert from &apos;assert&apos;\nimport { shallow } from &apos;enzyme&apos; \nimport { Header } from &apos;./Header&apos;;\n\ndescribe(&apos;<Header />&apos;, function() {  \n  it(&apos;should render the heading&apos;, function() {\n    const wrapper = shallow(\n      <Header siteName=\"Animals in Zoo\">Some content</Header>\n    )\n    assert(wrapper.contains(<h1>Animals in Zoo</h1>))\n  });\n\n  it(&apos;should not render the heading&apos;, function() {\n    const wrapper = shallow(\n      <Header siteName={null}>Some content</Header>\n    )\n    assert(appWithHeading.find(&apos;h1&apos;).length === 0)\n  })\n})\n```\n\n且不需再手动改动变量的值，以完成测试逻辑。\n\n另一个重构非纯组件的典型案例就是针对有网络请求的副作用情况，重放我们在组件单一职责中的代码：\n\n```\nimport axios from &apos;axios&apos;\nimport WeatherInfo from &apos;./weatherInfo&apos;\n\nclass WeatherFetch extends Component {  \n  constructor(props) {\n    super(props)\n    this.state = { temperature: &apos;N/A&apos;, windSpeed: &apos;N/A&apos; }\n  }\n\n  componentDidMount() {\n    axios.get(&apos;http://weather.com/api&apos;).then(response => {\n      const { current } = response.data\n      this.setState({\n        temperature: current.temperature,\n        windSpeed: current.windSpeed\n        })\n      })\n  }\n\n  render() {\n    const { temperature, windSpeed } = this.state\n    return (\n      <WeatherInfo temperature={temperature} windSpeed={windSpeed} />\n    )\n  }\n}\n```\n\n从表面上看，WeatherFetch 组件不得不“非纯”，因为网络请求不可避免，但是我们可以将请求的主体逻辑分离出组件，而组件只负责调用请求，这样的操作我称之为“（准）纯组件”：\n\n```\nimport { connect } from &apos;react-redux&apos; \nimport { fetch } from &apos;./action&apos;\n\nexport class WeatherFetch extends Component {  \n   render() {\n     const { temperature, windSpeed } = this.props\n     return (\n       <WeatherInfo temperature={temperature} windSpeed={windSpeed} />\n     )\n   }\n\n   componentDidMount() {\n     this.props.fetch()\n   }\n}\n\nfunction mapStateToProps(state) {  \n  return {\n    temperature: state.temperate,\n    windSpeed: state.windSpeed\n  }\n}\n\nexport default connect(mapStateToProps, { fetch })\n```\n\n我们使用 Redux 来完成，这样一来 WeatherFetch 组件至少可以保证“相同的 props，会渲染相同的结果”。测试也就变得可行：\n\n```\nimport assert from &apos;assert&apos;\nimport { shallow, mount } from &apos;enzyme&apos;\nimport { spy } from &apos;sinon&apos;\n\nimport { WeatherFetch } from &apos;./WeatherFetch&apos;;  \nimport WeatherInfo from &apos;./WeatherInfo&apos;\n\ndescribe(&apos;<WeatherFetch />&apos;, function() {  \n  it(&apos;should render the weather info&apos;, function() {\n    function noop() {}\n    const wrapper = shallow(\n      <WeatherFetch temperature=\"30\" windSpeed=\"10\" fetch={noop} />\n    )\n    assert(wrapper.contains(\n      <WeatherInfo temperature=\"30\" windSpeed=\"10\" />\n    ))\n  });\n\n  it(&apos;should fetch weather when mounted&apos;, function() {\n    const fetchSpy = spy()\n    const wrapper = mount(\n     <WeatherFetch temperature=\"30\" windSpeed=\"10\" fetch={fetchSpy}/>\n    )\n    assert(fetchSpy.calledOnce)\n  })\n})\n```\n\n### <font color=13aa6c>组件可测试性</font>\n\n我们一直在提“可测试性”，上面也出现了测试用例代码，我认为是否具有测试意识，是区别高级和一般程序员的考证之一。\n\n还记得我们在上面提到的 Controls 组件吗？最初实现：\n\n```\nclass App extends Component {  \n  constructor(props) {\n    super(props)\n    this.state = { number: 0 }\n  }\n\n  render() {\n    return (\n      <div className=\"app\"> \n        <span className=\"number\">{this.state.number}</span>\n        <Controls parent={this} />\n      </div>\n    )\n  }\n}\n\nclass Controls extends Component {\n  updateNumber(toAdd) {\n    this.props.parent.setState(prevState => ({\n      number: prevState.number + toAdd       \n    }))\n  }\n\n  render() {\n    return (\n      <div className=\"controls\">\n        <button onClick={() => this.updateNumber(+1)}>\n          Increase\n        </button> \n        <button onClick={() => this.updateNumber(-1)}>\n          Decrease\n        </button>\n      </div>\n    )\n  }\n}\n```\n\n因为 Controls 组件的行为完全依赖其父组件，因此为了测试，我们需要临时构造一个父组件 Temp 来完成：\n\n```\nclass Temp extends Component {  \n  constructor(props) {\n    super(props)\n    this.state = { number: 0 }\n  }\n  render() {\n    return null\n  }\n}\n\ndescribe(&apos;<Controls />&apos;, function() {  \n  it(&apos;should update parent state&apos;, function() {\n    const parent = shallow(<Temp/>)\n    const wrapper = shallow(<Controls parent={parent} />)\n\n    assert(parent.state(&apos;number&apos;) === 0)\n\n    wrapper.find(&apos;button&apos;).at(0).simulate(&apos;click&apos;)\n    assert(parent.state(&apos;number&apos;) === 1)\n\n    wrapper.find(&apos;button&apos;).at(1).simulate(&apos;click&apos;)\n    assert(parent.state(&apos;number&apos;) === 0)\n  });\n});\n```\n\n测试编写的非常痛苦，而经过我们重构之后，变的就非常简单了：\n\n```\nclass App extends Component {  \n  constructor(props) {\n    super(props)\n    this.state = { number: 0 }\n  }\n\n  updateNumber(toAdd) {\n    this.setState(prevState => ({\n      number: prevState.number + toAdd       \n    }))\n  }\n\n  render() {\n    return (\n      <div className=\"app\"> \n        <span className=\"number\">{this.state.number}</span>\n        <Controls \n          onIncrease={() => this.updateNumber(+1)}\n          onDecrease={() => this.updateNumber(-1)} \n        />\n      </div>\n    )\n  }\n}\n\n\nconst Controls = ({ onIncrease, onDecrease }) => {  \n  return (\n    <div className=\"controls\">\n      <button onClick={onIncrease}>Increase</button> \n      <button onClick={onDecrease}>Decrease</button>\n    </div>\n  )\n}\n\ndescribe(&apos;<Controls />&apos;, function() {  \n  it(&apos;should execute callback on buttons click&apos;, function() {\n    const increase = sinon.spy()\n    const descrease = sinon.spy()\n    const wrapper = shallow(\n      <Controls onIncrease={increase} onDecrease={descrease} />\n    )\n\n    wrapper.find(&apos;button&apos;).at(0).simulate(&apos;click&apos;)\n    assert(increase.calledOnce)\n    wrapper.find(&apos;button&apos;).at(1).simulate(&apos;click&apos;)\n    assert(descrease.calledOnce)\n  })\n})\n```\n\n有的开发者觉得“测试不重要”，因此也不用关心组件编写的可测试性。其实我认为，之所以会有程序员认为“测试不重要”，是因为他不具有看待项目的更高视野和角度，也没有编写稳定可靠组件库或其他库的经验。我们要端正态度，想要进阶，就要从态度入手，从掌握一门测试用例的使用入手。\n\n### <font color=13aa6c>组件命名是意识和态度问题</font>\n\n我为什么要把组件命名放在最后一部分呢？因为组件命名太简单了，任何一个开发者只要有意识，能用心，都能完成很好的命名；同时组件命名又太重要了，良好的组件命名就是“行走着的注释”。但意识是一个很虚的概念，有的程序员也许天生就不具备，有的程序员即便具备了，也懒得去琢磨。这里，我不赘述太多道理，读者只需观察两段代码即可，其中第一段，我加了大量的注释辅助：\n\n```\n// <Games> 返回一组 game 信息\n// data 是一个数组，包含了所有 game 信息\nfunction Games({ data }) {  \n  // 选出前 10 条 games\n  const data1 = data.slice(0, 10)\n  // list 是包含了 10 条 games 的 Game 组件集合\n  const list = data1.map(function(v) {\n    // v 代码当前 game\n    return <Game key={v.id} name={v.name} />\n  })\n  return <ul>{list}</ul>\n}\n\n<Games  \n   data=[{ id: 1, name: &apos;Mario&apos; }, { id: 2, name: &apos;Doom&apos; }] \n/>\n```\n\n第二段代码不需要一行注释：\n\n```\nconst GAMES_LIMIT = 10\n\nconst GamesList = ({ items }) => {  \n  const itemsSlice = items.slice(0, GAMES_LIMIT)\n  const games = itemsSlice.map(gameItem => \n    <Game key={gameItem.id} name={gameItem.name} />\n  )\n  return <ul>{games}</ul>\n}\n\n<GamesList  \n  items=[{ id: 1, name: &apos;Mario&apos; }, { id: 2, name: &apos;Doom&apos; }]\n/>\n```\n\n组件设计功力，其实一个命名就能看出来；在做 code review 时，一个命名也能出卖你的深浅。\n\n### <font color=13aa6c>总结</font>\n\n本讲我们剖析了组件设计的基本原则，在原则范畴内，展现了组件的灵活性，并将组件复用性融汇在课程中。其实不光 React 组件如此，任何框架的组件也都是如此，超脱于组件范畴之外，API 设计也应用着相同的原则。这是编程最本质的思想，甚至从某种程度上，在编程之外，原子组建成大千世界的哲学道理都是异曲同工的。\n\n### <font color=13aa6c>分享交流</font>\n\n在阅读文章过程中有任何疑问可随时跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。**你的分享不仅帮助他人，更会提升自己。**\n\n你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。\n\n>**为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。**","pdfUrl":"","reader":"","duration":"","title":"揭秘 React 真谛：组件设计","column":"5c91c813968b1d64b1e08fde","isNotification":false,"readingStatistics":46,"htmlContent":"<p>组件不是 React 特有的概念，但是 React 将组件化的思想发扬光大，可谓用到了极致。良好的组件设计会是良好的应用开发基础，这一讲就让我们谈一谈组件设计的奥秘。</p>\n<p>相关知识点如下：</p>\n<img src=\"https://images.gitbook.cn/684bbbb0-9983-11e9-ae98-dfdddc232198\" width=400>\n<p>我们将以 React 组件为例，但是其中的设计思想具有共性，不管是其他框架还是原生 Web component 都将适用。</p>\n<h3><a id=\"font_color13aa6cfont_8\"></a><font color=13aa6c>单一职责没那么简单</font></h3>\n<p>单一职责我们并不陌生，原则上讲，组件只应该做一件事情。但是对于应用来说，全部组件都拆散，只有单一职责并没有必要，反而增加了编写的繁琐程度。那什么时候需要拆分组件，保证单一职责呢？我认为如果一个功能集合有可能发生变化，那么就需要最大程度地保证单一职责。</p>\n<p>单一职责带来的最大好处就是在修改组件时，能够做到全在掌控下，不必担心对其他组件造成影响。举个例子：我们的组件需要通过网络请求获取数据并展示数据内容，这样一来潜在的功能集合改变就有：</p>\n<ul>\n<li>请求 API 地址发生变化</li>\n<li>请求返回数据格式变化</li>\n<li>开发者想更换网络请求第三方库，比如 jQuery.ajax 改成 axios</li>\n<li>更改请求数据逻辑</li>\n</ul>\n<p>再看一个例子：我们需要一个 table 组件，渲染一个 list，那么潜在更改的可能有：</p>\n<ul>\n<li>限制一次性渲染的 item 个数（只渲染前 10 个，剩下的懒加载）</li>\n<li>当数据列表为空时显示 “This list is empty”</li>\n<li>任何渲染逻辑的更改</li>\n</ul>\n<p>这个图很好地说明了问题：</p>\n<img src=\"https://images.gitbook.cn/49f0c740-9984-11e9-9465-a7e3d006cf60\" width = \"45%\" />\n<p>我们来实际看一个场景：</p>\n<pre><code class=\"lang-\">import axios from &apos;axios&apos;\n\nclass Weather extends Component {  \n  constructor(props) {\n    super(props)\n    this.state = { temperature: &apos;N/A&apos;, windSpeed: &apos;N/A&apos; }\n  }\n\n  componentDidMount() {\n    axios.get(&apos;http://weather.com/api&apos;).then(response =&gt; {\n      const { current } = response.data\n      this.setState({\n        temperature: current.temperature,\n        windSpeed: current.windSpeed\n      })\n    })\n  }\n\n  render() {\n    const { temperature, windSpeed } = this.state\n    return (\n      &lt;div className=&quot;weather&quot;&gt;\n        &lt;div&gt;Temperature: {temperature} °C&lt;/div&gt;\n        &lt;div&gt;Wind: {windSpeed} km/h&lt;/div&gt;\n      &lt;/div&gt;\n    )\n  }\n}\n</code></pre>\n<p>这个组件很容易理解，并且看上去没什么大问题，但是并不符合单一职责。比如这个 Weather 组件将数据获取与渲染逻辑耦合在一起，如果数据请求有变化，就需要在 componentDidMount 生命周期中进行改动；如果展示天气的逻辑有变化，render 方法又需要变动。</p>\n<p>如果我们将这个组件拆分成：WeatherFetch 和 WeatherInfo 两个组件，这两个组件各自只做一件事情，保持单一职责：</p>\n<pre><code class=\"lang-\">import axios from &apos;axios&apos;\nimport WeatherInfo from &apos;./weatherInfo&apos;\n\nclass WeatherFetch extends Component {  \n  constructor(props) {\n    super(props)\n    this.state = { temperature: &apos;N/A&apos;, windSpeed: &apos;N/A&apos; }\n  }\n\n  componentDidMount() {\n    axios.get(&apos;http://weather.com/api&apos;).then(response =&gt; {\n      const { current } = response.data\n      this.setState({\n        temperature: current.temperature,\n        windSpeed: current.windSpeed\n        })\n      })\n  }\n\n  render() {\n    const { temperature, windSpeed } = this.state\n    return (\n      &lt;WeatherInfo temperature={temperature} windSpeed={windSpeed} /&gt;\n    )\n  }\n}\n</code></pre>\n<p>另一个文件中：</p>\n<pre><code class=\"lang-\">const WeatherInfo = ({ temperature, windSpeed }) =&gt; \n  (\n    &lt;div className=&quot;weather&quot;&gt;\n      &lt;div&gt;Temperature: {temperature} °C&lt;/div&gt;\n      &lt;div&gt;Wind: {windSpeed} km/h&lt;/div&gt;\n    &lt;/div&gt;\n  )\n</code></pre>\n<p>如果我们想进行重构，使用 async/await 代替 Promise，只需要直接更改 WeatherFetch 组件：</p>\n<pre><code class=\"lang-\">class WeatherFetch extends Component {  \n  // ...\n\n  async componentDidMount() {\n    const response = await axios.get(&apos;http://weather.com/api&apos;)\n    const { current } = response.data\n\n    this.setState({\n      temperature: current.temperature,\n      windSpeed: current.windSpeed\n      })\n    })\n  }\n\n  // ...\n}\n</code></pre>\n<p>而不会对 WeatherInfo 组件有任何影响。</p>\n<p>或者显示风速的逻辑从 Wind: 0 km/h 改为文字描述 Wind: 风平浪静，也只需要改动 WeatherInfo：</p>\n<pre><code class=\"lang-\">const WeatherInfo = ({ temperature, windSpeed }) =&gt; {\n  const windInfo = windSpeed === 0 ? &apos;calm&apos; : `${windSpeed} km/h`\n  return (\n    &lt;div className=&quot;weather&quot;&gt;\n      &lt;div&gt;Temperature: {temperature} °C&lt;/div&gt;\n      &lt;div&gt;Wind: {windSpeed} km/h&lt;/div&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre>\n<p>这只是一个简单的例子，在真实项目中，保持组件的单一职责将会非常重要，甚至我们可以使用 HoC 强制组件的单一职责性。</p>\n<p>来思考这样的代码：</p>\n<pre><code class=\"lang-\">class PersistentForm extends Component {  \n  constructor(props) {\n    super(props)\n    this.state = { inputValue: localStorage.getItem(&apos;inputValue&apos;) }\n    this.handleChange = this.handleChange.bind(this)\n    this.handleClick = this.handleClick.bind(this)\n  }\n\n  handleChange(event) {\n    this.setState({\n      inputValue: event.target.value\n    })\n  }\n\n  handleClick() {\n    localStorage.setItem(&apos;inputValue&apos;, this.state.inputValue)\n  }\n\n  render() {\n    const { inputValue } = this.state\n    return (\n      &lt;div className=&quot;persistent-form&quot;&gt;\n        &lt;input type=&quot;text&quot; value={inputValue} \n          onChange={this.handleChange}\n        /&gt; \n        &lt;button onClick={this.handleClick}&gt;\n          Save to storage\n        &lt;/button&gt;\n      &lt;/div&gt;\n    )\n  }\n}\n</code></pre>\n<p>这是一个持久化存储的表单，我们将表单字段内容存储在 localStorage 中，这样不管是刷新页面还是重新进入页面，都会保存上一次点击提交时的内容。可惜 PersistentForm 组件也是包含了两部分职责：存储内容和渲染内容。</p>\n<p>这次我们的重构不再是简单的拆分组件，而是使用 HoC 来完成职责单一的实现：</p>\n<pre><code class=\"lang-\">class PersistentForm extends Component {  \n  constructor(props) {\n    super(props)\n    this.state = { inputValue: props.initialValue }\n    this.handleChange = this.handleChange.bind(this)\n    this.handleClick = this.handleClick.bind(this)\n  }\n\n  handleChange(event) {\n    this.setState({\n      inputValue: event.target.value\n    })\n  }\n\n  handleClick() {\n    this.props.saveValue(this.state.inputValue)\n  }\n\n  render() {\n    const { inputValue } = this.state\n    return (\n      &lt;div className=&quot;persistent-form&quot;&gt;\n        &lt;input type=&quot;text&quot; value={inputValue} \n          onChange={this.handleChange}\n        /&gt; \n        &lt;button onClick={this.handleClick}&gt;\n          Save to storage\n        &lt;/button&gt;\n      &lt;/div&gt;\n    )\n  }\n}\n</code></pre>\n<p>我们只是改变了两行代码，初始 state 不再直接读取 localStorage，而是由 this.props.initialValue 提供；handleClick 逻辑调用 this.props.saveValue，而不再直接操作 localStorage，this.props.saveValue 将会由 withPersistence 这个 HoC 提供：</p>\n<pre><code class=\"lang-\">function withPersistence(storageKey, storage) {  \n  return function(WrappedComponent) {\n    return class PersistentComponent extends Component {\n      constructor(props) {\n        super(props)\n        this.state = { initialValue: storage.getItem(storageKey) }\n      }\n\n      render() {\n         return (\n           &lt;WrappedComponent\n             initialValue={this.state.initialValue}\n             saveValue={this.saveValue}\n             {...this.props}\n           /&gt;\n         );\n      }\n\n      saveValue(value) {\n        storage.setItem(storageKey, value)\n      }\n    }\n  }\n}\n</code></pre>\n<p>使用方式：</p>\n<pre><code class=\"lang-\">const LocalStoragePersistentForm  \n  = withPersistence(&apos;key&apos;, localStorage)(PersistentForm)\n</code></pre>\n<p>这种方式是组件单一职责和组件复用的结合体现，其他组件当然也可以使用这个 HoC:</p>\n<pre><code class=\"lang-\">const LocalStorageMyOtherForm  \n  = withPersistence(&apos;key&apos;, localStorage)(MyOtherForm)\n</code></pre>\n<p>存储和渲染职责解耦，我们便可以随时切换存储方式，比如切换为 sessionStorage 代替 localStorage：</p>\n<pre><code class=\"lang-\">const SessionStoragePersistentForm  \n  = withPersistence(&apos;key&apos;, sessionStorage)(PersistentForm)\n</code></pre>\n<h3><a id=\"font_color13aa6cfont_272\"></a><font color=13aa6c>组件通信和封装</font></h3>\n<p>另一个和组件职责单一相关的话题是组件的封装，封装又涉及到组件间的通信。因为我们知道，组件再封装，还是要和其他组件去交互通信的，那么当我们说封装时在说些什么呢？</p>\n<p>组件关联有紧耦合和松耦合之分，紧耦合是指两个或多个组件之间需要了解彼此的组件内设计，这样的情况是我们不想看到的，这破坏了组件的独立性，“牵一发动全身”。这么看来，松耦合带来的好处是很直接的：</p>\n<ul>\n<li>一处组件的改动完全独立，不影响其他组件</li>\n<li>更好的复用设计</li>\n<li>更好的可测试性</li>\n</ul>\n<p>我们直接来看场景代码，一个简单的计数器足以说明问题：</p>\n<pre><code class=\"lang-\">class App extends Component {  \n  constructor(props) {\n    super(props)\n    this.state = { number: 0 }\n  }\n\n  render() {\n    return (\n      &lt;div className=&quot;app&quot;&gt; \n        &lt;span className=&quot;number&quot;&gt;{this.state.number}&lt;/span&gt;\n        &lt;Controls parent={this} /&gt;\n      &lt;/div&gt;\n    )\n  }\n}\n\nclass Controls extends Component {\n  updateNumber(toAdd) {\n    this.props.parent.setState(prevState =&gt; ({\n      number: prevState.number + toAdd       \n    }))\n  }\n\n  render() {\n    return (\n      &lt;div className=&quot;controls&quot;&gt;\n        &lt;button onClick={() =&gt; this.updateNumber(+1)}&gt;\n          Increase\n        &lt;/button&gt; \n        &lt;button onClick={() =&gt; this.updateNumber(-1)}&gt;\n          Decrease\n        &lt;/button&gt;\n      &lt;/div&gt;\n    )\n  }\n}\n</code></pre>\n<p>这样的组件实现问题很明显：App 组件不具有封装性，它将实例传给 Controls 组件，Controls 组件可以直接更改 App state 的内容。事实上，我们并不是不允许 Controls 组件修改 App 组件，只是 Controls 组件直接调用 App 组件的 setState 方法是不被建议的，因为 Controls 组件如果要调用 App 的 setState，就得需要知道 App 组件 state 的结构，需要感知 this.props.parent.state.number 等详情。</p>\n<p>同时上述代码也不利于测试，这个我们将在后面进行说明。那么该如何重构呢？我们应该用更加“含蓄”或者更加“粗暴、直接地”方式修改 number 值。秉承封装性：“只有组件自己知道自己的 state 结构”，将 updateNumber 迁移至 App 组件内：</p>\n<pre><code class=\"lang-\">class App extends Component {  \n  constructor(props) {\n    super(props)\n    this.state = { number: 0 }\n  }\n\n  updateNumber(toAdd) {\n    this.setState(prevState =&gt; ({\n      number: prevState.number + toAdd       \n    }))\n  }\n\n  render() {\n    return (\n      &lt;div className=&quot;app&quot;&gt; \n        &lt;span className=&quot;number&quot;&gt;{this.state.number}&lt;/span&gt;\n        &lt;Controls \n          onIncrease={() =&gt; this.updateNumber(+1)}\n          onDecrease={() =&gt; this.updateNumber(-1)} \n        /&gt;\n      &lt;/div&gt;\n    )\n  }\n}\n\n\nconst Controls = ({ onIncrease, onDecrease }) =&gt; {  \n  return (\n    &lt;div className=&quot;controls&quot;&gt;\n      &lt;button onClick={onIncrease}&gt;Increase&lt;/button&gt; \n      &lt;button onClick={onDecrease}&gt;Decrease&lt;/button&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre>\n<p>这样一来，Controls 组件就不需要再知道 App 组件的内部情况，实现了更好的复用性和可测试性，App 组件因此也具有了更好的封装性。</p>\n<h3><a id=\"font_color13aa6cfont_367\"></a><font color=13aa6c>组合性是灵魂</font></h3>\n<p>如果说组件单一职责确定了如何拆分组件，封装性明确了组件如何组织，那么组合性就完成了整个应用的拼接。</p>\n<p>React 具有天生的组合基因：</p>\n<img src=\"https://images.gitbook.cn/85431690-9984-11e9-ae98-dfdddc232198\" width = \"80%\" />\n<p>对应声明式代码：</p>\n<pre><code class=\"lang-\">const app = (  \n  &lt;Application&gt;\n    &lt;Header /&gt;\n    &lt;Sidebar&gt;\n      &lt;Menu /&gt;\n    &lt;/Sidebar&gt;\n    &lt;Content&gt;\n      &lt;Article /&gt;\n    &lt;/Content&gt;\n    &lt;Footer /&gt;\n  &lt;/Application&gt;\n)\n</code></pre>\n<p>如果两个组件 Composed1 和 Composed2 具有相同的逻辑，我们可以使用组合性进行拆分重组：</p>\n<pre><code class=\"lang-\">const instance1 = (  \n  &lt;Composed1&gt;\n  \t// Composed1 逻辑\n  \t// 重复逻辑\n  &lt;/Composed1&gt;\n)\nconst instance2 = (  \n  &lt;Composed2&gt;\n  \t// 重复逻辑\n  \t// Composed2 逻辑\n  &lt;/Composed2&gt;\n)\n</code></pre>\n<p>重复逻辑提取为 Common 组件：</p>\n<pre><code class=\"lang-\">const instance1 = (  \n  &lt;Composed1&gt;\n    &lt;Logic1 /&gt;\n    &lt;Common /&gt;\n  &lt;/Composed1&gt;\n)\nconst instance2 = (  \n  &lt;Composed2&gt;\n    &lt;Common /&gt;\n    &lt;Logic2 /&gt;\n  &lt;/Composed2&gt;\n)\n</code></pre>\n<p>另外一个典型应用就是 render prop 模式，这个我们前面已经介绍过，这里给出一个很简单的示例，具体不再展开：</p>\n<pre><code class=\"lang-\">const ByDevice = ({ children: { mobile, other } }) =&gt; {  \n  return Utils.isMobile() ? mobile : other\n}\n\n&lt;ByDevice&gt;\n\t{{  \n\t  mobile: &lt;div&gt;Mobile detected!&lt;/div&gt;,\n\t  other:  &lt;div&gt;Not a mobile device&lt;/div&gt;\n\t}}\n&lt;/ByDevice&gt;\n</code></pre>\n<h3><a id=\"font_color13aa6cfont_441\"></a><font color=13aa6c>副作用和（准）纯组件</font></h3>\n<p>纯函数和非纯函数概念大家并不陌生，简单来说，通过函数参数能够唯一确定函数返回值的函数，我们称之为纯函数，反之就是有副作用的非纯函数。纯/非纯函数延伸到组件中，就是纯/非纯组件。</p>\n<p>在理想主义者眼中，最好的情况是应用组件全部由纯组件组成，这样对于组件的调试和强健性非常重要。但这只能是理想情况，在真实环境中，我们需要发送网络请求以获取数据（副作用，因为数据不固定，需要从网络获取），进行条件渲染等操作，如何最大限度地保证纯组件或者（准）纯组件呢？我们先来下一个定义：</p>\n<blockquote>\n<p>（准）纯组件是渲染数据全部来自于 props，但是会产生副作用的组件</p>\n</blockquote>\n<p>从非纯组件中提取纯组件部分，是一个很常见有效的做法。</p>\n<pre><code class=\"lang-\">const globalConfig = {  \n  siteName: &apos;Animals in Zoo&apos;\n}\n\nconst Header = ({ children }) =&gt; {  \n  const heading = \n    globalConfig.siteName ? &lt;h1&gt;{globalConfig.siteName}&lt;/h1&gt; : null\n  return (\n     &lt;div&gt;\n       {heading}\n       {children}\n     &lt;/div&gt;\n  );\n}\n</code></pre>\n<p>这个组件是典型的非纯组件，因为它依赖全局变量 siteName，可能渲染出：</p>\n<pre><code class=\"lang-\">&lt;div&gt;  \n  &lt;h1&gt;Animals in Zoo&lt;/h1&gt;\n  Some content\n&lt;/div\n</code></pre>\n<p>或者：</p>\n<pre><code class=\"lang-\">&lt;div&gt;  \n  Some content\n&lt;/div&gt;\n</code></pre>\n<p>在编写测试用例时，还需要考虑 globalConfig.siteName，使得逻辑更加复杂：</p>\n<pre><code class=\"lang-\">import assert from &apos;assert&apos;\nimport { shallow } from &apos;enzyme&apos;\nimport { globalConfig } from &apos;./config&apos;\nimport Header from &apos;./Header&apos;\n\ndescribe(&apos;&lt;Header /&gt;&apos;, function() {  \n  it(&apos;should render the heading&apos;, function() {\n    const wrapper = shallow(\n      &lt;Header&gt;Some content&lt;/Header&gt;\n    )\n    assert(wrapper.contains(&lt;h1&gt;Animals in Zoo&lt;/h1&gt;))\n  })\n\n  it(&apos;should not render the heading&apos;, function() {\n    // 改动全局变量\n    globalConfig.siteName = null\n    const wrapper = shallow(\n      &lt;Header&gt;Some content&lt;/Header&gt;\n    )\n    assert(appWithHeading.find(&apos;h1&apos;).length === 0)\n  })\n})\n</code></pre>\n<p>在测试 Header 组件时，多了一种 case 不说，我们还需要手动改写全局变量的值。</p>\n<p>一个常用的优化方式是使全局变量作为 Header 的 props 出现，而不再是一个外部变量，那么函数式组件 Header 就完全依赖其参数：</p>\n<pre><code class=\"lang-\">const Header = ({ children, siteName }) =&gt; {  \n  const heading = siteName ? &lt;h1&gt;{siteName}&lt;/h1&gt; : null;\n  return (\n     &lt;div className=&quot;header&quot;&gt;\n       {heading}\n       {children}\n     &lt;/div&gt;\n  );\n}\n\nHeader.defaultProps = {  \n  siteName: globalConfig.siteName\n}\n</code></pre>\n<p>这样一来 Header 就成了纯组件，测试用例便可以简化为：</p>\n<pre><code class=\"lang-\">import assert from &apos;assert&apos;\nimport { shallow } from &apos;enzyme&apos; \nimport { Header } from &apos;./Header&apos;;\n\ndescribe(&apos;&lt;Header /&gt;&apos;, function() {  \n  it(&apos;should render the heading&apos;, function() {\n    const wrapper = shallow(\n      &lt;Header siteName=&quot;Animals in Zoo&quot;&gt;Some content&lt;/Header&gt;\n    )\n    assert(wrapper.contains(&lt;h1&gt;Animals in Zoo&lt;/h1&gt;))\n  });\n\n  it(&apos;should not render the heading&apos;, function() {\n    const wrapper = shallow(\n      &lt;Header siteName={null}&gt;Some content&lt;/Header&gt;\n    )\n    assert(appWithHeading.find(&apos;h1&apos;).length === 0)\n  })\n})\n</code></pre>\n<p>且不需再手动改动变量的值，以完成测试逻辑。</p>\n<p>另一个重构非纯组件的典型案例就是针对有网络请求的副作用情况，重放我们在组件单一职责中的代码：</p>\n<pre><code class=\"lang-\">import axios from &apos;axios&apos;\nimport WeatherInfo from &apos;./weatherInfo&apos;\n\nclass WeatherFetch extends Component {  \n  constructor(props) {\n    super(props)\n    this.state = { temperature: &apos;N/A&apos;, windSpeed: &apos;N/A&apos; }\n  }\n\n  componentDidMount() {\n    axios.get(&apos;http://weather.com/api&apos;).then(response =&gt; {\n      const { current } = response.data\n      this.setState({\n        temperature: current.temperature,\n        windSpeed: current.windSpeed\n        })\n      })\n  }\n\n  render() {\n    const { temperature, windSpeed } = this.state\n    return (\n      &lt;WeatherInfo temperature={temperature} windSpeed={windSpeed} /&gt;\n    )\n  }\n}\n</code></pre>\n<p>从表面上看，WeatherFetch 组件不得不“非纯”，因为网络请求不可避免，但是我们可以将请求的主体逻辑分离出组件，而组件只负责调用请求，这样的操作我称之为“（准）纯组件”：</p>\n<pre><code class=\"lang-\">import { connect } from &apos;react-redux&apos; \nimport { fetch } from &apos;./action&apos;\n\nexport class WeatherFetch extends Component {  \n   render() {\n     const { temperature, windSpeed } = this.props\n     return (\n       &lt;WeatherInfo temperature={temperature} windSpeed={windSpeed} /&gt;\n     )\n   }\n\n   componentDidMount() {\n     this.props.fetch()\n   }\n}\n\nfunction mapStateToProps(state) {  \n  return {\n    temperature: state.temperate,\n    windSpeed: state.windSpeed\n  }\n}\n\nexport default connect(mapStateToProps, { fetch })\n</code></pre>\n<p>我们使用 Redux 来完成，这样一来 WeatherFetch 组件至少可以保证“相同的 props，会渲染相同的结果”。测试也就变得可行：</p>\n<pre><code class=\"lang-\">import assert from &apos;assert&apos;\nimport { shallow, mount } from &apos;enzyme&apos;\nimport { spy } from &apos;sinon&apos;\n\nimport { WeatherFetch } from &apos;./WeatherFetch&apos;;  \nimport WeatherInfo from &apos;./WeatherInfo&apos;\n\ndescribe(&apos;&lt;WeatherFetch /&gt;&apos;, function() {  \n  it(&apos;should render the weather info&apos;, function() {\n    function noop() {}\n    const wrapper = shallow(\n      &lt;WeatherFetch temperature=&quot;30&quot; windSpeed=&quot;10&quot; fetch={noop} /&gt;\n    )\n    assert(wrapper.contains(\n      &lt;WeatherInfo temperature=&quot;30&quot; windSpeed=&quot;10&quot; /&gt;\n    ))\n  });\n\n  it(&apos;should fetch weather when mounted&apos;, function() {\n    const fetchSpy = spy()\n    const wrapper = mount(\n     &lt;WeatherFetch temperature=&quot;30&quot; windSpeed=&quot;10&quot; fetch={fetchSpy}/&gt;\n    )\n    assert(fetchSpy.calledOnce)\n  })\n})\n</code></pre>\n<h3><a id=\"font_color13aa6cfont_649\"></a><font color=13aa6c>组件可测试性</font></h3>\n<p>我们一直在提“可测试性”，上面也出现了测试用例代码，我认为是否具有测试意识，是区别高级和一般程序员的考证之一。</p>\n<p>还记得我们在上面提到的 Controls 组件吗？最初实现：</p>\n<pre><code class=\"lang-\">class App extends Component {  \n  constructor(props) {\n    super(props)\n    this.state = { number: 0 }\n  }\n\n  render() {\n    return (\n      &lt;div className=&quot;app&quot;&gt; \n        &lt;span className=&quot;number&quot;&gt;{this.state.number}&lt;/span&gt;\n        &lt;Controls parent={this} /&gt;\n      &lt;/div&gt;\n    )\n  }\n}\n\nclass Controls extends Component {\n  updateNumber(toAdd) {\n    this.props.parent.setState(prevState =&gt; ({\n      number: prevState.number + toAdd       \n    }))\n  }\n\n  render() {\n    return (\n      &lt;div className=&quot;controls&quot;&gt;\n        &lt;button onClick={() =&gt; this.updateNumber(+1)}&gt;\n          Increase\n        &lt;/button&gt; \n        &lt;button onClick={() =&gt; this.updateNumber(-1)}&gt;\n          Decrease\n        &lt;/button&gt;\n      &lt;/div&gt;\n    )\n  }\n}\n</code></pre>\n<p>因为 Controls 组件的行为完全依赖其父组件，因此为了测试，我们需要临时构造一个父组件 Temp 来完成：</p>\n<pre><code class=\"lang-\">class Temp extends Component {  \n  constructor(props) {\n    super(props)\n    this.state = { number: 0 }\n  }\n  render() {\n    return null\n  }\n}\n\ndescribe(&apos;&lt;Controls /&gt;&apos;, function() {  \n  it(&apos;should update parent state&apos;, function() {\n    const parent = shallow(&lt;Temp/&gt;)\n    const wrapper = shallow(&lt;Controls parent={parent} /&gt;)\n\n    assert(parent.state(&apos;number&apos;) === 0)\n\n    wrapper.find(&apos;button&apos;).at(0).simulate(&apos;click&apos;)\n    assert(parent.state(&apos;number&apos;) === 1)\n\n    wrapper.find(&apos;button&apos;).at(1).simulate(&apos;click&apos;)\n    assert(parent.state(&apos;number&apos;) === 0)\n  });\n});\n</code></pre>\n<p>测试编写的非常痛苦，而经过我们重构之后，变的就非常简单了：</p>\n<pre><code class=\"lang-\">class App extends Component {  \n  constructor(props) {\n    super(props)\n    this.state = { number: 0 }\n  }\n\n  updateNumber(toAdd) {\n    this.setState(prevState =&gt; ({\n      number: prevState.number + toAdd       \n    }))\n  }\n\n  render() {\n    return (\n      &lt;div className=&quot;app&quot;&gt; \n        &lt;span className=&quot;number&quot;&gt;{this.state.number}&lt;/span&gt;\n        &lt;Controls \n          onIncrease={() =&gt; this.updateNumber(+1)}\n          onDecrease={() =&gt; this.updateNumber(-1)} \n        /&gt;\n      &lt;/div&gt;\n    )\n  }\n}\n\n\nconst Controls = ({ onIncrease, onDecrease }) =&gt; {  \n  return (\n    &lt;div className=&quot;controls&quot;&gt;\n      &lt;button onClick={onIncrease}&gt;Increase&lt;/button&gt; \n      &lt;button onClick={onDecrease}&gt;Decrease&lt;/button&gt;\n    &lt;/div&gt;\n  )\n}\n\ndescribe(&apos;&lt;Controls /&gt;&apos;, function() {  \n  it(&apos;should execute callback on buttons click&apos;, function() {\n    const increase = sinon.spy()\n    const descrease = sinon.spy()\n    const wrapper = shallow(\n      &lt;Controls onIncrease={increase} onDecrease={descrease} /&gt;\n    )\n\n    wrapper.find(&apos;button&apos;).at(0).simulate(&apos;click&apos;)\n    assert(increase.calledOnce)\n    wrapper.find(&apos;button&apos;).at(1).simulate(&apos;click&apos;)\n    assert(descrease.calledOnce)\n  })\n})\n</code></pre>\n<p>有的开发者觉得“测试不重要”，因此也不用关心组件编写的可测试性。其实我认为，之所以会有程序员认为“测试不重要”，是因为他不具有看待项目的更高视野和角度，也没有编写稳定可靠组件库或其他库的经验。我们要端正态度，想要进阶，就要从态度入手，从掌握一门测试用例的使用入手。</p>\n<h3><a id=\"font_color13aa6cfont_779\"></a><font color=13aa6c>组件命名是意识和态度问题</font></h3>\n<p>我为什么要把组件命名放在最后一部分呢？因为组件命名太简单了，任何一个开发者只要有意识，能用心，都能完成很好的命名；同时组件命名又太重要了，良好的组件命名就是“行走着的注释”。但意识是一个很虚的概念，有的程序员也许天生就不具备，有的程序员即便具备了，也懒得去琢磨。这里，我不赘述太多道理，读者只需观察两段代码即可，其中第一段，我加了大量的注释辅助：</p>\n<pre><code class=\"lang-\">// &lt;Games&gt; 返回一组 game 信息\n// data 是一个数组，包含了所有 game 信息\nfunction Games({ data }) {  \n  // 选出前 10 条 games\n  const data1 = data.slice(0, 10)\n  // list 是包含了 10 条 games 的 Game 组件集合\n  const list = data1.map(function(v) {\n    // v 代码当前 game\n    return &lt;Game key={v.id} name={v.name} /&gt;\n  })\n  return &lt;ul&gt;{list}&lt;/ul&gt;\n}\n\n&lt;Games  \n   data=[{ id: 1, name: &apos;Mario&apos; }, { id: 2, name: &apos;Doom&apos; }] \n/&gt;\n</code></pre>\n<p>第二段代码不需要一行注释：</p>\n<pre><code class=\"lang-\">const GAMES_LIMIT = 10\n\nconst GamesList = ({ items }) =&gt; {  \n  const itemsSlice = items.slice(0, GAMES_LIMIT)\n  const games = itemsSlice.map(gameItem =&gt; \n    &lt;Game key={gameItem.id} name={gameItem.name} /&gt;\n  )\n  return &lt;ul&gt;{games}&lt;/ul&gt;\n}\n\n&lt;GamesList  \n  items=[{ id: 1, name: &apos;Mario&apos; }, { id: 2, name: &apos;Doom&apos; }]\n/&gt;\n</code></pre>\n<p>组件设计功力，其实一个命名就能看出来；在做 code review 时，一个命名也能出卖你的深浅。</p>\n<h3><a id=\"font_color13aa6cfont_822\"></a><font color=13aa6c>总结</font></h3>\n<p>本讲我们剖析了组件设计的基本原则，在原则范畴内，展现了组件的灵活性，并将组件复用性融汇在课程中。其实不光 React 组件如此，任何框架的组件也都是如此，超脱于组件范畴之外，API 设计也应用着相同的原则。这是编程最本质的思想，甚至从某种程度上，在编程之外，原子组建成大千世界的哲学道理都是异曲同工的。</p>\n<h3><a id=\"font_color13aa6cfont_826\"></a><font color=13aa6c>分享交流</font></h3>\n<p>在阅读文章过程中有任何疑问可随时跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。<strong>你的分享不仅帮助他人，更会提升自己。</strong></p>\n<p>你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。</p>\n<blockquote>\n<p><strong>为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。</strong></p>\n</blockquote>\n","createdAt":"2019-04-21T04:22:12.593Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":18,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FoThASW9dVEPMEo9nP-zaOfbKyLZ"},{"_id":"5cbbf009bbbba80861a35c2b","communication_start_time":null,"type":1,"audioPath":"","abstract":"","content":"如果说组件是 React 应用的骨骼，那么数据就是 React 应用的血液。单向数据流就像血液在应用体中穿梭。处理数据向来不是一件简单的事情，良好的数据状态管理不仅需要经验的积累，更是设计能力的反应。目前来看 Redux 无疑能够将数据状态理清，与此同时 Vue 阵营模仿 Redux 的 Vuex 也起到了相同的效果。这一讲我们就来谈谈数据状态管理，了解 Redux 的真谛，并分析其利弊和上层解决方案。\n\n相关知识点如下：\n\n<img src=\"https://images.gitbook.cn/9e6ec5b0-9b41-11e9-a438-01dafdf3f255\" width=600>\n\n### <font color=13aa6c>数据状态管理之痛</font>\n\n我们先思考一个问题，为什么需要数据状态管理，数据状态管理到底在解决什么样的问题。这其实是框架、组件化带来的概念，让我们回到最初的起点，还是那个简单的案例：\n\n<img src=\"https://images.gitbook.cn/c3fabdc0-9b41-11e9-9fc2-2d8a42344276\" width = \"30%\" />\n\n点击页面中一处“收藏”之后，页面里其他“收藏”按钮也需要切换为“已收藏”状态：\n\n<img src=\"https://images.gitbook.cn/3e2c7ac0-9b42-11e9-a438-01dafdf3f255\" width = \"30%\" />\n\n如果没有数据状态，也许我们需要：\n\n```\nconst btnEle1 = $(&apos;#btn1&apos;)\nconst btnEle2 = $(&apos;#btn2&apos;)\n\nbtnEle1.on(&apos;click&apos;, () => {\n\tif (btnEle.textContent === &apos;已收藏&apos;) {\n\t\treturn\n\t}\n\tbtnEle1.textContent = &apos;已收藏&apos;\n\tbtnEle2.textContent = &apos;已收藏&apos;\n})\n\nbtnEle2.on(&apos;click&apos;, () => {\n\tif (btnEle2.textContent === &apos;已收藏&apos;) {\n\t\treturn\n\t}\n\tbtnEle1.textContent = &apos;已收藏&apos;\n\tbtnEle2.textContent = &apos;已收藏&apos;\n})\n```\n\n这只是两个按钮的情况，处理起来就非常混乱难以维护了，这种情况非常容易滋生 bugs。\n\n现代化的框架解决这个问题的思路是组件化，组件依赖数据，对应这个场景数据状态就是简单的：\n\n```\nhasMarked: false / true\n```\n\n根据这个数据，所有的收藏组件都可以响应正确的视图操作。我们把面条式的代码转换成可维护的代码，重中之重就成了数据的管理，这就是数据状态的雏形。但是数据一旦庞大起来，如何和组件形成良好的交互就是一门学问了。比如我们要思考：\n\n- 一个组件需要和另一个组件共享状态\n- 一个组件需要改变另一个组件的状态\n\n以 React 为例，其他框架类似，如果 React 或者 Vue 自己来维护这些数据，数据状态就是一个对象，并且这个对象在组件之间要互相修改，及其混乱。\n\n接着我们衍生出这样的问题：hasMarked 这类数据到底是应该放在 state 中维护，还是借助数据状态管理类库，比如在 Redux 中维护呢？至少这样一来，数据源是单一的，数据状态和组件是解耦的，也更加方便开发者进行调试和扩展数据。\n\n#### 数据谁来维护？\n\n我们以 React state 和 Redux 为例，继续分析上面抛出的“数据谁来维护？”问题：\n\n- React 中 state 维护数据在组件内部，这样当某项 state 需要与其他组件共享时，我们可以通过 props 来完成组件间通讯。实践上来看，这就需要相对顶层的组件维护共享的 state 并提供修改此项 state 的方法，state 本身和修改方法都需要通过 props 传递给子孙组件。\n\n- 使用 Redux 的时候，state 维护在 Redux store 当中。任何需要访问并更新 state 的组件都需要感知或订阅 Redux store，这通常借助容器组件来完成。Redux 对于数据采用集中管理的方式。\n\n我尝试从数据持久度、数据消费范围上来回答这个问题。\n\n首先，数据持久度上，不同状态数据在持久度上大体可以分为三类：\n\n- 快速变更型\n- 中等持续型\n- 长远稳定型\n\n**快速变更型，** 这类数据在应用中代表了某些原子级别的信息，且显著特点是变更频率最快。比如一个文本输入框数据值，可能随着用户输入在短时间内持续发生变化。这类数据显然更适合维护在 React 组件之内。\n\n**中等持续型数据，** 在用户浏览或使用应用时，这类数据往往会在页面刷新前保持稳定。比如从异步请求接口通过 Ajax 方式得来的数据；又或者用户在个人中心页，编辑信息提交的数据。这类数据较为通用，也许会被不同组件所需求。在 Redux store 中维护，并通过 connect 方法进行连接，是不错的选择。\n\n**长远稳定型数据，** 指在页面多次刷新或者多次访问期间都保持不变的数据。因为 Redux store 会在每次页面挂载后都重新生成一份，因此这种类型的数据显然应该存储在 Redux 以外其他地方，比如服务端数据库或者 local storage。\n\n下面，我们从另一维度：数据消费范围来分析。数据特性体现在消费层面，即有多少组件需要使用。我们以此来区分 React 和 Redux 的不同分工。**广义上，越多组件需要消费同一种数据，那么这种数据维护在 Redux store 当中就越合理；反之，如果某种数据隔离于其他数据，只服务于应用中某单一部分，那么由 React 维护更加合理。**\n\n具体来看，共享的数据在 React 当中，应该存在于高层组件，由此组件进行一层层传递。如果在 props 传递深度上，只需要一两个层级就能满足消费数据的组件需求，这样的跨度是可以接受的；反之，如果跨越层级很多，那么关联到的所有中间层级组件都需要进行接力赛式的传递，这样显然会增加很多乏味的传递代码，也破坏了中间组件的复用性。这个时候，使用 Redux 维护共享状态，合理设置容器组件，通过 connect 来打通数据，就是一种更好的方式。\n\n一些完全不存在父子关系的组件，如果需要共享数据，比如前面提到过的一个页面需要多处展示用户头像。这往往会造成数据辐射分散的问题，对于 React 模式的状态管理十分不利。在这种场景下，使用 Redux 同样是更好的选择。\n\n最后一点，如果你的应用有跟踪状态的功能，比如需要完成“重放”，“返回”或者“Redo/Undo”类似需求，那么 Redux 无疑是最佳选择。因为 Redux 天生擅长于此：每一个 action 都描述了数据状态的改变和更新，数据的集中管理非常方便进行记录。\n\n最后，什么情况下该使用哪种数据管理方式，是 React 维护 state 还是 Redux 集中管理，这个讨论不会有唯一定论。这需要开发者对于 React、Redux 有深入理解，并结合场景需求完成选择。\n\n上面的 Redux 可以被任何一个数据管理类库所取代，也就是说，适合放在 Redux 中的数据，如果开发者没有使用 Redux，而使用了 Mobx，那么也应该放在 Mobx store 中。\n\n#### 数据管理场景\n\n我们来看一个场景来加深理解。\n\n### <font color=13aa6c>Redux 到底怎么用</font>\n\n某电商网站，应用页面骨架如下：\n\n<img src=\"https://images.gitbook.cn/2bbef600-9b43-11e9-9465-a7e3d006cf60\" width = \"50%\" />\n\n对应代码：\n\n```\n<ShoppingApp>\n   <Header />\n   <SideMenu />\n   <ProductsContainer>\n       // 遍历渲染每一个商品\n   </ProductsContainer>\n</ShoppingApp>\n```\n\n其中，ProductsContainer 组件负责渲染每一个商品条目：\n\n```\nimport Product from &apos;./Product&apos;\n\nexport default class ProductsContainer extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      products: [\n        &apos;商品1&apos;,\n        &apos;商品2&apos;,\n        &apos;商品3&apos;\n      ]\n    }\n  }\n  renderProducts() {\n    return this.state.products.map((product) => {\n      return <Product name={product} />\n    })\n  }\n  render() {\n    return (\n      <div className=&apos;products-container&apos;>\n        {this.renderProducts()}\n      </div>\n    )\n  }\n}\n```\n\nProduct 组件作为 UI 组件／展示组件，负责接受数据、展现数据，Product 即可以用函数式／无状态组件完成：\n\n```\nimport React, { Component } from &apos;react&apos;\n\nexport default class Product extends Component {\n  render() {\n    return (\n      <div className=&apos;product&apos;>\n        {this.props.name}\n      </div>\n    )\n  }\n}\n```\n\n这样的设计，完全使用 React state 就可以完成，且合理高效。\n\n但是，如果商品有“立即购买”按钮，点击购买之后加入商品到购物车（对应上面 Cart Info 部分）。这时候需要注意，购物车的商品信息会在更多页面被消费。比如：\n\n- 当前页面右上角需要展示购物车里的商品数目\n- 购物车页面本身\n- 支付前 checkout 页面\n- 支付页面\n\n这就是单页面应用需要对数据状态进行管理的信号：我们维护一个 cartList 数组，供应用消费使用，这个数组放在 Redux 或者 Mobx，或者 Vuex 当中都是可行的。\n\n#### 合理 connect 场景\n\n在使用 Redux 时，我们搭配 React-redux 来对组件和数据进行联通（connect），一个常陷入的误区就是滥用 connect，而没有进行更合理的设计分析。也可能只在顶层进行了 connect 设计，然后再一层层进行数据传递。\n\n比如在一个页面中存在 Profile、Feeds（信息流）、Images（图片）区域，如图所示。\n\n<img src=\"https://images.gitbook.cn/3fe04fd0-9b43-11e9-9fc2-2d8a42344276\" width = \"40%\" />\n\n这些区域构成了页面的主体，它们分别对应于 Profile、Feeds、Images 组件，共同作为 Page 组件的子组件而存在。\n\n```\n<Page>\n    <Profile/>\n    <Feeds/>\n    <Images/>\n</Page>\n```\n\n如果只对 Page 这个顶层组件进行 connect 设计，其他组件的数据依靠 Page 组件进行分发，则设计如图所示：\n\n<img src=\"https://images.gitbook.cn/693a18c0-9b43-11e9-a438-01dafdf3f255\" width = \"60%\" />\n\n这样做存在的问题如下：\n\n- 当改动 Profile 组件中的用户头像时，由于数据变动整个 Page 组件都会重新渲染；\n- 当删除 Feeds 组件中的一条信息时，整个 Page 组件也都会重新渲染；\n- 当在 Images 组件中添加一张图片时，整个 Page 组件同样都会重新渲染。\n\n因此，更好的做法是对 Profile、Feeds、Images 这三个组件分别进行 connect 设计，在 connect 方法中使用 mapStateToProps 筛选出不同组件关心的 state 部分，如图所示：\n\n<img src=\"https://images.gitbook.cn/893fa890-9b45-11e9-9465-a7e3d006cf60\" width = \"60%\" />\n\n这样做的好处很明显：\n\n- 当改动 Profile 组件中的用户头像时，只有 Profile 组件重新渲染；\n- 当删除 Feeds 组件中的一条信息时，只有 Feed 组件重新渲染；\n- 当在 Images 组件中添加一张图片时，只有 Images 组件重新渲染。\n\n#### 扁平化数据状态\n\n扁平化的数据结构是一个很有意义的概念，它不仅能够合理引导开发逻辑，同时也是性能优化的一种体现。请看这样的数据结构：\n\n```\n{\n  articles: [{\n    comments: [{\n      authors: [{\n      }]\n    }]\n  }],\n  ...\n}\n```\n\n不难想象这是一个文章列表加文章评论互动的场景，其对应于三个组件：Article、Comment 和 Author。这样的页面设计比比皆是，如图所示：\n\n<img src=\"https://images.gitbook.cn/b17c8fd0-9b45-11e9-9465-a7e3d006cf60\" width = \"35%\" />\n\n相关 reducer 的处理很棘手，如果 articles[2].comments[4].authors1 发生了变化，想要返回更新后的状态，并保证不可变性，操作起来不是那么简单的，我们需要对深层对象结构进行拷贝或递归。\n\n因此，更好的数据结构设计一定是扁平化的，我们对 articles、comments、authors 进行扁平化处理。例如 comments 数组不再存储 authors 数据，而是记录 userId，需要时在 users 数组中进行提取即可：\n\n```\n{\n  articles: [{\n    ...\n  }],\n  comments: [{\n    articleId: ..,\n    userId: ...,\n    ...\n  }],\n  users: [{\n    ...\n  }]\n}\n```\n\n不同组件只需要关心不同的数据片段，比如 Comment 组件只关心 comments 数组；Author 组件只关心 users 数组。这样不仅操作更合理，而且有效减少了渲染压力。\n\n### <font color=13aa6c>Redux 的罪与罚</font>\n\n前文终点提到了 Redux，其实现原理较为简单，核心代码也不过几行，简要来说：Redux 是我们之前提到的发布订阅模式结合函数式编程的体现。这里不再过多赘述，我们主要来看看以 Redux 为首的数据状态管理类库的“缺陷”和发展点。\n\n其实，Dan Abramov 很早就提到过 “You might not need Redux”，文中提到了 Redux 的限制。他也说过 “Try Mobx” 这种“打脸”行为。归纳一下，Redux 的限制主要体现在：\n\n- Redux 带来了函数式编程、不可变性思想等，为了配合这些理念，开发者必须要写很多“模式代码（boilerplate）”，繁琐以及重复是开发者不愿意容忍的。当然也有很多 hack 旨在减少 boilerplate，但目前阶段，可以说 Redux 天生就附着繁琐。\n- 使用 Redux，那么你的应用就要用 objects 或者 arrays 描述状态。\n- 使用 Redux，那么你的应用就要使用 plain objects 即 actions 来描述变化。\n- 使用 Redux，那么你的应用就要使用纯函数去处理变化。\n- 应用中，状态很多都要抽象到 store，不能痛痛快快地写业务，一个变化就要对应编写 action（action creator）、reducer 等。\n\n这些“缺点”和响应式结合函数式的 Mobx 相比，编程体验被“打了折扣”。\n\n#### Redux 上层解决方案\n\n为了弥补这些缺点，社区开启了一轮又一轮的尝试，其中一个努力方向是基于 Redux 封装一整套上层解决方案，这个方向以 Redux-sage、dva、rematch 类库或框架为主。\n\n我总结一下这些解决方案的特点和思路：\n\n- 简化初始化过程\n\n传统的 Redux 初始化充满了 hack，过于函数式，且较为繁琐：\n\n```\nimport { createStore, applyMiddleware, compose } from &apos;redux&apos;\nimport thunk from &apos;redux-thunk&apos;\nimport rootReducer from &apos;./reducers&apos;\n\n\nconst initialState = {\n\t// ...\n}\n\nconst store = initialState => createStore(\n\trootReducer,\n\tinitialState,\n\tcompose(\n\t\tapplyMiddleware(thunk),\n\t\t// ...\n\t)\n)\n```\n\n这其中我们只应用了一个中间件，还没有涉及到 devtool 的配置。而不论是 Dva 还是其他方案，都采用面向对象式的配置化初始。\n\n- 简化 reducers\n\n传统的 reducers 可能需要写恼人的 switch...case 或很多样板代码，而更上层的解决方案进行封装后，类似：\n\n```\nconst reducer = {\n\tACTIONTYPE1: (state, action) => newState,\n\tACTIONTYPE2: (state, action) => newState,\n}\n```\n\n更加清爽。\n\n- 带请求的副作用\n\n处理网络请求，Redux 一般需要 thunk 中间件，它的原理是：首先 dispatch 一个 action，但是这个 action 不是 plain object 类型，而是一个函数；thunk 中间件发现 action type 为函数类型时，把 dispatch 和 getState 等方法作为参数，传递给函数进行副作用逻辑。\n\n如果读者不是 React、Redux 开发者，也许很难看懂上一段描述，这也是 Redux 处理异步副作用的晦涩体现。更上层的解决方案 Redux-saga 采用 generator 的思想，或 async/await 处理副作用，无疑更加友好合理。\n\n为了更好地配合生成器方案，上层方案将 action 分为普通 action 和副作用 action，开发者使用起来也更加清晰。\n\n- reducer 和 action 合并\n\n为了进一步减少模版代码，一个通用的做法是在 Redux 之上，将 reducer 和 action 声明合并，类似：\n\n```\nconst store = {\n\tstate: {\n\t\tcount: 0,\n\t\tstate1: {}\n\t},\n\treduers: {\n\t\taction1: (state, action) => newState,\n\t\taction2: (state, action) => newState,\n\t}\n}\n```\n\n这样的声明一步到位，我们定义了两个 action：\n\n- action1\n- action2\n\n它们出自于 store.reducers 的键名，而对应键值即为 reducer 逻辑。\n\n这些都是基于 Redux 封装上层解决方案的基本思想，了解了这些，Dva、Redux-saga 原理已经对读者不再陌生！\n\n当然，理清了数据状态管理的意义，简化了数据管理的操作，我们还要分析到底应该如何组织数据。\n\n### <font color=13aa6c>我们到底需要怎样的数据状态管理</font>\n\n关于 Redux，这里不再过多讨论。我们试图脱离开 Redux 本身，思考到底需要什么样的数据状态管理方案。整理我们的核心诉求就是：方便地修改数据，方便地获取数据。\n\n#### 新的发展趋势：Mobx \n\n从核心诉求出发，我们有两种做法：修改数据，Redux 提倡函数式、提倡不可变性、提倡数据扁平化，获取数据说到底是依赖发布订阅模式。相对地，Mobx 是面向对象和响应式的结合，它的数据源是可变的，对数据的观察是响应式的：\n\n```\nconst foo = observable({\n    a: 1,\n    b: 2\n})\n\nautoRun(() => {\n    console.log(foo.a)\n})\n\nfoo.b = 3 // 没有任何输出\nfoo.a = 2 // 输出：2\n```\n\n这像不像我们前面课程提到的数据拦截/代理？没错，它们的原理都是完全一致的。尝试对上面的代码改为：\n\n```\nconst state = observable({\n    state1: {}\n})\n\nautoRun(() => {\n    return (<Component state1={state1} />)\n})\n\nstate.state1 = {} \n```\n\n当我们改动 state.state1 时，autoRun 的回调将会触发，引起了组件的重新渲染。不同于 Redux，这就是另一种流派 Mobx 的核心理念。\n\n不管是 Redux 还是 Mobx，它们都做到了：组件可以读取 state，修改 state；有新 state 时更新。这个 state 是单一数据源，只不过修改 state 方式不同。更近一步地说，Mobx 通过包装对象和数组为可观察对象，隐藏了大部分的样板代码，比 Redux 更加简洁，也更加“魔幻”，更像是“双向绑定”。\n\n对此我的建议是：在数据状态不太复杂的情况下，Mobx 也许更加简洁高效；如果数据状态非常复杂，或者你是函数式编程的粉丝，可以考虑 Redux，但是在 Redux 层上进行封装，使用类似 Dva 方案，是一个明智的选择。\n\n#### 如何做到 Redux free（context 和 hooks）\n\n做到 Redux free，有两种选择：一个是拥抱 Mobx 或者 GraphQL，但还是没有脱离框架或者类库；另一个选择就是选择原生 React 方案，其中之一就是 context API，React 16.3 介绍了稳定版的 context 特性，它从某种程度上可以更方便地实现组件间通信，尤其是对于跨越多层父子组件的情况，更加高效。我们知道 Redux-react 就是基于 context 实现的，那么在一些简单的情况下，完全可以使用稳定的 context，而抛弃 Redux。\n\n在 ReactConf 2018 会议中，React 团队发布了 React hooks。简单来看，hooks 给予了函数式组件像类组件工作的能力，函数式组件可以使用 state，并且在一些副作用后进行 update。useReducer hooks 搭配 context API 以及 useContext hook，完全可以模仿一个简单的 Redux。useReducer hooks 使我们可以像 reducer 的方式一样更新 state，useContext 可以隔层级传递数据，原生 React 似乎有了内置 Redux 的能力。当然这种能力是不全面的，比如对网络请求副作用的管理、时间旅行和调试等。\n\n这不是一篇讲解 React 的课程，具体代码细节我们不再展开，感兴趣的读者可以参考：\n\n- [react hooks VS redux](https://www.reddit.com/r/reactjs/comments/bqf5ot/can_anyone_tell_me_why_hooks_have_exploded/eo6fe6e/?context=10000)\n- [from-redux-to-hooks-case-study](https://staleclosures.dev/from-redux-to-hooks-case-study/)\n\n### <font color=13aa6c>总结</font>\n\n其实数据状态管理没有永恒的“最佳实践”。随着应用业务的发展，数据的复杂程度是不断扩张的，数据和组件是绑定在一起的概念，我们如何梳理好数据，如何对于特定的行为修改特定的数据，给予特定组件特定的数据，是一个非常有趣的话题，也是进阶路上的“必修课”。\n\n### <font color=13aa6c>分享交流</font>\n\n阅读文章过程中有任何疑问可随时跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。**你的分享不仅帮助他人，更会提升自己。**\n\n你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。\n\n>**为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。**","pdfUrl":"","reader":"","duration":"","title":"揭秘 React 真谛：数据状态管理","column":"5c91c813968b1d64b1e08fde","isNotification":false,"readingStatistics":39,"htmlContent":"<p>如果说组件是 React 应用的骨骼，那么数据就是 React 应用的血液。单向数据流就像血液在应用体中穿梭。处理数据向来不是一件简单的事情，良好的数据状态管理不仅需要经验的积累，更是设计能力的反应。目前来看 Redux 无疑能够将数据状态理清，与此同时 Vue 阵营模仿 Redux 的 Vuex 也起到了相同的效果。这一讲我们就来谈谈数据状态管理，了解 Redux 的真谛，并分析其利弊和上层解决方案。</p>\n<p>相关知识点如下：</p>\n<img src=\"https://images.gitbook.cn/9e6ec5b0-9b41-11e9-a438-01dafdf3f255\" width=600>\n<h3><a id=\"font_color13aa6cfont_6\"></a><font color=13aa6c>数据状态管理之痛</font></h3>\n<p>我们先思考一个问题，为什么需要数据状态管理，数据状态管理到底在解决什么样的问题。这其实是框架、组件化带来的概念，让我们回到最初的起点，还是那个简单的案例：</p>\n<img src=\"https://images.gitbook.cn/c3fabdc0-9b41-11e9-9fc2-2d8a42344276\" width = \"30%\" />\n<p>点击页面中一处“收藏”之后，页面里其他“收藏”按钮也需要切换为“已收藏”状态：</p>\n<img src=\"https://images.gitbook.cn/3e2c7ac0-9b42-11e9-a438-01dafdf3f255\" width = \"30%\" />\n<p>如果没有数据状态，也许我们需要：</p>\n<pre><code class=\"lang-\">const btnEle1 = $(&apos;#btn1&apos;)\nconst btnEle2 = $(&apos;#btn2&apos;)\n\nbtnEle1.on(&apos;click&apos;, () =&gt; {\n\tif (btnEle.textContent === &apos;已收藏&apos;) {\n\t\treturn\n\t}\n\tbtnEle1.textContent = &apos;已收藏&apos;\n\tbtnEle2.textContent = &apos;已收藏&apos;\n})\n\nbtnEle2.on(&apos;click&apos;, () =&gt; {\n\tif (btnEle2.textContent === &apos;已收藏&apos;) {\n\t\treturn\n\t}\n\tbtnEle1.textContent = &apos;已收藏&apos;\n\tbtnEle2.textContent = &apos;已收藏&apos;\n})\n</code></pre>\n<p>这只是两个按钮的情况，处理起来就非常混乱难以维护了，这种情况非常容易滋生 bugs。</p>\n<p>现代化的框架解决这个问题的思路是组件化，组件依赖数据，对应这个场景数据状态就是简单的：</p>\n<pre><code class=\"lang-\">hasMarked: false / true\n</code></pre>\n<p>根据这个数据，所有的收藏组件都可以响应正确的视图操作。我们把面条式的代码转换成可维护的代码，重中之重就成了数据的管理，这就是数据状态的雏形。但是数据一旦庞大起来，如何和组件形成良好的交互就是一门学问了。比如我们要思考：</p>\n<ul>\n<li>一个组件需要和另一个组件共享状态</li>\n<li>一个组件需要改变另一个组件的状态</li>\n</ul>\n<p>以 React 为例，其他框架类似，如果 React 或者 Vue 自己来维护这些数据，数据状态就是一个对象，并且这个对象在组件之间要互相修改，及其混乱。</p>\n<p>接着我们衍生出这样的问题：hasMarked 这类数据到底是应该放在 state 中维护，还是借助数据状态管理类库，比如在 Redux 中维护呢？至少这样一来，数据源是单一的，数据状态和组件是解耦的，也更加方便开发者进行调试和扩展数据。</p>\n<h4><a id=\"_56\"></a>数据谁来维护？</h4>\n<p>我们以 React state 和 Redux 为例，继续分析上面抛出的“数据谁来维护？”问题：</p>\n<ul>\n<li>\n<p>React 中 state 维护数据在组件内部，这样当某项 state 需要与其他组件共享时，我们可以通过 props 来完成组件间通讯。实践上来看，这就需要相对顶层的组件维护共享的 state 并提供修改此项 state 的方法，state 本身和修改方法都需要通过 props 传递给子孙组件。</p>\n</li>\n<li>\n<p>使用 Redux 的时候，state 维护在 Redux store 当中。任何需要访问并更新 state 的组件都需要感知或订阅 Redux store，这通常借助容器组件来完成。Redux 对于数据采用集中管理的方式。</p>\n</li>\n</ul>\n<p>我尝试从数据持久度、数据消费范围上来回答这个问题。</p>\n<p>首先，数据持久度上，不同状态数据在持久度上大体可以分为三类：</p>\n<ul>\n<li>快速变更型</li>\n<li>中等持续型</li>\n<li>长远稳定型</li>\n</ul>\n<p><strong>快速变更型，</strong> 这类数据在应用中代表了某些原子级别的信息，且显著特点是变更频率最快。比如一个文本输入框数据值，可能随着用户输入在短时间内持续发生变化。这类数据显然更适合维护在 React 组件之内。</p>\n<p><strong>中等持续型数据，</strong> 在用户浏览或使用应用时，这类数据往往会在页面刷新前保持稳定。比如从异步请求接口通过 Ajax 方式得来的数据；又或者用户在个人中心页，编辑信息提交的数据。这类数据较为通用，也许会被不同组件所需求。在 Redux store 中维护，并通过 connect 方法进行连接，是不错的选择。</p>\n<p><strong>长远稳定型数据，</strong> 指在页面多次刷新或者多次访问期间都保持不变的数据。因为 Redux store 会在每次页面挂载后都重新生成一份，因此这种类型的数据显然应该存储在 Redux 以外其他地方，比如服务端数据库或者 local storage。</p>\n<p>下面，我们从另一维度：数据消费范围来分析。数据特性体现在消费层面，即有多少组件需要使用。我们以此来区分 React 和 Redux 的不同分工。<strong>广义上，越多组件需要消费同一种数据，那么这种数据维护在 Redux store 当中就越合理；反之，如果某种数据隔离于其他数据，只服务于应用中某单一部分，那么由 React 维护更加合理。</strong></p>\n<p>具体来看，共享的数据在 React 当中，应该存在于高层组件，由此组件进行一层层传递。如果在 props 传递深度上，只需要一两个层级就能满足消费数据的组件需求，这样的跨度是可以接受的；反之，如果跨越层级很多，那么关联到的所有中间层级组件都需要进行接力赛式的传递，这样显然会增加很多乏味的传递代码，也破坏了中间组件的复用性。这个时候，使用 Redux 维护共享状态，合理设置容器组件，通过 connect 来打通数据，就是一种更好的方式。</p>\n<p>一些完全不存在父子关系的组件，如果需要共享数据，比如前面提到过的一个页面需要多处展示用户头像。这往往会造成数据辐射分散的问题，对于 React 模式的状态管理十分不利。在这种场景下，使用 Redux 同样是更好的选择。</p>\n<p>最后一点，如果你的应用有跟踪状态的功能，比如需要完成“重放”，“返回”或者“Redo/Undo”类似需求，那么 Redux 无疑是最佳选择。因为 Redux 天生擅长于此：每一个 action 都描述了数据状态的改变和更新，数据的集中管理非常方便进行记录。</p>\n<p>最后，什么情况下该使用哪种数据管理方式，是 React 维护 state 还是 Redux 集中管理，这个讨论不会有唯一定论。这需要开发者对于 React、Redux 有深入理解，并结合场景需求完成选择。</p>\n<p>上面的 Redux 可以被任何一个数据管理类库所取代，也就是说，适合放在 Redux 中的数据，如果开发者没有使用 Redux，而使用了 Mobx，那么也应该放在 Mobx store 中。</p>\n<h4><a id=\"_90\"></a>数据管理场景</h4>\n<p>我们来看一个场景来加深理解。</p>\n<h3><a id=\"font_color13aa6cRedux_font_94\"></a><font color=13aa6c>Redux 到底怎么用</font></h3>\n<p>某电商网站，应用页面骨架如下：</p>\n<img src=\"https://images.gitbook.cn/2bbef600-9b43-11e9-9465-a7e3d006cf60\" width = \"50%\" />\n<p>对应代码：</p>\n<pre><code class=\"lang-\">&lt;ShoppingApp&gt;\n   &lt;Header /&gt;\n   &lt;SideMenu /&gt;\n   &lt;ProductsContainer&gt;\n       // 遍历渲染每一个商品\n   &lt;/ProductsContainer&gt;\n&lt;/ShoppingApp&gt;\n</code></pre>\n<p>其中，ProductsContainer 组件负责渲染每一个商品条目：</p>\n<pre><code class=\"lang-\">import Product from &apos;./Product&apos;\n\nexport default class ProductsContainer extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      products: [\n        &apos;商品1&apos;,\n        &apos;商品2&apos;,\n        &apos;商品3&apos;\n      ]\n    }\n  }\n  renderProducts() {\n    return this.state.products.map((product) =&gt; {\n      return &lt;Product name={product} /&gt;\n    })\n  }\n  render() {\n    return (\n      &lt;div className=&apos;products-container&apos;&gt;\n        {this.renderProducts()}\n      &lt;/div&gt;\n    )\n  }\n}\n</code></pre>\n<p>Product 组件作为 UI 组件／展示组件，负责接受数据、展现数据，Product 即可以用函数式／无状态组件完成：</p>\n<pre><code class=\"lang-\">import React, { Component } from &apos;react&apos;\n\nexport default class Product extends Component {\n  render() {\n    return (\n      &lt;div className=&apos;product&apos;&gt;\n        {this.props.name}\n      &lt;/div&gt;\n    )\n  }\n}\n</code></pre>\n<p>这样的设计，完全使用 React state 就可以完成，且合理高效。</p>\n<p>但是，如果商品有“立即购买”按钮，点击购买之后加入商品到购物车（对应上面 Cart Info 部分）。这时候需要注意，购物车的商品信息会在更多页面被消费。比如：</p>\n<ul>\n<li>当前页面右上角需要展示购物车里的商品数目</li>\n<li>购物车页面本身</li>\n<li>支付前 checkout 页面</li>\n<li>支付页面</li>\n</ul>\n<p>这就是单页面应用需要对数据状态进行管理的信号：我们维护一个 cartList 数组，供应用消费使用，这个数组放在 Redux 或者 Mobx，或者 Vuex 当中都是可行的。</p>\n<h4><a id=\"_connect__170\"></a>合理 connect 场景</h4>\n<p>在使用 Redux 时，我们搭配 React-redux 来对组件和数据进行联通（connect），一个常陷入的误区就是滥用 connect，而没有进行更合理的设计分析。也可能只在顶层进行了 connect 设计，然后再一层层进行数据传递。</p>\n<p>比如在一个页面中存在 Profile、Feeds（信息流）、Images（图片）区域，如图所示。</p>\n<img src=\"https://images.gitbook.cn/3fe04fd0-9b43-11e9-9fc2-2d8a42344276\" width = \"40%\" />\n<p>这些区域构成了页面的主体，它们分别对应于 Profile、Feeds、Images 组件，共同作为 Page 组件的子组件而存在。</p>\n<pre><code class=\"lang-\">&lt;Page&gt;\n    &lt;Profile/&gt;\n    &lt;Feeds/&gt;\n    &lt;Images/&gt;\n&lt;/Page&gt;\n</code></pre>\n<p>如果只对 Page 这个顶层组件进行 connect 设计，其他组件的数据依靠 Page 组件进行分发，则设计如图所示：</p>\n<img src=\"https://images.gitbook.cn/693a18c0-9b43-11e9-a438-01dafdf3f255\" width = \"60%\" />\n<p>这样做存在的问题如下：</p>\n<ul>\n<li>当改动 Profile 组件中的用户头像时，由于数据变动整个 Page 组件都会重新渲染；</li>\n<li>当删除 Feeds 组件中的一条信息时，整个 Page 组件也都会重新渲染；</li>\n<li>当在 Images 组件中添加一张图片时，整个 Page 组件同样都会重新渲染。</li>\n</ul>\n<p>因此，更好的做法是对 Profile、Feeds、Images 这三个组件分别进行 connect 设计，在 connect 方法中使用 mapStateToProps 筛选出不同组件关心的 state 部分，如图所示：</p>\n<img src=\"https://images.gitbook.cn/893fa890-9b45-11e9-9465-a7e3d006cf60\" width = \"60%\" />\n<p>这样做的好处很明显：</p>\n<ul>\n<li>当改动 Profile 组件中的用户头像时，只有 Profile 组件重新渲染；</li>\n<li>当删除 Feeds 组件中的一条信息时，只有 Feed 组件重新渲染；</li>\n<li>当在 Images 组件中添加一张图片时，只有 Images 组件重新渲染。</li>\n</ul>\n<h4><a id=\"_208\"></a>扁平化数据状态</h4>\n<p>扁平化的数据结构是一个很有意义的概念，它不仅能够合理引导开发逻辑，同时也是性能优化的一种体现。请看这样的数据结构：</p>\n<pre><code class=\"lang-\">{\n  articles: [{\n    comments: [{\n      authors: [{\n      }]\n    }]\n  }],\n  ...\n}\n</code></pre>\n<p>不难想象这是一个文章列表加文章评论互动的场景，其对应于三个组件：Article、Comment 和 Author。这样的页面设计比比皆是，如图所示：</p>\n<img src=\"https://images.gitbook.cn/b17c8fd0-9b45-11e9-9465-a7e3d006cf60\" width = \"35%\" />\n<p>相关 reducer 的处理很棘手，如果 articles[2].comments[4].authors1 发生了变化，想要返回更新后的状态，并保证不可变性，操作起来不是那么简单的，我们需要对深层对象结构进行拷贝或递归。</p>\n<p>因此，更好的数据结构设计一定是扁平化的，我们对 articles、comments、authors 进行扁平化处理。例如 comments 数组不再存储 authors 数据，而是记录 userId，需要时在 users 数组中进行提取即可：</p>\n<pre><code class=\"lang-\">{\n  articles: [{\n    ...\n  }],\n  comments: [{\n    articleId: ..,\n    userId: ...,\n    ...\n  }],\n  users: [{\n    ...\n  }]\n}\n</code></pre>\n<p>不同组件只需要关心不同的数据片段，比如 Comment 组件只关心 comments 数组；Author 组件只关心 users 数组。这样不仅操作更合理，而且有效减少了渲染压力。</p>\n<h3><a id=\"font_color13aa6cRedux_font_250\"></a><font color=13aa6c>Redux 的罪与罚</font></h3>\n<p>前文终点提到了 Redux，其实现原理较为简单，核心代码也不过几行，简要来说：Redux 是我们之前提到的发布订阅模式结合函数式编程的体现。这里不再过多赘述，我们主要来看看以 Redux 为首的数据状态管理类库的“缺陷”和发展点。</p>\n<p>其实，Dan Abramov 很早就提到过 “You might not need Redux”，文中提到了 Redux 的限制。他也说过 “Try Mobx” 这种“打脸”行为。归纳一下，Redux 的限制主要体现在：</p>\n<ul>\n<li>Redux 带来了函数式编程、不可变性思想等，为了配合这些理念，开发者必须要写很多“模式代码（boilerplate）”，繁琐以及重复是开发者不愿意容忍的。当然也有很多 hack 旨在减少 boilerplate，但目前阶段，可以说 Redux 天生就附着繁琐。</li>\n<li>使用 Redux，那么你的应用就要用 objects 或者 arrays 描述状态。</li>\n<li>使用 Redux，那么你的应用就要使用 plain objects 即 actions 来描述变化。</li>\n<li>使用 Redux，那么你的应用就要使用纯函数去处理变化。</li>\n<li>应用中，状态很多都要抽象到 store，不能痛痛快快地写业务，一个变化就要对应编写 action（action creator）、reducer 等。</li>\n</ul>\n<p>这些“缺点”和响应式结合函数式的 Mobx 相比，编程体验被“打了折扣”。</p>\n<h4><a id=\"Redux__264\"></a>Redux 上层解决方案</h4>\n<p>为了弥补这些缺点，社区开启了一轮又一轮的尝试，其中一个努力方向是基于 Redux 封装一整套上层解决方案，这个方向以 Redux-sage、dva、rematch 类库或框架为主。</p>\n<p>我总结一下这些解决方案的特点和思路：</p>\n<ul>\n<li>简化初始化过程</li>\n</ul>\n<p>传统的 Redux 初始化充满了 hack，过于函数式，且较为繁琐：</p>\n<pre><code class=\"lang-\">import { createStore, applyMiddleware, compose } from &apos;redux&apos;\nimport thunk from &apos;redux-thunk&apos;\nimport rootReducer from &apos;./reducers&apos;\n\n\nconst initialState = {\n\t// ...\n}\n\nconst store = initialState =&gt; createStore(\n\trootReducer,\n\tinitialState,\n\tcompose(\n\t\tapplyMiddleware(thunk),\n\t\t// ...\n\t)\n)\n</code></pre>\n<p>这其中我们只应用了一个中间件，还没有涉及到 devtool 的配置。而不论是 Dva 还是其他方案，都采用面向对象式的配置化初始。</p>\n<ul>\n<li>简化 reducers</li>\n</ul>\n<p>传统的 reducers 可能需要写恼人的 switch…case 或很多样板代码，而更上层的解决方案进行封装后，类似：</p>\n<pre><code class=\"lang-\">const reducer = {\n\tACTIONTYPE1: (state, action) =&gt; newState,\n\tACTIONTYPE2: (state, action) =&gt; newState,\n}\n</code></pre>\n<p>更加清爽。</p>\n<ul>\n<li>带请求的副作用</li>\n</ul>\n<p>处理网络请求，Redux 一般需要 thunk 中间件，它的原理是：首先 dispatch 一个 action，但是这个 action 不是 plain object 类型，而是一个函数；thunk 中间件发现 action type 为函数类型时，把 dispatch 和 getState 等方法作为参数，传递给函数进行副作用逻辑。</p>\n<p>如果读者不是 React、Redux 开发者，也许很难看懂上一段描述，这也是 Redux 处理异步副作用的晦涩体现。更上层的解决方案 Redux-saga 采用 generator 的思想，或 async/await 处理副作用，无疑更加友好合理。</p>\n<p>为了更好地配合生成器方案，上层方案将 action 分为普通 action 和副作用 action，开发者使用起来也更加清晰。</p>\n<ul>\n<li>reducer 和 action 合并</li>\n</ul>\n<p>为了进一步减少模版代码，一个通用的做法是在 Redux 之上，将 reducer 和 action 声明合并，类似：</p>\n<pre><code class=\"lang-\">const store = {\n\tstate: {\n\t\tcount: 0,\n\t\tstate1: {}\n\t},\n\treduers: {\n\t\taction1: (state, action) =&gt; newState,\n\t\taction2: (state, action) =&gt; newState,\n\t}\n}\n</code></pre>\n<p>这样的声明一步到位，我们定义了两个 action：</p>\n<ul>\n<li>action1</li>\n<li>action2</li>\n</ul>\n<p>它们出自于 store.reducers 的键名，而对应键值即为 reducer 逻辑。</p>\n<p>这些都是基于 Redux 封装上层解决方案的基本思想，了解了这些，Dva、Redux-saga 原理已经对读者不再陌生！</p>\n<p>当然，理清了数据状态管理的意义，简化了数据管理的操作，我们还要分析到底应该如何组织数据。</p>\n<h3><a id=\"font_color13aa6cfont_345\"></a><font color=13aa6c>我们到底需要怎样的数据状态管理</font></h3>\n<p>关于 Redux，这里不再过多讨论。我们试图脱离开 Redux 本身，思考到底需要什么样的数据状态管理方案。整理我们的核心诉求就是：方便地修改数据，方便地获取数据。</p>\n<h4><a id=\"Mobx_349\"></a>新的发展趋势：Mobx</h4>\n<p>从核心诉求出发，我们有两种做法：修改数据，Redux 提倡函数式、提倡不可变性、提倡数据扁平化，获取数据说到底是依赖发布订阅模式。相对地，Mobx 是面向对象和响应式的结合，它的数据源是可变的，对数据的观察是响应式的：</p>\n<pre><code class=\"lang-\">const foo = observable({\n    a: 1,\n    b: 2\n})\n\nautoRun(() =&gt; {\n    console.log(foo.a)\n})\n\nfoo.b = 3 // 没有任何输出\nfoo.a = 2 // 输出：2\n</code></pre>\n<p>这像不像我们前面课程提到的数据拦截/代理？没错，它们的原理都是完全一致的。尝试对上面的代码改为：</p>\n<pre><code class=\"lang-\">const state = observable({\n    state1: {}\n})\n\nautoRun(() =&gt; {\n    return (&lt;Component state1={state1} /&gt;)\n})\n\nstate.state1 = {} \n</code></pre>\n<p>当我们改动 state.state1 时，autoRun 的回调将会触发，引起了组件的重新渲染。不同于 Redux，这就是另一种流派 Mobx 的核心理念。</p>\n<p>不管是 Redux 还是 Mobx，它们都做到了：组件可以读取 state，修改 state；有新 state 时更新。这个 state 是单一数据源，只不过修改 state 方式不同。更近一步地说，Mobx 通过包装对象和数组为可观察对象，隐藏了大部分的样板代码，比 Redux 更加简洁，也更加“魔幻”，更像是“双向绑定”。</p>\n<p>对此我的建议是：在数据状态不太复杂的情况下，Mobx 也许更加简洁高效；如果数据状态非常复杂，或者你是函数式编程的粉丝，可以考虑 Redux，但是在 Redux 层上进行封装，使用类似 Dva 方案，是一个明智的选择。</p>\n<h4><a id=\"_Redux_freecontext__hooks_387\"></a>如何做到 Redux free（context 和 hooks）</h4>\n<p>做到 Redux free，有两种选择：一个是拥抱 Mobx 或者 GraphQL，但还是没有脱离框架或者类库；另一个选择就是选择原生 React 方案，其中之一就是 context API，React 16.3 介绍了稳定版的 context 特性，它从某种程度上可以更方便地实现组件间通信，尤其是对于跨越多层父子组件的情况，更加高效。我们知道 Redux-react 就是基于 context 实现的，那么在一些简单的情况下，完全可以使用稳定的 context，而抛弃 Redux。</p>\n<p>在 ReactConf 2018 会议中，React 团队发布了 React hooks。简单来看，hooks 给予了函数式组件像类组件工作的能力，函数式组件可以使用 state，并且在一些副作用后进行 update。useReducer hooks 搭配 context API 以及 useContext hook，完全可以模仿一个简单的 Redux。useReducer hooks 使我们可以像 reducer 的方式一样更新 state，useContext 可以隔层级传递数据，原生 React 似乎有了内置 Redux 的能力。当然这种能力是不全面的，比如对网络请求副作用的管理、时间旅行和调试等。</p>\n<p>这不是一篇讲解 React 的课程，具体代码细节我们不再展开，感兴趣的读者可以参考：</p>\n<ul>\n<li><a href=\"https://www.reddit.com/r/reactjs/comments/bqf5ot/can_anyone_tell_me_why_hooks_have_exploded/eo6fe6e/?context=10000\" target=\"_blank\">react hooks VS redux</a></li>\n<li><a href=\"https://staleclosures.dev/from-redux-to-hooks-case-study/\" target=\"_blank\">from-redux-to-hooks-case-study</a></li>\n</ul>\n<h3><a id=\"font_color13aa6cfont_398\"></a><font color=13aa6c>总结</font></h3>\n<p>其实数据状态管理没有永恒的“最佳实践”。随着应用业务的发展，数据的复杂程度是不断扩张的，数据和组件是绑定在一起的概念，我们如何梳理好数据，如何对于特定的行为修改特定的数据，给予特定组件特定的数据，是一个非常有趣的话题，也是进阶路上的“必修课”。</p>\n<h3><a id=\"font_color13aa6cfont_402\"></a><font color=13aa6c>分享交流</font></h3>\n<p>阅读文章过程中有任何疑问可随时跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。<strong>你的分享不仅帮助他人，更会提升自己。</strong></p>\n<p>你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。</p>\n<blockquote>\n<p><strong>为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。</strong></p>\n</blockquote>\n","createdAt":"2019-04-21T04:22:33.689Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":19,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FoThASW9dVEPMEo9nP-zaOfbKyLZ"},{"_id":"5cbbf035bbbba80861a35c2c","communication_start_time":null,"type":1,"audioPath":"","abstract":"","content":"React 自推出以来，一直进行着自身完善和演进。作为 React 开发者或前端开发者，有幸见证着一个伟大“框架”的成长，是非常幸运的。那么在这个过程中，我们应该学些什么？React 现在处于什么发展阶段？React 未来又将有哪些规划？\n\n高级前端工程师不能只停留在使用框架上，我们自然要思考上述这些问题。这一讲我们就来聊聊 React 的现状与未来，如果不熟悉 React，也并不妨碍大家阅读。\n\n相关知识点如下：\n\n<img src=\"https://images.gitbook.cn/3acdade0-9d3b-11e9-9eee-292fd7e6afca\" width=600>\n\n### <font color=13aa6c>React 现状分析</font>\n\nReact 经过几年的打磨，目前维持了一个稳定的迭代周期，并不断给开发者带来惊喜。其中难能可贵的是在 breaking changes 不多的前提下，仍在持续输出具有变革精神的特性，保持着旺盛的生命力。不管是什么平台的调查，都显示 React 受众仍然最多，可以预见的是，React 未来仍将会统领前端发展。\n\n关于 React 现状，我总结出以下几个特点：\n\n- 开发模式已经定型，有利于开发者持续学习\n- 仍然有强大的开发团队维护，不断带来改变，这些改变一方面使 React 更好，另一方面甚至推动了 JavaScript 语言的发展\n- 社区生态强大，有一系列解决方案，数据状态管理、组件库、服务端渲染生态群百花齐放\n\n在这些特点的背后，也有一些让开发者担忧的地方：\n\n- 概念越来越多。一定程度上，新老概念并存，学习曲线激增\n- 存在较多 unsafe_ 标记的 APIs，始终担忧彻底废弃相关 APIs 那一天的到来\n- 新特性带来了较多“魔法”，也带来了一些困惑\n\n当然，这些让开发者担忧的地方并不足以和 React 的强大相提并论，这些“问题”甚至在任何一个框架中都会存在。因此，我建议不管是工作需要，还是自身学习需要，前端开发者都可以使用并研究 React。\n\n### <font color=13aa6c>从 React Component 看 React 发展史</font>\n\n回顾 React 发展历史，很多 APIs 和特性的演进都很有意思，比如 refs、context，其中任何一点都值得单拎出来深入分析。但是我挑选了一个开发者一定会使用的 React Component 话题：从组件的创建和声明方式，我们来看一个框架的变革，并由此引出 React 目前最受关注的的 hooks 新特性。\n\nReact Component 的发展主要经历了三个阶段：\n\n- createClass 创建组件时期\n- ES class 声明组件时期\n- 无状态（函数式）组件 + React hooks 时期\n\n这一路，也是 React 从一个纯粹的视图层类库走向成熟完善的解决方案的过程。我们逐一来看。\n\n#### createClass 创建组件时期\n\n相信很多新的开发者都没有使用过 createClass API 创建组件，createClass 是一个函数，接受参数并返回组件实例，用起来并不复杂：\n\n```\nimport React from &apos;react&apos;\n\nconst component1 = React.createClass({\n  propTypes: {\n    foo: React.PropTypes.string\n  },\n  \n  getDefaultProps() {\n    return {\n\t\tfoo: &apos;bar&apos;\n    }\n  },\n  \n\n  getInitialState() { \n  \treturn {\n\t  state1: &apos;lucas&apos;\n\t}\n  },\n  \n  handleClick() {\n  \n  },\n\t\n  render() {\n    return (\n      <p onClick={this.handleClick}></p>\n    )\n  }\n})\n```\n\n看起来很好理解，但是编写还是有些违背直觉。从 React 15.5 版本开始，官方就不再开始推荐，到了 React 16 版本，已经彻底废弃。\n\n#### Class 声明组件时期\n\ncreateClass 退出历史舞台的原因是被强势的 class 声明组件方式所取代。当时 ES6 正在如火如荼地发展，新增了 class 这一语法糖，React 团队很快赶时髦，支持了使用 class 声明组件的方式：\n\n```\nclass Component1 extends React.Component {\n  state = { name: &apos;Lucas&apos; }\n  \n  handleClick = e => {\n    console.log(e)\n    this.setState({\n      name: &apos;Messi&apos;,\n    })\n  }\n  \n  render() {\n    return (\n      <div onClick={this.handleClick}>\n        {{this.state.name}}\n      </div>\n    )\n  }\n}\n```\n\n代码非常直观清爽，但是 class 声明方式和早期的 createClass 相比，有非常重要的两点差别：\n\n- React.createClass 支持在事件处理函数中自动绑定 this，而 class 声明的组件需要开发者手动绑定\n- React.Component 不能使用 React mixins 来实现复用\n\n这两个显著不同点决定了 React 生态社区发展的方向。\n\n其中第一点不同，决定了 React 放弃了“多管闲事”地绑定 this，虽然这个行为在很多人看来毫无必要，很多类 React 框架都会帮助开发者对事件处理函数绑定 this，Vue 也是如此。\n\n但是我们一般进行绑定 this 的方案多种多样，上述代码采用了 ES Next 的属性初始化方法，对 handleClick 进行了绑定。\n\n第二点不同，决定了 React 实现复用的方式发展方向。首先肯定的是官方认为 mixin 是弊大于利的，已经被彻底放弃。那么社区跟进复用方案主要有两种：\n\n- 高阶组件\n- render prop 模式\n\n其中高阶组件很好地体现了 React 函数式思想，是 React 精华之体现。而 render prop 目前也非常流行，并最终推动了 React 自身的发展：新的 context 特性，其 API 也变革为 render prop 模式，这是社区反哺 React 的例证：\n\n```\n<ContextComponent.Consumer>\n  {value => (\n    <Component value={value}>\n  )}\n</ContextComponent.Consumer>\n```\n\n但是使用 class 声明组件不是完美无懈可击的。React 官方团队认为，这种方式“已经背离了 React 的初衷”。我总结下来，class 声明组件的问题有以下两个。\n\n- 带来了“面向生命周期编程”的困扰，随着逻辑变复杂，组件的生命周期函数随之变得很难维护和理解。我们想理清楚 componentDidMount、componentDidUpdate、componentWillUnmount、componentWillRecieveProps 这些钩子的逻辑并不困难。但是这些生命周期函数中的代码和 render 中的 state 以及 props 有什么关系？这些问题将会随着应用的复杂被无限放大，\n- React 是函数式的，而 class 声明组件这种面向对象的行为显得不伦不类。\n\n基于这两点，React 很快推出了函数式组件，或无状态组件（下面统称函数式组件，因为无状态组件在 hooks 特性下也会有状态）。\n\n#### 函数式组件\n\n函数式组件非常简单，我们用函数定义一个组件，该函数接受 props 作为参数，只负责渲染：\n\n```\nconst component = props => <div> { props.name } </div>\n```\n\n这样的实现看上去棒极了，组件只负责接收数据并渲染，难得如此清爽和直接。然而它是完全无法取代 class 组件的，因为它不存在生命周期，完全的无状态让我们无法处理必要的逻辑。\n\n因此，class 声明组件结合函数式组件的方案，类似容器组件结合木偶组件，成为现在的主流方式。\n\n从 React component 的发展，我们能够管中窥豹：从中可以发现 React 绑定 this 的设计、React 实现复用的方案等一系列知识点，它无疑是 React 类库的主干。不过我们继续设想，能不能赋予函数式组件以类似生命周期的能力，完美解决 class 组件的问题？这就是 React 近期带来的 React hooks 特性。请继续阅读。\n\n### <font color=13aa6c>颠覆性的 React hooks</font>\n\n说起 React hooks，想必大家已经了解了它出现的背景，那么它是如何解决问题的呢？\n\n简单来说，它使得开发者可以按业务逻辑拆分代码，而不是生命周期。这样如果想实现复用，直接在任何组件中引入相关 hooks 即可。Hooks 把代码按照业务逻辑的相关性进行拆分，把同一业务的代码集中在一起，不同业务的代码独立开来，维护起来就清楚很多。\n\n这里我们不会科普 hooks 的使用方案，因为官网上介绍的一定最好、最详尽，我们从原理和设计的角度来进行分析。\n\n#### 轻量级 useState \n\n事实上，setState API 并没有什么问题，它也足够轻量，真正笨重的是 class 组件结合 setState。而使用 useState hook，使得函数式组件也具备了操作 state 的能力，且不需要引入生命周期函数。\n\nuseState 是一个函数，入参是 initialState；它返回一个数组，第一值是 state，第二个值是改变 state 的函数。\n\n这里我来插播一个细节，为什么 useState 返回一个数组呢（其实返回的是 tuple，但是 JavaScript 还没有这个概念）？\n\n```\nlet [name, setName]= useState(&apos;lucas&apos;)\n```\n\n如果返回的是一个对象是否更合适呢？\n\n```\nlet { state: name, setState: setName } = useState(&apos;lucas&apos;)\n```\n\n这样表意更加清晰，而简单。也支持我们自动设置别名。事实上 React RFC 确实有相关讨论：[RFC: React Hooks ](https://github.com/reactjs/rfcs/pull/68#issuecomment-433135283)。\n\nuseState 其实很好实现：\n\n```\nconst React = (function() {\n  let stateValue\n\n  return Object.assign(React, {\n    useState(initialStateValue) {\n      stateValue = stateValue || initialStateValue\n\n      function setState(value) {\n        stateValue = value\n      }\n\n      return [stateValue, setState]\n    }\n  })\n})()\n```\n\n我们使用 stateValue 闭包变量储存 state，并提供修改 stateValue 的方法 setState，一并作为数组返回。\n\n#### useEffect 和生命周期那些事儿\n\n函数式组件通过 useState 具备了操控 state 的能力，修改 state 需要在适当的场景进行：class 声明的组件在组件生命周期中进行 state 更迭，那么在函数式组件中呢？我们需要用 useEffect 模拟生命周期，目前 useEffect 相当于 class Component 中的 componentDidMount、componentDidUpdate、componentWillUnmount 三个生命周期的综合。\n\n也就是说：useEffect 声明的回调函数会在组件挂载、更新、卸载的时候执行。为了避免每次渲染都执行所有的 useEffect 回调，useEffect 提供了第二个参数，该参数是数组类型。只有在渲染时数组中的值发生了变化，才会执行该 useEffect 回调。如果传的是个空数组，也就是说并不依赖任何其它值，因此这样只会在组件第一次 Mount 后和 Unmount 前调用。\n\n我们尝试实现 useEffect：\n\n```\nconst React = (function() {\n  let deps\n  \n  return Object.assign(React, {\n    useEffect(callback, depsArray) {\n      const shouldUpdate = !depsArray\n      \n      const depsChange = deps ? !deps.every((depItem, index) => depItem === depsArray[index]) : true\n      \n      if (shouldUpdate || depsChange) {\n      \tcallback()\n      \t\n      \tdeps = depsArray || []\n      }\n    }\n  })\n})()\n```\n\n我们看闭包变量 deps 存储前一刻 useEffect 的依赖数组值。在每次调用 useEffect 时，我们都会遍历 deps 数组和当前 depsArray 数组值，如果其中的任何一项有变化，depsChange 将为 true，进而执行 useEffect 的回调。\n\n有读者可能会想到，那么生命周期 shouldComponentUpdate 如何模拟呢？事实上，我们不需要用 useEffect 来实现 shouldComponentUpdate。React 新特性中专门提供了 React.memo 来帮助开发者进行性能优化。另外，useEffect 是无法模拟 getSnapshotBeforeUpdate 和 componentDidCatch 这两个生命周期函数的。\n\n上述两种实现都是简易版的，旨在剖析这两个 hooks 的工作原理，更多细节都没有实现。最重要的一点是：如果组件内多次调用 useState 或 useEffect，我们的实现为了区分每次 useState 调用之前不同的 state 值及 setter，需要额外使用一个数组来存储每次调用的配对值，比如：\n\n```\nconst React = (function() {\n  let hooks = []\n  let currentHook = 0\n\n  return Object.assign(React, {\n    useState(initialStateValue) {\n      hooks[currentHook] = hooks[currentHook] || initialStateValue\n\n      function setState(value) {\n        hooks[currentHook] = value\n      }\n\n      return [hooks[currentHook++], setState]\n    },\n    \n    useEffect(callback, depsArray) {\n      const shouldUpdate = !depsArray\n      \n      const depsChange = hooks[currentHook] ? !hooks[currentHook].every((depItem, index) => depItem === depsArray[index]) : true\n      \n      if (shouldUpdate || depsChange) {\n      \tcallback()\n      \t\n      \thooks[currentHook++] = depsArray || []\n      }\n    }\n\n  })\n})()\n``` \n\n这也是为什么 hooks 只可以在顶层使用，不能写在循环体、条件渲染，或者嵌套 function 里。因为 React 内部实现需要按调用顺序来记录每个 useState 的调用，以做区分。\n\n#### useReducer 和 Redux\n\n我们知道，如果 State 的变化有比较复杂的状态流转，可以使用新的 hooks：useReducer 让应用更加 Redux 化，使得逻辑更加清晰。那么首先思考一个问题：到底是该用 useState 还是 useReducer 呢？\n\n为此，我总结如下。\n\n使用 useState 的情况：\n\n- state 为基本类型（也要看情况）\n- state 转换逻辑简单的场景\n- state 转换只会在当前组件中出现，其他组件不需要感知这个 state\n- 多个 useState hooks 之间的 state 并没有关联关系\n\n使用 useReducer 的情况：\n\n- state 为引用类型（也要看情况）\n- state 转换逻辑比较复杂的场景\n- 不同 state 之间存在较强的关联关系，应该作为一个 object，用一个 state 来表示的场景\n- 如果需要更好的可维护性和可测试性\n\n其实翻看 React 源码 useState 实现，useState 本质是 useReducer 的一个语法糖。\n\n第二个问题：useReducer 是否代表着 React 内置了 Redux，我们就可以脱离 Redux 了呢？事实上，确实可以用简单的 React 代码，借助 context API 实现全局 Redux 或者局部 Redux：\n\nstore.js 文件：\n\n```\nimport React from &apos;react&apos;\nconst store = React.createContext(null)\n\nexport const initialState = { \n\t// ...\n}\n\nexport const reducer = (state, action) => {\n  switch (action.type) {\n    // ...\n  }\n}\nexport default store\n```\n\nProvider 根组件挂载：\n\n```\nimport React, { useReducer } from &apos;react&apos;\nimport store, { reducer, initialState } from &apos;./store&apos;\n\nfunction App() {\n  const [state, dispatch] = useReducer(reducer, initialState)\n  return (\n     <store.Provider value={{ state, dispatch }}>\n      <div/>\n     </store>\n  )\n}\n```\n\n业务组件就可以直接使用：\n\n```\nimport React, { useContext } from &apos;react&apos;\nimport store from &apos;./store&apos;\n\ncosnt Child = props => {\n  const { state, dispatch } = useContext(store)\n  // ...\n}\n```\n\n但是这样的行为尚不足以完全取代 Redux，我们这里不做展开。\n\n#### React hooks 之 Hooks 之所以可以设计为 Hooks 的原因\n\n我们现在了解了：\n\n- useState 让函数式组件能够使用 state\n- useEffect 让函数式组件可以模拟生命周期方法，并进行副作用操作\n- useReducer 让我们能够更清晰地处理状态数据\n- useContext 可以获取 context 值\n\n那么为什么其他的一些 APIs，比如 React.memo 并没有成为一个 hook 呢？事实上 React 认为能够成为 hooks 的条件有两个特定：\n\n- composition：这个新特性需要具有组合能力，也就是说需要有复用价值，因为 hooks 的一大目标就是完成组件的复用。针对于此，开发者可以自定义 hooks，而不必官方束缚指定的 hooks，这样反倒可能会发成冲突；\n\n- debugging：hooks 一大特性就是能够调试，如果应用出现差错，我们能够从错误的 props 和 state 当中找到错误的组件或逻辑，能够具有这样调试功能的特性，才应该成为一个 hooks。\n\n为此 Dan abramov 专门写了篇文章来讲述：[Why Isn’t X a Hook?](https://overreacted.io/why-isnt-x-a-hook/)，这里我们不再赘述。\n\n### <font color=13aa6c>值得关注的其他 React 特性</font>\n\n我认为在众多新特性中，还有一个可能会对社区带来较大影响的是 React v16.6 发布的 React.Suspense 和 React.lazy。具体用法我们不再讲解，读者可自行补充基础知识。React.Suspens 给了 React 组件异步（中断）渲染的能力，打破了 React 组件之前“一鼓作气”渲染的格局。而 React.lazy 带来了延迟加载的能力，可以很好地取代社区上的一些轮子实现。\n\n我们来看一个场景，React.Suspense 结合 React.lazy，实现代码分割和按需加载。\n\n目前按需加载一般都采用 react-lodable，这个库稳定优雅且支持服务端渲染：\n\n```\nconst Loading = ({ delay }) => {\n  if (delay) {\n    return <Spinner />\n  }\n  return null\n}\n \nexport const AsyncComponent = Loadable({\n  loader: () => import(/* webpackChunkName: \"Component1\" */ &apos;./component1&apos;),\n  loading: Loading,\n  delay: 500\n})\n```\n\n这段代码定义了一个 Loading 组件，在请求返回之前进行渲染；delay 参数表示时间超过 500 毫秒才显示 Loading，防止闪烁 Loading 的出现。\n\n如果换成 React.Suspense + React.lazy：\n\n```\nconst Component = React.lazy(() => import(/* webpackChunkName: \"Component1\" */ &apos;./component1&apos;))\n \nexport const AsyncComponent = props => (\n  <React.Suspense fallback={<Loading />}>\n    <Component {...props} />\n  </React.Suspense>\n);\n```\n\nReact.lazy 封装动态 import 的 React 组件，它要求 import() 必须返回一个会 Promise 对象，并且这个 Promise 对象会 resolve 为一个 ES 模块，模块中 export default 必须是一个合法的 React 组件。\n\nReact.Suspense 组件设置 fallback prop，当发现我们的 Component 是一个 Promise 类型时，且这个 Promise 没有被 resolved，那么就启用 fallback prop 所提供的组件，以便在我们等待网络返回结果时进行渲染。 \n\n我们可以结合 Error Boundary 特性，对于网络或者其他错误时，进行错误处理：\n\n```\n<MyCustomErrorBoundary>\n  <AsyncComponent />\n</MyCustomErrorBoundary>\n```\n\n这样一来我们就实现了简单的 react-loadable 库。当然在 React.suspense 正式发布之前，我们当然可以自己手动实现一个 React.Suspense 组件，这里提供一个简单的版本，未考虑边界情况：\n\n```\nexport class Suspense extends React.Component {\n    state = {\n      isLoading: false\n    }\n\n    componentDidCatch(error) {\n      if (typeof error.then === &apos;function&apos;) {\n        this.setState({ isLoading: true })\n        error.then(() => {\n          this.setState({ isLoading: false })\n        })\n      }\n    }\n\n    render() {\n      const { children, fallback } = this.props\n      const { isLoading } = this.state\n\n      return isLoading ? fallback : children\n    }\n}\n```\n\n核心思路就是在首次渲染 Promise 出错时，使用 componentDidCatch 进行捕获，转而通过状态切换渲染 fallback 组件；在 Promise resolve 之后，通过状态切换渲染目标组件。\n\n\n### <font color=13aa6c>总结</font>\n\n这一讲我们梳理了 React 发展史上重要的里程碑，并展望了 React 未来发展。任何一门框架其实都免不了从问世到巅峰、再到逐步退出的过程。一个框架的兴衰，印证着技术潮流的更迭，作为开发者，合理分析框架发展背后的技术趋势，就非常重要了。\n\n### <font color=13aa6c>分享交流</font>\n\n阅读文章过程中有任何疑问可随时跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。**你的分享不仅帮助他人，更会提升自己。**\n\n你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。\n\n>**为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。**","pdfUrl":"","reader":"","duration":"","title":"React 的现状与未来","column":"5c91c813968b1d64b1e08fde","isNotification":false,"readingStatistics":26,"htmlContent":"<p>React 自推出以来，一直进行着自身完善和演进。作为 React 开发者或前端开发者，有幸见证着一个伟大“框架”的成长，是非常幸运的。那么在这个过程中，我们应该学些什么？React 现在处于什么发展阶段？React 未来又将有哪些规划？</p>\n<p>高级前端工程师不能只停留在使用框架上，我们自然要思考上述这些问题。这一讲我们就来聊聊 React 的现状与未来，如果不熟悉 React，也并不妨碍大家阅读。</p>\n<p>相关知识点如下：</p>\n<img src=\"https://images.gitbook.cn/3acdade0-9d3b-11e9-9eee-292fd7e6afca\" width=600>\n<h3><a id=\"font_color13aa6cReact_font_8\"></a><font color=13aa6c>React 现状分析</font></h3>\n<p>React 经过几年的打磨，目前维持了一个稳定的迭代周期，并不断给开发者带来惊喜。其中难能可贵的是在 breaking changes 不多的前提下，仍在持续输出具有变革精神的特性，保持着旺盛的生命力。不管是什么平台的调查，都显示 React 受众仍然最多，可以预见的是，React 未来仍将会统领前端发展。</p>\n<p>关于 React 现状，我总结出以下几个特点：</p>\n<ul>\n<li>开发模式已经定型，有利于开发者持续学习</li>\n<li>仍然有强大的开发团队维护，不断带来改变，这些改变一方面使 React 更好，另一方面甚至推动了 JavaScript 语言的发展</li>\n<li>社区生态强大，有一系列解决方案，数据状态管理、组件库、服务端渲染生态群百花齐放</li>\n</ul>\n<p>在这些特点的背后，也有一些让开发者担忧的地方：</p>\n<ul>\n<li>概念越来越多。一定程度上，新老概念并存，学习曲线激增</li>\n<li>存在较多 unsafe_ 标记的 APIs，始终担忧彻底废弃相关 APIs 那一天的到来</li>\n<li>新特性带来了较多“魔法”，也带来了一些困惑</li>\n</ul>\n<p>当然，这些让开发者担忧的地方并不足以和 React 的强大相提并论，这些“问题”甚至在任何一个框架中都会存在。因此，我建议不管是工作需要，还是自身学习需要，前端开发者都可以使用并研究 React。</p>\n<h3><a id=\"font_color13aa6c_React_Component__React_font_26\"></a><font color=13aa6c>从 React Component 看 React 发展史</font></h3>\n<p>回顾 React 发展历史，很多 APIs 和特性的演进都很有意思，比如 refs、context，其中任何一点都值得单拎出来深入分析。但是我挑选了一个开发者一定会使用的 React Component 话题：从组件的创建和声明方式，我们来看一个框架的变革，并由此引出 React 目前最受关注的的 hooks 新特性。</p>\n<p>React Component 的发展主要经历了三个阶段：</p>\n<ul>\n<li>createClass 创建组件时期</li>\n<li>ES class 声明组件时期</li>\n<li>无状态（函数式）组件 + React hooks 时期</li>\n</ul>\n<p>这一路，也是 React 从一个纯粹的视图层类库走向成熟完善的解决方案的过程。我们逐一来看。</p>\n<h4><a id=\"createClass__38\"></a>createClass 创建组件时期</h4>\n<p>相信很多新的开发者都没有使用过 createClass API 创建组件，createClass 是一个函数，接受参数并返回组件实例，用起来并不复杂：</p>\n<pre><code class=\"lang-\">import React from &apos;react&apos;\n\nconst component1 = React.createClass({\n  propTypes: {\n    foo: React.PropTypes.string\n  },\n  \n  getDefaultProps() {\n    return {\n\t\tfoo: &apos;bar&apos;\n    }\n  },\n  \n\n  getInitialState() { \n  \treturn {\n\t  state1: &apos;lucas&apos;\n\t}\n  },\n  \n  handleClick() {\n  \n  },\n\t\n  render() {\n    return (\n      &lt;p onClick={this.handleClick}&gt;&lt;/p&gt;\n    )\n  }\n})\n</code></pre>\n<p>看起来很好理解，但是编写还是有些违背直觉。从 React 15.5 版本开始，官方就不再开始推荐，到了 React 16 版本，已经彻底废弃。</p>\n<h4><a id=\"Class__77\"></a>Class 声明组件时期</h4>\n<p>createClass 退出历史舞台的原因是被强势的 class 声明组件方式所取代。当时 ES6 正在如火如荼地发展，新增了 class 这一语法糖，React 团队很快赶时髦，支持了使用 class 声明组件的方式：</p>\n<pre><code class=\"lang-\">class Component1 extends React.Component {\n  state = { name: &apos;Lucas&apos; }\n  \n  handleClick = e =&gt; {\n    console.log(e)\n    this.setState({\n      name: &apos;Messi&apos;,\n    })\n  }\n  \n  render() {\n    return (\n      &lt;div onClick={this.handleClick}&gt;\n        {{this.state.name}}\n      &lt;/div&gt;\n    )\n  }\n}\n</code></pre>\n<p>代码非常直观清爽，但是 class 声明方式和早期的 createClass 相比，有非常重要的两点差别：</p>\n<ul>\n<li>React.createClass 支持在事件处理函数中自动绑定 this，而 class 声明的组件需要开发者手动绑定</li>\n<li>React.Component 不能使用 React mixins 来实现复用</li>\n</ul>\n<p>这两个显著不同点决定了 React 生态社区发展的方向。</p>\n<p>其中第一点不同，决定了 React 放弃了“多管闲事”地绑定 this，虽然这个行为在很多人看来毫无必要，很多类 React 框架都会帮助开发者对事件处理函数绑定 this，Vue 也是如此。</p>\n<p>但是我们一般进行绑定 this 的方案多种多样，上述代码采用了 ES Next 的属性初始化方法，对 handleClick 进行了绑定。</p>\n<p>第二点不同，决定了 React 实现复用的方式发展方向。首先肯定的是官方认为 mixin 是弊大于利的，已经被彻底放弃。那么社区跟进复用方案主要有两种：</p>\n<ul>\n<li>高阶组件</li>\n<li>render prop 模式</li>\n</ul>\n<p>其中高阶组件很好地体现了 React 函数式思想，是 React 精华之体现。而 render prop 目前也非常流行，并最终推动了 React 自身的发展：新的 context 特性，其 API 也变革为 render prop 模式，这是社区反哺 React 的例证：</p>\n<pre><code class=\"lang-\">&lt;ContextComponent.Consumer&gt;\n  {value =&gt; (\n    &lt;Component value={value}&gt;\n  )}\n&lt;/ContextComponent.Consumer&gt;\n</code></pre>\n<p>但是使用 class 声明组件不是完美无懈可击的。React 官方团队认为，这种方式“已经背离了 React 的初衷”。我总结下来，class 声明组件的问题有以下两个。</p>\n<ul>\n<li>带来了“面向生命周期编程”的困扰，随着逻辑变复杂，组件的生命周期函数随之变得很难维护和理解。我们想理清楚 componentDidMount、componentDidUpdate、componentWillUnmount、componentWillRecieveProps 这些钩子的逻辑并不困难。但是这些生命周期函数中的代码和 render 中的 state 以及 props 有什么关系？这些问题将会随着应用的复杂被无限放大，</li>\n<li>React 是函数式的，而 class 声明组件这种面向对象的行为显得不伦不类。</li>\n</ul>\n<p>基于这两点，React 很快推出了函数式组件，或无状态组件（下面统称函数式组件，因为无状态组件在 hooks 特性下也会有状态）。</p>\n<h4><a id=\"_135\"></a>函数式组件</h4>\n<p>函数式组件非常简单，我们用函数定义一个组件，该函数接受 props 作为参数，只负责渲染：</p>\n<pre><code class=\"lang-\">const component = props =&gt; &lt;div&gt; { props.name } &lt;/div&gt;\n</code></pre>\n<p>这样的实现看上去棒极了，组件只负责接收数据并渲染，难得如此清爽和直接。然而它是完全无法取代 class 组件的，因为它不存在生命周期，完全的无状态让我们无法处理必要的逻辑。</p>\n<p>因此，class 声明组件结合函数式组件的方案，类似容器组件结合木偶组件，成为现在的主流方式。</p>\n<p>从 React component 的发展，我们能够管中窥豹：从中可以发现 React 绑定 this 的设计、React 实现复用的方案等一系列知识点，它无疑是 React 类库的主干。不过我们继续设想，能不能赋予函数式组件以类似生命周期的能力，完美解决 class 组件的问题？这就是 React 近期带来的 React hooks 特性。请继续阅读。</p>\n<h3><a id=\"font_color13aa6c_React_hooksfont_149\"></a><font color=13aa6c>颠覆性的 React hooks</font></h3>\n<p>说起 React hooks，想必大家已经了解了它出现的背景，那么它是如何解决问题的呢？</p>\n<p>简单来说，它使得开发者可以按业务逻辑拆分代码，而不是生命周期。这样如果想实现复用，直接在任何组件中引入相关 hooks 即可。Hooks 把代码按照业务逻辑的相关性进行拆分，把同一业务的代码集中在一起，不同业务的代码独立开来，维护起来就清楚很多。</p>\n<p>这里我们不会科普 hooks 的使用方案，因为官网上介绍的一定最好、最详尽，我们从原理和设计的角度来进行分析。</p>\n<h4><a id=\"_useState_157\"></a>轻量级 useState</h4>\n<p>事实上，setState API 并没有什么问题，它也足够轻量，真正笨重的是 class 组件结合 setState。而使用 useState hook，使得函数式组件也具备了操作 state 的能力，且不需要引入生命周期函数。</p>\n<p>useState 是一个函数，入参是 initialState；它返回一个数组，第一值是 state，第二个值是改变 state 的函数。</p>\n<p>这里我来插播一个细节，为什么 useState 返回一个数组呢（其实返回的是 tuple，但是 JavaScript 还没有这个概念）？</p>\n<pre><code class=\"lang-\">let [name, setName]= useState(&apos;lucas&apos;)\n</code></pre>\n<p>如果返回的是一个对象是否更合适呢？</p>\n<pre><code class=\"lang-\">let { state: name, setState: setName } = useState(&apos;lucas&apos;)\n</code></pre>\n<p>这样表意更加清晰，而简单。也支持我们自动设置别名。事实上 React RFC 确实有相关讨论：<a href=\"https://github.com/reactjs/rfcs/pull/68#issuecomment-433135283\" target=\"_blank\">RFC: React Hooks </a>。</p>\n<p>useState 其实很好实现：</p>\n<pre><code class=\"lang-\">const React = (function() {\n  let stateValue\n\n  return Object.assign(React, {\n    useState(initialStateValue) {\n      stateValue = stateValue || initialStateValue\n\n      function setState(value) {\n        stateValue = value\n      }\n\n      return [stateValue, setState]\n    }\n  })\n})()\n</code></pre>\n<p>我们使用 stateValue 闭包变量储存 state，并提供修改 stateValue 的方法 setState，一并作为数组返回。</p>\n<h4><a id=\"useEffect__199\"></a>useEffect 和生命周期那些事儿</h4>\n<p>函数式组件通过 useState 具备了操控 state 的能力，修改 state 需要在适当的场景进行：class 声明的组件在组件生命周期中进行 state 更迭，那么在函数式组件中呢？我们需要用 useEffect 模拟生命周期，目前 useEffect 相当于 class Component 中的 componentDidMount、componentDidUpdate、componentWillUnmount 三个生命周期的综合。</p>\n<p>也就是说：useEffect 声明的回调函数会在组件挂载、更新、卸载的时候执行。为了避免每次渲染都执行所有的 useEffect 回调，useEffect 提供了第二个参数，该参数是数组类型。只有在渲染时数组中的值发生了变化，才会执行该 useEffect 回调。如果传的是个空数组，也就是说并不依赖任何其它值，因此这样只会在组件第一次 Mount 后和 Unmount 前调用。</p>\n<p>我们尝试实现 useEffect：</p>\n<pre><code class=\"lang-\">const React = (function() {\n  let deps\n  \n  return Object.assign(React, {\n    useEffect(callback, depsArray) {\n      const shouldUpdate = !depsArray\n      \n      const depsChange = deps ? !deps.every((depItem, index) =&gt; depItem === depsArray[index]) : true\n      \n      if (shouldUpdate || depsChange) {\n      \tcallback()\n      \t\n      \tdeps = depsArray || []\n      }\n    }\n  })\n})()\n</code></pre>\n<p>我们看闭包变量 deps 存储前一刻 useEffect 的依赖数组值。在每次调用 useEffect 时，我们都会遍历 deps 数组和当前 depsArray 数组值，如果其中的任何一项有变化，depsChange 将为 true，进而执行 useEffect 的回调。</p>\n<p>有读者可能会想到，那么生命周期 shouldComponentUpdate 如何模拟呢？事实上，我们不需要用 useEffect 来实现 shouldComponentUpdate。React 新特性中专门提供了 React.memo 来帮助开发者进行性能优化。另外，useEffect 是无法模拟 getSnapshotBeforeUpdate 和 componentDidCatch 这两个生命周期函数的。</p>\n<p>上述两种实现都是简易版的，旨在剖析这两个 hooks 的工作原理，更多细节都没有实现。最重要的一点是：如果组件内多次调用 useState 或 useEffect，我们的实现为了区分每次 useState 调用之前不同的 state 值及 setter，需要额外使用一个数组来存储每次调用的配对值，比如：</p>\n<pre><code class=\"lang-\">const React = (function() {\n  let hooks = []\n  let currentHook = 0\n\n  return Object.assign(React, {\n    useState(initialStateValue) {\n      hooks[currentHook] = hooks[currentHook] || initialStateValue\n\n      function setState(value) {\n        hooks[currentHook] = value\n      }\n\n      return [hooks[currentHook++], setState]\n    },\n    \n    useEffect(callback, depsArray) {\n      const shouldUpdate = !depsArray\n      \n      const depsChange = hooks[currentHook] ? !hooks[currentHook].every((depItem, index) =&gt; depItem === depsArray[index]) : true\n      \n      if (shouldUpdate || depsChange) {\n      \tcallback()\n      \t\n      \thooks[currentHook++] = depsArray || []\n      }\n    }\n\n  })\n})()\n</code></pre>\n<p>这也是为什么 hooks 只可以在顶层使用，不能写在循环体、条件渲染，或者嵌套 function 里。因为 React 内部实现需要按调用顺序来记录每个 useState 的调用，以做区分。</p>\n<h4><a id=\"useReducer__Redux_267\"></a>useReducer 和 Redux</h4>\n<p>我们知道，如果 State 的变化有比较复杂的状态流转，可以使用新的 hooks：useReducer 让应用更加 Redux 化，使得逻辑更加清晰。那么首先思考一个问题：到底是该用 useState 还是 useReducer 呢？</p>\n<p>为此，我总结如下。</p>\n<p>使用 useState 的情况：</p>\n<ul>\n<li>state 为基本类型（也要看情况）</li>\n<li>state 转换逻辑简单的场景</li>\n<li>state 转换只会在当前组件中出现，其他组件不需要感知这个 state</li>\n<li>多个 useState hooks 之间的 state 并没有关联关系</li>\n</ul>\n<p>使用 useReducer 的情况：</p>\n<ul>\n<li>state 为引用类型（也要看情况）</li>\n<li>state 转换逻辑比较复杂的场景</li>\n<li>不同 state 之间存在较强的关联关系，应该作为一个 object，用一个 state 来表示的场景</li>\n<li>如果需要更好的可维护性和可测试性</li>\n</ul>\n<p>其实翻看 React 源码 useState 实现，useState 本质是 useReducer 的一个语法糖。</p>\n<p>第二个问题：useReducer 是否代表着 React 内置了 Redux，我们就可以脱离 Redux 了呢？事实上，确实可以用简单的 React 代码，借助 context API 实现全局 Redux 或者局部 Redux：</p>\n<p>store.js 文件：</p>\n<pre><code class=\"lang-\">import React from &apos;react&apos;\nconst store = React.createContext(null)\n\nexport const initialState = { \n\t// ...\n}\n\nexport const reducer = (state, action) =&gt; {\n  switch (action.type) {\n    // ...\n  }\n}\nexport default store\n</code></pre>\n<p>Provider 根组件挂载：</p>\n<pre><code class=\"lang-\">import React, { useReducer } from &apos;react&apos;\nimport store, { reducer, initialState } from &apos;./store&apos;\n\nfunction App() {\n  const [state, dispatch] = useReducer(reducer, initialState)\n  return (\n     &lt;store.Provider value={{ state, dispatch }}&gt;\n      &lt;div/&gt;\n     &lt;/store&gt;\n  )\n}\n</code></pre>\n<p>业务组件就可以直接使用：</p>\n<pre><code class=\"lang-\">import React, { useContext } from &apos;react&apos;\nimport store from &apos;./store&apos;\n\ncosnt Child = props =&gt; {\n  const { state, dispatch } = useContext(store)\n  // ...\n}\n</code></pre>\n<p>但是这样的行为尚不足以完全取代 Redux，我们这里不做展开。</p>\n<h4><a id=\"React_hooks__Hooks__Hooks__339\"></a>React hooks 之 Hooks 之所以可以设计为 Hooks 的原因</h4>\n<p>我们现在了解了：</p>\n<ul>\n<li>useState 让函数式组件能够使用 state</li>\n<li>useEffect 让函数式组件可以模拟生命周期方法，并进行副作用操作</li>\n<li>useReducer 让我们能够更清晰地处理状态数据</li>\n<li>useContext 可以获取 context 值</li>\n</ul>\n<p>那么为什么其他的一些 APIs，比如 React.memo 并没有成为一个 hook 呢？事实上 React 认为能够成为 hooks 的条件有两个特定：</p>\n<ul>\n<li>\n<p>composition：这个新特性需要具有组合能力，也就是说需要有复用价值，因为 hooks 的一大目标就是完成组件的复用。针对于此，开发者可以自定义 hooks，而不必官方束缚指定的 hooks，这样反倒可能会发成冲突；</p>\n</li>\n<li>\n<p>debugging：hooks 一大特性就是能够调试，如果应用出现差错，我们能够从错误的 props 和 state 当中找到错误的组件或逻辑，能够具有这样调试功能的特性，才应该成为一个 hooks。</p>\n</li>\n</ul>\n<p>为此 Dan abramov 专门写了篇文章来讲述：<a href=\"https://overreacted.io/why-isnt-x-a-hook/\" target=\"_blank\">Why Isn’t X a Hook?</a>，这里我们不再赘述。</p>\n<h3><a id=\"font_color13aa6c_React_font_356\"></a><font color=13aa6c>值得关注的其他 React 特性</font></h3>\n<p>我认为在众多新特性中，还有一个可能会对社区带来较大影响的是 React v16.6 发布的 React.Suspense 和 React.lazy。具体用法我们不再讲解，读者可自行补充基础知识。React.Suspens 给了 React 组件异步（中断）渲染的能力，打破了 React 组件之前“一鼓作气”渲染的格局。而 React.lazy 带来了延迟加载的能力，可以很好地取代社区上的一些轮子实现。</p>\n<p>我们来看一个场景，React.Suspense 结合 React.lazy，实现代码分割和按需加载。</p>\n<p>目前按需加载一般都采用 react-lodable，这个库稳定优雅且支持服务端渲染：</p>\n<pre><code class=\"lang-\">const Loading = ({ delay }) =&gt; {\n  if (delay) {\n    return &lt;Spinner /&gt;\n  }\n  return null\n}\n \nexport const AsyncComponent = Loadable({\n  loader: () =&gt; import(/* webpackChunkName: &quot;Component1&quot; */ &apos;./component1&apos;),\n  loading: Loading,\n  delay: 500\n})\n</code></pre>\n<p>这段代码定义了一个 Loading 组件，在请求返回之前进行渲染；delay 参数表示时间超过 500 毫秒才显示 Loading，防止闪烁 Loading 的出现。</p>\n<p>如果换成 React.Suspense + React.lazy：</p>\n<pre><code class=\"lang-\">const Component = React.lazy(() =&gt; import(/* webpackChunkName: &quot;Component1&quot; */ &apos;./component1&apos;))\n \nexport const AsyncComponent = props =&gt; (\n  &lt;React.Suspense fallback={&lt;Loading /&gt;}&gt;\n    &lt;Component {...props} /&gt;\n  &lt;/React.Suspense&gt;\n);\n</code></pre>\n<p>React.lazy 封装动态 import 的 React 组件，它要求 import() 必须返回一个会 Promise 对象，并且这个 Promise 对象会 resolve 为一个 ES 模块，模块中 export default 必须是一个合法的 React 组件。</p>\n<p>React.Suspense 组件设置 fallback prop，当发现我们的 Component 是一个 Promise 类型时，且这个 Promise 没有被 resolved，那么就启用 fallback prop 所提供的组件，以便在我们等待网络返回结果时进行渲染。</p>\n<p>我们可以结合 Error Boundary 特性，对于网络或者其他错误时，进行错误处理：</p>\n<pre><code class=\"lang-\">&lt;MyCustomErrorBoundary&gt;\n  &lt;AsyncComponent /&gt;\n&lt;/MyCustomErrorBoundary&gt;\n</code></pre>\n<p>这样一来我们就实现了简单的 react-loadable 库。当然在 React.suspense 正式发布之前，我们当然可以自己手动实现一个 React.Suspense 组件，这里提供一个简单的版本，未考虑边界情况：</p>\n<pre><code class=\"lang-\">export class Suspense extends React.Component {\n    state = {\n      isLoading: false\n    }\n\n    componentDidCatch(error) {\n      if (typeof error.then === &apos;function&apos;) {\n        this.setState({ isLoading: true })\n        error.then(() =&gt; {\n          this.setState({ isLoading: false })\n        })\n      }\n    }\n\n    render() {\n      const { children, fallback } = this.props\n      const { isLoading } = this.state\n\n      return isLoading ? fallback : children\n    }\n}\n</code></pre>\n<p>核心思路就是在首次渲染 Promise 出错时，使用 componentDidCatch 进行捕获，转而通过状态切换渲染 fallback 组件；在 Promise resolve 之后，通过状态切换渲染目标组件。</p>\n<h3><a id=\"font_color13aa6cfont_434\"></a><font color=13aa6c>总结</font></h3>\n<p>这一讲我们梳理了 React 发展史上重要的里程碑，并展望了 React 未来发展。任何一门框架其实都免不了从问世到巅峰、再到逐步退出的过程。一个框架的兴衰，印证着技术潮流的更迭，作为开发者，合理分析框架发展背后的技术趋势，就非常重要了。</p>\n<h3><a id=\"font_color13aa6cfont_438\"></a><font color=13aa6c>分享交流</font></h3>\n<p>阅读文章过程中有任何疑问可随时跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。<strong>你的分享不仅帮助他人，更会提升自己。</strong></p>\n<p>你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。</p>\n<blockquote>\n<p><strong>为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。</strong></p>\n</blockquote>\n","createdAt":"2019-04-21T04:23:17.645Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":20,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FoThASW9dVEPMEo9nP-zaOfbKyLZ"},{"_id":"5cbbf073bbbba80861a35c30","communication_start_time":null,"type":1,"audioPath":"","abstract":"","content":"不管是服务端渲染还是服务端渲染衍生出的同构应用，现在来看已经并不新鲜了，实现起来也并不困难。可是有的开发者认为：同构应用不就是调用一个 renderToString（React 中）类似的 API 吗？\n\n讲道理确实是这样的，但是讲道理你也许并没有真正在实战中领会同构应用的精髓。\n\n同构应用能够完成的本质条件是虚拟 DOM，基于虚拟 DOM 我们可以生成真实的 DOM，并由浏览器渲染；也可以调用不同框架的不同 APIs，将虚拟 DOM 生成字符串，由服务端传输给客户端。\n\n但是同构应用也不只是这么简单。拿面试来说，同构应用的考察点不是“纸上谈兵”的理论，而是实际实施时的细节。这一讲我们就来聊一聊“同构应用中往往被忽略的细节”，需要读者提前了解服务端渲染和同构应用的概念。\n\n相关知识点如下：\n\n<img src=\"https://images.gitbook.cn/d5314df0-9d55-11e9-8a2c-e9ea8cc9b822\" width=350>\n\n### <font color=13aa6c>打包环境区分</font>\n\n第一个细节：我们知道同构应用实现了客户端代码和服务端代码的基本统一，我们只需要编写一种组件，就能生成适用于服务端和客户端的组件案例。可是你是否知道，服务端代码和客户端代码大多数情况下还是需要单独处理？比如：\n\n- 路由代码差别：服务端需要根据请求路径，匹配页面组件；客户端需要通过浏览器中的地址，匹配页面组件。\n\n客户端代码：\n\n```\nconst App = () => {\n  return (\n    <Provider store={store}>\n      <BrowserRouter>\n        <div>\n          <Route path=&apos;/&apos; component={Home}>\n          <Route path=&apos;/product&apos; component={Product}>\n        </div>\n      </BrowserRouter>\n    </Provider>\n  )\n}\nReactDom.render(<App/>, document.querySelector(&apos;#root&apos;))\n```\n\nBrowserRouter 组件根据 window.location 以及 history API 实现页面切换，而服务端肯定是无法获取 window.location 的，服务端代码如下：\n\n```\nconst App = () => {\n  return \n    <Provider store={store}>\n      <StaticRouter location={req.path} context={context}>\n        <div>\n          <Route path=&apos;/&apos; component={Home}>\n        </div>\n      </StaticRouter>\n    </Provider>\n}\nReturn ReactDom.renderToString(<App/>)\n```\n\n需要使用 StaticRouter 组件，并将请求地址和上下文信息作为 location 和 context 这两个 props 传入 StaticRouter 中。\n\n- 打包差别：服务端运行的代码如果需要依赖 Node 核心模块或者第三方模块，就不再需要把这些模块代码打包到最终代码中了。因为环境已经安装这些依赖，可以直接引用。这样一来，就需要我们在 webpack 中配置：target：node，并借助  webpack-node-externals 插件，解决第三方依赖打包的问题。\n\n- 对于图片等静态资源，url-loader 会在服务端代码和客户端代码打包过程中分别被引用，因此会在资源目录中生成了重复的文件。当然后打包出来的因为重名，会覆盖前一次打包出来的结果，并不影响使用，但是整个构建过程并不优雅。\n\n- 由于路由在服务端和客户端的差别，因此 webpack 配置文件的 entry 会不相同：\n\n```\n{\n\tentry: &apos;./src/client/index.js&apos;,\n}\n\n{\n\tentry: &apos;./src/server/index.js&apos;,\n}\n```\n\n### <font color=13aa6c>注水和脱水</font>\n\n什么叫做注水和脱水呢？这个和同构应用中数据的获取有关：在服务器端渲染时，首先服务端请求接口拿到数据，并处理准备好数据状态（如果使用 Redux，就是进行 store 的更新），为了减少客户端的请求，我们需要保留住这个状态。一般做法是在服务器端返回 HTML 字符串的时候，将数据 JSON.stringify 一并返回，这个过程，叫做脱水（dehydrate）；在客户端，就不再需要进行数据的请求了，可以直接使用服务端下发下来的数据，这个过程叫注水（hydrate）。用代码来表示：\n\n服务端：\n\n```\nctx.body = `\n  <!DOCTYPE html>\n  <html lang=\"en\">\n    <head>\n      <meta charset=\"UTF-8\">\n    </head>\n    <body>\n    \t<script>\n        window.context = {\n          initialState: ${JSON.stringify(store.getState())}\n        }\n      </script>\n      <div id=\"app\">\n      \t// ...\n      </div>\n    </body>\n  </html>\n`\n```\n\n客户端：\n\n```\nexport const getClientStore = () => {\n  const defaultState = JSON.parse(window.context.state)\n  return createStore(reducer, defaultState, applyMiddleware(thunk))\n}\n```\n\n这一系列过程非常典型，但是也会有几个细节值得探讨：**在服务端渲染时，服务端如何能够请求所有的 APIs，保障数据全部已经请求呢？**\n\n一般有两种方法：\n\n- react-router 的解决方案是配置路由 route-config，结合 matchRoutes，找到页面上相关组件所需的请求接口的方法并执行请求。这就要求开发者通过路由配置信息，显式地告知服务端请求内容。\n\n我们首先配置路由：\n\n```\nconst routes = [\n  {\n    path: \"/\",\n    component: Root,\n    loadData: () => getSomeData()\n  }\n  // etc.\n]\n\nimport { routes } from \"./routes\"\n\nfunction App() {\n  return (\n    <Switch>\n      {routes.map(route => (\n        <Route {...route} />\n      ))}\n    </Switch>\n  )\n}\n```\n\n在服务端代码中：\n\n```\nimport { matchPath } from \"react-router-dom\"\n\nconst promises = []\nroutes.some(route => {\n  const match = matchPath(req.path, route)\n  if (match) promises.push(route.loadData(match))\n  return match\n})\n\nPromise.all(promises).then(data => {\n  putTheDataSomewhereTheClientCanFindIt(data)\n})\n```\n\n- 另外一种思路类似 Next.js，我们需要在 React 组件上定义静态方法。\n比如定义静态 loadData 方法，在服务端渲染时，我们可以遍历所有组件的 loadData，获取需要请求的接口。这样的方式借鉴了早期 React-apollo 的解决方案，我个人很喜欢这种设计。这里贴出我为 Facebook 团队 react-apollo 开源项目贡献的改动代码，其目的就是遍历组件，获取请求接口：\n\n```\nfunction getPromisesFromTree({\n  rootElement,\n  rootContext = {},\n}: PromiseTreeArgument): PromiseTreeResult[] {\n  const promises: PromiseTreeResult[] = [];\n\n  walkTree(rootElement, rootContext, (_, instance, context, childContext) => {\n    if (instance && hasFetchDataFunction(instance)) {\n      const promise = instance.fetchData();\n      if (isPromise<Object>(promise)) {\n        promises.push({ promise, context: childContext || context, instance });\n        return false;\n      }\n    }\n  });\n\n  return promises;\n}\n\n// Recurse a React Element tree, running visitor on each element.\n// If visitor returns `false`, don&apos;t call the element&apos;s render function\n// or recurse into its child elements.\nexport function walkTree(\n  element: React.ReactNode,\n  context: Context,\n  visitor: (\n    element: React.ReactNode,\n    instance: React.Component<any> | null,\n    context: Context,\n    childContext?: Context,\n  ) => boolean | void,\n) {\n  if (Array.isArray(element)) {\n    element.forEach(item => walkTree(item, context, visitor));\n    return;\n  }\n\n  if (!element) {\n    return;\n  }\n\n  // A stateless functional component or a class\n  if (isReactElement(element)) {\n    if (typeof element.type === &apos;function&apos;) {\n      const Comp = element.type;\n      const props = Object.assign({}, Comp.defaultProps, getProps(element));\n      let childContext = context;\n      let child;\n\n      // Are we are a react class?\n      if (isComponentClass(Comp)) {\n        const instance = new Comp(props, context);\n        // In case the user doesn&apos;t pass these to super in the constructor.\n        // Note: `Component.props` are now readonly in `@types/react`, so\n        // we&apos;re using `defineProperty` as a workaround (for now).\n        Object.defineProperty(instance, &apos;props&apos;, {\n          value: instance.props || props,\n        });\n        instance.context = instance.context || context;\n\n        // Set the instance state to null (not undefined) if not set, to match React behaviour\n        instance.state = instance.state || null;\n\n        // Override setState to just change the state, not queue up an update\n        // (we can&apos;t do the default React thing as we aren&apos;t mounted\n        // \"properly\", however we don&apos;t need to re-render as we only support\n        // setState in componentWillMount, which happens *before* render).\n        instance.setState = newState => {\n          if (typeof newState === &apos;function&apos;) {\n            // React&apos;s TS type definitions don&apos;t contain context as a third parameter for\n            // setState&apos;s updater function.\n            // Remove this cast to `any` when that is fixed.\n            newState = (newState as any)(instance.state, instance.props, instance.context);\n          }\n          instance.state = Object.assign({}, instance.state, newState);\n        };\n\n        if (Comp.getDerivedStateFromProps) {\n          const result = Comp.getDerivedStateFromProps(instance.props, instance.state);\n          if (result !== null) {\n            instance.state = Object.assign({}, instance.state, result);\n          }\n        } else if (instance.UNSAFE_componentWillMount) {\n          instance.UNSAFE_componentWillMount();\n        } else if (instance.componentWillMount) {\n          instance.componentWillMount();\n        }\n\n        if (providesChildContext(instance)) {\n          childContext = Object.assign({}, context, instance.getChildContext());\n        }\n\n        if (visitor(element, instance, context, childContext) === false) {\n          return;\n        }\n\n        child = instance.render();\n      } else {\n        // Just a stateless functional\n        if (visitor(element, null, context) === false) {\n          return;\n        }\n\n        child = Comp(props, context);\n      }\n\n      if (child) {\n        if (Array.isArray(child)) {\n          child.forEach(item => walkTree(item, childContext, visitor));\n        } else {\n          walkTree(child, childContext, visitor);\n        }\n      }\n    } else if ((element.type as any)._context || (element.type as any).Consumer) {\n      // A React context provider or consumer\n      if (visitor(element, null, context) === false) {\n        return;\n      }\n\n      let child;\n      if ((element.type as any)._context) {\n        // A provider - sets the context value before rendering children\n        ((element.type as any)._context as any)._currentValue = element.props.value;\n        child = element.props.children;\n      } else {\n        // A consumer\n        child = element.props.children((element.type as any)._currentValue);\n      }\n\n      if (child) {\n        if (Array.isArray(child)) {\n          child.forEach(item => walkTree(item, context, visitor));\n        } else {\n          walkTree(child, context, visitor);\n        }\n      }\n    } else {\n      // A basic string or dom element, just get children\n      if (visitor(element, null, context) === false) {\n        return;\n      }\n\n      if (element.props && element.props.children) {\n        React.Children.forEach(element.props.children, (child: any) => {\n          if (child) {\n            walkTree(child, context, visitor);\n          }\n        });\n      }\n    }\n  } else if (typeof element === &apos;string&apos; || typeof element === &apos;number&apos;) {\n    // Just visit these, they are leaves so we don&apos;t keep traversing.\n    visitor(element, null, context);\n  }\n}\n```\n\n注水和脱水，是同构应用最为核心和关键的细节点。\n\n### <font color=13aa6c>请求认证处理</font>\n\n上面讲到服务端预先请求数据，那么思考这样的场景：某个请求依赖 cookie 表明的用户信息，比如请求“我的学习计划列表”。这种情况下服务端请求是不同于客户端的，不会有浏览器添加 cookie 以及不含有其他相关的 header 信息。这个请求在服务端发送时，一定不会拿到预期的结果。\n\n为了解决这个问题，我们来看看 React-apollo 的解决方法：\n\n```\nimport { ApolloProvider } from &apos;react-apollo&apos;\nimport { ApolloClient } from &apos;apollo-client&apos;\nimport { createHttpLink } from &apos;apollo-link-http&apos;\nimport Express from &apos;express&apos;\nimport { StaticRouter } from &apos;react-router&apos;\nimport { InMemoryCache } from \"apollo-cache-inmemory\"\n\nimport Layout from &apos;./routes/Layout&apos;\n\n// Note you don&apos;t have to use any particular http server, but\n// we&apos;re using Express in this example\nconst app = new Express();\napp.use((req, res) => {\n\n  const client = new ApolloClient({\n    ssrMode: true,\n    // Remember that this is the interface the SSR server will use to connect to the\n    // API server, so we need to ensure it isn&apos;t firewalled, etc\n    link: createHttpLink({\n      uri: &apos;http://localhost:3010&apos;,\n      credentials: &apos;same-origin&apos;,\n      headers: {\n        cookie: req.header(&apos;Cookie&apos;),\n      },\n    }),\n    cache: new InMemoryCache(),\n  });\n\n  const context = {}\n\n  // The client-side App will instead use <BrowserRouter>\n  const App = (\n    <ApolloProvider client={client}>\n      <StaticRouter location={req.url} context={context}>\n        <Layout />\n      </StaticRouter>\n    </ApolloProvider>\n  );\n\n  // rendering code (see below)\n})\n```\n\n这个做法也非常简单，原理是：服务端请求时需要保留客户端页面请求的信息，并在 API 请求时携带并透传这个信息。上述代码中，createHttpLink 方法调用时：\n\n```\nheaders: {\n\tcookie: req.header(&apos;Cookie&apos;),\n},\n```\n\n这个配置项就是关键，它使得服务端的请求完整地还原了客户端信息，因此验证类接口也不再会有问题。\n\n事实上，很多早期 React 完成服务端渲染的轮子都借鉴了 React-apollo 众多优秀思想，对这个话题感兴趣的读者可以抽空去了解 React-apollo。\n\n### <font color=13aa6c>样式问题处理</font>\n\n同构应用的样式处理容易被开发者所忽视，而一旦忽略，就会掉到坑里。比如，正常的服务端渲染只是返回了 HTML 字符串，样式需要浏览器加载完 CSS 后才会加上，这个样式添加的过程就会造成页面的闪动。\n\n再比如，我们不能再使用 style-loader 了，因为这个 webpack loader 会在编译时将样式模块载入到 HTML header 中。但是在服务端渲染环境下，没有 window 对象，style-loader 进而会报错。一般我们换用 isomorphic-style-loader 来实现：\n\n```\n{\n    test: /\\.css$/,\n    use: [\n        &apos;isomorphic-style-loader&apos;,\n        &apos;css-loader&apos;,\n        &apos;postcss-loader&apos;\n    ],\n}\n```\n\n同时 isomorphic-style-loader 也会解决页面样式闪动的问题。它的原理也不难理解：在服务器端输出 html 字符串的同时，也将样式插入到 html 字符串当中，将结果一同传送到客户端。\n\nisomorphic-style-loader 的原理是什么呢？\n\n我们知道对于 webpack 来说，所有的资源都是模块，webpack loader 在编译过程中可以将导入的 CSS 文件转换成对象，拿到样式信息。因此 isomorphic-style-loader 可以获取页面中所有组件样式。为了实现的更加通用化，isomorphic-style-loader 利用 context API，在渲染页面组件时获取所有 React 组件的样式信息，最终插入到 HTML 字符串中。\n\n在服务端渲染时，我们需要加入这样的逻辑：\n\n```\nimport express from &apos;express&apos;\nimport React from &apos;react&apos;\nimport ReactDOM from &apos;react-dom&apos;\nimport StyleContext from &apos;isomorphic-style-loader/StyleContext&apos;\nimport App from &apos;./App.js&apos;\n\nconst server = express()\nconst port = process.env.PORT || 3000\n\n// Server-side rendering of the React app\nserver.get(&apos;*&apos;, (req, res, next) => {\n\n  const css = new Set() // CSS for all rendered React components\n  \n  const insertCss = (...styles) => styles.forEach(style => css.add(style._getCss()))\n  \n  const body = ReactDOM.renderToString(\n    <StyleContext.Provider value={{ insertCss }}>\n      <App />\n    </StyleContext.Provider>\n  )\n  const html = `<!doctype html>\n    <html>\n      <head>\n        <script src=\"client.js\" defer></script>\n        <style>${[...css].join(&apos;&apos;)}</style>\n      </head>\n      <body>\n        <div id=\"root\">${body}</div>\n      </body>\n    </html>`\n  res.status(200).send(html)\n})\n\nserver.listen(port, () => {\n  console.log(`Node.js app is running at http://localhost:${port}/`)\n})\n```\n\n我们定义了 css Set 类型来存储页面所有的样式，并定义了 insertCss 方法，该方法通过 context 传给每个 React 组件，这样每个组件就可以调用 insertCss 方法。该方法调用时，会将组件样式加入到 css Set 当中。\n\n最后我们用 [...css].join(&apos;&apos;) 就可以获取页面的所有样式字符串。\n\n强调一下，isomorphic-style-loader 的源码目前已经更新，采用了最新的 React hooks API，我推荐给 React 开发者阅读，相信一定收获很多！\n\n### <font color=13aa6c>meta tags 渲染</font>\n\nReact 应用中，骨架往往类似：\n\n```\nconst App = () => {\n  return (\n    <div>\n       <Component1 />\n       <Component2 />\n    </div>\n  )\n}\nReactDom.render(<App/>, document.querySelector(&apos;#root&apos;))\n```\n\nApp 组件嵌入到 document.querySelector(&apos;#root&apos;) 节点当中，一般是不包含 head 标签的。但是单页应用在切换路由时，可能也会需要动态修改 head 标签信息，比如 title 内容。也就是说：在单页面应用切换页面，不会经过服务端渲染，但是我们仍然需要更改 document 的 title 内容。\n\n那么服务端如何渲染 meta tags head 标签就是一个常被忽略但是至关重要的话题，我们往往使用 React-helmet 库来解决问题。\n\nHome 组件：\n\n```\nimport Helmet from \"react-helmet\";\n\n<div>\n    <Helmet>\n        <title>Home page</title>\n        <meta name=\"description\" content=\"Home page description\" />\n    </Helmet>\n    <h1>Home component</h1>\n```\n\nUsers 组件：\n\n```\n<Helmet>\n    <title>Users page</title>\n    <meta name=\"description\" content=\"Users page description\" />\n</Helmet>\n```\n\nReact-helmet 这个库会在 Home 组件和 Users 组件渲染时，检测到 Helmet，并自动执行副作用逻辑。\n\n### <font color=13aa6c>404 处理</font>\n\n当服务端渲染时，我们还需要留心对 404 的情况进行处理，有 layout.js 文件如下：\n\n```\n<Switch>\n    <Route path=\"/\" exact component={Home} />\n    <Route path=\"/users\" exact component={Users} />\n</Switch>\n```\n\n当访问：`/home` 时，会得到一个空白页面，浏览器也没有得到 404 的状态码。为了处理这种情况，我们加入：\n\n```\n<Switch>\n    <Route path=\"/\" exact component={Home} />\n    <Route path=\"/users\" exact component={Users} />\n    <Route component={NotFound} />\n</Switch>\n```\n\n并创建 NotFound.js 文件：\n\n```\nimport React from &apos;react&apos;\n\nexport default function NotFound({ staticContext }) {\n    if (staticContext) {\n        staticContext.notFound = true\n    }\n    return (\n        <div>Not found</div>\n    )\n}\n```\n\n注意，在访问一个不存在的地址时，我们要返回 404 状态码。一般 React router 类库已经帮我们进行了较好的封装，Static Router 会注入一个 context prop，并将 context.notFound 赋值为 true，在 server/index.js 加入：\n\n```\nconst context = {}\nconst html = renderer(data, req.path, context);\nif (context.notFound) {\n    res.status(404)\n}\nres.send(html)\n```\n\n即可。这一系列处理过程没有什么难点，但是这种处理意识，还是需要具备的。\n\n### <font color=13aa6c>安全问题</font>\n\n安全问题非常关键，尤其是涉及到服务端渲染，开发者要格外小心。这里提出一个点：我们前面提到了注水和脱水过程，其中的代码：\n\n```\nctx.body = `\n  <!DOCTYPE html>\n  <html lang=\"en\">\n    <head>\n      <meta charset=\"UTF-8\">\n    </head>\n    <body>\n    \t<script>\n        window.context = {\n          initialState: ${JSON.stringify(store.getState())}\n        }\n      </script>\n      <div id=\"app\">\n      \t// ...\n      </div>\n    </body>\n  </html>\n`\n```\n\n非常容易遭受 XSS 攻击，JSON.stringify 可能会造成 script 注入。因此，我们需要严格清洗 JSON 字符串中的 HTML 标签和其他危险的字符。我习惯使用 serialize-javascript 库进行处理，这也是同构应用中最容易被忽视的细节。\n\n这里给大家留一个思考题，React dangerouslySetInnerHTML API 也有类似风险，React 是怎么处理这个安全隐患的呢？\n\n### <font color=13aa6c>性能优化</font>\n\n我们将数据请求移到了服务端，但是依然要格外重视性能优化。目前针对于此，业界普遍做法包括以下几点。\n\n- 使用缓存：服务端优化一个最重要的手段就是缓存，不同于传统服务端缓存措施，我们甚至可以实现组件级缓存，业界 walmartlabs 在这方面的实践非常多，且收获了较大的性能提升。感兴趣的读者可以找到相关技术信息。\n- 采用 HSF 代替 HTTP，HSF 是 High-Speed Service Framework 的缩写，译为分布式的远程服务调用框架，对外提供服务上，HSF 性能远超过 HTTP。\n- 对于服务端压力过大的场景，动态切换为客户端渲染。\n- NodeJS 升级。\n- React 升级。\n\n如图所示，React 16 在服务端渲染上的性能对比提升：\n\n![enter image description here](https://images.gitbook.cn/62d9e840-9ee8-11e9-ac5c-d5048fafc34b)\n\n> 备注：图片来自 [hacker noon](https://hackernoon.com/whats-new-with-server-side-rendering-in-react-16-9b0d78585d67)\n\n### <font color=13aa6c>总结</font>\n\n本讲没有“手把手”教你实现服务端渲染的同构应用，因为这些知识并不困难，社区上资料也很多。我们从更高的角度出发，剖析同构应用中那些关键的细节点和疑难问题的解决方案，这些经验来源于真刀真枪的线上案例，如果读者没有开发过同构应用，也能从中全方位地了解关键信息，一旦掌握了这些细节，同构应用的实现就会更稳、更可靠。\n\n同构应用其实远比理论复杂，绝对不是几个 APIs 和几台服务器就能完成的，希望大家多思考、多动手，一定会更有体会。\n\n另外，同构应用各种细节也不止于此，坑也不止于此，欢迎大家和我讨论。\n\n### <font color=13aa6c>分享交流</font>\n\n阅读文章过程中有任何疑问可随时跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。**你的分享不仅帮助他人，更会提升自己。**\n\n你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。\n\n>**为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。**","pdfUrl":"","reader":"","duration":"","title":"同构应用中你所忽略的细节","column":"5c91c813968b1d64b1e08fde","isNotification":false,"readingStatistics":3,"htmlContent":"<p>不管是服务端渲染还是服务端渲染衍生出的同构应用，现在来看已经并不新鲜了，实现起来也并不困难。可是有的开发者认为：同构应用不就是调用一个 renderToString（React 中）类似的 API 吗？</p>\n<p>讲道理确实是这样的，但是讲道理你也许并没有真正在实战中领会同构应用的精髓。</p>\n<p>同构应用能够完成的本质条件是虚拟 DOM，基于虚拟 DOM 我们可以生成真实的 DOM，并由浏览器渲染；也可以调用不同框架的不同 APIs，将虚拟 DOM 生成字符串，由服务端传输给客户端。</p>\n<p>但是同构应用也不只是这么简单。拿面试来说，同构应用的考察点不是“纸上谈兵”的理论，而是实际实施时的细节。这一讲我们就来聊一聊“同构应用中往往被忽略的细节”，需要读者提前了解服务端渲染和同构应用的概念。</p>\n<p>相关知识点如下：</p>\n<img src=\"https://images.gitbook.cn/d5314df0-9d55-11e9-8a2c-e9ea8cc9b822\" width=350>\n<h3><a id=\"font_color13aa6cfont_12\"></a><font color=13aa6c>打包环境区分</font></h3>\n<p>第一个细节：我们知道同构应用实现了客户端代码和服务端代码的基本统一，我们只需要编写一种组件，就能生成适用于服务端和客户端的组件案例。可是你是否知道，服务端代码和客户端代码大多数情况下还是需要单独处理？比如：</p>\n<ul>\n<li>路由代码差别：服务端需要根据请求路径，匹配页面组件；客户端需要通过浏览器中的地址，匹配页面组件。</li>\n</ul>\n<p>客户端代码：</p>\n<pre><code class=\"lang-\">const App = () =&gt; {\n  return (\n    &lt;Provider store={store}&gt;\n      &lt;BrowserRouter&gt;\n        &lt;div&gt;\n          &lt;Route path=&apos;/&apos; component={Home}&gt;\n          &lt;Route path=&apos;/product&apos; component={Product}&gt;\n        &lt;/div&gt;\n      &lt;/BrowserRouter&gt;\n    &lt;/Provider&gt;\n  )\n}\nReactDom.render(&lt;App/&gt;, document.querySelector(&apos;#root&apos;))\n</code></pre>\n<p>BrowserRouter 组件根据 window.location 以及 history API 实现页面切换，而服务端肯定是无法获取 window.location 的，服务端代码如下：</p>\n<pre><code class=\"lang-\">const App = () =&gt; {\n  return \n    &lt;Provider store={store}&gt;\n      &lt;StaticRouter location={req.path} context={context}&gt;\n        &lt;div&gt;\n          &lt;Route path=&apos;/&apos; component={Home}&gt;\n        &lt;/div&gt;\n      &lt;/StaticRouter&gt;\n    &lt;/Provider&gt;\n}\nReturn ReactDom.renderToString(&lt;App/&gt;)\n</code></pre>\n<p>需要使用 StaticRouter 组件，并将请求地址和上下文信息作为 location 和 context 这两个 props 传入 StaticRouter 中。</p>\n<ul>\n<li>\n<p>打包差别：服务端运行的代码如果需要依赖 Node 核心模块或者第三方模块，就不再需要把这些模块代码打包到最终代码中了。因为环境已经安装这些依赖，可以直接引用。这样一来，就需要我们在 webpack 中配置：target：node，并借助  webpack-node-externals 插件，解决第三方依赖打包的问题。</p>\n</li>\n<li>\n<p>对于图片等静态资源，url-loader 会在服务端代码和客户端代码打包过程中分别被引用，因此会在资源目录中生成了重复的文件。当然后打包出来的因为重名，会覆盖前一次打包出来的结果，并不影响使用，但是整个构建过程并不优雅。</p>\n</li>\n<li>\n<p>由于路由在服务端和客户端的差别，因此 webpack 配置文件的 entry 会不相同：</p>\n</li>\n</ul>\n<pre><code class=\"lang-\">{\n\tentry: &apos;./src/client/index.js&apos;,\n}\n\n{\n\tentry: &apos;./src/server/index.js&apos;,\n}\n</code></pre>\n<h3><a id=\"font_color13aa6cfont_70\"></a><font color=13aa6c>注水和脱水</font></h3>\n<p>什么叫做注水和脱水呢？这个和同构应用中数据的获取有关：在服务器端渲染时，首先服务端请求接口拿到数据，并处理准备好数据状态（如果使用 Redux，就是进行 store 的更新），为了减少客户端的请求，我们需要保留住这个状态。一般做法是在服务器端返回 HTML 字符串的时候，将数据 JSON.stringify 一并返回，这个过程，叫做脱水（dehydrate）；在客户端，就不再需要进行数据的请求了，可以直接使用服务端下发下来的数据，这个过程叫注水（hydrate）。用代码来表示：</p>\n<p>服务端：</p>\n<pre><code class=\"lang-\">ctx.body = `\n  &lt;!DOCTYPE html&gt;\n  &lt;html lang=&quot;en&quot;&gt;\n    &lt;head&gt;\n      &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n    \t&lt;script&gt;\n        window.context = {\n          initialState: ${JSON.stringify(store.getState())}\n        }\n      &lt;/script&gt;\n      &lt;div id=&quot;app&quot;&gt;\n      \t// ...\n      &lt;/div&gt;\n    &lt;/body&gt;\n  &lt;/html&gt;\n`\n</code></pre>\n<p>客户端：</p>\n<pre><code class=\"lang-\">export const getClientStore = () =&gt; {\n  const defaultState = JSON.parse(window.context.state)\n  return createStore(reducer, defaultState, applyMiddleware(thunk))\n}\n</code></pre>\n<p>这一系列过程非常典型，但是也会有几个细节值得探讨：<strong>在服务端渲染时，服务端如何能够请求所有的 APIs，保障数据全部已经请求呢？</strong></p>\n<p>一般有两种方法：</p>\n<ul>\n<li>react-router 的解决方案是配置路由 route-config，结合 matchRoutes，找到页面上相关组件所需的请求接口的方法并执行请求。这就要求开发者通过路由配置信息，显式地告知服务端请求内容。</li>\n</ul>\n<p>我们首先配置路由：</p>\n<pre><code class=\"lang-\">const routes = [\n  {\n    path: &quot;/&quot;,\n    component: Root,\n    loadData: () =&gt; getSomeData()\n  }\n  // etc.\n]\n\nimport { routes } from &quot;./routes&quot;\n\nfunction App() {\n  return (\n    &lt;Switch&gt;\n      {routes.map(route =&gt; (\n        &lt;Route {...route} /&gt;\n      ))}\n    &lt;/Switch&gt;\n  )\n}\n</code></pre>\n<p>在服务端代码中：</p>\n<pre><code class=\"lang-\">import { matchPath } from &quot;react-router-dom&quot;\n\nconst promises = []\nroutes.some(route =&gt; {\n  const match = matchPath(req.path, route)\n  if (match) promises.push(route.loadData(match))\n  return match\n})\n\nPromise.all(promises).then(data =&gt; {\n  putTheDataSomewhereTheClientCanFindIt(data)\n})\n</code></pre>\n<ul>\n<li>另外一种思路类似 Next.js，我们需要在 React 组件上定义静态方法。<br />\n比如定义静态 loadData 方法，在服务端渲染时，我们可以遍历所有组件的 loadData，获取需要请求的接口。这样的方式借鉴了早期 React-apollo 的解决方案，我个人很喜欢这种设计。这里贴出我为 Facebook 团队 react-apollo 开源项目贡献的改动代码，其目的就是遍历组件，获取请求接口：</li>\n</ul>\n<pre><code class=\"lang-\">function getPromisesFromTree({\n  rootElement,\n  rootContext = {},\n}: PromiseTreeArgument): PromiseTreeResult[] {\n  const promises: PromiseTreeResult[] = [];\n\n  walkTree(rootElement, rootContext, (_, instance, context, childContext) =&gt; {\n    if (instance &amp;&amp; hasFetchDataFunction(instance)) {\n      const promise = instance.fetchData();\n      if (isPromise&lt;Object&gt;(promise)) {\n        promises.push({ promise, context: childContext || context, instance });\n        return false;\n      }\n    }\n  });\n\n  return promises;\n}\n\n// Recurse a React Element tree, running visitor on each element.\n// If visitor returns `false`, don&apos;t call the element&apos;s render function\n// or recurse into its child elements.\nexport function walkTree(\n  element: React.ReactNode,\n  context: Context,\n  visitor: (\n    element: React.ReactNode,\n    instance: React.Component&lt;any&gt; | null,\n    context: Context,\n    childContext?: Context,\n  ) =&gt; boolean | void,\n) {\n  if (Array.isArray(element)) {\n    element.forEach(item =&gt; walkTree(item, context, visitor));\n    return;\n  }\n\n  if (!element) {\n    return;\n  }\n\n  // A stateless functional component or a class\n  if (isReactElement(element)) {\n    if (typeof element.type === &apos;function&apos;) {\n      const Comp = element.type;\n      const props = Object.assign({}, Comp.defaultProps, getProps(element));\n      let childContext = context;\n      let child;\n\n      // Are we are a react class?\n      if (isComponentClass(Comp)) {\n        const instance = new Comp(props, context);\n        // In case the user doesn&apos;t pass these to super in the constructor.\n        // Note: `Component.props` are now readonly in `@types/react`, so\n        // we&apos;re using `defineProperty` as a workaround (for now).\n        Object.defineProperty(instance, &apos;props&apos;, {\n          value: instance.props || props,\n        });\n        instance.context = instance.context || context;\n\n        // Set the instance state to null (not undefined) if not set, to match React behaviour\n        instance.state = instance.state || null;\n\n        // Override setState to just change the state, not queue up an update\n        // (we can&apos;t do the default React thing as we aren&apos;t mounted\n        // &quot;properly&quot;, however we don&apos;t need to re-render as we only support\n        // setState in componentWillMount, which happens *before* render).\n        instance.setState = newState =&gt; {\n          if (typeof newState === &apos;function&apos;) {\n            // React&apos;s TS type definitions don&apos;t contain context as a third parameter for\n            // setState&apos;s updater function.\n            // Remove this cast to `any` when that is fixed.\n            newState = (newState as any)(instance.state, instance.props, instance.context);\n          }\n          instance.state = Object.assign({}, instance.state, newState);\n        };\n\n        if (Comp.getDerivedStateFromProps) {\n          const result = Comp.getDerivedStateFromProps(instance.props, instance.state);\n          if (result !== null) {\n            instance.state = Object.assign({}, instance.state, result);\n          }\n        } else if (instance.UNSAFE_componentWillMount) {\n          instance.UNSAFE_componentWillMount();\n        } else if (instance.componentWillMount) {\n          instance.componentWillMount();\n        }\n\n        if (providesChildContext(instance)) {\n          childContext = Object.assign({}, context, instance.getChildContext());\n        }\n\n        if (visitor(element, instance, context, childContext) === false) {\n          return;\n        }\n\n        child = instance.render();\n      } else {\n        // Just a stateless functional\n        if (visitor(element, null, context) === false) {\n          return;\n        }\n\n        child = Comp(props, context);\n      }\n\n      if (child) {\n        if (Array.isArray(child)) {\n          child.forEach(item =&gt; walkTree(item, childContext, visitor));\n        } else {\n          walkTree(child, childContext, visitor);\n        }\n      }\n    } else if ((element.type as any)._context || (element.type as any).Consumer) {\n      // A React context provider or consumer\n      if (visitor(element, null, context) === false) {\n        return;\n      }\n\n      let child;\n      if ((element.type as any)._context) {\n        // A provider - sets the context value before rendering children\n        ((element.type as any)._context as any)._currentValue = element.props.value;\n        child = element.props.children;\n      } else {\n        // A consumer\n        child = element.props.children((element.type as any)._currentValue);\n      }\n\n      if (child) {\n        if (Array.isArray(child)) {\n          child.forEach(item =&gt; walkTree(item, context, visitor));\n        } else {\n          walkTree(child, context, visitor);\n        }\n      }\n    } else {\n      // A basic string or dom element, just get children\n      if (visitor(element, null, context) === false) {\n        return;\n      }\n\n      if (element.props &amp;&amp; element.props.children) {\n        React.Children.forEach(element.props.children, (child: any) =&gt; {\n          if (child) {\n            walkTree(child, context, visitor);\n          }\n        });\n      }\n    }\n  } else if (typeof element === &apos;string&apos; || typeof element === &apos;number&apos;) {\n    // Just visit these, they are leaves so we don&apos;t keep traversing.\n    visitor(element, null, context);\n  }\n}\n</code></pre>\n<p>注水和脱水，是同构应用最为核心和关键的细节点。</p>\n<h3><a id=\"font_color13aa6cfont_317\"></a><font color=13aa6c>请求认证处理</font></h3>\n<p>上面讲到服务端预先请求数据，那么思考这样的场景：某个请求依赖 cookie 表明的用户信息，比如请求“我的学习计划列表”。这种情况下服务端请求是不同于客户端的，不会有浏览器添加 cookie 以及不含有其他相关的 header 信息。这个请求在服务端发送时，一定不会拿到预期的结果。</p>\n<p>为了解决这个问题，我们来看看 React-apollo 的解决方法：</p>\n<pre><code class=\"lang-\">import { ApolloProvider } from &apos;react-apollo&apos;\nimport { ApolloClient } from &apos;apollo-client&apos;\nimport { createHttpLink } from &apos;apollo-link-http&apos;\nimport Express from &apos;express&apos;\nimport { StaticRouter } from &apos;react-router&apos;\nimport { InMemoryCache } from &quot;apollo-cache-inmemory&quot;\n\nimport Layout from &apos;./routes/Layout&apos;\n\n// Note you don&apos;t have to use any particular http server, but\n// we&apos;re using Express in this example\nconst app = new Express();\napp.use((req, res) =&gt; {\n\n  const client = new ApolloClient({\n    ssrMode: true,\n    // Remember that this is the interface the SSR server will use to connect to the\n    // API server, so we need to ensure it isn&apos;t firewalled, etc\n    link: createHttpLink({\n      uri: &apos;http://localhost:3010&apos;,\n      credentials: &apos;same-origin&apos;,\n      headers: {\n        cookie: req.header(&apos;Cookie&apos;),\n      },\n    }),\n    cache: new InMemoryCache(),\n  });\n\n  const context = {}\n\n  // The client-side App will instead use &lt;BrowserRouter&gt;\n  const App = (\n    &lt;ApolloProvider client={client}&gt;\n      &lt;StaticRouter location={req.url} context={context}&gt;\n        &lt;Layout /&gt;\n      &lt;/StaticRouter&gt;\n    &lt;/ApolloProvider&gt;\n  );\n\n  // rendering code (see below)\n})\n</code></pre>\n<p>这个做法也非常简单，原理是：服务端请求时需要保留客户端页面请求的信息，并在 API 请求时携带并透传这个信息。上述代码中，createHttpLink 方法调用时：</p>\n<pre><code class=\"lang-\">headers: {\n\tcookie: req.header(&apos;Cookie&apos;),\n},\n</code></pre>\n<p>这个配置项就是关键，它使得服务端的请求完整地还原了客户端信息，因此验证类接口也不再会有问题。</p>\n<p>事实上，很多早期 React 完成服务端渲染的轮子都借鉴了 React-apollo 众多优秀思想，对这个话题感兴趣的读者可以抽空去了解 React-apollo。</p>\n<h3><a id=\"font_color13aa6cfont_379\"></a><font color=13aa6c>样式问题处理</font></h3>\n<p>同构应用的样式处理容易被开发者所忽视，而一旦忽略，就会掉到坑里。比如，正常的服务端渲染只是返回了 HTML 字符串，样式需要浏览器加载完 CSS 后才会加上，这个样式添加的过程就会造成页面的闪动。</p>\n<p>再比如，我们不能再使用 style-loader 了，因为这个 webpack loader 会在编译时将样式模块载入到 HTML header 中。但是在服务端渲染环境下，没有 window 对象，style-loader 进而会报错。一般我们换用 isomorphic-style-loader 来实现：</p>\n<pre><code class=\"lang-\">{\n    test: /\\.css$/,\n    use: [\n        &apos;isomorphic-style-loader&apos;,\n        &apos;css-loader&apos;,\n        &apos;postcss-loader&apos;\n    ],\n}\n</code></pre>\n<p>同时 isomorphic-style-loader 也会解决页面样式闪动的问题。它的原理也不难理解：在服务器端输出 html 字符串的同时，也将样式插入到 html 字符串当中，将结果一同传送到客户端。</p>\n<p>isomorphic-style-loader 的原理是什么呢？</p>\n<p>我们知道对于 webpack 来说，所有的资源都是模块，webpack loader 在编译过程中可以将导入的 CSS 文件转换成对象，拿到样式信息。因此 isomorphic-style-loader 可以获取页面中所有组件样式。为了实现的更加通用化，isomorphic-style-loader 利用 context API，在渲染页面组件时获取所有 React 组件的样式信息，最终插入到 HTML 字符串中。</p>\n<p>在服务端渲染时，我们需要加入这样的逻辑：</p>\n<pre><code class=\"lang-\">import express from &apos;express&apos;\nimport React from &apos;react&apos;\nimport ReactDOM from &apos;react-dom&apos;\nimport StyleContext from &apos;isomorphic-style-loader/StyleContext&apos;\nimport App from &apos;./App.js&apos;\n\nconst server = express()\nconst port = process.env.PORT || 3000\n\n// Server-side rendering of the React app\nserver.get(&apos;*&apos;, (req, res, next) =&gt; {\n\n  const css = new Set() // CSS for all rendered React components\n  \n  const insertCss = (...styles) =&gt; styles.forEach(style =&gt; css.add(style._getCss()))\n  \n  const body = ReactDOM.renderToString(\n    &lt;StyleContext.Provider value={{ insertCss }}&gt;\n      &lt;App /&gt;\n    &lt;/StyleContext.Provider&gt;\n  )\n  const html = `&lt;!doctype html&gt;\n    &lt;html&gt;\n      &lt;head&gt;\n        &lt;script src=&quot;client.js&quot; defer&gt;&lt;/script&gt;\n        &lt;style&gt;${[...css].join(&apos;&apos;)}&lt;/style&gt;\n      &lt;/head&gt;\n      &lt;body&gt;\n        &lt;div id=&quot;root&quot;&gt;${body}&lt;/div&gt;\n      &lt;/body&gt;\n    &lt;/html&gt;`\n  res.status(200).send(html)\n})\n\nserver.listen(port, () =&gt; {\n  console.log(`Node.js app is running at http://localhost:${port}/`)\n})\n</code></pre>\n<p>我们定义了 css Set 类型来存储页面所有的样式，并定义了 insertCss 方法，该方法通过 context 传给每个 React 组件，这样每个组件就可以调用 insertCss 方法。该方法调用时，会将组件样式加入到 css Set 当中。</p>\n<p>最后我们用 […css].join(’’) 就可以获取页面的所有样式字符串。</p>\n<p>强调一下，isomorphic-style-loader 的源码目前已经更新，采用了最新的 React hooks API，我推荐给 React 开发者阅读，相信一定收获很多！</p>\n<h3><a id=\"font_color13aa6cmeta_tags_font_450\"></a><font color=13aa6c>meta tags 渲染</font></h3>\n<p>React 应用中，骨架往往类似：</p>\n<pre><code class=\"lang-\">const App = () =&gt; {\n  return (\n    &lt;div&gt;\n       &lt;Component1 /&gt;\n       &lt;Component2 /&gt;\n    &lt;/div&gt;\n  )\n}\nReactDom.render(&lt;App/&gt;, document.querySelector(&apos;#root&apos;))\n</code></pre>\n<p>App 组件嵌入到 document.querySelector(’#root’) 节点当中，一般是不包含 head 标签的。但是单页应用在切换路由时，可能也会需要动态修改 head 标签信息，比如 title 内容。也就是说：在单页面应用切换页面，不会经过服务端渲染，但是我们仍然需要更改 document 的 title 内容。</p>\n<p>那么服务端如何渲染 meta tags head 标签就是一个常被忽略但是至关重要的话题，我们往往使用 React-helmet 库来解决问题。</p>\n<p>Home 组件：</p>\n<pre><code class=\"lang-\">import Helmet from &quot;react-helmet&quot;;\n\n&lt;div&gt;\n    &lt;Helmet&gt;\n        &lt;title&gt;Home page&lt;/title&gt;\n        &lt;meta name=&quot;description&quot; content=&quot;Home page description&quot; /&gt;\n    &lt;/Helmet&gt;\n    &lt;h1&gt;Home component&lt;/h1&gt;\n</code></pre>\n<p>Users 组件：</p>\n<pre><code class=\"lang-\">&lt;Helmet&gt;\n    &lt;title&gt;Users page&lt;/title&gt;\n    &lt;meta name=&quot;description&quot; content=&quot;Users page description&quot; /&gt;\n&lt;/Helmet&gt;\n</code></pre>\n<p>React-helmet 这个库会在 Home 组件和 Users 组件渲染时，检测到 Helmet，并自动执行副作用逻辑。</p>\n<h3><a id=\"font_color13aa6c404_font_494\"></a><font color=13aa6c>404 处理</font></h3>\n<p>当服务端渲染时，我们还需要留心对 404 的情况进行处理，有 layout.js 文件如下：</p>\n<pre><code class=\"lang-\">&lt;Switch&gt;\n    &lt;Route path=&quot;/&quot; exact component={Home} /&gt;\n    &lt;Route path=&quot;/users&quot; exact component={Users} /&gt;\n&lt;/Switch&gt;\n</code></pre>\n<p>当访问：<code>/home</code> 时，会得到一个空白页面，浏览器也没有得到 404 的状态码。为了处理这种情况，我们加入：</p>\n<pre><code class=\"lang-\">&lt;Switch&gt;\n    &lt;Route path=&quot;/&quot; exact component={Home} /&gt;\n    &lt;Route path=&quot;/users&quot; exact component={Users} /&gt;\n    &lt;Route component={NotFound} /&gt;\n&lt;/Switch&gt;\n</code></pre>\n<p>并创建 NotFound.js 文件：</p>\n<pre><code class=\"lang-\">import React from &apos;react&apos;\n\nexport default function NotFound({ staticContext }) {\n    if (staticContext) {\n        staticContext.notFound = true\n    }\n    return (\n        &lt;div&gt;Not found&lt;/div&gt;\n    )\n}\n</code></pre>\n<p>注意，在访问一个不存在的地址时，我们要返回 404 状态码。一般 React router 类库已经帮我们进行了较好的封装，Static Router 会注入一个 context prop，并将 context.notFound 赋值为 true，在 server/index.js 加入：</p>\n<pre><code class=\"lang-\">const context = {}\nconst html = renderer(data, req.path, context);\nif (context.notFound) {\n    res.status(404)\n}\nres.send(html)\n</code></pre>\n<p>即可。这一系列处理过程没有什么难点，但是这种处理意识，还是需要具备的。</p>\n<h3><a id=\"font_color13aa6cfont_543\"></a><font color=13aa6c>安全问题</font></h3>\n<p>安全问题非常关键，尤其是涉及到服务端渲染，开发者要格外小心。这里提出一个点：我们前面提到了注水和脱水过程，其中的代码：</p>\n<pre><code class=\"lang-\">ctx.body = `\n  &lt;!DOCTYPE html&gt;\n  &lt;html lang=&quot;en&quot;&gt;\n    &lt;head&gt;\n      &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n    \t&lt;script&gt;\n        window.context = {\n          initialState: ${JSON.stringify(store.getState())}\n        }\n      &lt;/script&gt;\n      &lt;div id=&quot;app&quot;&gt;\n      \t// ...\n      &lt;/div&gt;\n    &lt;/body&gt;\n  &lt;/html&gt;\n`\n</code></pre>\n<p>非常容易遭受 XSS 攻击，JSON.stringify 可能会造成 script 注入。因此，我们需要严格清洗 JSON 字符串中的 HTML 标签和其他危险的字符。我习惯使用 serialize-javascript 库进行处理，这也是同构应用中最容易被忽视的细节。</p>\n<p>这里给大家留一个思考题，React dangerouslySetInnerHTML API 也有类似风险，React 是怎么处理这个安全隐患的呢？</p>\n<h3><a id=\"font_color13aa6cfont_572\"></a><font color=13aa6c>性能优化</font></h3>\n<p>我们将数据请求移到了服务端，但是依然要格外重视性能优化。目前针对于此，业界普遍做法包括以下几点。</p>\n<ul>\n<li>使用缓存：服务端优化一个最重要的手段就是缓存，不同于传统服务端缓存措施，我们甚至可以实现组件级缓存，业界 walmartlabs 在这方面的实践非常多，且收获了较大的性能提升。感兴趣的读者可以找到相关技术信息。</li>\n<li>采用 HSF 代替 HTTP，HSF 是 High-Speed Service Framework 的缩写，译为分布式的远程服务调用框架，对外提供服务上，HSF 性能远超过 HTTP。</li>\n<li>对于服务端压力过大的场景，动态切换为客户端渲染。</li>\n<li>NodeJS 升级。</li>\n<li>React 升级。</li>\n</ul>\n<p>如图所示，React 16 在服务端渲染上的性能对比提升：</p>\n<p><img src=\"https://images.gitbook.cn/62d9e840-9ee8-11e9-ac5c-d5048fafc34b\" alt=\"enter image description here\" /></p>\n<blockquote>\n<p>备注：图片来自 <a href=\"https://hackernoon.com/whats-new-with-server-side-rendering-in-react-16-9b0d78585d67\" target=\"_blank\">hacker noon</a></p>\n</blockquote>\n<h3><a id=\"font_color13aa6cfont_588\"></a><font color=13aa6c>总结</font></h3>\n<p>本讲没有“手把手”教你实现服务端渲染的同构应用，因为这些知识并不困难，社区上资料也很多。我们从更高的角度出发，剖析同构应用中那些关键的细节点和疑难问题的解决方案，这些经验来源于真刀真枪的线上案例，如果读者没有开发过同构应用，也能从中全方位地了解关键信息，一旦掌握了这些细节，同构应用的实现就会更稳、更可靠。</p>\n<p>同构应用其实远比理论复杂，绝对不是几个 APIs 和几台服务器就能完成的，希望大家多思考、多动手，一定会更有体会。</p>\n<p>另外，同构应用各种细节也不止于此，坑也不止于此，欢迎大家和我讨论。</p>\n<h3><a id=\"font_color13aa6cfont_596\"></a><font color=13aa6c>分享交流</font></h3>\n<p>阅读文章过程中有任何疑问可随时跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。<strong>你的分享不仅帮助他人，更会提升自己。</strong></p>\n<p>你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。</p>\n<blockquote>\n<p><strong>为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。</strong></p>\n</blockquote>\n","createdAt":"2019-04-21T04:24:19.171Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":21,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FoThASW9dVEPMEo9nP-zaOfbKyLZ"},{"_id":"5cbbf09fbbbba80861a35c34","communication_start_time":null,"type":1,"audioPath":"","abstract":"","content":"我记得作为实习生时，第一个独立前端项目是为欧洲天然气石油系统做一个计费应用：在地图上，用户可以和地图交互，从欧亚大陆任何一个石油气点为起点，到任何一个石油气点作为终点，计算出沿途所有的路径运输方案以及计费详情，还要支持各种终端的查询以及打印，这是一个纯 JavaScript 单页面应用 + Severless 的项目。\n\n实习期满离职前我进行复盘：繁多的原生 JavaScript APIs 让我无语，兼容性让我崩溃，“如果我一开始就选用 jQuery 做该多好！” ，too young too simple。这时候再让我复盘，“jQuery 也不适用那样一个单页应用，我为什么不用 React 或者 Vue？”果然 sometimes naive。\n\n前端框架确实一直在演进、发展，那么框架除了简化我们的操作外，我们还能从中学到什么？这一讲，我就对这个开放性话题进行展开。本节课内容比较轻松，没有大量的代码案例，让我们来舒缓一下，但请读者在阅读时始终思考——“从框架和类库，我们该学到什么”这一问题。\n\nVue 和 React 加其生态方案使得 Vue 和 React 不再是单纯的视图层类库，因此下面我们将 Vue 和 React 统称“框架”，表示其全家桶。\n\n相关知识点如下：\n\n<img src=\"https://images.gitbook.cn/60120df0-a383-11e9-95a5-cd4900ba781e\" width=500>\n\n### <font color=13aa6c>React VS Vue：神仙打架</font>\n\nReact 和 Vue 这两个极其优秀的前端“框架”基本上占据了前端开发的半壁江山甚至更多。作为开发者，你可以首选 React 或者 Vue 其中一个，但是如若尝试将两者进行对比，那么一定会收获很多。\n\n这里我们将从以下五大方面进行比较：\n\n- 数据绑定\n- 组件化和数据流\n- 数据状态管理\n- 渲染和更新\n- 社区\n\n#### 数据绑定\n\nVue 在数据绑定上，采取了双向绑定策略，依靠 Object.defineProperty （Vue 3.0 已迁移到 Proxy）以及监听 DOM 事件实现。具体实现方法在先前课程中我们已经剖析过了，简单来说数据改变，依赖对数据进行拦截 / 代理；视图改变，依赖 DOM 事件（如 onInput、onChange 等）。Vue 实例中的 data 和 模版展现是一条线，无论谁被修改，另一方也会发生变动。\n\n值得一提的是 Vue 也支持计算属性，即 computed 属性，这个策略和 React-redux 当中的 mapStateToProps 有异曲同工之妙，都是通过计算，将所需要的数据注入给组件使用。\n\n需要区分清楚的是：双向绑定和单向数据流并没有直接关联，双向绑定是指数据和视图之间的绑定关系，而单向数据流是指组件之间数据的传递。\n\nReact 并没有数据和视图之间的双向绑定，它的策略是“局部刷新”。当数据发生变化时，直接重新渲染组件，以得到最新的视图。这种“无脑”刷新的做法看似粗暴，但是换来的简单直观，并且 React 本身在性能上也提供了一定保障。\n\n#### 组件化和数据流\n\nVue 中组件不像 React 组件，它不是完全以组件功能和 UI 为维度划分的，而 Vue 组件本质是一个 Vue 实例。每个 Vue 实例在创建时都需要经过：设置数据监听、编译模版、应用模版到 DOM，在更新时根据数据变化更新 DOM 的过程。在这个过程中，类似 React 也提供了生命周期方法。\n\nVue 组件间通信或者说组件间数据流如同 React，也是单向的。数据流向也很类似：props 实现父组件向下传递数据，events 实现子组件向上发送消息给父组件，React 中是基于 props 的回调实现子组件向父组件传递数据（Vue 也支持）。\n\n当然，这两种框架也分别通过 context 和 provide/inject 实现了跨层级数据通信，它们的实现也是非常类似的。\n\n#### 数据状态管理\n\n对于较为复杂的数据状态，Redux 是 React 应用最常用的解决方案。这里需要说明的是：Redux 和视图无关，它只是提供了数据管理的流程，因此 Vue 使用 Redux 也是完全没有问题的。\n\n当然，Vue 中更常用的是 Vuex，其借鉴了 Redux（Flux），也具有和 Redux 相同的 store 概念，组件不允许直接修改 store state，而是需要 dispatch action 来通知 store 的变化。但是这个过程不同于 Redux 的函数式思想，Vuex 改变 store 的方法支持提交一个 mutation。mutation 类似于事件发布订阅系统：每个 mutation 都有一个字符串来表示事件类型（type）和一个回调函数（handler）以进行对应的修改。\n\n另一个显著区别是：在 Vuex 中，store 是被直接注入到组件实例中的，因此用起来更加方便。而 Redux 需要 connect 方法，把 props 和 dispatch 注入给组件。\n\n**造成这些不同的本质原因是：**\n\n- Redux 提倡不可变性，而 Vuex 的数据是可变的，Redux 中 reducer 每次都会生成新的 state 以替代旧的 state，而 Vuex 是直接修改；\n- Redux 在检测数据变化的时候，是通过浅比较的方式比较差异的，而 Vuex 其实和 Vue 的原理一样，是通过遍历数据的 getter / setter 来比较。\n\n#### 渲染和更新\n\n就像上面所提到的，React 和 Redux 倡导不可变性，更新需要维持不可变原则；而 Vue 对数据进行了拦截/代理，因此它不要求不可变性，而允许开发者修改数据，以引起响应式更新。\n\nReact 更像 MVC 或者 MVVM 模式中的 view 层，但是搭配 Redux 等，它也是一个完整的 MVVM 类库。Vue 直接是一个典型 MVVM 模式的体现，虽然它一直标榜自己也只是 View 层，但是毫无疑问它本身包含了对数据的操作。比如，Vue 文档中经常会使用 VM（ViewModel 简称），这个变量名表示 Vue 实例，其命名让人想到 MVVM，这是 MVVM 模式的体现。\n\nReact 所有组件的渲染都依靠灵活而强大的 JSX。JSX 并不是一种模版语言，而是 JavaScript 表达式和函数调用的语法糖。在编译之后，JSX 被转化为普通的 JavaScript 对象，用来表示虚拟 DOM。\n\nVue templates 是典型的模版，这相比于 JSX，表达更加自然。在底层实现上，Vue 模版被编译成 DOM 渲染函数，结合响应系统，进行数据依赖的收集。Vue 渲染的过程如下：\n\n- new Vue，进行实例化\n- 挂载 $mount 方法，通过自定义 Render 方法、template、el 等生成 Render 函数，准备渲染内容\n- 通过 Watcher 进行依赖收集\n- 当数据发生变化时，Render 函数执行生成 VNode 对象\n- 通过 patch 方法，对比新旧 VNode 对象，通过 DOM Diff 算法，添加、修改、删除真正的 DOM 元素\n\n当然 Vue 也可以支持 JSX。\n\n关于更新性能问题，简单来说，在 React 应用中，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树。当然我们可以使用 PureComponent，或是手动实现 shouldComponentUpdate 方法，来规避不必要的渲染。但是这个实现过程要知悉数据状态结构，也需要一定的额外负担。\n\n在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的，因此系统能精确知晓哪个组件需要被重渲染。从理论上看，Vue 的渲染更新机制更加细粒度，也更加精确。\n\n#### 社区\n\n这两个框架都具有非常强大的社区，但是对于社区的理念，Vue 和 React 稍有不同。举个例子：路由系统的实现。\n\nVue 的路由库和状态管理库都是由官方维护的，并且与核心库是同步更新的。而 React 把这件事情交给了社区，比如 React 应用中，需要引入 react-router 库来实现路由系统。\n\n### <font color=13aa6c>新版本发布的思考</font>\n\n我一直认为开发者可以从框架新版本的迭代 changelog 里汲取非常多的养分。因为每次发版，都是经过开源框架的维护团队精心设计的，更新点或涉及 bug fix 或涉及新的 features，我们便可以思考“为什么会有这些变动”?，“为什么这样解决 bug”?\n\n除此之外，我还建议开发者从更高的层次“开启上帝视角”，抓着某一话题，某一次变更进行研究、学习。这里我就举个例子：Vue3.0 带来的一些思考。\n\n本讲在编写之时，恰逢尤雨溪在上海 Vue Conf 进行分享，演讲主题：State of Vue，其中涉及到新版本发布。从这次新版本发布对 Vue 的改动，结合我们的课程，我能找到很多切入点进行分析，比如虚拟 DOM、Proxy 实现数据代理。\n\n其中尤雨溪表示 Vue3.0 相比以往版本更加快速。那么“更加迅速”是如何做到更快的呢？我们在《第 4-1 课：触类旁通多种框架》一课中对比过 Object.defineProperty 和 Proxy 实现的数据拦截和代理。那么在 Vue3.0，Vue 团队就是用 Proxy 来代替  Object.defineProperty，达到了更好的性能保障。\n\n除此之外，Vue 新版本还重构了虚拟 DOM，正好在《第 4-1 课：触类旁通多种框架》一课中也简单实现了一个粗糙的虚拟 DOM，我们可以展开谈谈：传统虚拟 DOM 的性能瓶颈在于虚拟 DOM 的 diff，也许某次更新只有一个很小的变动，但还是需要对比整棵虚拟 DOM 树，这显然是非常不划算的。\n\nVue 新版本将虚拟 DOM 的节点分为动态节点和静态节点。静态节点是指不会发生改变的节点，这些节点在进行 diff 时是应该进行规避的，而我们只需要对比动态节点。\n\n比如这样的内容：\n\n```\n<template>\n\t<div>\n\t\t<div id=\"1\">\n\t\t\t<p> 前端进阶 </p>\n\t\t\t<p> 前端进阶 </p>\n\t\t\t<p> 前端进阶 </p>\n\t\t\t<p> {{data.foo}} </p>\n\t\t\t<p> 前端进阶 </p>\n\t\t\t<p> 前端进阶 </p>\n\t\t</div>\n\t</div>\n</template>\n```\n\n最理想的情况是只需要对比可能会发生变化的 p 标签。再看这种情况：\n\n```\n<template>\n\t<div>\n\t\t前端进阶\n\t</div>\n\t<div v-if=\"XXX\">\n\t\t<span>前端进阶</span>\n\t\t<span>{{data.foo}}</span>\n\t</div>\n</template>\n```\n\n最理想的情况是只需要对比 `<div v-if=\"XXX\">` 以及 `<span>{{data.foo}}</span>`，因为前者可能会根据判断条件消失 / 出现，后者直接取决于模版变量的值，都属于动态节点。\n\n这样一来，我们便可以根据模版，将动态节点切割为区块，在进行 diff 操作时，递归进行区块中的动态节点比对即可。因此，**新的 diff 策略更新性能不再取决于模版整体节点数量的多少，而和动态内容的数量正相关。**\n\n当然，这次 Vue 新版本的发布还有很多有意思的点，将其和 React 相比，和 React hooks 相比也非常有趣。这里不再展开。\n\n### <font color=13aa6c>从框架再谈基础</font>\n\n这一环节我们不需要详细展开，每一个开发者都应该认识到基础的重要性。从框架上来看，如果基础薄弱，你可能就不会明白为什么：\n\n- “React 事件处理函数还需要手动绑定 this”，“而 React 生命周期函数中却不需要手动绑定 this”\n- “为什么 Vue 可以实现双向绑定”等问题。\n\n研究框架也不一定非要等到基础很扎实的时候。因为我们在学习框架之时，也是对自己基础查漏补缺的很好时机。\n\n### <font color=13aa6c>总结</font>\n\n这一讲比较轻松，我们重点分析了框架对比、框架发展。从中每一个开发者都应该能体会到“从框架和类库，我们该学到什么”。也许通过这种形式，我们不仅能够从更高层面理解框架，更能对框架的学习、今后的学习有所启发。\n\n到此，框架大章节到此结束了，我们调整一下心情，进入下一大章节的学习。\n\n### <font color=13aa6c>分享交流</font>\n\n阅读文章过程中有任何疑问可随时跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。**你的分享不仅帮助他人，更会提升自己。**\n\n你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。\n\n>**为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。**","pdfUrl":"","reader":"","duration":"","title":"从框架和类库，我们该学到什么","column":"5c91c813968b1d64b1e08fde","isNotification":false,"readingStatistics":0,"htmlContent":"<p>我记得作为实习生时，第一个独立前端项目是为欧洲天然气石油系统做一个计费应用：在地图上，用户可以和地图交互，从欧亚大陆任何一个石油气点为起点，到任何一个石油气点作为终点，计算出沿途所有的路径运输方案以及计费详情，还要支持各种终端的查询以及打印，这是一个纯 JavaScript 单页面应用 + Severless 的项目。</p>\n<p>实习期满离职前我进行复盘：繁多的原生 JavaScript APIs 让我无语，兼容性让我崩溃，“如果我一开始就选用 jQuery 做该多好！” ，too young too simple。这时候再让我复盘，“jQuery 也不适用那样一个单页应用，我为什么不用 React 或者 Vue？”果然 sometimes naive。</p>\n<p>前端框架确实一直在演进、发展，那么框架除了简化我们的操作外，我们还能从中学到什么？这一讲，我就对这个开放性话题进行展开。本节课内容比较轻松，没有大量的代码案例，让我们来舒缓一下，但请读者在阅读时始终思考——“从框架和类库，我们该学到什么”这一问题。</p>\n<p>Vue 和 React 加其生态方案使得 Vue 和 React 不再是单纯的视图层类库，因此下面我们将 Vue 和 React 统称“框架”，表示其全家桶。</p>\n<p>相关知识点如下：</p>\n<img src=\"https://images.gitbook.cn/60120df0-a383-11e9-95a5-cd4900ba781e\" width=500>\n<h3><a id=\"font_color13aa6cReact_VS_Vuefont_12\"></a><font color=13aa6c>React VS Vue：神仙打架</font></h3>\n<p>React 和 Vue 这两个极其优秀的前端“框架”基本上占据了前端开发的半壁江山甚至更多。作为开发者，你可以首选 React 或者 Vue 其中一个，但是如若尝试将两者进行对比，那么一定会收获很多。</p>\n<p>这里我们将从以下五大方面进行比较：</p>\n<ul>\n<li>数据绑定</li>\n<li>组件化和数据流</li>\n<li>数据状态管理</li>\n<li>渲染和更新</li>\n<li>社区</li>\n</ul>\n<h4><a id=\"_24\"></a>数据绑定</h4>\n<p>Vue 在数据绑定上，采取了双向绑定策略，依靠 Object.defineProperty （Vue 3.0 已迁移到 Proxy）以及监听 DOM 事件实现。具体实现方法在先前课程中我们已经剖析过了，简单来说数据改变，依赖对数据进行拦截 / 代理；视图改变，依赖 DOM 事件（如 onInput、onChange 等）。Vue 实例中的 data 和 模版展现是一条线，无论谁被修改，另一方也会发生变动。</p>\n<p>值得一提的是 Vue 也支持计算属性，即 computed 属性，这个策略和 React-redux 当中的 mapStateToProps 有异曲同工之妙，都是通过计算，将所需要的数据注入给组件使用。</p>\n<p>需要区分清楚的是：双向绑定和单向数据流并没有直接关联，双向绑定是指数据和视图之间的绑定关系，而单向数据流是指组件之间数据的传递。</p>\n<p>React 并没有数据和视图之间的双向绑定，它的策略是“局部刷新”。当数据发生变化时，直接重新渲染组件，以得到最新的视图。这种“无脑”刷新的做法看似粗暴，但是换来的简单直观，并且 React 本身在性能上也提供了一定保障。</p>\n<h4><a id=\"_34\"></a>组件化和数据流</h4>\n<p>Vue 中组件不像 React 组件，它不是完全以组件功能和 UI 为维度划分的，而 Vue 组件本质是一个 Vue 实例。每个 Vue 实例在创建时都需要经过：设置数据监听、编译模版、应用模版到 DOM，在更新时根据数据变化更新 DOM 的过程。在这个过程中，类似 React 也提供了生命周期方法。</p>\n<p>Vue 组件间通信或者说组件间数据流如同 React，也是单向的。数据流向也很类似：props 实现父组件向下传递数据，events 实现子组件向上发送消息给父组件，React 中是基于 props 的回调实现子组件向父组件传递数据（Vue 也支持）。</p>\n<p>当然，这两种框架也分别通过 context 和 provide/inject 实现了跨层级数据通信，它们的实现也是非常类似的。</p>\n<h4><a id=\"_42\"></a>数据状态管理</h4>\n<p>对于较为复杂的数据状态，Redux 是 React 应用最常用的解决方案。这里需要说明的是：Redux 和视图无关，它只是提供了数据管理的流程，因此 Vue 使用 Redux 也是完全没有问题的。</p>\n<p>当然，Vue 中更常用的是 Vuex，其借鉴了 Redux（Flux），也具有和 Redux 相同的 store 概念，组件不允许直接修改 store state，而是需要 dispatch action 来通知 store 的变化。但是这个过程不同于 Redux 的函数式思想，Vuex 改变 store 的方法支持提交一个 mutation。mutation 类似于事件发布订阅系统：每个 mutation 都有一个字符串来表示事件类型（type）和一个回调函数（handler）以进行对应的修改。</p>\n<p>另一个显著区别是：在 Vuex 中，store 是被直接注入到组件实例中的，因此用起来更加方便。而 Redux 需要 connect 方法，把 props 和 dispatch 注入给组件。</p>\n<p><strong>造成这些不同的本质原因是：</strong></p>\n<ul>\n<li>Redux 提倡不可变性，而 Vuex 的数据是可变的，Redux 中 reducer 每次都会生成新的 state 以替代旧的 state，而 Vuex 是直接修改；</li>\n<li>Redux 在检测数据变化的时候，是通过浅比较的方式比较差异的，而 Vuex 其实和 Vue 的原理一样，是通过遍历数据的 getter / setter 来比较。</li>\n</ul>\n<h4><a id=\"_55\"></a>渲染和更新</h4>\n<p>就像上面所提到的，React 和 Redux 倡导不可变性，更新需要维持不可变原则；而 Vue 对数据进行了拦截/代理，因此它不要求不可变性，而允许开发者修改数据，以引起响应式更新。</p>\n<p>React 更像 MVC 或者 MVVM 模式中的 view 层，但是搭配 Redux 等，它也是一个完整的 MVVM 类库。Vue 直接是一个典型 MVVM 模式的体现，虽然它一直标榜自己也只是 View 层，但是毫无疑问它本身包含了对数据的操作。比如，Vue 文档中经常会使用 VM（ViewModel 简称），这个变量名表示 Vue 实例，其命名让人想到 MVVM，这是 MVVM 模式的体现。</p>\n<p>React 所有组件的渲染都依靠灵活而强大的 JSX。JSX 并不是一种模版语言，而是 JavaScript 表达式和函数调用的语法糖。在编译之后，JSX 被转化为普通的 JavaScript 对象，用来表示虚拟 DOM。</p>\n<p>Vue templates 是典型的模版，这相比于 JSX，表达更加自然。在底层实现上，Vue 模版被编译成 DOM 渲染函数，结合响应系统，进行数据依赖的收集。Vue 渲染的过程如下：</p>\n<ul>\n<li>new Vue，进行实例化</li>\n<li>挂载 $mount 方法，通过自定义 Render 方法、template、el 等生成 Render 函数，准备渲染内容</li>\n<li>通过 Watcher 进行依赖收集</li>\n<li>当数据发生变化时，Render 函数执行生成 VNode 对象</li>\n<li>通过 patch 方法，对比新旧 VNode 对象，通过 DOM Diff 算法，添加、修改、删除真正的 DOM 元素</li>\n</ul>\n<p>当然 Vue 也可以支持 JSX。</p>\n<p>关于更新性能问题，简单来说，在 React 应用中，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树。当然我们可以使用 PureComponent，或是手动实现 shouldComponentUpdate 方法，来规避不必要的渲染。但是这个实现过程要知悉数据状态结构，也需要一定的额外负担。</p>\n<p>在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的，因此系统能精确知晓哪个组件需要被重渲染。从理论上看，Vue 的渲染更新机制更加细粒度，也更加精确。</p>\n<h4><a id=\"_77\"></a>社区</h4>\n<p>这两个框架都具有非常强大的社区，但是对于社区的理念，Vue 和 React 稍有不同。举个例子：路由系统的实现。</p>\n<p>Vue 的路由库和状态管理库都是由官方维护的，并且与核心库是同步更新的。而 React 把这件事情交给了社区，比如 React 应用中，需要引入 react-router 库来实现路由系统。</p>\n<h3><a id=\"font_color13aa6cfont_83\"></a><font color=13aa6c>新版本发布的思考</font></h3>\n<p>我一直认为开发者可以从框架新版本的迭代 changelog 里汲取非常多的养分。因为每次发版，都是经过开源框架的维护团队精心设计的，更新点或涉及 bug fix 或涉及新的 features，我们便可以思考“为什么会有这些变动”?，“为什么这样解决 bug”?</p>\n<p>除此之外，我还建议开发者从更高的层次“开启上帝视角”，抓着某一话题，某一次变更进行研究、学习。这里我就举个例子：Vue3.0 带来的一些思考。</p>\n<p>本讲在编写之时，恰逢尤雨溪在上海 Vue Conf 进行分享，演讲主题：State of Vue，其中涉及到新版本发布。从这次新版本发布对 Vue 的改动，结合我们的课程，我能找到很多切入点进行分析，比如虚拟 DOM、Proxy 实现数据代理。</p>\n<p>其中尤雨溪表示 Vue3.0 相比以往版本更加快速。那么“更加迅速”是如何做到更快的呢？我们在《第 4-1 课：触类旁通多种框架》一课中对比过 Object.defineProperty 和 Proxy 实现的数据拦截和代理。那么在 Vue3.0，Vue 团队就是用 Proxy 来代替  Object.defineProperty，达到了更好的性能保障。</p>\n<p>除此之外，Vue 新版本还重构了虚拟 DOM，正好在《第 4-1 课：触类旁通多种框架》一课中也简单实现了一个粗糙的虚拟 DOM，我们可以展开谈谈：传统虚拟 DOM 的性能瓶颈在于虚拟 DOM 的 diff，也许某次更新只有一个很小的变动，但还是需要对比整棵虚拟 DOM 树，这显然是非常不划算的。</p>\n<p>Vue 新版本将虚拟 DOM 的节点分为动态节点和静态节点。静态节点是指不会发生改变的节点，这些节点在进行 diff 时是应该进行规避的，而我们只需要对比动态节点。</p>\n<p>比如这样的内容：</p>\n<pre><code class=\"lang-\">&lt;template&gt;\n\t&lt;div&gt;\n\t\t&lt;div id=&quot;1&quot;&gt;\n\t\t\t&lt;p&gt; 前端进阶 &lt;/p&gt;\n\t\t\t&lt;p&gt; 前端进阶 &lt;/p&gt;\n\t\t\t&lt;p&gt; 前端进阶 &lt;/p&gt;\n\t\t\t&lt;p&gt; {{data.foo}} &lt;/p&gt;\n\t\t\t&lt;p&gt; 前端进阶 &lt;/p&gt;\n\t\t\t&lt;p&gt; 前端进阶 &lt;/p&gt;\n\t\t&lt;/div&gt;\n\t&lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n<p>最理想的情况是只需要对比可能会发生变化的 p 标签。再看这种情况：</p>\n<pre><code class=\"lang-\">&lt;template&gt;\n\t&lt;div&gt;\n\t\t前端进阶\n\t&lt;/div&gt;\n\t&lt;div v-if=&quot;XXX&quot;&gt;\n\t\t&lt;span&gt;前端进阶&lt;/span&gt;\n\t\t&lt;span&gt;{{data.foo}}&lt;/span&gt;\n\t&lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n<p>最理想的情况是只需要对比 <code>&lt;div v-if=&quot;XXX&quot;&gt;</code> 以及 <code>&lt;span&gt;{{data.foo}}&lt;/span&gt;</code>，因为前者可能会根据判断条件消失 / 出现，后者直接取决于模版变量的值，都属于动态节点。</p>\n<p>这样一来，我们便可以根据模版，将动态节点切割为区块，在进行 diff 操作时，递归进行区块中的动态节点比对即可。因此，<strong>新的 diff 策略更新性能不再取决于模版整体节点数量的多少，而和动态内容的数量正相关。</strong></p>\n<p>当然，这次 Vue 新版本的发布还有很多有意思的点，将其和 React 相比，和 React hooks 相比也非常有趣。这里不再展开。</p>\n<h3><a id=\"font_color13aa6cfont_134\"></a><font color=13aa6c>从框架再谈基础</font></h3>\n<p>这一环节我们不需要详细展开，每一个开发者都应该认识到基础的重要性。从框架上来看，如果基础薄弱，你可能就不会明白为什么：</p>\n<ul>\n<li>“React 事件处理函数还需要手动绑定 this”，“而 React 生命周期函数中却不需要手动绑定 this”</li>\n<li>“为什么 Vue 可以实现双向绑定”等问题。</li>\n</ul>\n<p>研究框架也不一定非要等到基础很扎实的时候。因为我们在学习框架之时，也是对自己基础查漏补缺的很好时机。</p>\n<h3><a id=\"font_color13aa6cfont_143\"></a><font color=13aa6c>总结</font></h3>\n<p>这一讲比较轻松，我们重点分析了框架对比、框架发展。从中每一个开发者都应该能体会到“从框架和类库，我们该学到什么”。也许通过这种形式，我们不仅能够从更高层面理解框架，更能对框架的学习、今后的学习有所启发。</p>\n<p>到此，框架大章节到此结束了，我们调整一下心情，进入下一大章节的学习。</p>\n<h3><a id=\"font_color13aa6cfont_149\"></a><font color=13aa6c>分享交流</font></h3>\n<p>阅读文章过程中有任何疑问可随时跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。<strong>你的分享不仅帮助他人，更会提升自己。</strong></p>\n<p>你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。</p>\n<blockquote>\n<p><strong>为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。</strong></p>\n</blockquote>\n","createdAt":"2019-04-21T04:25:03.777Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":22,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FoThASW9dVEPMEo9nP-zaOfbKyLZ"},{"_id":"5c99c6c6ccb24267c1d01ba1","communication_start_time":null,"type":1,"audioPath":"","abstract":"","content":"**模块化是工程化的基础**：只有能将代码模块化，拆分为合理单元，才具备调度整合的能力，才有架构和工程一说。早期，JavaScript 只是作为浏览器端脚本语言出现，只负责简单的页面交互，并不具备先天的模块化能力。\n\n随着 Node.js 的发展和 ES 的演进，模块化如今在前端领域早已经不新鲜。但是，对于模块化我们不应该只停留在了解、会用的基础上，还要深入其中，认识在这个演进过程中：\n\n- 模块化经历了怎样的发展历程，从中我们能学习到哪些知识？\n- 跟其他早已发展成熟的语言相比，JavaScript 语言的模块化又有哪些特点？\n- 新的模块化 feature 又有哪些？dynamic import 现在停留在哪个阶段？\n\n让我们通过本节课程达成这一目标。**不同于社区上常见的文章，我们并不会把焦点放在介绍各种模块化方案的使用方法上，而是直接剖析其实现，分析标准的制定。**\n\n这个主题的知识点如下：\n\n<img src=\"https://images.gitbook.cn/863babe0-4edc-11e9-8044-3de24c2bc492\" width=550>\n\n**接下来，我们通过 2 节内容来学习这个主题。**\n\n### <font color=13aa6c>模块化简单概念</font>\n\n到底什么是模块化？简单来说就是：**对于一个复杂的应用程序，与其将所有代码一股脑地放在一个文件当中，不如按照一定的语法，遵循确定的规则（规范）拆分成几个互相独立的文件。这些文件应该具有原子特性，也就是说，其内部完成共同的或者类似的逻辑，通过对外暴露一些数据或调用方法，与外部完成整合。**\n\n这样一来，每个文件彼此独立，开发者更容易开发和维护代码，模块之间又能够互相调用和通信，这是现代化开发的基本模式。\n\n其实，不论在我们的日常生活还是其他科学领域，都离不开模块化的概念，它主要体现了以下原则：\n\n- 可复用性\n- 可组合型\n- 中心化\n- 独立性\n\n**在模块化的基础上，结合工程化，又可以衍生出很多概念和话题。比如基于模块化的 tree shaking 技术，模块循环加载的处理等。不过不要着急，我们先来看看前端模块化的发展历程。**\n\n### <font color=13aa6c>模块化发展历程</font>\n\n我认为前端模块化发展主要经历了三个阶段：\n\n- 早期“假”模块化时代\n- 规范标准时代\n- ES 原生时代\n\n**这些阶段逐次递进，每一种新方案的诞生，都离不开老方案的启示。**\n\n#### 早期“假”模块化时代\n\n在早期，JavaScript 属于运行在浏览器端的玩具脚本，它只负责实现一些简单的交互。随着互联网技术的演进，这样的设计逐渐不能满足业务的需求。这时候开发者往往从代码可读性上，借助函数作用域来模拟实现“假”的模块化，我称其为**函数模式**，即将不同功能封装成不同的函数：\n\n```\nfunction f1(){\n\t//...\n}\nfunction f2(){\n\t//...\n}\n```\n\n这样的方式其实根本不算模块化，各个函数在同一个文件中，混乱地互相调用，而且存在命名冲突的风险。这没有在根本上解决问题，只是从代码编写的角度，拆分成了更小的函数单元而已。\n\n于是，聪明的开发者很快就想出了第二种方式，姑且称它为**对象模式**，即利用对象，实现命名空间的概念：\n\n```\nconst module1 = {\n\tfoo: &apos;bar&apos;,\n\tf11: function f11 () { //... },\n\tf12: function f12 () { //... },\n}\n\nconst module2 = {\n\tdata: &apos;data&apos;,\n\tf21: function f21 () { //... },\n\tf22: function f22 () { //... },\n}\n```\n\n这样我们模拟了简单的 module1、module2 命名空间，在函数主体中可以调用：\n\n```\nmodule1.f11()\nconsole.log(module2.data)\n```\n\n可是这样问题也很明显，module1 和 module2 中的数据并不安全，任何开发者都可以修改：\n\n```\nmodule2.data = &apos;modified data&apos;\n```\n\n对象内部成员可以随意被改写，极易出现 bug。那么有什么手段能弥补这个不足呢？\n\n想一想之前关于闭包的课程，从某种角度上看，闭包简直就是一个天生解决数据访问性问题的方案。通过立即执行函数（IIFE），我们构造一个私有的作用域，再通过闭包，将需要对外暴露的数据和接口输出，我们称此为 **IIFE 模式**。立即执行函数结合闭包实现的代码如下：\n\n```\nconst module = (function(){\n\tvar foo = &apos;bar&apos;\n\tvar fn1 = function (){\n\t\t// ...\n\t}\n\tvar fn2 = function fn2(){\n\t\t// ...\n\t}\n\treturn {\n\t\tfn1: fn1,\n\t\tfn2: fn2\n\t}\n})()\n```\n\n我们在调用时：\n\n```\nmodule.fn1()\n```\n\n如果想要访问变量 foo：\n\n```\nmodule.foo\n// undefined\n```\n\n是访问不到具体数据的。\n​\t\n了解了这种模式，我们可以在此基础上“玩出另外一个花”来，该方式的变种：结合顶层 window 对象，我们再来看：\n\n```\n(function(window) {\n\tvar data = &apos;data&apos;\n\n\tfunction foo() {\n\t\tconsole.log(`foo executing, data is ${data}`)\n\t}\n\tfunction bar() {\n\t\tdata = &apos;modified data&apos;\n\t    console.log(`bar executing, data is now ${data} `)\n\t}\n\twindow.module1 = { foo, bar }\n})(window)\n```\n\n这样的实现，数据 data 完全做到了私有，外界无法修改 data 值。那么如何访问 data 呢？这时候需要模块内部设计并暴露相关接口。上述代码中，只需要调用模块 module1 暴露给外界（window）的函数即可:\n\n```\nmodule1.foo()\n// foo executing, data is data\n```\n\n修改 data 值的途径，也只能由模块 module1 提供：\n\n```\nmodule1.bar()\n// bar executing, data is now modified data \n```\n\n如此一来，已经初具“模块化”的实质，实现了模块化所应该具备的初级功能。\n\n我们再进一步思考，如果 module1 依赖外部模块 module2，该怎么办？请参考代码：\n\n```\n(function(window, $) {\n\tvar data = &apos;data&apos;\n\n\tfunction foo() {\n\t\tconsole.log(`foo executing, data is ${data}`)\n\t\tconsole.log($)\n\t}\n\tfunction bar() {\n\t\tdata = &apos;modified data&apos;\n\t\tconsole.log(`bar executing, data is now ${data} `)\n\t}\n\twindow.module1 = { foo, bar }\n})(window, jQuery)\n```\n\n**事实上，这就是现代模块化方案的基石。到此为止，我们经历了模块化的第一阶段：“假”模块化时代。**这种实现极具阿 Q 精神，它并不是语言原生层面上的实现，而是开发者利用语言，借助 JavaScript 特性，模拟了类似的功能，为后续方案打开了大门。请继续阅读。\n\n#### 规范标准时代 CommonJS\n\nNode.js 无疑对前端的发展具有极大的促进作用，它带来的 CommonJS 模块化规范像一股“改革春风”：在 Node.js 中，每一个文件就是一个模块，具有单独的作用域，对其他文件是不可见的。关于 CommonJS 的规范，我们这里不做过多介绍，基础内容读者可自行理解，我们只来看看它的**几个容易被忽略的特点。**\n\n- 文件即模块，文件内所有代码都运行在独立的作用域，因此不会污染全局空间。\n- 模块可以被多次引用、加载。在第一次被加载时，**会被缓存**，之后都从缓存中直接读取结果。\n- 加载某个模块，就是引入该模块的 module.exports 属性。\n- module.exports 属性**输出的是值的拷贝**，一旦这个值被输出，模块内再发生变化不会影响到输出的值。\n- 模块加载顺序按照代码引入的顺序。\n- 注意 module.exports 和 exports 的区别\n\nCommonJS 规范用代码如何在浏览器端实现呢？其实就是实现 module.exports 和 require 方法。\n\n实现思路：根据 require 的文件路径，加载文件内容并执行，同时将对外接口进行缓存。因此我们需要定义：\n\n```\nlet module = {}\nmodule.exports = {}\n```\n\n借助立即执行函数，将 module 和 module.exports 对象进行赋值：\n\n```\n(function(module, exports) {\n\t// ...  \n}(module, module.exports))\n```\n\n社区上对 CommonJS 实现的模拟很多，这里我不在浪费笔墨重复，给大家推荐[浅谈前端模块化](https://juejin.im/post/5c1619b8e51d4530e8357c86)，以及 [browserify](https://github.com/browserify/browserify)。\n\n#### 规范标准时代 AMD\n\n由于 Node.js 运行于服务器上，所有的文件一般都已经存在了本地硬盘中，不需要额外的网络请求去异步加载，因而 CommonJS 规范加载模块是同步的。只有加载完成，才执行后续操作。但是，如果放在浏览器环境中，我们都需要从服务器端获取模块文件，此时再采用同步的方式，显然就不合适了。这时候，社区上推出了 AMD 规范。\n\nAMD 规范，全称为：Asynchronous Module Definition，看到 “Asynchronous”，我们就能够反映到它的模块化标准不同于 CommonJS，是异步的，完全贴合浏览器的。\n\n它规定了如何定义模块，如何对外输出，如何引入依赖。这一切都需要代码去实现，因此一个著名的库 —— require.js 应运而生，require.js 实现很简单：通过 define 方法，将代码定义为模块；通过 require 方法，实现代码的模块加载。\n\ndefine 和 require 就是 require.js 在全局注入的函数。\n\n在熟练使用的基础上，建议读者参考 [require.js 源码](https://github.com/requirejs/requirejs)。\n\n```\nvar require, define;\n(function (global, setTimeout) {\n\t// ...\n}(this, (typeof setTimeout === &apos;undefined&apos; ? undefined : setTimeout)));\n```\n\n我们看到，require.js 在全局定义了 require 和 define 两个方法，也是利用立即执行函数，将全局对象（this）和 setTimeout 传入函数体内。其中：\n\n```\ndefine = function (name, deps, callback) {\n\t// ...\n\tif (context) {\n\t\tcontext.defQueue.push([name, deps, callback]);\n\t\tcontext.defQueueMap[name] = true;\n\t} else {\n\t\tglobalDefQueue.push([name, deps, callback]);\n\t}\n}\n```\n\n这里主要是将依赖注入到依赖队列。而 require 的主要作用是完成创建 script 标签去请求相应的模块，对模块进行加载和执行：\n\n```\nreq.load = function (context, moduleName, url) {\n    var config = (context && context.config) || {},\n    node;\n    if (isBrowser) {\n        //create a async script element\n        node = req.createNode(config, moduleName, url);\n\n        //add Events [onreadystatechange,load,error]\n        .....\n\n        //set url for loading\n        node.src = url;\n\n        //insert script element to head and start load\n        currentlyAddingScript = node;\n        if (baseElement) {\n            head.insertBefore(node, baseElement);\n        } else {\n            head.appendChild(node);\n        }\n        currentlyAddingScript = null;\n\n        return node;\n    } else if (isWebWorker) {\n        .........\n    }\n};\n\nreq.createNode = function (config, moduleName, url) {\n    var node = config.xhtml ?\n        document.createElementNS(&apos;http://www.w3.org/1999/xhtml&apos;, &apos;html:script&apos;) :\n        document.createElement(&apos;script&apos;);\n    node.type = config.scriptType || &apos;text/javascript&apos;;\n    node.charset = &apos;utf-8&apos;;\n    node.async = true;\n    return node;\n};\n```\n\n细心的读者可能会有疑问：在我们使用 require.js 之后，并没有发现额外多出来的 script 标签，这个秘密就在于 checkLoaded 方法会把已经加载完毕的脚本删除，因为我们需要的是模块内容，一旦加载之后，没有必要保留有 script 标签了：\n\n```\nfunction removeScript(name) {\n    if (isBrowser) {\n        each(scripts(), function (scriptNode) {\n            if (scriptNode.getAttribute(&apos;data-requiremodule&apos;) === name &&\n                    scriptNode.getAttribute(&apos;data-requirecontext&apos;) === context.contextName) {\n                scriptNode.parentNode.removeChild(scriptNode);\n                return true;\n            }\n        });\n    }\n}\n```\n\n更多源码内容，感兴趣的读者可以在评论区讨论交流，或者直接向我提问。\n\n#### 规范标准时代 CMD\n\nCMD 规范整合了 CommonJS 和 AMD 规范的特点。它的全称为：Common Module Definition，类似 require.js，CMD 规范的实现为 sea.js。\n\nAMD 和 CMD 的两个主要区别如下。\n\n- AMD 需要异步加载模块，而 CMD 在 require 依赖的时候，可以通过同步的形式（require），也可以通过异步的形式（require.async）。\n- CMD 遵循依赖就近原则，AMD 遵循依赖前置原则。也就是说，在 AMD 中，我们需要把模块所需要的依赖都提前在依赖数组中声明。而在 CMD 中，我们只需要在具体代码逻辑内，使用依赖前，把依赖的模块 require 进来。\n\n具体到代码实现，sea.js 与 require.js 并没有本质差别，这里不再另做分析。\n\n#### 规范标准时代 UMD\n\nUMD 全称：Universal Module Definition，看到 “Universal”，我们可以猜到它允许在环境中同时使用 AMD 与 CommonJS 规范，相当于一个整合。该模式的**核心思想**在于利用立即执行函数根据环境来判断需要的参数类别，譬如在 CommonJS 环境下，上述代码会以如下方式执行：\n\n```\nfunction (factory) {\n    module.exports = factory();\n} \n```\n\n而如果是在 AMD 模块规范下，函数的参数就变成了 define，适用 AMD 规范。\n\n具体代码：\n\n```\n(function (root, factory) {\n    if (typeof define === &apos;function&apos; && define.amd) {\n        // AMD 规范\n        define([&apos;b&apos;], factory);\n    } else if (typeof module === &apos;object&apos; && module.exports) {\n        // 类 Node 环境，并不支持完全严格的 CommonJS 规范\n        // 但是属于 CommonJS-like 环境，支持 module.exports 用法\n        module.exports = factory(require(&apos;b&apos;));\n    } else {\n        // 浏览器环境\n        root.returnExports = factory(root.b);\n    }\n}(this, function (b) {\n    // 返回值作为 export 内容\n    return {};\n}));\n```\n\n至此，我们介绍完了模块化的 Node.js 和社区解决方案。这些方案充分利用了 JavaScript 语言特性，并结合浏览器端的特点，加以实现。不同的实现方式体现了不同的设计哲学，但是它们的最终方向都指向了模块化的几个原则：可复用性、可组合型、中心化、独立性，下一节我们继续这个主题，介绍模块化的原生解决方案。\n\n### <font color=13aa6c>分享交流</font>\n\n阅读文章过程中有任何疑问可随时跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。**你的分享不仅帮助他人，更会提升自己。**\n\n你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。\n\n>**为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。**","pdfUrl":"","reader":"","duration":"","title":"深入浅出模块化（含 tree shaking）（上）","column":"5c91c813968b1d64b1e08fde","isNotification":false,"htmlContent":"<p><strong>模块化是工程化的基础</strong>：只有能将代码模块化，拆分为合理单元，才具备调度整合的能力，才有架构和工程一说。早期，JavaScript 只是作为浏览器端脚本语言出现，只负责简单的页面交互，并不具备先天的模块化能力。</p>\n<p>随着 Node.js 的发展和 ES 的演进，模块化如今在前端领域早已经不新鲜。但是，对于模块化我们不应该只停留在了解、会用的基础上，还要深入其中，认识在这个演进过程中：</p>\n<ul>\n<li>模块化经历了怎样的发展历程，从中我们能学习到哪些知识？</li>\n<li>跟其他早已发展成熟的语言相比，JavaScript 语言的模块化又有哪些特点？</li>\n<li>新的模块化 feature 又有哪些？dynamic import 现在停留在哪个阶段？</li>\n</ul>\n<p>让我们通过本节课程达成这一目标。<strong>不同于社区上常见的文章，我们并不会把焦点放在介绍各种模块化方案的使用方法上，而是直接剖析其实现，分析标准的制定。</strong></p>\n<p>这个主题的知识点如下：</p>\n<img src=\"https://images.gitbook.cn/863babe0-4edc-11e9-8044-3de24c2bc492\" width=550>\n<p><strong>接下来，我们通过 2 节内容来学习这个主题。</strong></p>\n<h3><a id=\"font_color13aa6cfont_16\"></a><font color=13aa6c>模块化简单概念</font></h3>\n<p>到底什么是模块化？简单来说就是：<strong>对于一个复杂的应用程序，与其将所有代码一股脑地放在一个文件当中，不如按照一定的语法，遵循确定的规则（规范）拆分成几个互相独立的文件。这些文件应该具有原子特性，也就是说，其内部完成共同的或者类似的逻辑，通过对外暴露一些数据或调用方法，与外部完成整合。</strong></p>\n<p>这样一来，每个文件彼此独立，开发者更容易开发和维护代码，模块之间又能够互相调用和通信，这是现代化开发的基本模式。</p>\n<p>其实，不论在我们的日常生活还是其他科学领域，都离不开模块化的概念，它主要体现了以下原则：</p>\n<ul>\n<li>可复用性</li>\n<li>可组合型</li>\n<li>中心化</li>\n<li>独立性</li>\n</ul>\n<p><strong>在模块化的基础上，结合工程化，又可以衍生出很多概念和话题。比如基于模块化的 tree shaking 技术，模块循环加载的处理等。不过不要着急，我们先来看看前端模块化的发展历程。</strong></p>\n<h3><a id=\"font_color13aa6cfont_31\"></a><font color=13aa6c>模块化发展历程</font></h3>\n<p>我认为前端模块化发展主要经历了三个阶段：</p>\n<ul>\n<li>早期“假”模块化时代</li>\n<li>规范标准时代</li>\n<li>ES 原生时代</li>\n</ul>\n<p><strong>这些阶段逐次递进，每一种新方案的诞生，都离不开老方案的启示。</strong></p>\n<h4><a id=\"_41\"></a>早期“假”模块化时代</h4>\n<p>在早期，JavaScript 属于运行在浏览器端的玩具脚本，它只负责实现一些简单的交互。随着互联网技术的演进，这样的设计逐渐不能满足业务的需求。这时候开发者往往从代码可读性上，借助函数作用域来模拟实现“假”的模块化，我称其为<strong>函数模式</strong>，即将不同功能封装成不同的函数：</p>\n<pre><code class=\"lang-\">function f1(){\n\t//...\n}\nfunction f2(){\n\t//...\n}\n</code></pre>\n<p>这样的方式其实根本不算模块化，各个函数在同一个文件中，混乱地互相调用，而且存在命名冲突的风险。这没有在根本上解决问题，只是从代码编写的角度，拆分成了更小的函数单元而已。</p>\n<p>于是，聪明的开发者很快就想出了第二种方式，姑且称它为<strong>对象模式</strong>，即利用对象，实现命名空间的概念：</p>\n<pre><code class=\"lang-\">const module1 = {\n\tfoo: &apos;bar&apos;,\n\tf11: function f11 () { //... },\n\tf12: function f12 () { //... },\n}\n\nconst module2 = {\n\tdata: &apos;data&apos;,\n\tf21: function f21 () { //... },\n\tf22: function f22 () { //... },\n}\n</code></pre>\n<p>这样我们模拟了简单的 module1、module2 命名空间，在函数主体中可以调用：</p>\n<pre><code class=\"lang-\">module1.f11()\nconsole.log(module2.data)\n</code></pre>\n<p>可是这样问题也很明显，module1 和 module2 中的数据并不安全，任何开发者都可以修改：</p>\n<pre><code class=\"lang-\">module2.data = &apos;modified data&apos;\n</code></pre>\n<p>对象内部成员可以随意被改写，极易出现 bug。那么有什么手段能弥补这个不足呢？</p>\n<p>想一想之前关于闭包的课程，从某种角度上看，闭包简直就是一个天生解决数据访问性问题的方案。通过立即执行函数（IIFE），我们构造一个私有的作用域，再通过闭包，将需要对外暴露的数据和接口输出，我们称此为 <strong>IIFE 模式</strong>。立即执行函数结合闭包实现的代码如下：</p>\n<pre><code class=\"lang-\">const module = (function(){\n\tvar foo = &apos;bar&apos;\n\tvar fn1 = function (){\n\t\t// ...\n\t}\n\tvar fn2 = function fn2(){\n\t\t// ...\n\t}\n\treturn {\n\t\tfn1: fn1,\n\t\tfn2: fn2\n\t}\n})()\n</code></pre>\n<p>我们在调用时：</p>\n<pre><code class=\"lang-\">module.fn1()\n</code></pre>\n<p>如果想要访问变量 foo：</p>\n<pre><code class=\"lang-\">module.foo\n// undefined\n</code></pre>\n<p>是访问不到具体数据的。<br />\n​\t<br />\n了解了这种模式，我们可以在此基础上“玩出另外一个花”来，该方式的变种：结合顶层 window 对象，我们再来看：</p>\n<pre><code class=\"lang-\">(function(window) {\n\tvar data = &apos;data&apos;\n\n\tfunction foo() {\n\t\tconsole.log(`foo executing, data is ${data}`)\n\t}\n\tfunction bar() {\n\t\tdata = &apos;modified data&apos;\n\t    console.log(`bar executing, data is now ${data} `)\n\t}\n\twindow.module1 = { foo, bar }\n})(window)\n</code></pre>\n<p>这样的实现，数据 data 完全做到了私有，外界无法修改 data 值。那么如何访问 data 呢？这时候需要模块内部设计并暴露相关接口。上述代码中，只需要调用模块 module1 暴露给外界（window）的函数即可:</p>\n<pre><code class=\"lang-\">module1.foo()\n// foo executing, data is data\n</code></pre>\n<p>修改 data 值的途径，也只能由模块 module1 提供：</p>\n<pre><code class=\"lang-\">module1.bar()\n// bar executing, data is now modified data \n</code></pre>\n<p>如此一来，已经初具“模块化”的实质，实现了模块化所应该具备的初级功能。</p>\n<p>我们再进一步思考，如果 module1 依赖外部模块 module2，该怎么办？请参考代码：</p>\n<pre><code class=\"lang-\">(function(window, $) {\n\tvar data = &apos;data&apos;\n\n\tfunction foo() {\n\t\tconsole.log(`foo executing, data is ${data}`)\n\t\tconsole.log($)\n\t}\n\tfunction bar() {\n\t\tdata = &apos;modified data&apos;\n\t\tconsole.log(`bar executing, data is now ${data} `)\n\t}\n\twindow.module1 = { foo, bar }\n})(window, jQuery)\n</code></pre>\n<p>**事实上，这就是现代模块化方案的基石。到此为止，我们经历了模块化的第一阶段：“假”模块化时代。**这种实现极具阿 Q 精神，它并不是语言原生层面上的实现，而是开发者利用语言，借助 JavaScript 特性，模拟了类似的功能，为后续方案打开了大门。请继续阅读。</p>\n<h4><a id=\"_CommonJS_173\"></a>规范标准时代 CommonJS</h4>\n<p>Node.js 无疑对前端的发展具有极大的促进作用，它带来的 CommonJS 模块化规范像一股“改革春风”：在 Node.js 中，每一个文件就是一个模块，具有单独的作用域，对其他文件是不可见的。关于 CommonJS 的规范，我们这里不做过多介绍，基础内容读者可自行理解，我们只来看看它的<strong>几个容易被忽略的特点。</strong></p>\n<ul>\n<li>文件即模块，文件内所有代码都运行在独立的作用域，因此不会污染全局空间。</li>\n<li>模块可以被多次引用、加载。在第一次被加载时，<strong>会被缓存</strong>，之后都从缓存中直接读取结果。</li>\n<li>加载某个模块，就是引入该模块的 module.exports 属性。</li>\n<li>module.exports 属性<strong>输出的是值的拷贝</strong>，一旦这个值被输出，模块内再发生变化不会影响到输出的值。</li>\n<li>模块加载顺序按照代码引入的顺序。</li>\n<li>注意 module.exports 和 exports 的区别</li>\n</ul>\n<p>CommonJS 规范用代码如何在浏览器端实现呢？其实就是实现 module.exports 和 require 方法。</p>\n<p>实现思路：根据 require 的文件路径，加载文件内容并执行，同时将对外接口进行缓存。因此我们需要定义：</p>\n<pre><code class=\"lang-\">let module = {}\nmodule.exports = {}\n</code></pre>\n<p>借助立即执行函数，将 module 和 module.exports 对象进行赋值：</p>\n<pre><code class=\"lang-\">(function(module, exports) {\n\t// ...  \n}(module, module.exports))\n</code></pre>\n<p>社区上对 CommonJS 实现的模拟很多，这里我不在浪费笔墨重复，给大家推荐<a href=\"https://juejin.im/post/5c1619b8e51d4530e8357c86\" target=\"_blank\">浅谈前端模块化</a>，以及 <a href=\"https://github.com/browserify/browserify\" target=\"_blank\">browserify</a>。</p>\n<h4><a id=\"_AMD_203\"></a>规范标准时代 AMD</h4>\n<p>由于 Node.js 运行于服务器上，所有的文件一般都已经存在了本地硬盘中，不需要额外的网络请求去异步加载，因而 CommonJS 规范加载模块是同步的。只有加载完成，才执行后续操作。但是，如果放在浏览器环境中，我们都需要从服务器端获取模块文件，此时再采用同步的方式，显然就不合适了。这时候，社区上推出了 AMD 规范。</p>\n<p>AMD 规范，全称为：Asynchronous Module Definition，看到 “Asynchronous”，我们就能够反映到它的模块化标准不同于 CommonJS，是异步的，完全贴合浏览器的。</p>\n<p>它规定了如何定义模块，如何对外输出，如何引入依赖。这一切都需要代码去实现，因此一个著名的库 —— require.js 应运而生，require.js 实现很简单：通过 define 方法，将代码定义为模块；通过 require 方法，实现代码的模块加载。</p>\n<p>define 和 require 就是 require.js 在全局注入的函数。</p>\n<p>在熟练使用的基础上，建议读者参考 <a href=\"https://github.com/requirejs/requirejs\" target=\"_blank\">require.js 源码</a>。</p>\n<pre><code class=\"lang-\">var require, define;\n(function (global, setTimeout) {\n\t// ...\n}(this, (typeof setTimeout === &apos;undefined&apos; ? undefined : setTimeout)));\n</code></pre>\n<p>我们看到，require.js 在全局定义了 require 和 define 两个方法，也是利用立即执行函数，将全局对象（this）和 setTimeout 传入函数体内。其中：</p>\n<pre><code class=\"lang-\">define = function (name, deps, callback) {\n\t// ...\n\tif (context) {\n\t\tcontext.defQueue.push([name, deps, callback]);\n\t\tcontext.defQueueMap[name] = true;\n\t} else {\n\t\tglobalDefQueue.push([name, deps, callback]);\n\t}\n}\n</code></pre>\n<p>这里主要是将依赖注入到依赖队列。而 require 的主要作用是完成创建 script 标签去请求相应的模块，对模块进行加载和执行：</p>\n<pre><code class=\"lang-\">req.load = function (context, moduleName, url) {\n    var config = (context &amp;&amp; context.config) || {},\n    node;\n    if (isBrowser) {\n        //create a async script element\n        node = req.createNode(config, moduleName, url);\n\n        //add Events [onreadystatechange,load,error]\n        .....\n\n        //set url for loading\n        node.src = url;\n\n        //insert script element to head and start load\n        currentlyAddingScript = node;\n        if (baseElement) {\n            head.insertBefore(node, baseElement);\n        } else {\n            head.appendChild(node);\n        }\n        currentlyAddingScript = null;\n\n        return node;\n    } else if (isWebWorker) {\n        .........\n    }\n};\n\nreq.createNode = function (config, moduleName, url) {\n    var node = config.xhtml ?\n        document.createElementNS(&apos;http://www.w3.org/1999/xhtml&apos;, &apos;html:script&apos;) :\n        document.createElement(&apos;script&apos;);\n    node.type = config.scriptType || &apos;text/javascript&apos;;\n    node.charset = &apos;utf-8&apos;;\n    node.async = true;\n    return node;\n};\n</code></pre>\n<p>细心的读者可能会有疑问：在我们使用 require.js 之后，并没有发现额外多出来的 script 标签，这个秘密就在于 checkLoaded 方法会把已经加载完毕的脚本删除，因为我们需要的是模块内容，一旦加载之后，没有必要保留有 script 标签了：</p>\n<pre><code class=\"lang-\">function removeScript(name) {\n    if (isBrowser) {\n        each(scripts(), function (scriptNode) {\n            if (scriptNode.getAttribute(&apos;data-requiremodule&apos;) === name &amp;&amp;\n                    scriptNode.getAttribute(&apos;data-requirecontext&apos;) === context.contextName) {\n                scriptNode.parentNode.removeChild(scriptNode);\n                return true;\n            }\n        });\n    }\n}\n</code></pre>\n<p>更多源码内容，感兴趣的读者可以在评论区讨论交流，或者直接向我提问。</p>\n<h4><a id=\"_CMD_296\"></a>规范标准时代 CMD</h4>\n<p>CMD 规范整合了 CommonJS 和 AMD 规范的特点。它的全称为：Common Module Definition，类似 require.js，CMD 规范的实现为 sea.js。</p>\n<p>AMD 和 CMD 的两个主要区别如下。</p>\n<ul>\n<li>AMD 需要异步加载模块，而 CMD 在 require 依赖的时候，可以通过同步的形式（require），也可以通过异步的形式（require.async）。</li>\n<li>CMD 遵循依赖就近原则，AMD 遵循依赖前置原则。也就是说，在 AMD 中，我们需要把模块所需要的依赖都提前在依赖数组中声明。而在 CMD 中，我们只需要在具体代码逻辑内，使用依赖前，把依赖的模块 require 进来。</li>\n</ul>\n<p>具体到代码实现，sea.js 与 require.js 并没有本质差别，这里不再另做分析。</p>\n<h4><a id=\"_UMD_307\"></a>规范标准时代 UMD</h4>\n<p>UMD 全称：Universal Module Definition，看到 “Universal”，我们可以猜到它允许在环境中同时使用 AMD 与 CommonJS 规范，相当于一个整合。该模式的<strong>核心思想</strong>在于利用立即执行函数根据环境来判断需要的参数类别，譬如在 CommonJS 环境下，上述代码会以如下方式执行：</p>\n<pre><code class=\"lang-\">function (factory) {\n    module.exports = factory();\n} \n</code></pre>\n<p>而如果是在 AMD 模块规范下，函数的参数就变成了 define，适用 AMD 规范。</p>\n<p>具体代码：</p>\n<pre><code class=\"lang-\">(function (root, factory) {\n    if (typeof define === &apos;function&apos; &amp;&amp; define.amd) {\n        // AMD 规范\n        define([&apos;b&apos;], factory);\n    } else if (typeof module === &apos;object&apos; &amp;&amp; module.exports) {\n        // 类 Node 环境，并不支持完全严格的 CommonJS 规范\n        // 但是属于 CommonJS-like 环境，支持 module.exports 用法\n        module.exports = factory(require(&apos;b&apos;));\n    } else {\n        // 浏览器环境\n        root.returnExports = factory(root.b);\n    }\n}(this, function (b) {\n    // 返回值作为 export 内容\n    return {};\n}));\n</code></pre>\n<p>至此，我们介绍完了模块化的 Node.js 和社区解决方案。这些方案充分利用了 JavaScript 语言特性，并结合浏览器端的特点，加以实现。不同的实现方式体现了不同的设计哲学，但是它们的最终方向都指向了模块化的几个原则：可复用性、可组合型、中心化、独立性，下一节我们继续这个主题，介绍模块化的原生解决方案。</p>\n<h3><a id=\"font_color13aa6cfont_342\"></a><font color=13aa6c>分享交流</font></h3>\n<p>阅读文章过程中有任何疑问可随时跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。<strong>你的分享不仅帮助他人，更会提升自己。</strong></p>\n<p>你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。</p>\n<blockquote>\n<p><strong>为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。</strong></p>\n</blockquote>\n","readingStatistics":0,"createdAt":"2019-03-26T06:29:26.433Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":23,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FpV63qUTKXGNICJmqWh73kLAKi4d"},{"_id":"5c99c75dccb24267c1d01bb6","communication_start_time":null,"type":1,"audioPath":"","abstract":"","content":"本节课程，让我们继续模块化的话题。在此之前，先来回顾一下这个主题的知识点：\n\n<img src=\"https://images.gitbook.cn/863babe0-4edc-11e9-8044-3de24c2bc492\" width=550>\n\n### <font color=13aa6c>模块化发展历程</font>\n\n在上一讲中，介绍了以下方案实现模块化：\n\n- 早期命名空间模拟模块化\n- CommonJS\n- AMD\n- CMD\n- UMD\n\n接下来我们来探讨 ES 原生模块化的知识，并就 tree shaking 这个话题展开。\n\n#### ES 原生时代和 tree shaking\n\nES 模块化（或称为 ESM）的具体使用方法我们不再具体介绍，请读者先了解相关基础内容。\n\nES 模块的设计思想是尽量**静态化**，这样能保证在编译时就确定模块之间的依赖关系，每个模块的输入和输出变量也都是确定的。CommonJS 和 AMD 模块，无法保证前置即确定这些内容，只能在运行时确定。这是 ES 模块化和其他规范的显著不同。第二个差别在于，CommonJS 模块输出的是一个值的**拷贝**，ES 模块输出的是值的**引用**。我们来具体看一下：\n\n```\n// data.js\nexport let data = &apos;data&apos;\nexport function modifyData() {\n\tdata = &apos;modified data&apos;\n}\n\n// index.js\nimport { data, modifyData } from &apos;./lib&apos;\nconsole.log(data) // data\nmodifyData()\nconsole.log(data) // modified data\n```\n\n我们在 index.js 中调用了 modifyData 方法，之后查询 data 值，得到了最新的变化。\n\n而同样的逻辑，在 CommonJS 规范下的表现为：\n\n```\n// data.js\nvar data = &apos;data&apos;\nfunction modifyData() {\n\tdata = &apos;modified data&apos;\n}\n\nmodule.exports = {\n\tdata: data,\n\tmodifyData: modifyData\n}\n\n// index.js\nvar data = require(&apos;./data&apos;).data\nvar modifyData = require(&apos;./data&apos;).modifyData\nconsole.log(data) // data\nmodifyData()\nconsole.log(data) // data\n```\n\n因为 CommonJS 是输出了值的拷贝，而非引用，因此在调用 modifyData 之后，index.js 的 data 值并没有发生变化，其值为一个全新的拷贝。\n\n##### **ES 模块化为什么要设计成静态的**\n\n一个明显的优势是：通过静态分析，我们能够分析出导入的依赖。如果导入的模块没有被使用，我们便可以通过 tree shaking 等手段减少代码体积，进而提升运行性能。这就是基于 ESM 实现 tree shaking 的基础。\n\n这么说可能过于笼统，我们从设计的角度分析这两种规范哲学的利弊。静态性需要规范去强制保证，不像 CommonJS 那样灵活，ES 模块化的静态性带来了限制：\n\n- 只能在文件顶部 import 依赖\n- export 导出的变量类型严格限制\n- 变量不允许被重新绑定，import 的模块名只能是字符串常量，即不可以动态确定依赖\n\n这样的限制在语言层面带来的便利之一是：我们可以通过作用域分析，分析出代码里变量所属的作用域以及它们之间的引用关系，进而可以推导出变量和导入依赖变量的引用关系，在没有明显引用时，就可以进行去冗余。\n\n##### **tree shaking**\n\n上面说到的“在没有明显引用时，就可以进行去冗余”，就是我们经常提到的 **tree shaking**，它的目的就是减少应用中写出，但没有被实际运用的 JavaScript 代码。这样一来，无用代码的清除，意味着更小的代码体积，bundle size 的缩减，对用户体验起到了积极作用。\n\n在计算机科学当中，一个典型去除无用代码、冗余代码的手段是 [DCE](https://en.wikipedia.org/wiki/Dead_code_elimination)，dead code elimination。**那么 tree shaking 和 DCE（Dead Code Elemination）有什么区别？**\n\n> Rollup 的主要贡献者 Rich Harris 做过这样的比喻：假设我们用鸡蛋做蛋糕。显然，我们不需要蛋壳而只需要蛋清和蛋黄，那么如何去除蛋壳呢？DCE 是这样做的：直接把整个鸡蛋放到碗里搅拌，蛋糕做完后再慢慢地从里面挑出蛋壳\n\n相反，与 DCE 不同，tree shaking 是开始阶段就把蛋壳剥离，留下蛋清和蛋黄。事实上，也可以将 tree shaking 理解为广义 DCE 的一种，它在前置打包时即排除掉不会用到的代码。\n\n当然说到底，tree shaking 只是一种辅助手段，良好的模块拆分和设计才是减少代码体积的关键。\n\nTree shaking 也有局限性，它还有很多不能清除无用代码的场景，比如 Rollup 的 tree shaking 实现只处理函数和顶层的 `import/export` 导入的变量，不能把没用到的类的方法消除；对于 tree shaking 来说，具有副作用的脚本无法被优化。\n\n更多情况读者可以参考：\n\n- [tree-shaking 不完全指南](https://juejin.im/post/5a64724df265da3e5a575d65)\n- [webpack-common-shake](https://github.com/indutny/webpack-common-shake#limitations)\n- [你的 Tree-Shaking 并没什么卵用](https://juejin.im/post/5a5652d8f265da3e497ff3de)\n- [Webpack Tree shaking 深入探究](https://juejin.im/post/5bb8ef58f265da0a972e3434)\n\n##### **tree shaking 使用注意事项**\n\nwebpack 和 Rollup 构建工具目前都有成熟的方案，但是笔者并不建议马上引入到项目中。事实上，是否要在成熟的项目上立即实施 tree shaking 需要妥善考虑。这里我也提供几篇收藏的文章，介绍了 tree shaking 的使用方法，这些基本操作内容，我们不再展开，可以按照官方文档实施，我也在文档之外推荐这些内容供大家学习。\n\n- [Webpack 之 treeShaking](https://mp.weixin.qq.com/s/Y4v7tAWUeDNs_FWpUnKmAw)\n- [体积减少80%！释放 webpack tree-shaking 的真正潜力](https://juejin.im/post/5b8ce49df265da438151b468)\n- [Tree-Shaking 性能优化实践 - 原理篇](https://juejin.im/post/5a4dc842518825698e7279a9)\n\n##### ES 的 export 和 export default\n\nES 模块化导出有 export 和 export default 两种。这里我们建议减少使用 export default 导出，原因是一方面 export default 导出整体对象结果，不利于 tree shaking 进行分析；另一方面，export default 导出的结果可以随意命名变量，不利于团队统一管理。\n\nNicholas C. Zakas 有一篇文章： [Why I&apos;ve stopped exporting defaults from my JavaScript modules](https://link.juejin.im/?target=https%3A%2F%2Fhumanwhocodes.com%2Fblog%2F2019%2F01%2Fstop-using-default-exports-javascript-module%2F) ，表达了类似的观点。\n\n###<font color=13aa6c>未来趋势和思考</font>\n\n个人认为，ES 模块化是未来不可避免的发展趋势，它的优点毫无争议，比如开箱即用的 tree shaking 和未来浏览器兼容性支持。Node.js 的 CommonJS 模块化方案甚至也会慢慢过渡到 ES 模块化上。如果你正在使用 webpack 构建应用项目，那么 ES 模块化是首选；如果你的项目是一个前端库，也建议使用 ES 模块化。这么看来，或许只有在编写 Node.js 程序时，才需要考虑 CommonJS。\n\n#### 在浏览器中快速使用 ES 模块化\n\n目前各大浏览器较新版本都已经开始逐步支持 ES 模块了。如果我们想在浏览器中使用原生 ES 模块方案，只需要在 script 标签上添加一个 type=\"module\" 属性。通过该属性，浏览器知道这个文件是以模块化的方式运行的。而对于不支持的浏览器，需要通过 nomodule 属性来指定某脚本为 fallback 方案：\n\n```\n<script type=\"module\">\n\timport module1 from &apos;./module1&apos;\n</script>\n<script nomodule>\n \talert(&apos;你的浏览器不支持 ES 模块，请先升级！&apos;)\n</script>\n```\n\n使用 type=\"module\"  的另一个作用是进行 ES Next 兼容性的嗅探。因为支持 ES 模块化的浏览器，都支持 ES Promise 等特性，基于此，应用场景较多。\n\n#### 在 Node.js 中使用 ES 模块化\n\nNode.js 从 9.0 版本开始支持 ES 模块，执行脚本需要启动时加上 --experimental-modules，不过这一用法要求相应的文件后缀名必须为 *.mjs：\n\n```\nnode --experimental-modules module1.mjs\nimport module1 from &apos;./module1.mjs&apos;\nconsole.log(module1)\n```\n\n另外，也可以安装 babel-cli 和 babel-preset-env，配置 .babelrc 文件后，执行：\n\n```\n./node_modules/.bin/babel-node \n```\n\n或：\n\n```\nnpx babel-node \n```\n\n在工具方面，webpack 本身维护了一套模块系统，这套模块系统兼容了几乎所有前端历史进程下的模块规范，包括 AMD/CommonJS/ES 模块化等，具体分析咱们见后续课程《webpack 工程师 > 前端工程师》（即下一讲的内容）。\n\n### <font color=13aa6c>总结</font>\n\n通过本课程的学习，我们了解了 JavaScript 模块化的历史，重点分析了不同过渡方案的不同实现以及 ES 模块化标准的细节。希望读者对模块系统有一个更清晰的认识，同时希望大家可以仔细阅读源码，对代码设计有自己的理解和体会。\n\n### <font color=13aa6c>分享交流</font>\n\n在「模块化」相关话题上你有什么感悟？留言分享给一起学习的小伙伴吧！阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空解答）。**你的分享不仅帮助他人，更会提升自己。**\n\n你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。\n\n>**为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。**","pdfUrl":"","reader":"","duration":"","title":"深入浅出模块化（含 tree shaking）（下）","column":"5c91c813968b1d64b1e08fde","isNotification":false,"htmlContent":"<p>本节课程，让我们继续模块化的话题。在此之前，先来回顾一下这个主题的知识点：</p>\n<img src=\"https://images.gitbook.cn/863babe0-4edc-11e9-8044-3de24c2bc492\" width=550>\n<h3><a id=\"font_color13aa6cfont_4\"></a><font color=13aa6c>模块化发展历程</font></h3>\n<p>在上一讲中，介绍了以下方案实现模块化：</p>\n<ul>\n<li>早期命名空间模拟模块化</li>\n<li>CommonJS</li>\n<li>AMD</li>\n<li>CMD</li>\n<li>UMD</li>\n</ul>\n<p>接下来我们来探讨 ES 原生模块化的知识，并就 tree shaking 这个话题展开。</p>\n<h4><a id=\"ES__tree_shaking_16\"></a>ES 原生时代和 tree shaking</h4>\n<p>ES 模块化（或称为 ESM）的具体使用方法我们不再具体介绍，请读者先了解相关基础内容。</p>\n<p>ES 模块的设计思想是尽量<strong>静态化</strong>，这样能保证在编译时就确定模块之间的依赖关系，每个模块的输入和输出变量也都是确定的。CommonJS 和 AMD 模块，无法保证前置即确定这些内容，只能在运行时确定。这是 ES 模块化和其他规范的显著不同。第二个差别在于，CommonJS 模块输出的是一个值的<strong>拷贝</strong>，ES 模块输出的是值的<strong>引用</strong>。我们来具体看一下：</p>\n<pre><code class=\"lang-\">// data.js\nexport let data = &apos;data&apos;\nexport function modifyData() {\n\tdata = &apos;modified data&apos;\n}\n\n// index.js\nimport { data, modifyData } from &apos;./lib&apos;\nconsole.log(data) // data\nmodifyData()\nconsole.log(data) // modified data\n</code></pre>\n<p>我们在 index.js 中调用了 modifyData 方法，之后查询 data 值，得到了最新的变化。</p>\n<p>而同样的逻辑，在 CommonJS 规范下的表现为：</p>\n<pre><code class=\"lang-\">// data.js\nvar data = &apos;data&apos;\nfunction modifyData() {\n\tdata = &apos;modified data&apos;\n}\n\nmodule.exports = {\n\tdata: data,\n\tmodifyData: modifyData\n}\n\n// index.js\nvar data = require(&apos;./data&apos;).data\nvar modifyData = require(&apos;./data&apos;).modifyData\nconsole.log(data) // data\nmodifyData()\nconsole.log(data) // data\n</code></pre>\n<p>因为 CommonJS 是输出了值的拷贝，而非引用，因此在调用 modifyData 之后，index.js 的 data 值并没有发生变化，其值为一个全新的拷贝。</p>\n<h5><a id=\"ES__62\"></a><strong>ES 模块化为什么要设计成静态的</strong></h5>\n<p>一个明显的优势是：通过静态分析，我们能够分析出导入的依赖。如果导入的模块没有被使用，我们便可以通过 tree shaking 等手段减少代码体积，进而提升运行性能。这就是基于 ESM 实现 tree shaking 的基础。</p>\n<p>这么说可能过于笼统，我们从设计的角度分析这两种规范哲学的利弊。静态性需要规范去强制保证，不像 CommonJS 那样灵活，ES 模块化的静态性带来了限制：</p>\n<ul>\n<li>只能在文件顶部 import 依赖</li>\n<li>export 导出的变量类型严格限制</li>\n<li>变量不允许被重新绑定，import 的模块名只能是字符串常量，即不可以动态确定依赖</li>\n</ul>\n<p>这样的限制在语言层面带来的便利之一是：我们可以通过作用域分析，分析出代码里变量所属的作用域以及它们之间的引用关系，进而可以推导出变量和导入依赖变量的引用关系，在没有明显引用时，就可以进行去冗余。</p>\n<h5><a id=\"tree_shaking_74\"></a><strong>tree shaking</strong></h5>\n<p>上面说到的“在没有明显引用时，就可以进行去冗余”，就是我们经常提到的 <strong>tree shaking</strong>，它的目的就是减少应用中写出，但没有被实际运用的 JavaScript 代码。这样一来，无用代码的清除，意味着更小的代码体积，bundle size 的缩减，对用户体验起到了积极作用。</p>\n<p>在计算机科学当中，一个典型去除无用代码、冗余代码的手段是 <a href=\"https://en.wikipedia.org/wiki/Dead_code_elimination\" target=\"_blank\">DCE</a>，dead code elimination。<strong>那么 tree shaking 和 DCE（Dead Code Elemination）有什么区别？</strong></p>\n<blockquote>\n<p>Rollup 的主要贡献者 Rich Harris 做过这样的比喻：假设我们用鸡蛋做蛋糕。显然，我们不需要蛋壳而只需要蛋清和蛋黄，那么如何去除蛋壳呢？DCE 是这样做的：直接把整个鸡蛋放到碗里搅拌，蛋糕做完后再慢慢地从里面挑出蛋壳</p>\n</blockquote>\n<p>相反，与 DCE 不同，tree shaking 是开始阶段就把蛋壳剥离，留下蛋清和蛋黄。事实上，也可以将 tree shaking 理解为广义 DCE 的一种，它在前置打包时即排除掉不会用到的代码。</p>\n<p>当然说到底，tree shaking 只是一种辅助手段，良好的模块拆分和设计才是减少代码体积的关键。</p>\n<p>Tree shaking 也有局限性，它还有很多不能清除无用代码的场景，比如 Rollup 的 tree shaking 实现只处理函数和顶层的 <code>import/export</code> 导入的变量，不能把没用到的类的方法消除；对于 tree shaking 来说，具有副作用的脚本无法被优化。</p>\n<p>更多情况读者可以参考：</p>\n<ul>\n<li><a href=\"https://juejin.im/post/5a64724df265da3e5a575d65\" target=\"_blank\">tree-shaking 不完全指南</a></li>\n<li><a href=\"https://github.com/indutny/webpack-common-shake#limitations\" target=\"_blank\">webpack-common-shake</a></li>\n<li><a href=\"https://juejin.im/post/5a5652d8f265da3e497ff3de\" target=\"_blank\">你的 Tree-Shaking 并没什么卵用</a></li>\n<li><a href=\"https://juejin.im/post/5bb8ef58f265da0a972e3434\" target=\"_blank\">Webpack Tree shaking 深入探究</a></li>\n</ul>\n<h5><a id=\"tree_shaking__95\"></a><strong>tree shaking 使用注意事项</strong></h5>\n<p>webpack 和 Rollup 构建工具目前都有成熟的方案，但是笔者并不建议马上引入到项目中。事实上，是否要在成熟的项目上立即实施 tree shaking 需要妥善考虑。这里我也提供几篇收藏的文章，介绍了 tree shaking 的使用方法，这些基本操作内容，我们不再展开，可以按照官方文档实施，我也在文档之外推荐这些内容供大家学习。</p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/Y4v7tAWUeDNs_FWpUnKmAw\" target=\"_blank\">Webpack 之 treeShaking</a></li>\n<li><a href=\"https://juejin.im/post/5b8ce49df265da438151b468\" target=\"_blank\">体积减少80%！释放 webpack tree-shaking 的真正潜力</a></li>\n<li><a href=\"https://juejin.im/post/5a4dc842518825698e7279a9\" target=\"_blank\">Tree-Shaking 性能优化实践 - 原理篇</a></li>\n</ul>\n<h5><a id=\"ES__export__export_default_103\"></a>ES 的 export 和 export default</h5>\n<p>ES 模块化导出有 export 和 export default 两种。这里我们建议减少使用 export default 导出，原因是一方面 export default 导出整体对象结果，不利于 tree shaking 进行分析；另一方面，export default 导出的结果可以随意命名变量，不利于团队统一管理。</p>\n<p>Nicholas C. Zakas 有一篇文章： <a href=\"https://link.juejin.im/?target=https%3A%2F%2Fhumanwhocodes.com%2Fblog%2F2019%2F01%2Fstop-using-default-exports-javascript-module%2F\" target=\"_blank\">Why I’ve stopped exporting defaults from my JavaScript modules</a> ，表达了类似的观点。</p>\n<p>###<font color=13aa6c>未来趋势和思考</font></p>\n<p>个人认为，ES 模块化是未来不可避免的发展趋势，它的优点毫无争议，比如开箱即用的 tree shaking 和未来浏览器兼容性支持。Node.js 的 CommonJS 模块化方案甚至也会慢慢过渡到 ES 模块化上。如果你正在使用 webpack 构建应用项目，那么 ES 模块化是首选；如果你的项目是一个前端库，也建议使用 ES 模块化。这么看来，或许只有在编写 Node.js 程序时，才需要考虑 CommonJS。</p>\n<h4><a id=\"_ES__113\"></a>在浏览器中快速使用 ES 模块化</h4>\n<p>目前各大浏览器较新版本都已经开始逐步支持 ES 模块了。如果我们想在浏览器中使用原生 ES 模块方案，只需要在 script 标签上添加一个 type=“module” 属性。通过该属性，浏览器知道这个文件是以模块化的方式运行的。而对于不支持的浏览器，需要通过 nomodule 属性来指定某脚本为 fallback 方案：</p>\n<pre><code class=\"lang-\">&lt;script type=&quot;module&quot;&gt;\n\timport module1 from &apos;./module1&apos;\n&lt;/script&gt;\n&lt;script nomodule&gt;\n \talert(&apos;你的浏览器不支持 ES 模块，请先升级！&apos;)\n&lt;/script&gt;\n</code></pre>\n<p>使用 type=“module”  的另一个作用是进行 ES Next 兼容性的嗅探。因为支持 ES 模块化的浏览器，都支持 ES Promise 等特性，基于此，应用场景较多。</p>\n<h4><a id=\"_Nodejs__ES__128\"></a>在 Node.js 中使用 ES 模块化</h4>\n<p>Node.js 从 9.0 版本开始支持 ES 模块，执行脚本需要启动时加上 --experimental-modules，不过这一用法要求相应的文件后缀名必须为 *.mjs：</p>\n<pre><code class=\"lang-\">node --experimental-modules module1.mjs\nimport module1 from &apos;./module1.mjs&apos;\nconsole.log(module1)\n</code></pre>\n<p>另外，也可以安装 babel-cli 和 babel-preset-env，配置 .babelrc 文件后，执行：</p>\n<pre><code class=\"lang-\">./node_modules/.bin/babel-node \n</code></pre>\n<p>或：</p>\n<pre><code class=\"lang-\">npx babel-node \n</code></pre>\n<p>在工具方面，webpack 本身维护了一套模块系统，这套模块系统兼容了几乎所有前端历史进程下的模块规范，包括 AMD/CommonJS/ES 模块化等，具体分析咱们见后续课程《webpack 工程师 &gt; 前端工程师》（即下一讲的内容）。</p>\n<h3><a id=\"font_color13aa6cfont_152\"></a><font color=13aa6c>总结</font></h3>\n<p>通过本课程的学习，我们了解了 JavaScript 模块化的历史，重点分析了不同过渡方案的不同实现以及 ES 模块化标准的细节。希望读者对模块系统有一个更清晰的认识，同时希望大家可以仔细阅读源码，对代码设计有自己的理解和体会。</p>\n<h3><a id=\"font_color13aa6cfont_156\"></a><font color=13aa6c>分享交流</font></h3>\n<p>在「模块化」相关话题上你有什么感悟？留言分享给一起学习的小伙伴吧！阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空解答）。<strong>你的分享不仅帮助他人，更会提升自己。</strong></p>\n<p>你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。</p>\n<blockquote>\n<p><strong>为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。</strong></p>\n</blockquote>\n","readingStatistics":0,"createdAt":"2019-03-26T06:31:57.115Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":24,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FoThASW9dVEPMEo9nP-zaOfbKyLZ"},{"_id":"5c999aa9a6dde326dc85812e","communication_start_time":null,"type":1,"audioPath":"","abstract":"","content":"说起前端工程化， webpack 必然在前端工具链中占有最重要的地位；说起前端工程师进阶，webpack 更是一个绕不开的话题。\n\n从原始的刀耕火种时代，到 Gulp、Grunt 等早期方案的横空出世，再到 webpack 通过其丰富的功能和开放的设计一举奠定“江湖地位”，我想每个前端工程师都需要熟悉各个时代的“打包神器”。\n\n作为团队中不可或缺的高级工程师，能否玩转 webpack，能否通过工具搭建令人舒适的工作流和构建基础，能否不断适应技术发展打磨编译体系，将直接决定你的工作价值。\n\n在这一系列课程里，赘述社区上大量存在的“webpack 配置 demo”，或者讲解一些现成的插件应用意义不大，这些知识都可以免费找到。\n\n**分析 webpack 工作原理，探究 webpack 能力边界，结合实践并加以应用**将会是本讲的重点。\n\nwebpack 主题的知识点如下所示：\n\n<img src=\"https://images.gitbook.cn/e13b8fb0-4ecd-11e9-97d1-9b2c5e38f63d\" width=500>\n\n接下来，我们通过 2 节内容来学习这个主题。\n\n### <font color=13aa6c>webpack 到底将代码编译成了什么</font>\n\n**项目中经过 webpack 打包后的代码究竟被编译成了什么？**也许你认为并不重要。业务中的代码往往非常复杂，经过 webpack 编译后的代码可读性非常差。但是不管是复杂的项目还是最简单的一行代码，其经过 webpack 编译打包的**产出本质是相同的**。我们试图从最简单的情况开始，研究 webpack 打包产出的秘密。\n\n#### CommonJS 规范打包结果\n\n如何着手分析呢？首先创建并切入到项目，进行初始化：\n\n```shell\nmkdir webpack-demo\ncd webpack-demo\nnpm init -y\n```\n\n安装 webpack 最新版本：\n\n```shell\nnpm install --save-dev webpack\nnpm install --save-dev webpack-cli\n```\n\n根目录下创建 index.html：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <title>Document</title>\n</head>\n<body>\n    <div id=\"app\"></div>\n    <script src=\"./dist/main.js\"></script>\n</body>\n</html>\n```\n\n创建 `./src` 文件。因为我们要研究模块化打包产出，这一定涉及依赖关系，因此在 `./src` 目录下创建 hello.js 和 index.js，其中 index.js 为入口脚本，它将依赖 hello.js：\n\n```js\nconst sayHello = require(&apos;./hello&apos;)\nconsole.log(sayHello(&apos;lucas&apos;))\n```\n\nhello.js：\n\n```js\nmodule.exports = function (name) {\n    return &apos;hello &apos; + name\n}\n```\n\n这里我们为了演示，采用了 CommonJS 规范，也没有加入 Babel 编译环节。\n\n直接执行命令：\n\n```\nnode_modules/.bin/webpack --mode development\n```\n\n便得到了产出 `./dist`，打开 `./dist/main.js`，得到最终编译结果：\n\n```js\n(function(modules) {\n\t//缓存已经加载过的 module 的 exports，防止 module 在 exports 之前 JS 重复执行\n\tvar installedModules = {};\n\n\t//类似 commonJS 的 require()，它是 webpack 加载函数，用来加载 webpack 定义的模块，返回 exports 导出的对象\n\tfunction __webpack_require__(moduleId) {\n\t\t//缓存中存在，则直接返回结果\n\t\tif (installedModules[moduleId]) {\n\t\t\treturn installedModules[moduleId].exports\n\t\t}\n\n\t\t//第一次加载时，初始化模块对象，并进行缓存\n\t\tvar module = installedModules[moduleId] = {\n\t\t\ti: moduleId, // 模块 ID\n\t\t\tl: false, // 是否已加载标识\n\t\t\texports: {} // 模块导出对象\n\t\t};\n\n\t\t/**\n\t\t* 执行模块\n\t\t* @param module.exports -- 模块导出对象引用，改变模块包裹函数内部的 this 指向\n\t\t* @param module -- 当前模块对象引用\n\t\t* @param module.exports -- 模块导出对象引用\n\t\t* @param __webpack_require__ -- 用于在模块中加载其他模块\n\t\t*/\n\t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t\t//标记是否已加载标识\n\t\tmodule.l = true;\n\n\t    //返回模块导出对象引用\n\t\treturn module.exports\n\t}\n\n\t__webpack_require__.m = modules;\n\t__webpack_require__.c = installedModules;\n\t//定义 exports 对象导出的属性\n\t__webpack_require__.d = function(exports, name, getter) {\n\t\t//如果 exports （不含原型链上）没有 [name] 属性，定义该属性的 getter\n\t\tif (!__webpack_require__.o(exports, name)) {\n\t\t\tObject.defineProperty(exports, name, {\n\t\t\t\tenumerable: true,\n\t\t\t\tget: getter\n\t\t\t})\n\t\t}\n\t};\n\t__webpack_require__.r = function(exports) {\n\t\tif (typeof Symbol !== &apos;undefined&apos; && Symbol.toStringTag) {\n\t\t\tObject.defineProperty(exports, Symbol.toStringTag, {\n\t\t\t\tvalue: &apos;Module&apos;\n\t\t\t})\n\t\t}\n\t\tObject.defineProperty(exports, &apos;__esModule&apos;, {\n\t\t\tvalue: true\n\t\t})\n\t};\n\t__webpack_require__.t = function(value, mode) {\n\t\tif (mode & 1) value = __webpack_require__(value);\n\t\tif (mode & 8) return value;\n\t\tif ((mode & 4) && typeof value === &apos;object&apos; && value && value.__esModule) return value;\n\t\tvar ns = Object.create(null);\n\t\t__webpack_require__.r(ns);\n\t\tObject.defineProperty(ns, &apos;default&apos;, {\n\t\t\tenumerable: true,\n\t\t\tvalue: value\n\t\t});\n\t\tif (mode & 2 && typeof value != &apos;string&apos;) for (var key in value) __webpack_require__.d(ns, key, function(key) {\n\t\t\treturn value[key]\n\t\t}.bind(null, key));\n\t\treturn ns\n\t};\n\t__webpack_require__.n = function(module) {\n\t\tvar getter = module && module.__esModule ?\n\t\tfunction getDefault() {\n\t\t\treturn module[&apos;default&apos;]\n\t\t} : function getModuleExports() {\n\t\t\treturn module\n\t\t};\n\t\t__webpack_require__.d(getter, &apos;a&apos;, getter);\n\t\treturn getter\n\t};\n\t__webpack_require__.o = function(object, property) {\n\t\treturn Object.prototype.hasOwnProperty.call(object, property)\n\t};\n\t// __webpack_public_path__\n\t__webpack_require__.p = \"\";\n\n\t//加载入口模块并返回入口模块的 exports\n\treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\")\n})({\n\t\"./src/hello.js\": (function(module, exports) {\n\t\teval(\"module.exports = function(name) {\\n    return &apos;hello &apos; + name\\n}\\n\\n//# sourceURL=webpack:///./src/hello.js?\")\n\t}),\n\t\"./src/index.js\": (function(module, exports, __webpack_require__) {\n\t\teval(\"var sayHello = __webpack_require__(/*! ./hello */ \\\"./src/hello.js\\\")\\nconsole.log(sayHello(&apos;lucas&apos;))\\n\\n//# sourceURL=webpack:///./src/index.js?\")\n\t})\n});\n```\n\n不要着急阅读，我们先把最核心的代码骨架提出来，上面的代码其实就是一个 IIFE（立即执行函数表达式）：\n\n```\n(function(modules){\n  // ...\n})({\n  \"./src/hello.js\": (function(){\n    // ...\n  }),\n  \"./src/index.js\": (function() {\n    // ...\n  })\n})\n```\n\n<div style=\"color:#024727;background:#f9f9f9;\"><p style=\"padding:10px\">Ben Cherry 的著名文章<a  href=\"http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html\"> JavaScript Module Pattern: In-Depth</a> 介绍了 IIFE 实现模块化的多种进阶尝试，阮一峰老师在其博客中也提到了相关内容。用 IIFE 实现模块化，我们并不陌生。</p></div>\n\n**深入上述代码结果（已添加注释），我们可以提炼出以下关键几点。**\n\n- webpack 打包结果就是一个 IIFE，\b一般称它为 webpackBootstrap，这个 IIFE 接收一个对象 modules 作为参数，modules 对象的 key 是依赖路径，value 是经过简单处理后的脚本（它不完全等同于我们编写的业务脚本，而是被 webpack 进行包裹后的内容）。\n- 打包结果中，定义了一个重要的模块加载函数 `__webpack_require__`。\n- 我们首先使用 `__webpack_require__` 加载函数去加载入口模块 `./src/index.js`。\n- 加载函数\b `__webpack_require__` 使用了闭包变量 installedModules，它的作用是将已加载过的模块结果保存在内存中。\n\n如果读者对于产出结果源码存在不理解的地方，请继续阅读，我们将会在 webpack 工作基本原理部分进一步说明，同时欢迎随时在评论区跟我讨论。\n\n#### ES 规范打包结果\n\n以上是基于 CommonJS 规范的模块化写法，业务中我们的代码往往遵循 ES Next 模块化标准，并通过 Babel 进行编译，这样的流程下，会得到什么结果呢？\n\n我们动手尝试一下，安装依赖：\n\n```\nnpm install --save-dev webpack\nnpm install --save-dev webpack-cli\nnpm install --save-dev babel-loader\nnpm install --save-dev @babel/core\nnpm install --save-dev @babel/preset-env\n```\n\n同时配置 package.json，加入：\n\n```\n\"scripts\": {\n    \"build\": \"webpack --mode development --progress --display-modules --colors --display-reasons\"\ns},\n```\n\n设置 npm script 以方便运行 webpack 构建，同时在 package.json 中加入 Babel 配置：\n\n```\n\"babel\": {\n\t\"presets\": [\"@babel/preset-env\"]\n}\n```\n\n将 index.js 和 hello.js 改写为 ESM 方式：\n\n```\n// hello.js\nconst sayHello = name => `hello ${name}`\nexport default sayHello\n\t\n// index.js\nimport sayHello from &apos;./hello.js&apos;\nconsole.log(sayHello(&apos;lucas&apos;))\n```\n\n执行：\n\n```\nnpm run build\n```\n\n得到的打包主体与之前内容基本一致。但是细节上，我们发现 IIFE 传入参数 modules 对象的 value 部分，即执行脚本内容多了以下语句：\n\n```\n__webpack_require__.r(__webpack_exports__)\n```\n\n实际上 `__webpack_require__.r` 这个方法是给模块的 exports 对象加上 ES 模块化规范的标记。\n\n具体标记方式为：如果支持 Symbol 对象，则通过 Object.defineProperty 为 exports 对象的 Symbol.toStringTag 属性赋值 Module，这样做的结果是 exports 对象在调用 toString 方法时会返回 Module；同时，将 `exports.__esModule` 赋值为 true。\n\n<div style=\"color:#024727;background:#f9f9f9;\"><p style=\"padding:10px\">除了 CommonJS 和 ES Module 规范，webpack 同样支持 AMD 规范，这里不再进行分析，读者可以重新打包来观察它们的区别。总之，希望大家记住 webpack 打包输出的结果就是一个 IIFE，通过这个 IIFE，以及 <code>__webpack_require__</code> 支持了各种模块化打包方案。</p></div>\n\n#### 按需加载打包结果\n\n**现代化的业务，尤其是在单页应用中，我们往往使用“按需加载”，那么对于这种相对较新的依赖技术，webpack 又会产出什么样的代码呢？**\n\n我们加入 Babel 插件，以支持 dynamic import：\n\n```\nnpm install --save-dev babel-plugin-dynamic-import-webpack\n```\n\n并在 webpack.config.js 中添加相关插件配置：\n\n```\nmodule.exports={\n    module:{\n        rules:[\n            {\n                test: /\\.js$/,\n                exclude: /node_modules/, \n                loader: \"babel-loader\",\n                options: {\n\t\t            \"plugins\": [\n\t\t                \"dynamic-import-webpack\"\n\t\t            ]\n\t\t        }\n            }\n        ]\n    }\n}\n```\n\n同时，将 index.js 使用 dynamic import 的方式实现按需加载：\n\n```\nimport(&apos;./hello&apos;).then(sayHello => {\n\tconsole.log(sayHello(&apos;lucas&apos;))\n})\n```\n\n最后执行：\n\n```\nnpm run build\n```\n\n这样一来，我们发现重新构建后会输出两个文件，分别是执行入口文件 main.js 和异步加载文件 0.js，因为异步按需加载显然不能把所有的代码再打到一个 bundle 当中了。\n\n0.js 内容为：\t\n\n```\n(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([\n[0],\n{\n\t\"./src/hello.js\": (function(module, __webpack_exports__, __webpack_require__) {\n\t\t\"use strict\";\n\t\teval(\"__webpack_require__.r(__webpack_exports__);\\n// module.exports = function(name) {\\n//     return &apos;hello &apos; + name\\n// }\\nvar sayHello = function sayHello(name) {\\n  return \\\"hello \\\".concat(name);\\n};\\n\\n/* harmony default export */ __webpack_exports__[\\\"default\\\"] = (sayHello);\\n\\n//# sourceURL=webpack:///./src/hello.js?\")\n\t})\n}])\n```\n\nmain.js 内容也与之前相比变化较大：\n\n```js\n(function(modules) {\n\t/***\n\t* webpackJsonp 用于从异步加载的文件中安装模块\n\t* 把 webpackJsonp 挂载到全局是为了方便在其他文件中调用\n\t*\n\t* @param chunkIds 异步加载的文件中存放的需要安装的模块对应的 Chunk ID\n\t* @param moreModules 异步加载的文件中存放的需要安装的模块列表\n\t* @param executeModules 在异步加载的文件中存放的需要安装的模块都安装成功后，需要执行的模块对应的 index\n\t*/\n\tfunction webpackJsonpCallback(data) {\n\t\tvar chunkIds = data[0];\n\t\tvar moreModules = data[1];\n\t\tvar moduleId, chunkId, i = 0,\n\t\t\tresolves = [];\n\t\t// 把所有 chunkId 对应的模块都标记成已经加载成功 \n\t\tfor (; i < chunkIds.length; i++) {\n\t\t\tchunkId = chunkIds[i];\n\t\t\tif (installedChunks[chunkId]) {\n\t\t\t\tresolves.push(installedChunks[chunkId][0])\n\t\t\t}\n\t\t\tinstalledChunks[chunkId] = 0\n\t\t}\n\t\tfor (moduleId in moreModules) {\n\t\t\tif (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n\t\t\t\tmodules[moduleId] = moreModules[moduleId]\n\t\t\t}\n\t\t}\n\t\tif (parentJsonpFunction) parentJsonpFunction(data);\n\t\twhile (resolves.length) {\n\t\t\tresolves.shift()()\n\t\t}\n\t};\n\n\tvar installedModules = {};\n\t// 存储每个 Chunk 的加载状态\n\t// 键为 Chunk 的 ID，值为 0 代表已经加载成功\n\tvar installedChunks = {\n\t\"main\": 0\n\t};\n\n\tfunction jsonpScriptSrc(chunkId) {\n\t\treturn __webpack_require__.p + \"\" + ({}[chunkId] || chunkId) + \".js\"\n\t}\n\tfunction __webpack_require__(moduleId) {\n\t\tif (installedModules[moduleId]) {\n\t\t\treturn installedModules[moduleId].exports\n\t\t}\n\t\tvar module = installedModules[moduleId] = {\n\t\t\ti: moduleId,\n\t\t\tl: false,\n\t\t\texports: {}\n\t\t};\n\t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\tmodule.l = true;\n\t\treturn module.exports\n\t}\n\n\t/**\n\t* 用于加载被分割出去的，需要异步加载的 Chunk 对应的文件\n\t* @param chunkId 需要异步加载的 Chunk 对应的 ID\n\t* @returns {Promise}\n\t*/\n\t__webpack_require__.e = function requireEnsure(chunkId) {\n\t\tvar promises = [];\n\t\tvar installedChunkData = installedChunks[chunkId];\n\t\t// 如果加载状态为 0 表示该 Chunk 已经加载成功了，直接返回 resolve Promise\n\t\tif (installedChunkData !== 0) {\n\t\t\tif (installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[2])\n\t\t\t} else {\n\t\t\t\tvar promise = new Promise(function(resolve, reject) {\n\t\t\t\t\tinstalledChunkData = installedChunks[chunkId] = [resolve, reject]\n\t\t\t\t});\n\t\t\t\tpromises.push(installedChunkData[2] = promise);\n\t\t\t\tvar script = document.createElement(&apos;script&apos;);\n\t\t\t\tvar onScriptComplete;\n\t\t\t\tscript.charset = &apos;utf-8&apos;;\n\t\t\t\t// 设置异步加载的最长超时时间\n\t\t\t\tscript.timeout = 120;\n\t\t\t\tif (__webpack_require__.nc) {\n\t\t\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc)\n\t\t\t\t}\n\t\t\t\t// 文件的路径为配置的 publicPath、chunkId 拼接而成\n\t\t\t\tscript.src = jsonpScriptSrc(chunkId);\n\t\t\t\tonScriptComplete = function(event) {\n\t\t\t\t\tscript.onerror = script.onload = null;\n\t\t\t\t\tclearTimeout(timeout);\n\t\t\t\t\tvar chunk = installedChunks[chunkId];\n\t\t\t\t\tif (chunk !== 0) {\n\t\t\t\t\t\tif (chunk) {\n\t\t\t\t\t\t\tvar errorType = event && (event.type === &apos;load&apos; ? &apos;missing&apos; : event.type);\n\t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\t\t\t\tvar error = new Error(&apos;Loading chunk &apos; + chunkId + &apos; failed.\\n(&apos; + errorType + &apos;: &apos; + realSrc + &apos;)&apos;);\n\t\t\t\t\t\t\terror.type = errorType;\n\t\t\t\t\t\t\terror.request = realSrc;\n\t\t\t\t\t\t\tchunk[1](error)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinstalledChunks[chunkId] = undefined\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tvar timeout = setTimeout(function() {\n\t\t\t\t\tonScriptComplete({\n\t\t\t\t\t\ttype: &apos;timeout&apos;,\n\t\t\t\t\t\ttarget: script\n\t\t\t\t\t})\n\t\t\t\t}, 120000);\n\t\t\t\tscript.onerror = script.onload = onScriptComplete;head \n\t\t\t\t// 通过 DOM 操作，往 HTML head 中插入一个 script 标签去异步加载 Chunk 对应的 JavaScript 文件\n\t\t\t\tdocument.head.appendChild(script)\n\t\t\t}\n\t\t}\n\t\treturn Promise.all(promises)\n\t};\n\n\t__webpack_require__.m = modules;\n\t__webpack_require__.c = installedModules;\n\t__webpack_require__.d = function(exports, name, getter) {\n\t\tif (!__webpack_require__.o(exports, name)) {\n\t\t\tObject.defineProperty(exports, name, {\n\t\t\t\tenumerable: true,\n\t\t\t\tget: getter\n\t\t\t})\n\t\t}\n\t};\n\n\t__webpack_require__.r = function(exports) {\n\t\tif (typeof Symbol !== &apos;undefined&apos; && Symbol.toStringTag) {\n\t\t\tObject.defineProperty(exports, Symbol.toStringTag, {\n\t\t\t\tvalue: &apos;Module&apos;\n\t\t\t})\n\t\t}\n\t\tObject.defineProperty(exports, &apos;__esModule&apos;, {\n\t\t\tvalue: true\n\t\t})\n\t};\n\t\n\t__webpack_require__.t = function(value, mode) {\n\t\tif (mode & 1) value = __webpack_require__(value);\n\t\tif (mode & 8) return value;\n\t\tif ((mode & 4) && typeof value === &apos;object&apos; && value && value.__esModule) return value;\n\t\tvar ns = Object.create(null);\n\t\t__webpack_require__.r(ns);\n\t\tObject.defineProperty(ns, &apos;default&apos;, {\n\t\t\tenumerable: true,\n\t\t\tvalue: value\n\t\t});\n\t\tif (mode & 2 && typeof value != &apos;string&apos;) for (var key in value) __webpack_require__.d(ns, key, function(key) {\n\t\t\treturn value[key]\n\t\t}.bind(null, key));\n\t\treturn ns\n\t};\n\t\n\t__webpack_require__.n = function(module) {\n\t\tvar getter = module && module.__esModule ?\n\t\tfunction getDefault() {\n\t\t\treturn module[&apos;default&apos;]\n\t\t} : function getModuleExports() {\n\t\t\treturn module\n\t};\n\t__webpack_require__.d(getter, &apos;a&apos;, getter);\n\t\treturn getter\n\t};\n\t__webpack_require__.o = function(object, property) {\n\t\treturn Object.prototype.hasOwnProperty.call(object, property)\n\t};\n\t__webpack_require__.p = \"\";\n\t__webpack_require__.oe = function(err) {\n\t\tconsole.error(err);\n\t\tthrow err;\n\t};\n\t\n\tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n\tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n\tjsonpArray.push = webpackJsonpCallback;\n\tjsonpArray = jsonpArray.slice();\n\tfor (var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n\n\tvar parentJsonpFunction = oldJsonpFunction;\n\treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\")\n\t})({\n\t\t// 所有没有经过异步加载的，随着执行入口文件加载的模块\n\t\t\"./src/index.js\": (function(module, exports, __webpack_require__) {\n\t\teval(\"// var sayHello = require(&apos;./hello&apos;)\\n// console.log(sayHello(&apos;lucas&apos;))\\n// import sayHello from &apos;./hello.js&apos;\\n// console.log(sayHello(&apos;lucas&apos;))\\nnew Promise(function (resolve) {\\n  __webpack_require__.e(/*! require.ensure */ 0).then((function (require) {\\n    resolve(__webpack_require__(/*! ./hello */ \\\"./src/hello.js\\\"));\\n  }).bind(null, __webpack_require__)).catch(__webpack_require__.oe);\\n}).then(function (sayHello) {\\n  console.log(sayHello(&apos;lucas&apos;));\\n});\\n\\n//# sourceURL=webpack:///./src/index.js?\")\n\t})\n});\n```\n\n按需加载相比常规打包产出结果变化较大，也更加复杂。我们仔细对比其中差异，发现 main.js：\n\n- 多了一个 `__webpack_require__.e` \n- 多了一个 webpackJsonp\n\n其中 `__webpack_require__.e` 实现非常重要，它初始化了一个 promise 数组，使用 Promise.all() 进行异步插入 script 脚本；webpackJsonp 会挂在到全局对象 window 上，进行模块安装。\n\n<div style=\"color:#024727;background:#f9f9f9;\"><p style=\"padding:10px\">熟悉 webpack 的读者可能会知道 CommonsChunkPlugin 插件（在 webpack v4 版本中已经被取代），这个插件用来分割第三方依赖或者公共库的代码，将业务逻辑和稳定的库脚本分离，以达到优化代码体积、合理使用缓存的目的。实际上，这样的思路和上述“按需加载”不谋而合，具体实现思路也一致。我们可以推测开发者在使用 CommonsChunkPlugin 插件打包后的代码结果和上面的代码结构类似，都存在 __webpack_require__.e 和 webpackJsonp。<strong>因为提取公共代码和异步加载本质上都是前置进行代码分割，再在必要时加载，具体实现可以观察 __webpack_require__.e 和 webpackJsonp</strong>。</p></div>\n\n到此，我们分析了业务中几乎所有的打包方式以及 webpack 产出结果。虽然这些内容较为晦涩，源码冗长而难以阅读，但是这对我们理解 webpack 内部工作原理，编写 loader、plugin 意义重大。只有分析过所有这些最基本的编译后代码，我们才能对上线代码的质量做到“心里有底”。在出现问题时，能够驾轻就熟，独当一面。这也是高级 Web 工程师所必备的素养。\n\n如果读者在阅读 webpack 打包后代码存在一些困难，也没有关系，细节实现相对打包思想设计并没有那么重要。也许你试着去设计一个模块系统，了解一下 require.js 或者 sea.js 的实现，这些内容也就不再“那么高深”了。这些代码实现细节可以放在一边，通过后续章节的学习之后，再返回来看，可能效果更好。\n\n### <font color=13aa6c>分享交流</font>\n\n请大家留言分享「前端工程化」相关的开发心得，你也可以阅读完下一节全部完成这个主题后再来总结。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后会抽空解答）。**你的分享不仅帮助他人，更会提升自己。**\n\n同时，欢迎说说自己最想了解的主题，课程内容会根据大家的意见和建议迭代和完善。\n\n>**为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。**","pdfUrl":"","reader":"","duration":"","title":"webpack 工程师和前端工程师（上）","column":"5c91c813968b1d64b1e08fde","isNotification":false,"htmlContent":"<p>说起前端工程化， webpack 必然在前端工具链中占有最重要的地位；说起前端工程师进阶，webpack 更是一个绕不开的话题。</p>\n<p>从原始的刀耕火种时代，到 Gulp、Grunt 等早期方案的横空出世，再到 webpack 通过其丰富的功能和开放的设计一举奠定“江湖地位”，我想每个前端工程师都需要熟悉各个时代的“打包神器”。</p>\n<p>作为团队中不可或缺的高级工程师，能否玩转 webpack，能否通过工具搭建令人舒适的工作流和构建基础，能否不断适应技术发展打磨编译体系，将直接决定你的工作价值。</p>\n<p>在这一系列课程里，赘述社区上大量存在的“webpack 配置 demo”，或者讲解一些现成的插件应用意义不大，这些知识都可以免费找到。</p>\n<p><strong>分析 webpack 工作原理，探究 webpack 能力边界，结合实践并加以应用</strong>将会是本讲的重点。</p>\n<p>webpack 主题的知识点如下所示：</p>\n<img src=\"https://images.gitbook.cn/e13b8fb0-4ecd-11e9-97d1-9b2c5e38f63d\" width=500>\n<p>接下来，我们通过 2 节内容来学习这个主题。</p>\n<h3><a id=\"font_color13aa6cwebpack_font_16\"></a><font color=13aa6c>webpack 到底将代码编译成了什么</font></h3>\n<p><strong>项目中经过 webpack 打包后的代码究竟被编译成了什么？<strong>也许你认为并不重要。业务中的代码往往非常复杂，经过 webpack 编译后的代码可读性非常差。但是不管是复杂的项目还是最简单的一行代码，其经过 webpack 编译打包的</strong>产出本质是相同的</strong>。我们试图从最简单的情况开始，研究 webpack 打包产出的秘密。</p>\n<h4><a id=\"CommonJS__20\"></a>CommonJS 规范打包结果</h4>\n<p>如何着手分析呢？首先创建并切入到项目，进行初始化：</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">mkdir webpack-demo\ncd webpack-demo\nnpm init -y\n</code></div></pre>\n<p>安装 webpack 最新版本：</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">npm install --save-dev webpack\nnpm install --save-dev webpack-cli\n</code></div></pre>\n<p>根目录下创建 index.html：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-meta\">&lt;!DOCTYPE html&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">\"en\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Document<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"./dist/main.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></div></pre>\n<p>创建 <code>./src</code> 文件。因为我们要研究模块化打包产出，这一定涉及依赖关系，因此在 <code>./src</code> 目录下创建 hello.js 和 index.js，其中 index.js 为入口脚本，它将依赖 hello.js：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">const</span> sayHello = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;./hello&apos;</span>)\n<span class=\"hljs-built_in\">console</span>.log(sayHello(<span class=\"hljs-string\">&apos;lucas&apos;</span>))\n</code></div></pre>\n<p>hello.js：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-built_in\">module</span>.exports = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">name</span>) </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&apos;hello &apos;</span> + name\n}\n</code></div></pre>\n<p>这里我们为了演示，采用了 CommonJS 规范，也没有加入 Babel 编译环节。</p>\n<p>直接执行命令：</p>\n<pre><code class=\"lang-\">node_modules/.bin/webpack --mode development\n</code></pre>\n<p>便得到了产出 <code>./dist</code>，打开 <code>./dist/main.js</code>，得到最终编译结果：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\">(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">modules</span>) </span>{\n\t<span class=\"hljs-comment\">//缓存已经加载过的 module 的 exports，防止 module 在 exports 之前 JS 重复执行</span>\n\t<span class=\"hljs-keyword\">var</span> installedModules = {};\n\n\t<span class=\"hljs-comment\">//类似 commonJS 的 require()，它是 webpack 加载函数，用来加载 webpack 定义的模块，返回 exports 导出的对象</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">__webpack_require__</span>(<span class=\"hljs-params\">moduleId</span>) </span>{\n\t\t<span class=\"hljs-comment\">//缓存中存在，则直接返回结果</span>\n\t\t<span class=\"hljs-keyword\">if</span> (installedModules[moduleId]) {\n\t\t\t<span class=\"hljs-keyword\">return</span> installedModules[moduleId].exports\n\t\t}\n\n\t\t<span class=\"hljs-comment\">//第一次加载时，初始化模块对象，并进行缓存</span>\n\t\t<span class=\"hljs-keyword\">var</span> <span class=\"hljs-built_in\">module</span> = installedModules[moduleId] = {\n\t\t\t<span class=\"hljs-attr\">i</span>: moduleId, <span class=\"hljs-comment\">// 模块 ID</span>\n\t\t\tl: <span class=\"hljs-literal\">false</span>, <span class=\"hljs-comment\">// 是否已加载标识</span>\n\t\t\texports: {} <span class=\"hljs-comment\">// 模块导出对象</span>\n\t\t};\n\n\t\t<span class=\"hljs-comment\">/**\n\t\t* 执行模块\n\t\t* @param module.exports -- 模块导出对象引用，改变模块包裹函数内部的 this 指向\n\t\t* @param module -- 当前模块对象引用\n\t\t* @param module.exports -- 模块导出对象引用\n\t\t* @param __webpack_require__ -- 用于在模块中加载其他模块\n\t\t*/</span>\n\t\tmodules[moduleId].call(<span class=\"hljs-built_in\">module</span>.exports, <span class=\"hljs-built_in\">module</span>, <span class=\"hljs-built_in\">module</span>.exports, __webpack_require__);\n\n\t\t<span class=\"hljs-comment\">//标记是否已加载标识</span>\n\t\t<span class=\"hljs-built_in\">module</span>.l = <span class=\"hljs-literal\">true</span>;\n\n\t    <span class=\"hljs-comment\">//返回模块导出对象引用</span>\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">module</span>.exports\n\t}\n\n\t__webpack_require__.m = modules;\n\t__webpack_require__.c = installedModules;\n\t<span class=\"hljs-comment\">//定义 exports 对象导出的属性</span>\n\t__webpack_require__.d = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">exports, name, getter</span>) </span>{\n\t\t<span class=\"hljs-comment\">//如果 exports （不含原型链上）没有 [name] 属性，定义该属性的 getter</span>\n\t\t<span class=\"hljs-keyword\">if</span> (!__webpack_require__.o(exports, name)) {\n\t\t\t<span class=\"hljs-built_in\">Object</span>.defineProperty(exports, name, {\n\t\t\t\t<span class=\"hljs-attr\">enumerable</span>: <span class=\"hljs-literal\">true</span>,\n\t\t\t\t<span class=\"hljs-attr\">get</span>: getter\n\t\t\t})\n\t\t}\n\t};\n\t__webpack_require__.r = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">exports</span>) </span>{\n\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Symbol</span> !== <span class=\"hljs-string\">&apos;undefined&apos;</span> &amp;&amp; <span class=\"hljs-built_in\">Symbol</span>.toStringTag) {\n\t\t\t<span class=\"hljs-built_in\">Object</span>.defineProperty(exports, <span class=\"hljs-built_in\">Symbol</span>.toStringTag, {\n\t\t\t\t<span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">&apos;Module&apos;</span>\n\t\t\t})\n\t\t}\n\t\t<span class=\"hljs-built_in\">Object</span>.defineProperty(exports, <span class=\"hljs-string\">&apos;__esModule&apos;</span>, {\n\t\t\t<span class=\"hljs-attr\">value</span>: <span class=\"hljs-literal\">true</span>\n\t\t})\n\t};\n\t__webpack_require__.t = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value, mode</span>) </span>{\n\t\t<span class=\"hljs-keyword\">if</span> (mode &amp; <span class=\"hljs-number\">1</span>) value = __webpack_require__(value);\n\t\t<span class=\"hljs-keyword\">if</span> (mode &amp; <span class=\"hljs-number\">8</span>) <span class=\"hljs-keyword\">return</span> value;\n\t\t<span class=\"hljs-keyword\">if</span> ((mode &amp; <span class=\"hljs-number\">4</span>) &amp;&amp; <span class=\"hljs-keyword\">typeof</span> value === <span class=\"hljs-string\">&apos;object&apos;</span> &amp;&amp; value &amp;&amp; value.__esModule) <span class=\"hljs-keyword\">return</span> value;\n\t\t<span class=\"hljs-keyword\">var</span> ns = <span class=\"hljs-built_in\">Object</span>.create(<span class=\"hljs-literal\">null</span>);\n\t\t__webpack_require__.r(ns);\n\t\t<span class=\"hljs-built_in\">Object</span>.defineProperty(ns, <span class=\"hljs-string\">&apos;default&apos;</span>, {\n\t\t\t<span class=\"hljs-attr\">enumerable</span>: <span class=\"hljs-literal\">true</span>,\n\t\t\t<span class=\"hljs-attr\">value</span>: value\n\t\t});\n\t\t<span class=\"hljs-keyword\">if</span> (mode &amp; <span class=\"hljs-number\">2</span> &amp;&amp; <span class=\"hljs-keyword\">typeof</span> value != <span class=\"hljs-string\">&apos;string&apos;</span>) <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> key <span class=\"hljs-keyword\">in</span> value) __webpack_require__.d(ns, key, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">key</span>) </span>{\n\t\t\t<span class=\"hljs-keyword\">return</span> value[key]\n\t\t}.bind(<span class=\"hljs-literal\">null</span>, key));\n\t\t<span class=\"hljs-keyword\">return</span> ns\n\t};\n\t__webpack_require__.n = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">module</span>) </span>{\n\t\t<span class=\"hljs-keyword\">var</span> getter = <span class=\"hljs-built_in\">module</span> &amp;&amp; <span class=\"hljs-built_in\">module</span>.__esModule ?\n\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getDefault</span>(<span class=\"hljs-params\"></span>) </span>{\n\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">module</span>[<span class=\"hljs-string\">&apos;default&apos;</span>]\n\t\t} : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getModuleExports</span>(<span class=\"hljs-params\"></span>) </span>{\n\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">module</span>\n\t\t};\n\t\t__webpack_require__.d(getter, <span class=\"hljs-string\">&apos;a&apos;</span>, getter);\n\t\t<span class=\"hljs-keyword\">return</span> getter\n\t};\n\t__webpack_require__.o = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">object, property</span>) </span>{\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Object</span>.prototype.hasOwnProperty.call(object, property)\n\t};\n\t<span class=\"hljs-comment\">// __webpack_public_path__</span>\n\t__webpack_require__.p = <span class=\"hljs-string\">\"\"</span>;\n\n\t<span class=\"hljs-comment\">//加载入口模块并返回入口模块的 exports</span>\n\t<span class=\"hljs-keyword\">return</span> __webpack_require__(__webpack_require__.s = <span class=\"hljs-string\">\"./src/index.js\"</span>)\n})({\n\t<span class=\"hljs-string\">\"./src/hello.js\"</span>: (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">module, exports</span>) </span>{\n\t\t<span class=\"hljs-built_in\">eval</span>(<span class=\"hljs-string\">\"module.exports = function(name) {\\n    return &apos;hello &apos; + name\\n}\\n\\n//# sourceURL=webpack:///./src/hello.js?\"</span>)\n\t}),\n\t<span class=\"hljs-string\">\"./src/index.js\"</span>: (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">module, exports, __webpack_require__</span>) </span>{\n\t\t<span class=\"hljs-built_in\">eval</span>(<span class=\"hljs-string\">\"var sayHello = __webpack_require__(/*! ./hello */ \\\"./src/hello.js\\\")\\nconsole.log(sayHello(&apos;lucas&apos;))\\n\\n//# sourceURL=webpack:///./src/index.js?\"</span>)\n\t})\n});\n</code></div></pre>\n<p>不要着急阅读，我们先把最核心的代码骨架提出来，上面的代码其实就是一个 IIFE（立即执行函数表达式）：</p>\n<pre><code class=\"lang-\">(function(modules){\n  // ...\n})({\n  &quot;./src/hello.js&quot;: (function(){\n    // ...\n  }),\n  &quot;./src/index.js&quot;: (function() {\n    // ...\n  })\n})\n</code></pre>\n<div style=\"color:#024727;background:#f9f9f9;\"><p style=\"padding:10px\">Ben Cherry 的著名文章<a  href=\"http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html\"> JavaScript Module Pattern: In-Depth</a> 介绍了 IIFE 实现模块化的多种进阶尝试，阮一峰老师在其博客中也提到了相关内容。用 IIFE 实现模块化，我们并不陌生。</p></div>\n<p><strong>深入上述代码结果（已添加注释），我们可以提炼出以下关键几点。</strong></p>\n<ul>\n<li>webpack 打包结果就是一个 IIFE，\b一般称它为 webpackBootstrap，这个 IIFE 接收一个对象 modules 作为参数，modules 对象的 key 是依赖路径，value 是经过简单处理后的脚本（它不完全等同于我们编写的业务脚本，而是被 webpack 进行包裹后的内容）。</li>\n<li>打包结果中，定义了一个重要的模块加载函数 <code>__webpack_require__</code>。</li>\n<li>我们首先使用 <code>__webpack_require__</code> 加载函数去加载入口模块 <code>./src/index.js</code>。</li>\n<li>加载函数\b <code>__webpack_require__</code> 使用了闭包变量 installedModules，它的作用是将已加载过的模块结果保存在内存中。</li>\n</ul>\n<p>如果读者对于产出结果源码存在不理解的地方，请继续阅读，我们将会在 webpack 工作基本原理部分进一步说明，同时欢迎随时在评论区跟我讨论。</p>\n<h4><a id=\"ES__203\"></a>ES 规范打包结果</h4>\n<p>以上是基于 CommonJS 规范的模块化写法，业务中我们的代码往往遵循 ES Next 模块化标准，并通过 Babel 进行编译，这样的流程下，会得到什么结果呢？</p>\n<p>我们动手尝试一下，安装依赖：</p>\n<pre><code class=\"lang-\">npm install --save-dev webpack\nnpm install --save-dev webpack-cli\nnpm install --save-dev babel-loader\nnpm install --save-dev @babel/core\nnpm install --save-dev @babel/preset-env\n</code></pre>\n<p>同时配置 package.json，加入：</p>\n<pre><code class=\"lang-\">&quot;scripts&quot;: {\n    &quot;build&quot;: &quot;webpack --mode development --progress --display-modules --colors --display-reasons&quot;\ns},\n</code></pre>\n<p>设置 npm script 以方便运行 webpack 构建，同时在 package.json 中加入 Babel 配置：</p>\n<pre><code class=\"lang-\">&quot;babel&quot;: {\n\t&quot;presets&quot;: [&quot;@babel/preset-env&quot;]\n}\n</code></pre>\n<p>将 index.js 和 hello.js 改写为 ESM 方式：</p>\n<pre><code class=\"lang-\">// hello.js\nconst sayHello = name =&gt; `hello ${name}`\nexport default sayHello\n\t\n// index.js\nimport sayHello from &apos;./hello.js&apos;\nconsole.log(sayHello(&apos;lucas&apos;))\n</code></pre>\n<p>执行：</p>\n<pre><code class=\"lang-\">npm run build\n</code></pre>\n<p>得到的打包主体与之前内容基本一致。但是细节上，我们发现 IIFE 传入参数 modules 对象的 value 部分，即执行脚本内容多了以下语句：</p>\n<pre><code class=\"lang-\">__webpack_require__.r(__webpack_exports__)\n</code></pre>\n<p>实际上 <code>__webpack_require__.r</code> 这个方法是给模块的 exports 对象加上 ES 模块化规范的标记。</p>\n<p>具体标记方式为：如果支持 Symbol 对象，则通过 Object.defineProperty 为 exports 对象的 Symbol.toStringTag 属性赋值 Module，这样做的结果是 exports 对象在调用 toString 方法时会返回 Module；同时，将 <code>exports.__esModule</code> 赋值为 true。</p>\n<div style=\"color:#024727;background:#f9f9f9;\"><p style=\"padding:10px\">除了 CommonJS 和 ES Module 规范，webpack 同样支持 AMD 规范，这里不再进行分析，读者可以重新打包来观察它们的区别。总之，希望大家记住 webpack 打包输出的结果就是一个 IIFE，通过这个 IIFE，以及 <code>__webpack_require__</code> 支持了各种模块化打包方案。</p></div>\n<h4><a id=\"_263\"></a>按需加载打包结果</h4>\n<p><strong>现代化的业务，尤其是在单页应用中，我们往往使用“按需加载”，那么对于这种相对较新的依赖技术，webpack 又会产出什么样的代码呢？</strong></p>\n<p>我们加入 Babel 插件，以支持 dynamic import：</p>\n<pre><code class=\"lang-\">npm install --save-dev babel-plugin-dynamic-import-webpack\n</code></pre>\n<p>并在 webpack.config.js 中添加相关插件配置：</p>\n<pre><code class=\"lang-\">module.exports={\n    module:{\n        rules:[\n            {\n                test: /\\.js$/,\n                exclude: /node_modules/, \n                loader: &quot;babel-loader&quot;,\n                options: {\n\t\t            &quot;plugins&quot;: [\n\t\t                &quot;dynamic-import-webpack&quot;\n\t\t            ]\n\t\t        }\n            }\n        ]\n    }\n}\n</code></pre>\n<p>同时，将 index.js 使用 dynamic import 的方式实现按需加载：</p>\n<pre><code class=\"lang-\">import(&apos;./hello&apos;).then(sayHello =&gt; {\n\tconsole.log(sayHello(&apos;lucas&apos;))\n})\n</code></pre>\n<p>最后执行：</p>\n<pre><code class=\"lang-\">npm run build\n</code></pre>\n<p>这样一来，我们发现重新构建后会输出两个文件，分别是执行入口文件 main.js 和异步加载文件 0.js，因为异步按需加载显然不能把所有的代码再打到一个 bundle 当中了。</p>\n<p>0.js 内容为：</p>\n<pre><code class=\"lang-\">(window[&quot;webpackJsonp&quot;] = window[&quot;webpackJsonp&quot;] || []).push([\n[0],\n{\n\t&quot;./src/hello.js&quot;: (function(module, __webpack_exports__, __webpack_require__) {\n\t\t&quot;use strict&quot;;\n\t\teval(&quot;__webpack_require__.r(__webpack_exports__);\\n// module.exports = function(name) {\\n//     return &apos;hello &apos; + name\\n// }\\nvar sayHello = function sayHello(name) {\\n  return \\&quot;hello \\&quot;.concat(name);\\n};\\n\\n/* harmony default export */ __webpack_exports__[\\&quot;default\\&quot;] = (sayHello);\\n\\n//# sourceURL=webpack:///./src/hello.js?&quot;)\n\t})\n}])\n</code></pre>\n<p>main.js 内容也与之前相比变化较大：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\">(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">modules</span>) </span>{\n\t<span class=\"hljs-comment\">/***\n\t* webpackJsonp 用于从异步加载的文件中安装模块\n\t* 把 webpackJsonp 挂载到全局是为了方便在其他文件中调用\n\t*\n\t* @param chunkIds 异步加载的文件中存放的需要安装的模块对应的 Chunk ID\n\t* @param moreModules 异步加载的文件中存放的需要安装的模块列表\n\t* @param executeModules 在异步加载的文件中存放的需要安装的模块都安装成功后，需要执行的模块对应的 index\n\t*/</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">webpackJsonpCallback</span>(<span class=\"hljs-params\">data</span>) </span>{\n\t\t<span class=\"hljs-keyword\">var</span> chunkIds = data[<span class=\"hljs-number\">0</span>];\n\t\t<span class=\"hljs-keyword\">var</span> moreModules = data[<span class=\"hljs-number\">1</span>];\n\t\t<span class=\"hljs-keyword\">var</span> moduleId, chunkId, i = <span class=\"hljs-number\">0</span>,\n\t\t\tresolves = [];\n\t\t<span class=\"hljs-comment\">// 把所有 chunkId 对应的模块都标记成已经加载成功 </span>\n\t\t<span class=\"hljs-keyword\">for</span> (; i &lt; chunkIds.length; i++) {\n\t\t\tchunkId = chunkIds[i];\n\t\t\t<span class=\"hljs-keyword\">if</span> (installedChunks[chunkId]) {\n\t\t\t\tresolves.push(installedChunks[chunkId][<span class=\"hljs-number\">0</span>])\n\t\t\t}\n\t\t\tinstalledChunks[chunkId] = <span class=\"hljs-number\">0</span>\n\t\t}\n\t\t<span class=\"hljs-keyword\">for</span> (moduleId <span class=\"hljs-keyword\">in</span> moreModules) {\n\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Object</span>.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n\t\t\t\tmodules[moduleId] = moreModules[moduleId]\n\t\t\t}\n\t\t}\n\t\t<span class=\"hljs-keyword\">if</span> (parentJsonpFunction) parentJsonpFunction(data);\n\t\t<span class=\"hljs-keyword\">while</span> (resolves.length) {\n\t\t\tresolves.shift()()\n\t\t}\n\t};\n\n\t<span class=\"hljs-keyword\">var</span> installedModules = {};\n\t<span class=\"hljs-comment\">// 存储每个 Chunk 的加载状态</span>\n\t<span class=\"hljs-comment\">// 键为 Chunk 的 ID，值为 0 代表已经加载成功</span>\n\t<span class=\"hljs-keyword\">var</span> installedChunks = {\n\t<span class=\"hljs-string\">\"main\"</span>: <span class=\"hljs-number\">0</span>\n\t};\n\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">jsonpScriptSrc</span>(<span class=\"hljs-params\">chunkId</span>) </span>{\n\t\t<span class=\"hljs-keyword\">return</span> __webpack_require__.p + <span class=\"hljs-string\">\"\"</span> + ({}[chunkId] || chunkId) + <span class=\"hljs-string\">\".js\"</span>\n\t}\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">__webpack_require__</span>(<span class=\"hljs-params\">moduleId</span>) </span>{\n\t\t<span class=\"hljs-keyword\">if</span> (installedModules[moduleId]) {\n\t\t\t<span class=\"hljs-keyword\">return</span> installedModules[moduleId].exports\n\t\t}\n\t\t<span class=\"hljs-keyword\">var</span> <span class=\"hljs-built_in\">module</span> = installedModules[moduleId] = {\n\t\t\t<span class=\"hljs-attr\">i</span>: moduleId,\n\t\t\t<span class=\"hljs-attr\">l</span>: <span class=\"hljs-literal\">false</span>,\n\t\t\t<span class=\"hljs-attr\">exports</span>: {}\n\t\t};\n\t\tmodules[moduleId].call(<span class=\"hljs-built_in\">module</span>.exports, <span class=\"hljs-built_in\">module</span>, <span class=\"hljs-built_in\">module</span>.exports, __webpack_require__);\n\t\t<span class=\"hljs-built_in\">module</span>.l = <span class=\"hljs-literal\">true</span>;\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">module</span>.exports\n\t}\n\n\t<span class=\"hljs-comment\">/**\n\t* 用于加载被分割出去的，需要异步加载的 Chunk 对应的文件\n\t* @param chunkId 需要异步加载的 Chunk 对应的 ID\n\t* @returns {Promise}\n\t*/</span>\n\t__webpack_require__.e = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">requireEnsure</span>(<span class=\"hljs-params\">chunkId</span>) </span>{\n\t\t<span class=\"hljs-keyword\">var</span> promises = [];\n\t\t<span class=\"hljs-keyword\">var</span> installedChunkData = installedChunks[chunkId];\n\t\t<span class=\"hljs-comment\">// 如果加载状态为 0 表示该 Chunk 已经加载成功了，直接返回 resolve Promise</span>\n\t\t<span class=\"hljs-keyword\">if</span> (installedChunkData !== <span class=\"hljs-number\">0</span>) {\n\t\t\t<span class=\"hljs-keyword\">if</span> (installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[<span class=\"hljs-number\">2</span>])\n\t\t\t} <span class=\"hljs-keyword\">else</span> {\n\t\t\t\t<span class=\"hljs-keyword\">var</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>{\n\t\t\t\t\tinstalledChunkData = installedChunks[chunkId] = [resolve, reject]\n\t\t\t\t});\n\t\t\t\tpromises.push(installedChunkData[<span class=\"hljs-number\">2</span>] = promise);\n\t\t\t\t<span class=\"hljs-keyword\">var</span> script = <span class=\"hljs-built_in\">document</span>.createElement(<span class=\"hljs-string\">&apos;script&apos;</span>);\n\t\t\t\t<span class=\"hljs-keyword\">var</span> onScriptComplete;\n\t\t\t\tscript.charset = <span class=\"hljs-string\">&apos;utf-8&apos;</span>;\n\t\t\t\t<span class=\"hljs-comment\">// 设置异步加载的最长超时时间</span>\n\t\t\t\tscript.timeout = <span class=\"hljs-number\">120</span>;\n\t\t\t\t<span class=\"hljs-keyword\">if</span> (__webpack_require__.nc) {\n\t\t\t\t\tscript.setAttribute(<span class=\"hljs-string\">\"nonce\"</span>, __webpack_require__.nc)\n\t\t\t\t}\n\t\t\t\t<span class=\"hljs-comment\">// 文件的路径为配置的 publicPath、chunkId 拼接而成</span>\n\t\t\t\tscript.src = jsonpScriptSrc(chunkId);\n\t\t\t\tonScriptComplete = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">event</span>) </span>{\n\t\t\t\t\tscript.onerror = script.onload = <span class=\"hljs-literal\">null</span>;\n\t\t\t\t\tclearTimeout(timeout);\n\t\t\t\t\t<span class=\"hljs-keyword\">var</span> chunk = installedChunks[chunkId];\n\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (chunk !== <span class=\"hljs-number\">0</span>) {\n\t\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (chunk) {\n\t\t\t\t\t\t\t<span class=\"hljs-keyword\">var</span> errorType = event &amp;&amp; (event.type === <span class=\"hljs-string\">&apos;load&apos;</span> ? <span class=\"hljs-string\">&apos;missing&apos;</span> : event.type);\n\t\t\t\t\t\t\t<span class=\"hljs-keyword\">var</span> realSrc = event &amp;&amp; event.target &amp;&amp; event.target.src;\n\t\t\t\t\t\t\t<span class=\"hljs-keyword\">var</span> error = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&apos;Loading chunk &apos;</span> + chunkId + <span class=\"hljs-string\">&apos; failed.\\n(&apos;</span> + errorType + <span class=\"hljs-string\">&apos;: &apos;</span> + realSrc + <span class=\"hljs-string\">&apos;)&apos;</span>);\n\t\t\t\t\t\t\terror.type = errorType;\n\t\t\t\t\t\t\terror.request = realSrc;\n\t\t\t\t\t\t\tchunk[<span class=\"hljs-number\">1</span>](error)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinstalledChunks[chunkId] = <span class=\"hljs-literal\">undefined</span>\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\t<span class=\"hljs-keyword\">var</span> timeout = setTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n\t\t\t\t\tonScriptComplete({\n\t\t\t\t\t\t<span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&apos;timeout&apos;</span>,\n\t\t\t\t\t\t<span class=\"hljs-attr\">target</span>: script\n\t\t\t\t\t})\n\t\t\t\t}, <span class=\"hljs-number\">120000</span>);\n\t\t\t\tscript.onerror = script.onload = onScriptComplete;head \n\t\t\t\t<span class=\"hljs-comment\">// 通过 DOM 操作，往 HTML head 中插入一个 script 标签去异步加载 Chunk 对应的 JavaScript 文件</span>\n\t\t\t\t<span class=\"hljs-built_in\">document</span>.head.appendChild(script)\n\t\t\t}\n\t\t}\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Promise</span>.all(promises)\n\t};\n\n\t__webpack_require__.m = modules;\n\t__webpack_require__.c = installedModules;\n\t__webpack_require__.d = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">exports, name, getter</span>) </span>{\n\t\t<span class=\"hljs-keyword\">if</span> (!__webpack_require__.o(exports, name)) {\n\t\t\t<span class=\"hljs-built_in\">Object</span>.defineProperty(exports, name, {\n\t\t\t\t<span class=\"hljs-attr\">enumerable</span>: <span class=\"hljs-literal\">true</span>,\n\t\t\t\t<span class=\"hljs-attr\">get</span>: getter\n\t\t\t})\n\t\t}\n\t};\n\n\t__webpack_require__.r = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">exports</span>) </span>{\n\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">Symbol</span> !== <span class=\"hljs-string\">&apos;undefined&apos;</span> &amp;&amp; <span class=\"hljs-built_in\">Symbol</span>.toStringTag) {\n\t\t\t<span class=\"hljs-built_in\">Object</span>.defineProperty(exports, <span class=\"hljs-built_in\">Symbol</span>.toStringTag, {\n\t\t\t\t<span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">&apos;Module&apos;</span>\n\t\t\t})\n\t\t}\n\t\t<span class=\"hljs-built_in\">Object</span>.defineProperty(exports, <span class=\"hljs-string\">&apos;__esModule&apos;</span>, {\n\t\t\t<span class=\"hljs-attr\">value</span>: <span class=\"hljs-literal\">true</span>\n\t\t})\n\t};\n\t\n\t__webpack_require__.t = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value, mode</span>) </span>{\n\t\t<span class=\"hljs-keyword\">if</span> (mode &amp; <span class=\"hljs-number\">1</span>) value = __webpack_require__(value);\n\t\t<span class=\"hljs-keyword\">if</span> (mode &amp; <span class=\"hljs-number\">8</span>) <span class=\"hljs-keyword\">return</span> value;\n\t\t<span class=\"hljs-keyword\">if</span> ((mode &amp; <span class=\"hljs-number\">4</span>) &amp;&amp; <span class=\"hljs-keyword\">typeof</span> value === <span class=\"hljs-string\">&apos;object&apos;</span> &amp;&amp; value &amp;&amp; value.__esModule) <span class=\"hljs-keyword\">return</span> value;\n\t\t<span class=\"hljs-keyword\">var</span> ns = <span class=\"hljs-built_in\">Object</span>.create(<span class=\"hljs-literal\">null</span>);\n\t\t__webpack_require__.r(ns);\n\t\t<span class=\"hljs-built_in\">Object</span>.defineProperty(ns, <span class=\"hljs-string\">&apos;default&apos;</span>, {\n\t\t\t<span class=\"hljs-attr\">enumerable</span>: <span class=\"hljs-literal\">true</span>,\n\t\t\t<span class=\"hljs-attr\">value</span>: value\n\t\t});\n\t\t<span class=\"hljs-keyword\">if</span> (mode &amp; <span class=\"hljs-number\">2</span> &amp;&amp; <span class=\"hljs-keyword\">typeof</span> value != <span class=\"hljs-string\">&apos;string&apos;</span>) <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> key <span class=\"hljs-keyword\">in</span> value) __webpack_require__.d(ns, key, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">key</span>) </span>{\n\t\t\t<span class=\"hljs-keyword\">return</span> value[key]\n\t\t}.bind(<span class=\"hljs-literal\">null</span>, key));\n\t\t<span class=\"hljs-keyword\">return</span> ns\n\t};\n\t\n\t__webpack_require__.n = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">module</span>) </span>{\n\t\t<span class=\"hljs-keyword\">var</span> getter = <span class=\"hljs-built_in\">module</span> &amp;&amp; <span class=\"hljs-built_in\">module</span>.__esModule ?\n\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getDefault</span>(<span class=\"hljs-params\"></span>) </span>{\n\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">module</span>[<span class=\"hljs-string\">&apos;default&apos;</span>]\n\t\t} : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getModuleExports</span>(<span class=\"hljs-params\"></span>) </span>{\n\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">module</span>\n\t};\n\t__webpack_require__.d(getter, <span class=\"hljs-string\">&apos;a&apos;</span>, getter);\n\t\t<span class=\"hljs-keyword\">return</span> getter\n\t};\n\t__webpack_require__.o = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">object, property</span>) </span>{\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Object</span>.prototype.hasOwnProperty.call(object, property)\n\t};\n\t__webpack_require__.p = <span class=\"hljs-string\">\"\"</span>;\n\t__webpack_require__.oe = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err</span>) </span>{\n\t\t<span class=\"hljs-built_in\">console</span>.error(err);\n\t\t<span class=\"hljs-keyword\">throw</span> err;\n\t};\n\t\n\t<span class=\"hljs-keyword\">var</span> jsonpArray = <span class=\"hljs-built_in\">window</span>[<span class=\"hljs-string\">\"webpackJsonp\"</span>] = <span class=\"hljs-built_in\">window</span>[<span class=\"hljs-string\">\"webpackJsonp\"</span>] || [];\n\t<span class=\"hljs-keyword\">var</span> oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n\tjsonpArray.push = webpackJsonpCallback;\n\tjsonpArray = jsonpArray.slice();\n\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n\n\t<span class=\"hljs-keyword\">var</span> parentJsonpFunction = oldJsonpFunction;\n\t<span class=\"hljs-keyword\">return</span> __webpack_require__(__webpack_require__.s = <span class=\"hljs-string\">\"./src/index.js\"</span>)\n\t})({\n\t\t<span class=\"hljs-comment\">// 所有没有经过异步加载的，随着执行入口文件加载的模块</span>\n\t\t<span class=\"hljs-string\">\"./src/index.js\"</span>: (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">module, exports, __webpack_require__</span>) </span>{\n\t\t<span class=\"hljs-built_in\">eval</span>(<span class=\"hljs-string\">\"// var sayHello = require(&apos;./hello&apos;)\\n// console.log(sayHello(&apos;lucas&apos;))\\n// import sayHello from &apos;./hello.js&apos;\\n// console.log(sayHello(&apos;lucas&apos;))\\nnew Promise(function (resolve) {\\n  __webpack_require__.e(/*! require.ensure */ 0).then((function (require) {\\n    resolve(__webpack_require__(/*! ./hello */ \\\"./src/hello.js\\\"));\\n  }).bind(null, __webpack_require__)).catch(__webpack_require__.oe);\\n}).then(function (sayHello) {\\n  console.log(sayHello(&apos;lucas&apos;));\\n});\\n\\n//# sourceURL=webpack:///./src/index.js?\"</span>)\n\t})\n});\n</code></div></pre>\n<p>按需加载相比常规打包产出结果变化较大，也更加复杂。我们仔细对比其中差异，发现 main.js：</p>\n<ul>\n<li>多了一个 <code>__webpack_require__.e</code></li>\n<li>多了一个 webpackJsonp</li>\n</ul>\n<p>其中 <code>__webpack_require__.e</code> 实现非常重要，它初始化了一个 promise 数组，使用 Promise.all() 进行异步插入 script 脚本；webpackJsonp 会挂在到全局对象 window 上，进行模块安装。</p>\n<div style=\"color:#024727;background:#f9f9f9;\"><p style=\"padding:10px\">熟悉 webpack 的读者可能会知道 CommonsChunkPlugin 插件（在 webpack v4 版本中已经被取代），这个插件用来分割第三方依赖或者公共库的代码，将业务逻辑和稳定的库脚本分离，以达到优化代码体积、合理使用缓存的目的。实际上，这样的思路和上述“按需加载”不谋而合，具体实现思路也一致。我们可以推测开发者在使用 CommonsChunkPlugin 插件打包后的代码结果和上面的代码结构类似，都存在 __webpack_require__.e 和 webpackJsonp。<strong>因为提取公共代码和异步加载本质上都是前置进行代码分割，再在必要时加载，具体实现可以观察 __webpack_require__.e 和 webpackJsonp</strong>。</p></div>\n<p>到此，我们分析了业务中几乎所有的打包方式以及 webpack 产出结果。虽然这些内容较为晦涩，源码冗长而难以阅读，但是这对我们理解 webpack 内部工作原理，编写 loader、plugin 意义重大。只有分析过所有这些最基本的编译后代码，我们才能对上线代码的质量做到“心里有底”。在出现问题时，能够驾轻就熟，独当一面。这也是高级 Web 工程师所必备的素养。</p>\n<p>如果读者在阅读 webpack 打包后代码存在一些困难，也没有关系，细节实现相对打包思想设计并没有那么重要。也许你试着去设计一个模块系统，了解一下 require.js 或者 sea.js 的实现，这些内容也就不再“那么高深”了。这些代码实现细节可以放在一边，通过后续章节的学习之后，再返回来看，可能效果更好。</p>\n<h3><a id=\"font_color13aa6cfont_526\"></a><font color=13aa6c>分享交流</font></h3>\n<p>请大家留言分享「前端工程化」相关的开发心得，你也可以阅读完下一节全部完成这个主题后再来总结。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后会抽空解答）。<strong>你的分享不仅帮助他人，更会提升自己。</strong></p>\n<p>同时，欢迎说说自己最想了解的主题，课程内容会根据大家的意见和建议迭代和完善。</p>\n<blockquote>\n<p><strong>为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。</strong></p>\n</blockquote>\n","readingStatistics":2,"createdAt":"2019-03-26T03:21:13.068Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":25,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FoThASW9dVEPMEo9nP-zaOfbKyLZ"},{"_id":"5c999b70a6dde326dc85814d","communication_start_time":null,"type":1,"audioPath":"","abstract":"","content":"上一节中，我们了解了 webpack 对于不同模块化标准的打包结果，分析了其自身的模块化解决方案。但是 webpack 绝不仅仅是一个打包器，它是一个完整的构建工具链。**那么它到底是如何工作的，原理是什么？了解了这些原理，我们又能如何扩展，以解决工作中的实际问题？** 这一节，我们来一探究竟。\n\n我们再次列出 webpack 主题的知识点：\n\n<img src=\"https://images.gitbook.cn/e13b8fb0-4ecd-11e9-97d1-9b2c5e38f63d\" width=600>\n\n### <font color=13aa6c>webpack 工作基本原理</font>\n\n通过前文学习，我们知道了 webpack 编译产出，对结果进行分析。“知其然，知其所以然”，在知晓打包结果的基础上，接下来我们尝试分析产出过程，了解 webpack 工作的基本原理。\n\nwebpack 工作流程可以简单总结为下图：\n\n<img src=\"https://images.gitbook.cn/800e19e0-4eac-11e9-9566-89cb1d9578c6\" width=700>\n\n- 首先，webpack 会读取项目中由开发者定义的 webpack.config.js 配置文件，或者从 shell 语句中获得必要的参数。这是 webpack 内部接收业务配置信息的方式。这就完成了配置读取的初步工作。\n- 接着，实例化所需 webpack 插件，在 webpack 事件流上挂载插件钩子，这样在合适的构建过程中，插件具备了改动产出结果的能力。\n- 同时，根据配置所定义的入口文件，以入口文件（可以不止有一个）为起始，进行依赖收集：对所有依赖的文件进行编译，这个编译过程依赖 loaders，不同类型文件根据开发者定义的不同 loader 进行解析。编译好的内容使用 acorn 或其它抽象语法树能力，解析生成 AST 静态语法树，分析文件依赖关系，将不同模块化语法（如 require）等替换为 `__webpack_require__`，即使用 webpack 自己的加载器进行模块化实现。\n- 上述过程进行完毕后，产出结果，根据开发者配置，将结果打包到相应目录。\n\n值得一提的是，在这整个打包过程中，**webpack 和插件采用基于事件流的发布订阅模式，监听某些关键过程，在这些环节中执行插件任务**。到最后，所有文件的编译和转化都已经完成，输出最终资源。\n\n如果深入源码，上述过程用更加专业的术语总结为——模块会经历**加载**（loaded）、**封存**（sealed）、**优化**（optimized）、**分块**（chunked）、**哈希**（hashed）和**重新创建**（restored）这几个经典步骤。在这里，我们了解大体流程即可。\n\n梳理完 webpack 工作“流水账”，我们还需要在理论上熟悉以下概念。\n\n#### 抽象语法树 AST\n\n即便大家没有接触过 AST，也应该不是第一次听说这个概念。\n\n在计算机科学中，抽象语法树（Abstract Syntax Tree，简称 AST），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构和表达。\n\n之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。比如类似于 if-condition-then 这样的条件跳转语句，可以使用带有两个分支的节点来表示。\n\nAST 并不会被计算机所识别，更不会被运行，它是对编程语言的一种表达，为代码分析提供了基础。\n\n**webpack 将文件转换成 AST 的目的就是方便开发者提取模块文件中的关键信息。** 这样一来，我们就可以“知晓开发者到底写了什么东西”，也就可以根据这些“写出的东西”，实现分析和扩展。在代码层面，我们可以把 AST 理解为一个 object：\n\n```\nvar ast = &apos;AST demo&apos;\n```\n\n这样的语句转换为 AST 就是：\n\n```json\n{\n  \"type\": \"Program\",\n  \"start\": 0,\n  \"end\": 20,\n  \"body\": [\n    {\n      \"type\": \"VariableDeclaration\",\n      \"start\": 0,\n      \"end\": 20,\n      \"declarations\": [\n        {\n          \"type\": \"VariableDeclarator\",\n          \"start\": 4,\n          \"end\": 20,\n          \"id\": {\n            \"type\": \"Identifier\",\n            \"start\": 4,\n            \"end\": 7,\n            \"name\": \"ast\"\n          },\n          \"init\": {\n            \"type\": \"Literal\",\n            \"start\": 10,\n            \"end\": 20,\n            \"value\": \"AST demo\",\n            \"raw\": \"&apos;AST demo&apos;\"\n          }\n        }\n      ],\n      \"kind\": \"var\"\n    }\n  ],\n  \"sourceType\": \"module\"\n}\n```\n\n从中我们可以看出，AST 结果精确地表明了这是一条变量声明语句，语句起始于哪里，赋值结果是什么等信息都被表达出来。\n\n一个更复杂的例子：\n\n```js\nlet tips = [1, 2]\n    \nfunction printTips() {\n  tips.forEach((tip, i) => console.log(`Tip ${i}:` + tip))\n}\n```\n\n会转化为：\n\n```json\n{\n  \"type\": \"Program\",\n  \"start\": 0,\n  \"end\": 285,\n  \"body\": [\n    {\n      \"type\": \"VariableDeclaration\",\n      \"start\": 179,\n      \"end\": 197,\n      \"declarations\": [\n        {\n          \"type\": \"VariableDeclarator\",\n          \"start\": 183,\n          \"end\": 196,\n          \"id\": {\n            \"type\": \"Identifier\",\n            \"start\": 183,\n            \"end\": 187,\n            \"name\": \"tips\"\n          },\n          \"init\": {\n            \"type\": \"ArrayExpression\",\n            \"start\": 190,\n            \"end\": 196,\n            \"elements\": [\n              {\n                \"type\": \"Literal\",\n                \"start\": 191,\n                \"end\": 192,\n                \"value\": 1,\n                \"raw\": \"1\"\n              },\n              {\n                \"type\": \"Literal\",\n                \"start\": 194,\n                \"end\": 195,\n                \"value\": 2,\n                \"raw\": \"2\"\n              }\n            ]\n          }\n        }\n      ],\n      \"kind\": \"let\"\n    },\n    {\n      \"type\": \"FunctionDeclaration\",\n      \"start\": 199,\n      \"end\": 283,\n      \"id\": {\n        \"type\": \"Identifier\",\n        \"start\": 208,\n        \"end\": 217,\n        \"name\": \"printTips\"\n      },\n      \"expression\": false,\n      \"generator\": false,\n      \"params\": [],\n      \"body\": {\n        \"type\": \"BlockStatement\",\n        \"start\": 220,\n        \"end\": 283,\n        \"body\": [\n          {\n            \"type\": \"ExpressionStatement\",\n            \"start\": 224,\n            \"end\": 281,\n            \"expression\": {\n              \"type\": \"CallExpression\",\n              \"start\": 224,\n              \"end\": 280,\n              \"callee\": {\n                \"type\": \"MemberExpression\",\n                \"start\": 224,\n                \"end\": 236,\n                \"object\": {\n                  \"type\": \"Identifier\",\n                  \"start\": 224,\n                  \"end\": 228,\n                  \"name\": \"tips\"\n                },\n                \"property\": {\n                  \"type\": \"Identifier\",\n                  \"start\": 229,\n                  \"end\": 236,\n                  \"name\": \"forEach\"\n                },\n                \"computed\": false\n              },\n              \"arguments\": [\n                {\n                  \"type\": \"ArrowFunctionExpression\",\n                  \"start\": 237,\n                  \"end\": 279,\n                  \"id\": null,\n                  \"expression\": true,\n                  \"generator\": false,\n                  \"params\": [\n                    {\n                      \"type\": \"Identifier\",\n                      \"start\": 238,\n                      \"end\": 241,\n                      \"name\": \"tip\"\n                    },\n                    {\n                      \"type\": \"Identifier\",\n                      \"start\": 243,\n                      \"end\": 244,\n                      \"name\": \"i\"\n                    }\n                  ],\n                  \"body\": {\n                    \"type\": \"CallExpression\",\n                    \"start\": 249,\n                    \"end\": 279,\n                    \"callee\": {\n                      \"type\": \"MemberExpression\",\n                      \"start\": 249,\n                      \"end\": 260,\n                      \"object\": {\n                        \"type\": \"Identifier\",\n                        \"start\": 249,\n                        \"end\": 256,\n                        \"name\": \"console\"\n                      },\n                      \"property\": {\n                        \"type\": \"Identifier\",\n                        \"start\": 257,\n                        \"end\": 260,\n                        \"name\": \"log\"\n                      },\n                      \"computed\": false\n                    },\n                    \"arguments\": [\n                      {\n                        \"type\": \"BinaryExpression\",\n                        \"start\": 261,\n                        \"end\": 278,\n                        \"left\": {\n                          \"type\": \"TemplateLiteral\",\n                          \"start\": 261,\n                          \"end\": 272,\n                          \"expressions\": [\n                            {\n                              \"type\": \"Identifier\",\n                              \"start\": 268,\n                              \"end\": 269,\n                              \"name\": \"i\"\n                            }\n                          ],\n                          \"quasis\": [\n                            {\n                              \"type\": \"TemplateElement\",\n                              \"start\": 262,\n                              \"end\": 266,\n                              \"value\": {\n                                \"raw\": \"Tip \",\n                                \"cooked\": \"Tip \"\n                              },\n                              \"tail\": false\n                            },\n                            {\n                              \"type\": \"TemplateElement\",\n                              \"start\": 270,\n                              \"end\": 271,\n                              \"value\": {\n                                \"raw\": \":\",\n                                \"cooked\": \":\"\n                              },\n                              \"tail\": true\n                            }\n                          ]\n                        },\n                        \"operator\": \"+\",\n                        \"right\": {\n                          \"type\": \"Identifier\",\n                          \"start\": 275,\n                          \"end\": 278,\n                          \"name\": \"tip\"\n                        }\n                      }\n                    ]\n                  }\n                }\n              ]\n            }\n          }\n        ]\n      }\n    }\n  ],\n  \"sourceType\": \"module\"\n}\n```\n\n我们看到，AST 结果除了表达出变量赋值 VariableDeclaration 信息以外，对函数声明 FunctionDeclaration 也做了精确的“解剖”，哪里出现了一个花括号，哪里实现了 API 调用，通过 AST 全部一览无余。\n\n设想一下，有了这样的语法树，开发者便可以针对源文件进行一些“分析、加工或转换”操作。\n\n#### compiler 和 compilation\n\ncompiler 和 compilation 这两个对象是 webpack 核心原理中最重要的概念。它们是理解 webpack 工作原理、loader 和插件工作的基础。\n\n- compiler 对象：它的实例包含了完整的 webpack 配置，全局只有一个 compiler 实例，因此它就像 webpack 的骨架或神经中枢。当插件被实例化的时候，会收到一个 compiler 对象，通过这个对象可以访问 webpack 的内部环境。\n- compilation 对象：当 webpack 以开发模式运行时，每当检测到文件变化，一个新的 compilation 对象将被创建。这个对象包含了当前的模块资源、编译生成资源、变化的文件等信息。也就是说，所有构建过程中产生的构建数据都存储在该对象上，它也掌控着构建过程中的每一个环节。该对象也提供了很多事件回调供插件做扩展。\n\n两者的关系可以通过以下图示说明：\n\n<img src=\"https://images.gitbook.cn/97a316a0-4eac-11e9-9566-89cb1d9578c6\" width=300>\n\nwebpack 的构建过程是通过 compiler 控制流程，compilation 进行解析。**在开发插件时，我们可以从 compiler 对象中拿到所有和 webpack 主环境相关的内容，包括事件钩子。** 更多信息我们将在下文介绍。\n\ncompiler 对象和 compilation 对象都继承自 tapable，tapable.js 这个库暴露了所有和事件相关的 pub/sub 的方法。webpack 基于事件流的 tapable 库，不仅能保证插件的有序性，还使得整个系统扩展性更好。\n\n关于 tapable 库的解读我们到这里不再深入，感兴趣的读者可以参加后续讨论和学习后续文章内容。\n\n### <font color=13aa6c>探秘并编写 webpack loader</font>\n\n熟悉了概念，我们就来进行实战：了解如何编写一个 webpack loader。事实上，在 webpack 中，loader 是魔法真正发生的阶段之一：Babel 将 ES Next 编译成 ES5，sass-loader 将 SCSS/Sass 编译成 CSS 等，都是由相关 loader 或者 plugin 完成的。因此，直观上理解，**loader 就是接受源文件，对源文件进行处理，返回编译后文件**。如图：\n\n<img src=\"https://images.gitbook.cn/9e70e110-4eac-11e9-9566-89cb1d9578c6\" width=400>\n\n我们看到一个 loader 秉承单一职责，完成最小单元的文件转换。当然，**一个源文件可能需要经历多步转换才能正常使用**，比如 Sass 文件先通过 sass-loader 输出 CSS，之后将内容交给 css-loader 处理，甚至 css-loader 输出的内容还需要交给 style-loader 处理，转换成通过脚本加载的 JavaScript 代码。如下使用方式：\n\n```js\nmodule.exports = {\n  ...\n  module: {\n    rules: [{\n      test: /\\.less$/,\n      use: [{\n        loader: &apos;style-loader&apos; // 通过 JS 字符串，创建 style node\n      }, {\n        loader: &apos;css-loader&apos; // 编译 css 使其符合 CommonJS 规范\n      }, {\n        loader: &apos;less-loader&apos; // 编译 less 为 css\n      }]\n    }]\n  }\n}\n```\n\n当我们调用多个 loader 串联去转换一个文件时，每个 loader 会链式地顺序执行。webpack 中，在同一文件存在多个匹配 loader 的情况下，遵循以下原则：\n\n- loader 的执行顺序是和配置顺序相反的，即配置的最后一个 loader 最先执行，第一个 loader 最后执行。\n- 第一个执行的 loader 接收源文件内容作为参数，其他 loader 接收前一个执行的 loader 的返回值作为参数。最后执行的 loader 会返回最终结果。\n\n如图，对应上面代码：\n\n<img src=\"https://images.gitbook.cn/a3934570-4eac-11e9-b0b9-2fcbe141d641\" width=600>\n\n因此，在你开发一个 loader 时，请保持其职责的单一性，只需关心输入和输出。\n\n不难理解：loader 本质就是函数，其最简单的结构为：\n\n```js\nmodule.exports = function(source){\n     // some magic...\n     return content\n}\n```\n\nloader 就是一个基于 CommonJS 规范的函数模块，它接受内容（这个内容可能是源文件也可能是经过其他 loader 处理后的结果），并返回新的内容。\n\n更进一步，我们知道在配置 webpack 时，对于 loader 可以增加一些配置，比如著名的 babel-loader 的简单配置：\n\n```js\nmodule:{\n    rules:[\n        {\n            test: /\\.js$/,\n            exclude: /node_modules/, \n            loader: \"babel-loader\",\n            options: {\n\t            \"plugins\": [\n\t                \"dynamic-import-webpack\"\n\t            ]\n\t        }\n        }\n    ]\n}\n```\n\n这样一来，上文简单的 loader 写法便不能满足需求了，因为我们除了 source 以外，还需要根据开发者配置的 options 信息进行处理，以输出最后结果。那么如何获取 options 呢？这时候就需要 loader-utils 模块了：\n\n```js\nconst loaderUtils = require(\"loader-utils\")\nmodule.exports = function(source) {\n    // 获取开发者配置的 options\n    const options = loaderUtils.getOptions(this)\n    // some magic...\n    return content\n}\n```\n\n另外，对于 loader 返回的内容，在实际开发中，单纯对 content 进行改写并返回也许是不够的。\n\n比如，我们想对 loader 处理过程中的错误进行捕获，或者又想导出 sourceMap 等信息，该如何做呢？\n\n这种情况需要用到 loader 中的 this.callback 进行内容的返回。this.callback 可以传入四个参数，分别是：\n\n- error：Error | null，当 loader 出错时向外抛出一个 error\n- content：String | Buffer，经过 loader 编译后需要导出的内容\n- sourceMap：为方便调试生成的编译后内容的 source map\n- ast：本次编译生成的 AST 静态语法树，之后执行的 loader 可以直接使用这个 AST，进而省去重复生成 AST 的过程\n\n这样，我们的 loader 代码变得更加复杂，同时也能够处理更多样的需求：\n\n```js\nmodule.exports = function(source) {\n    // 获取开发者配置的 options\n    const options = loaderUtils.getOptions(this)\n    // some magic...\n    // return content\n    this.callback(null, content)\n}\n```\n\n<div style=\"color:#024727;background:#f9f9f9;\"><p style=\"padding:10px\"><strong>注意</strong>　当我们使用 <code>this.callback</code> 返回内容时，该 loader 必须返回 <code>undefined</code>，这样 webpack 就知道该 loader 返回的结果在 <code>this.callback</code> 中，而不是 return 中。</p></div>\n\n**细心的读者会问，这里的 this 指向谁？**事实上，这个 this 是一个叫 loaderContext 的 loader-runner 特有对象。如果刨根问底，就要细读 webpack loader 部分相关源码了，这并不是我们的主题，感兴趣的读者可以针对 webpack 源码再进行分析。\n\n默认情况下，webpack 传给 loader 的内容源都是 UTF-8 格式编码的字符串。但请思考 file-loader 这个常用的 loader，它不是处理文本文件，而是处理二进制文件的，这种情况下，我们可以通过：source instanceof Buffer === true 来判断内容源类型：\n\n```js\nmodule.exports = function(source) {\n    source instanceof Buffer === true\n    return source\n}\n```\n\n如果自定义的 loader 也会返回二进制文件，需要在文件中显式注明：\n\n```js\nmodule.exports.raw = true\n```\n\n当然，还存在异步 loader 的情况，即对 source 的处理并不能同步完成，这时候使用简单的 async-await 即可：\n\n```js\nmodule.exports = async function(source) {\n    function timeout(delay) {\n        return new Promise((resolve, reject) => {\n            setTimeout(() => {\n                resolve(source)\n            }, delay)\n        })\n    }\n    const content = await timeout(1000)\n    this.callback(null, content)\n}\n```\n\n另一种异步 loader 解决方案是使用 webpack 提供的 this.async，调用 this.async 会返回一个 callback Function，在异步完成之后，我们进行调用。上面的示例代码可以改写为：\n\n```js\nmodule.exports = async function(source) {\n    function timeout(delay) {\n        return new Promise((resolve, reject) => {\n            setTimeout(() => {\n                resolve(source)\n            }, delay)\n        })\n    }\n    const callback = this.async()\n    timeout(1000).then(data => {\n        callback(null, data)\n    })\n}\n```\n\n实际上，对于我们熟悉的 less-loader，翻看其源码，就能发现它的核心是利用 less 这个库来解析 less 代码，less 会返回一个 promise，因此 less-loader 是异步的，其实现正是运用了 this.async() 来完成。\n\n到此，我们了解了 loader 的编写套路，更多细节内容，比如 loader 缓存开关、全程传参 pitch 等用法不再过多讨论，读者可以根据需要进行了解，也欢迎在课程评论区大家一起讨论沟通。\n\n#### 实战案例\n\n工程师想要进阶，一定要“学以致用”，解决实际问题。我们现在来编写一个 path-replace-loader，这个 loader 将允许自定义替换 require 语句中的 base path 为动态指定 path，使用和配置方式为：\n\n```\nmodule.exports = {\n\tmodule: {\n\t\trules: [{\n\t\t\ttest: /\\.js$/,\n\t\t\tloader: &apos;path-replace-loader&apos;,\n\t\t\texclude: /(mode_modules)/,\n\t\t\toptions: {\n\t\t\t\tpath: &apos;ORIGINAL_PATH&apos;,\n\t\t\t\treplacePath: &apos;REPLACE_PATH&apos;\n\t\t\t}\n\t\t}]\n\t}\n}\n```\n\n根据上面所介绍内容，我们给出 path-replace-loader 源码如下：\n\n``` js\nconst fs = require(&apos;fs&apos;)\nconst loaderUtils = require(&apos;loader-utils&apos;)\n\t\nmodule.exports = function(source) {\n\tthis.cacheable && this.cacheable()\n\tconst callback = this.async()\n\tconst options = loaderUtils.getOptions(this)\n\t\n\tif (this.resourcePath.indexOf(options.path) > -1) {\n\t\tconst newPath = this.resourcePath.replace(options.path, options.replacePath)\n\t\n\t\tfs.readFile(newPath, (err, data) => {\n\t\t\tif (err) {\n\t\t\t\tif (err.code === &apos;ENOENT&apos;) return callback(null, source)\n\t\t\t\treturn callback(err)\n\t\t\t}\n\t\n\t\t\tthis.addDependency(newPath)\n\t\t\tcallback(null, data)\n\t\t})\n\t}\n\telse {\n\t\tcallback(null, source)\n\t}\n}\n\t\nmodule.exports.raw = true \n```\n\n这只是一个简单的实例，但是涵盖了 loader 编写的不少内容，我们来简单分析一下：这是一个异步 loader，我们使用了下面，\n\n```js\nconst callback = this.async()\n// ...\ncallback(null, data)\n```\n\n的返回方式。通过：\n\n```js\nconst options = loaderUtils.getOptions(this)\n// ...\nconst newPath = this.resourcePath.replace(options.path, options.replacePath)\n```\n\n获取开发者的配置信息，并与 this.resourcePath（当前资源文件路径）比对，进行路径替换。\n\n对于错误的处理也很简单：如果新的目标路径文件不存在，则返回原路径文件：\n\n```js\nif (err.code === &apos;ENOENT&apos;) return callback(null, source)\n```\n\n其它错误也一并通过 return callback(err) 抛出。\n\n主逻辑使用了 this.addDependency(newPath) 将新的文件加入到 webpack 依赖当中，并返回内容 callback(null, data)。\n\n这个过程并不复杂，同时思路非常清晰，通过这个案例，读者可以根据自身团队需求，编写不同复杂度的 wepback loader，实现不同程度的拓展。\n\n###  <font color=13aa6c>探秘并编写 webpack plugin</font>\n\n除了 webpack loader 这个核心概念以外，webpack plugin 是另一个重要话题。loader 和 plugin 就像 webpack 的双子星，有着共同之处，但是分工却很明晰。\n\n我们反复提到过 webpack **事件流机制**，也就是说在 webpack 构建的生命周期中，会广播许多事件。这时候，开发中注册的各种插件，便可以根据需要监听与自身相关的事件。捕获事件后，在合适的时机通过 webpack 提供的 API 去改变编译输出结果。\n\n因此，我们可以总结出 loader 和 plugin 的**差异**。\n\n- loader 其实就是一个转换器，执行单纯的文件转换操作。\n- plugin 是一个扩展器，它丰富了 webpack 本身，在 loader 过程结束后，webpack 打包的整个过程中，weback plugin 并不直接操作文件，而是基于事件机制工作，监听 webpack 打包过程中的某些事件，见缝插针，修改打包结果。\n\n**究竟应该如何从零开始，编写一个 webpack 插件呢？**\n\n首先我们要清楚当前插件要解决什么问题，根据问题，找到相应的钩子事件，在相关事件中进行操作，改变输出结果。这就需要清楚开发中都有哪些钩子了，下面列举一些常用的，完整内容可以在官网找到：[Compiler 暴露的所有事件钩子](https://webpack.js.org/api/compiler-hooks/)。\n\n我们知道 compiler 对象暴露了和 webpack 整个生命周期相关的钩子，通过如下的方式访问：\n\n```js\n//基本写法\ncompiler.hooks.someHook.tap(...)\n```\n\n例如，如果希望 webpack 在读取 entry 配置完后就执行某项工作，我们可以：\n\n```js\ncompiler.hooks.entryOption.tap(...)\n```\n\n因为名字为 entryOption 的 SyncBailHook 类型 hook，就表明了入口配置信息执行完毕的事件，在相关 tap 函数中我们可以在这个时间节点插入操作。\n\n又如，如果希望在生成的资源输出之前执行某个功能，我们可以：\n\n```js\ncompiler.hooks.emit.tap(...)\n```\n\n因为名字为 emit 的 AsyncSeriesHook 类型 hook，就表明了资源输出前的时间节点。\n\n一个自定义 webpack plugin 的骨架结构就是一个带有 apply 方法的 class（用 prototype 实现同理 CustomPlugin.prototype.apply = function () {...}）：\n\n```js\nclass CustomPlugin {\n    constructor(options) {\n        this.options = options\n    }\n    apply(compiler) {\n        // 相关钩子注册回调\n        compiler.hooks.someHook.tap(&apos;CustomPlugin&apos;, () => {\n            // magic here...\n        })\n        \n        // 打印出此时 compiler 暴露的钩子\n        for(var hook of Object.keys(compiler.hooks)){\n            console.log(hook)\n        }\n    }\n}\n\t\nmodule.exports = customPlugin\n```\n\n除了 compiler 暴露了与 webpack 整体构建生命周期相关的钩子以外，compilation 也暴露了与模块和依赖有关的粒度更小的钩子，读者可以参考：[compilation 暴露的所有事件钩子](https://webpack.js.org/api/compilation-hooks/)，找到合适的时机插入自定义行为。\n\n其实 compilation 是 compiler 生命周期中的一个步骤，使用 compilation 相关钩子的通用写法为：\n\n```js\nclass CustomPlugin {\n    constructor(options) {\n        this.options = options\n    }\n    apply(compiler) {\n        compiler.hooks.compilation.tap(&apos;CustomPlugin&apos;, function(compilation, callback) {\n\t\t    compilation.hooks.someOtherHook.tap(&apos;SomePlugin&apos;,function() {\n\t\t        // some magic here\n\t\t    })\n\t\t})\n    }\n}\n\t\nmodule.exports = customPlugin\n```\n\n最终，我们可以总结一下 webpack 插件的**套路**。\n\n- 定义一个 JavaScript class 函数，或在函数原型（prototype）中定义一个以 compiler 对象为参数的 apply 方法。\n- apply 函数中通过 compiler 插入指定的事件钩子，在钩子回调中拿到 compilation 对象。\n- 使用 compilation 操纵修改 webapack 打包内容。\n\n当然，plugin 也存在异步的情况，一些事件钩子是异步的。相应地，我们可以使用 tapAsync 和 tapPromise 方法来处理：\n\n```js\nclass CustomAsyncPlugin {\n    constructor(options) {\n        this.options = options\n    }\n    apply(compiler) {\n        compiler.hooks.emit.tapAsync(&apos;CustomAsyncPlugin&apos;, function(compilation, callback) {\n\t\t    setTimeout(() => {\n\t\t    \tcallback()\n\t\t    }, 1000)\n\t\t})\n\t\n\t\tcompiler.hooks.emit.tapPromise(&apos;CustomAsyncPlugin&apos;, function(compilation, callback) {\n\t\t    return asyncFun().then(() => {\n\t\t\t\t//...\n\t\t    })\n\t\t})\n    }\n}\n```\n\n#### 实战案例\n\n接下来，我们来编写一个简单的 webpack 插件。相信不少 React 开发者了解：在使用 [create-react-app](https://github.com/facebook/create-react-app) 开发项目时，如果发生错误，会出现 error overlay 提示。我们来开发一个类似的功能，使用如下代码：\n\n```js\nmodule.exports = {\n\t// ...\n\tplugins: [new ErrorOverlayPlugin()],\n\tdevtool: &apos;cheap-module-source-map&apos;,\n\tdevServer: {}\n}\n```\n\n我们借助 errorOverlayMiddleware 中间件来进行错误拦截并展示：\n\n```js\nimport errorOverlayMiddleware fomt &apos;react-dev-utils/errorOverlayMiddleware&apos;\n\t\nclass ErrorOverlayPlugin {\n\tapply(compiler) {\n\t\tconst className = this.constructor.name\n\t\tif (compiler.options.mode !== &apos;development&apos;) return\n\t\n\t\tcompiler.hooks.entryOption.tap(className, (context, entry) => {\n\t\t\tconst chunkPath = require.resolve(&apos;./entry&apos;)\n\t\t\tadjustEntry(entry, chunkPath)\n\t\t}) \n\t\n\t\tcompiler.hooks.afterResolvers.tap(className, ({ options }) => {\n\t\t\tif (options.devServer) {\n\t\t\t\tconst originalBefore = options.devServer.before\n\t\t\t\toption.devServer.before = (app, server) => {\n\t\t\t\t\tif (originalBefore) {\n\t\t\t\t\t\toriginalBefore(app, server)\n\t\t\t\t\t}\n\t\t\t\t\tapp.use(errorOverlayMiddleware())\n\t\t\t\t}\n\t\n\t\t\t}\n\t\t}) \n\t}\n}\n\t\nfunction adjustEntry(entry, chunkPath) {\n\tif (Array.isArray(entry)) {\n\t\tif (!entry.includes(chunkPath)) {\n\t\t\tentry.unshift(chunkPath)\n\t\t}\n\t}\n\telse {\n\t\tObject.keys(entry).forEach(entryName => {\n\t\t\tentry[name] = adjustEntry(entry[entryName], chunkPath)\n\t\t})\n\t}\n}\n\t\nmodule.exports = ErrorOverlayPlugin\n```\n\n参考实现源码，我们发现，编写一个 webpack plugin 确实并不困难，只需要开发者了解相关步骤，熟记相关钩子，并多加尝试即可。\n\n简单分析一下上面代码，在非生产环境下，不打开错误窗口，而是直接返回，以免影响线上体验：\n\n```js\nif (compiler.options.mode !== &apos;development&apos;) return\n```\n\n在 entryOption hook 中，获取开发者配置的 entry 并通过 adjustEntry 方法获取正确的入口模块，该方法支持 entry 配置为 array 和 object 两种形式。在 afterResolvers hook 中，判断开发者是否开启 devServer，并对相关中间件进行调用 app.use(errorOverlayMiddleware())。\n\n实际生产环境当中，webpack pulgin 生态丰富多样，一般已有插件就可以满足大部分开发需求。如果团队结合自身业务需求，自主编写 webpack plugin，进而反哺生态，非常值得鼓励。\n\n#### webpack plugin 开发重点\n\n本节目前为止所介绍的内容已经可以带领大家入门插件开发。学习过程中我们会发现，webpack 插件开发重点在于对 compilation 和 compiler 以及两者对应钩子事件的理解、运用。我们提到 webpack 的事件机制基于 tapable 库，因此想完全理解 webpack 事件和钩子，有必要学习 tapable 。\n\n事实上，tapable 更加复杂而“神通广大”，它除了提供同步和异步类型的钩子以外，又根据执行方式，串行/并行，衍生出 Bail、Waterfall、Loop 多种类型。站在 tapable 等的肩膀上，webpack 插件的开发更加灵活，可扩张性更强。\n\n学习的目的在于应用。相信通过本小节的学习，读者已经能够理解 webpack 开发插件的流程。根据项目需要和业务特点，手握 webpack 插件开发的理论钥匙，在实践中多摸索、多尝试，每个人都一定会有所收获。\n\n### <font color=13aa6c>webpack VS Rollup</font>\n\nRollup 号称下一代打包方案，它的功能和特点非常突出：\n\n- 依赖解析，打包构建\n- 仅支持 ES Next 模块\n- Tree shaking\n\nRollup 凭借其清新且友好的配置，以及强大的功能横空出世，吸睛无数。\n\n可以说，Webpack 算得上目前最流行的打包方案，而 Rollup 是下一代打包方案，两者有何区别？目前业界对两者的定位，可以总结为一句话：**建库使用 Rollup，其他场景使用 webpack。**\n\n为什么这么说呢？还记得我们在前面提的 webpack 打包结果吗？从结果上看，webpack 方案会生成比较多的冗余代码，这对于业务代码来说没什么问题，能保证较强的程序健硕性和语法还原度，兼容性保障更有利。也许开发者会关心代码量多带来的冗余问题，但衡量其优缺点和开发效率性价比，webpack 始终是业务开发的首选；但对于库来说就不一样了，相同的脚本，使用 Rollup 产出，复杂的模块冗余会完全消失。Rollup 通过将代码顺序引入同一个文件来解决模块依赖问题，因此，Rollup 做拆包的话就会有问题，原因是模块完全透明了，而在复杂应用中我们往往需要进行拆包，在库的编写中很少用到这样的功能。\n\n当然，“库使用 Rollup，其他场景使用 webpack”——这不是一个绝对的原则。如果你需要代码拆分（Code Splitting），或者有很多静态资源需要处理，或者你构建的项目需要引入很多 CommonJS 规范的模块，再或者你需要拥有相对更大的社区支持，那么 webpack 是不错的选择。\n\n如果你的代码库基于 ES Next 模块，且希望自己写的代码能够被其他人直接使用，那么，你需要的打包工具可能就是 Rollup 。\n\n我们借用前面小节的代码，来看看经过 Rollup 编译之后的代码会成什么样子。\n\nmain.js：\n\n```js\nimport sayHello from &apos;./hello.js&apos;\nconsole.log(sayHello(&apos;lucas&apos;))\n```\n\nhello.js：\n\n```js\nconst sayHello = name => `hello ${name}`\nexport default sayHello\n```\n\n编译结果非常简单：\n\n```js\nconst sayHello = name => `hello ${name}`\nconsole.log(sayHello(&apos;lucas&apos;))\n```\n\n这与 webpack 的打包产出形成了鲜明差异。这种打包方式，天然支持 tree shaking，我们改写上例，加入一个没有用到的 sayHi 函数：\n\nmain.js：\n\n```js\nimport { sayHello } from &apos;./hello.js&apos;\n\nconsole.log( sayHello( &apos;lucas&apos; ) )\n```\n\nhello.js：\n\n```js\nexport const sayHi = name => `hi ${name}`\n\nexport const sayHello = name => `hello ${name}`\n```\n\n打包结果：\n\n```js\n&apos;use strict&apos;;\n\nconst sayHello = name => `hello ${name}`;\nconsole.log( sayHello( &apos;lucas&apos; ) );\n```\n\n通过顺序引入依赖，非常简单、清晰，并且自动做到了 tree shaking，其中的原理和更多话题我们将在“深入浅出模块化”相关内容继续说明。\n\n### <font color=13aa6c>综合运用</font>\n\n至此，我们对于 webpack 已经有了较为深入的理解。但是，以上实战代码都是些较小型的 demo，综合运用这些知识到底能解决哪些问题呢？\n\n我这里有一个很好的例子。\n\n我们知道，2018 年号称小程序元年。以微信小程序为首，百度智能小程序、支付宝小程序、头条小程序纷纷入局。作为开发人员应该注意到，在带给开发无限红利的同时，由于各平台小程序的开发语法和技术方案不尽相同，因而也带来了巨大的多端开发成本。\n\n如果团队能够实现这样一个脚手架：**以微信小程序为基础，将微信小程序的代码平滑转换为各端小程序，岂不大幅提高开发效率？**\n\n可是技术方案上，应该如何实现呢？受 [cantonjs](https://github.com/cantonjs) 启发，我们团队打造了一款跨多端小程序脚手架，其**基本原理**正是以 webpack 开发架构为基础，对于微信小程序的规范化打包，以及不同平台的差异化编译，主要依靠自定义实现 webpack loader 和 webpack plugin 来填平。\n\n在这套脚手架基础上，开发者可以选择任何一套小程序源代码（基于微信小程序/支付宝小程序/百度小程序）来开发多端小程序。脚手架支持自动编译 wxml 文件（微信小程序）为 axml 文件（支付宝小程序）或 swan 文件（百度小程序），能够转换基础平台 API： wx（微信小程序核心对象） 为 my（支付宝小程序核心对象） 或 swan（百度小程序核心对象），反之亦然。对于个别接口在平台上的天生差异，开发者可以通过 `__WECHAT__`  或 `__ALIPAY__` 或 `__BAIDU__` 来动态处理。\n\n具体细节，我们可以通过 DefinePlugin 这个 webpack 内置插件在 webpack 编译阶段注册全局变量： `__WECHAT__`  或 `__ALIPAY__` 或 `__BAIDU__`。\n\n```js\nnew webpack.DefinePlugin({\n  // Definitions...\n})\n```\n\n通过 webpack loader 使 webpack 能编译或处理 *.wxml 上引用的文件，并将原 App 中的 API 进行转换，使用方式与正常的 webpack 配置 loader 完全相同：\n\n```\n{\n  test: /\\.wxml$/,\n  include: /src/,\n  use: [\n    {\n      loader: &apos;file-loader&apos;,\n      options: {\n        name: &apos;[name].[ext]&apos;,\n        useRelativePath: true,\n        context: resolve(&apos;src&apos;),\n      },\n    },\n    {\n      loader: &apos;mini-program-loader&apos;,\n      options: {\n        root: resolve(&apos;src&apos;),\n        enforceRelativePath: true,\n      },\n    },\n  ],\n}\n```\n\n注意，我们声明 loader 的顺序表明先通过 mini-program-loader 处理，其结果交给 file-loader 处理。mini-program-loader 的实现并不复杂，我们通过 [sax.js](https://www.npmjs.com/package/sax) 解析 wxml （XML 风格）文件，进行 API 转换。sax.js 是解析 XML 或者 HTML 的基础库，正好适用于我们各端小程序的主文档文件（wxml、swan、axml）。\n\n通过 webpack-plugin 插件实现自动分析 ./app.js 入口文件，并智能打包，同时抹平 API 差异。\n\n```\nimport MiniProgramWebpackPlugin from &apos;mini-program-webpack-plugin&apos;\nexport default {\n  // ...configs,\n  plugins: [\n    // ...other,\n    new MiniProgramWebpackPlugin(options)\n  ],\n}\n```\n\n在这两个 loader 和 plugin 的基础上，我们实现的这个脚手架构建，通过 script 脚本，启动不同目标的小程序平台编译：yarn start、yarn start:alipay、yarn start:baidu，同时开发者可以根据自身项目特点，添加 prettier 和 lint 标准等。\n\n到此，一个基于 webpack、webpack loader、webpack plugin 的脚手架综合应用从场景到实现已经简要介绍完毕。\n\n通过这个案例，我们发现 webpack 的能力边界是无穷的，以高级前端工程师为目标的程序员，应该尽最大努力来开发 webpack 的潜能。\n\n### <font color=13aa6c>总结</font>\n\n正如本课程的标题所示：**webpack 工程师 > 前端工程师**。 webpack 要求的不仅仅是“配置工程师”那么简单，其后蕴含的 Node.js 知识、AST 知识、架构设计、代码设计原则等非常值得玩味。我们不应该畏难，社区为我们提供了大量的开箱即用工具，借助这些工具，希望大家能够掌握这方面的知识，并在此基础上运用自如。\n\n课程代码仓库：<a href=\"https://github.com/HOUCe/lucas-gitchat-courses\">https://github.com/HOUCe/lucas-gitchat-courses</a>\n\n### <font color=13aa6c>分享交流</font>\n\n请大家留言分享自己开发实践中「前端工程化」相关的趣事。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后会抽空解答）。**你的分享不仅帮助他人，更会提升自己。**\n\n你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。\n\n>**为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。**","pdfUrl":"","reader":"","duration":"","title":"webpack 工程师和前端工程师（下）","column":"5c91c813968b1d64b1e08fde","isNotification":false,"htmlContent":"<p>上一节中，我们了解了 webpack 对于不同模块化标准的打包结果，分析了其自身的模块化解决方案。但是 webpack 绝不仅仅是一个打包器，它是一个完整的构建工具链。<strong>那么它到底是如何工作的，原理是什么？了解了这些原理，我们又能如何扩展，以解决工作中的实际问题？</strong> 这一节，我们来一探究竟。</p>\n<p>我们再次列出 webpack 主题的知识点：</p>\n<img src=\"https://images.gitbook.cn/e13b8fb0-4ecd-11e9-97d1-9b2c5e38f63d\" width=600>\n<h3><a id=\"font_color13aa6cwebpack_font_6\"></a><font color=13aa6c>webpack 工作基本原理</font></h3>\n<p>通过前文学习，我们知道了 webpack 编译产出，对结果进行分析。“知其然，知其所以然”，在知晓打包结果的基础上，接下来我们尝试分析产出过程，了解 webpack 工作的基本原理。</p>\n<p>webpack 工作流程可以简单总结为下图：</p>\n<img src=\"https://images.gitbook.cn/800e19e0-4eac-11e9-9566-89cb1d9578c6\" width=700>\n<ul>\n<li>首先，webpack 会读取项目中由开发者定义的 webpack.config.js 配置文件，或者从 shell 语句中获得必要的参数。这是 webpack 内部接收业务配置信息的方式。这就完成了配置读取的初步工作。</li>\n<li>接着，实例化所需 webpack 插件，在 webpack 事件流上挂载插件钩子，这样在合适的构建过程中，插件具备了改动产出结果的能力。</li>\n<li>同时，根据配置所定义的入口文件，以入口文件（可以不止有一个）为起始，进行依赖收集：对所有依赖的文件进行编译，这个编译过程依赖 loaders，不同类型文件根据开发者定义的不同 loader 进行解析。编译好的内容使用 acorn 或其它抽象语法树能力，解析生成 AST 静态语法树，分析文件依赖关系，将不同模块化语法（如 require）等替换为 <code>__webpack_require__</code>，即使用 webpack 自己的加载器进行模块化实现。</li>\n<li>上述过程进行完毕后，产出结果，根据开发者配置，将结果打包到相应目录。</li>\n</ul>\n<p>值得一提的是，在这整个打包过程中，<strong>webpack 和插件采用基于事件流的发布订阅模式，监听某些关键过程，在这些环节中执行插件任务</strong>。到最后，所有文件的编译和转化都已经完成，输出最终资源。</p>\n<p>如果深入源码，上述过程用更加专业的术语总结为——模块会经历<strong>加载</strong>（loaded）、<strong>封存</strong>（sealed）、<strong>优化</strong>（optimized）、<strong>分块</strong>（chunked）、<strong>哈希</strong>（hashed）和<strong>重新创建</strong>（restored）这几个经典步骤。在这里，我们了解大体流程即可。</p>\n<p>梳理完 webpack 工作“流水账”，我们还需要在理论上熟悉以下概念。</p>\n<h4><a id=\"_AST_25\"></a>抽象语法树 AST</h4>\n<p>即便大家没有接触过 AST，也应该不是第一次听说这个概念。</p>\n<p>在计算机科学中，抽象语法树（Abstract Syntax Tree，简称 AST），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构和表达。</p>\n<p>之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。比如类似于 if-condition-then 这样的条件跳转语句，可以使用带有两个分支的节点来表示。</p>\n<p>AST 并不会被计算机所识别，更不会被运行，它是对编程语言的一种表达，为代码分析提供了基础。</p>\n<p><strong>webpack 将文件转换成 AST 的目的就是方便开发者提取模块文件中的关键信息。</strong> 这样一来，我们就可以“知晓开发者到底写了什么东西”，也就可以根据这些“写出的东西”，实现分析和扩展。在代码层面，我们可以把 AST 理解为一个 object：</p>\n<pre><code class=\"lang-\">var ast = &apos;AST demo&apos;\n</code></pre>\n<p>这样的语句转换为 AST 就是：</p>\n<pre><div class=\"hljs\"><code class=\"lang-json\">{\n  <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"Program\"</span>,\n  <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-number\">0</span>,\n  <span class=\"hljs-attr\">\"end\"</span>: <span class=\"hljs-number\">20</span>,\n  <span class=\"hljs-attr\">\"body\"</span>: [\n    {\n      <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"VariableDeclaration\"</span>,\n      <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-number\">0</span>,\n      <span class=\"hljs-attr\">\"end\"</span>: <span class=\"hljs-number\">20</span>,\n      <span class=\"hljs-attr\">\"declarations\"</span>: [\n        {\n          <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"VariableDeclarator\"</span>,\n          <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-number\">4</span>,\n          <span class=\"hljs-attr\">\"end\"</span>: <span class=\"hljs-number\">20</span>,\n          <span class=\"hljs-attr\">\"id\"</span>: {\n            <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"Identifier\"</span>,\n            <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-number\">4</span>,\n            <span class=\"hljs-attr\">\"end\"</span>: <span class=\"hljs-number\">7</span>,\n            <span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"ast\"</span>\n          },\n          <span class=\"hljs-attr\">\"init\"</span>: {\n            <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"Literal\"</span>,\n            <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-number\">10</span>,\n            <span class=\"hljs-attr\">\"end\"</span>: <span class=\"hljs-number\">20</span>,\n            <span class=\"hljs-attr\">\"value\"</span>: <span class=\"hljs-string\">\"AST demo\"</span>,\n            <span class=\"hljs-attr\">\"raw\"</span>: <span class=\"hljs-string\">\"&apos;AST demo&apos;\"</span>\n          }\n        }\n      ],\n      <span class=\"hljs-attr\">\"kind\"</span>: <span class=\"hljs-string\">\"var\"</span>\n    }\n  ],\n  <span class=\"hljs-attr\">\"sourceType\"</span>: <span class=\"hljs-string\">\"module\"</span>\n}\n</code></div></pre>\n<p>从中我们可以看出，AST 结果精确地表明了这是一条变量声明语句，语句起始于哪里，赋值结果是什么等信息都被表达出来。</p>\n<p>一个更复杂的例子：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">let</span> tips = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>]\n    \n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">printTips</span>(<span class=\"hljs-params\"></span>) </span>{\n  tips.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">tip, i</span>) =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`Tip <span class=\"hljs-subst\">${i}</span>:`</span> + tip))\n}\n</code></div></pre>\n<p>会转化为：</p>\n<pre><div class=\"hljs\"><code class=\"lang-json\">{\n  <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"Program\"</span>,\n  <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-number\">0</span>,\n  <span class=\"hljs-attr\">\"end\"</span>: <span class=\"hljs-number\">285</span>,\n  <span class=\"hljs-attr\">\"body\"</span>: [\n    {\n      <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"VariableDeclaration\"</span>,\n      <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-number\">179</span>,\n      <span class=\"hljs-attr\">\"end\"</span>: <span class=\"hljs-number\">197</span>,\n      <span class=\"hljs-attr\">\"declarations\"</span>: [\n        {\n          <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"VariableDeclarator\"</span>,\n          <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-number\">183</span>,\n          <span class=\"hljs-attr\">\"end\"</span>: <span class=\"hljs-number\">196</span>,\n          <span class=\"hljs-attr\">\"id\"</span>: {\n            <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"Identifier\"</span>,\n            <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-number\">183</span>,\n            <span class=\"hljs-attr\">\"end\"</span>: <span class=\"hljs-number\">187</span>,\n            <span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"tips\"</span>\n          },\n          <span class=\"hljs-attr\">\"init\"</span>: {\n            <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"ArrayExpression\"</span>,\n            <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-number\">190</span>,\n            <span class=\"hljs-attr\">\"end\"</span>: <span class=\"hljs-number\">196</span>,\n            <span class=\"hljs-attr\">\"elements\"</span>: [\n              {\n                <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"Literal\"</span>,\n                <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-number\">191</span>,\n                <span class=\"hljs-attr\">\"end\"</span>: <span class=\"hljs-number\">192</span>,\n                <span class=\"hljs-attr\">\"value\"</span>: <span class=\"hljs-number\">1</span>,\n                <span class=\"hljs-attr\">\"raw\"</span>: <span class=\"hljs-string\">\"1\"</span>\n              },\n              {\n                <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"Literal\"</span>,\n                <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-number\">194</span>,\n                <span class=\"hljs-attr\">\"end\"</span>: <span class=\"hljs-number\">195</span>,\n                <span class=\"hljs-attr\">\"value\"</span>: <span class=\"hljs-number\">2</span>,\n                <span class=\"hljs-attr\">\"raw\"</span>: <span class=\"hljs-string\">\"2\"</span>\n              }\n            ]\n          }\n        }\n      ],\n      <span class=\"hljs-attr\">\"kind\"</span>: <span class=\"hljs-string\">\"let\"</span>\n    },\n    {\n      <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"FunctionDeclaration\"</span>,\n      <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-number\">199</span>,\n      <span class=\"hljs-attr\">\"end\"</span>: <span class=\"hljs-number\">283</span>,\n      <span class=\"hljs-attr\">\"id\"</span>: {\n        <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"Identifier\"</span>,\n        <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-number\">208</span>,\n        <span class=\"hljs-attr\">\"end\"</span>: <span class=\"hljs-number\">217</span>,\n        <span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"printTips\"</span>\n      },\n      <span class=\"hljs-attr\">\"expression\"</span>: <span class=\"hljs-literal\">false</span>,\n      <span class=\"hljs-attr\">\"generator\"</span>: <span class=\"hljs-literal\">false</span>,\n      <span class=\"hljs-attr\">\"params\"</span>: [],\n      <span class=\"hljs-attr\">\"body\"</span>: {\n        <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"BlockStatement\"</span>,\n        <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-number\">220</span>,\n        <span class=\"hljs-attr\">\"end\"</span>: <span class=\"hljs-number\">283</span>,\n        <span class=\"hljs-attr\">\"body\"</span>: [\n          {\n            <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"ExpressionStatement\"</span>,\n            <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-number\">224</span>,\n            <span class=\"hljs-attr\">\"end\"</span>: <span class=\"hljs-number\">281</span>,\n            <span class=\"hljs-attr\">\"expression\"</span>: {\n              <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"CallExpression\"</span>,\n              <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-number\">224</span>,\n              <span class=\"hljs-attr\">\"end\"</span>: <span class=\"hljs-number\">280</span>,\n              <span class=\"hljs-attr\">\"callee\"</span>: {\n                <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"MemberExpression\"</span>,\n                <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-number\">224</span>,\n                <span class=\"hljs-attr\">\"end\"</span>: <span class=\"hljs-number\">236</span>,\n                <span class=\"hljs-attr\">\"object\"</span>: {\n                  <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"Identifier\"</span>,\n                  <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-number\">224</span>,\n                  <span class=\"hljs-attr\">\"end\"</span>: <span class=\"hljs-number\">228</span>,\n                  <span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"tips\"</span>\n                },\n                <span class=\"hljs-attr\">\"property\"</span>: {\n                  <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"Identifier\"</span>,\n                  <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-number\">229</span>,\n                  <span class=\"hljs-attr\">\"end\"</span>: <span class=\"hljs-number\">236</span>,\n                  <span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"forEach\"</span>\n                },\n                <span class=\"hljs-attr\">\"computed\"</span>: <span class=\"hljs-literal\">false</span>\n              },\n              <span class=\"hljs-attr\">\"arguments\"</span>: [\n                {\n                  <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"ArrowFunctionExpression\"</span>,\n                  <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-number\">237</span>,\n                  <span class=\"hljs-attr\">\"end\"</span>: <span class=\"hljs-number\">279</span>,\n                  <span class=\"hljs-attr\">\"id\"</span>: <span class=\"hljs-literal\">null</span>,\n                  <span class=\"hljs-attr\">\"expression\"</span>: <span class=\"hljs-literal\">true</span>,\n                  <span class=\"hljs-attr\">\"generator\"</span>: <span class=\"hljs-literal\">false</span>,\n                  <span class=\"hljs-attr\">\"params\"</span>: [\n                    {\n                      <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"Identifier\"</span>,\n                      <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-number\">238</span>,\n                      <span class=\"hljs-attr\">\"end\"</span>: <span class=\"hljs-number\">241</span>,\n                      <span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"tip\"</span>\n                    },\n                    {\n                      <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"Identifier\"</span>,\n                      <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-number\">243</span>,\n                      <span class=\"hljs-attr\">\"end\"</span>: <span class=\"hljs-number\">244</span>,\n                      <span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"i\"</span>\n                    }\n                  ],\n                  <span class=\"hljs-attr\">\"body\"</span>: {\n                    <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"CallExpression\"</span>,\n                    <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-number\">249</span>,\n                    <span class=\"hljs-attr\">\"end\"</span>: <span class=\"hljs-number\">279</span>,\n                    <span class=\"hljs-attr\">\"callee\"</span>: {\n                      <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"MemberExpression\"</span>,\n                      <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-number\">249</span>,\n                      <span class=\"hljs-attr\">\"end\"</span>: <span class=\"hljs-number\">260</span>,\n                      <span class=\"hljs-attr\">\"object\"</span>: {\n                        <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"Identifier\"</span>,\n                        <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-number\">249</span>,\n                        <span class=\"hljs-attr\">\"end\"</span>: <span class=\"hljs-number\">256</span>,\n                        <span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"console\"</span>\n                      },\n                      <span class=\"hljs-attr\">\"property\"</span>: {\n                        <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"Identifier\"</span>,\n                        <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-number\">257</span>,\n                        <span class=\"hljs-attr\">\"end\"</span>: <span class=\"hljs-number\">260</span>,\n                        <span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"log\"</span>\n                      },\n                      <span class=\"hljs-attr\">\"computed\"</span>: <span class=\"hljs-literal\">false</span>\n                    },\n                    <span class=\"hljs-attr\">\"arguments\"</span>: [\n                      {\n                        <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"BinaryExpression\"</span>,\n                        <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-number\">261</span>,\n                        <span class=\"hljs-attr\">\"end\"</span>: <span class=\"hljs-number\">278</span>,\n                        <span class=\"hljs-attr\">\"left\"</span>: {\n                          <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"TemplateLiteral\"</span>,\n                          <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-number\">261</span>,\n                          <span class=\"hljs-attr\">\"end\"</span>: <span class=\"hljs-number\">272</span>,\n                          <span class=\"hljs-attr\">\"expressions\"</span>: [\n                            {\n                              <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"Identifier\"</span>,\n                              <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-number\">268</span>,\n                              <span class=\"hljs-attr\">\"end\"</span>: <span class=\"hljs-number\">269</span>,\n                              <span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"i\"</span>\n                            }\n                          ],\n                          <span class=\"hljs-attr\">\"quasis\"</span>: [\n                            {\n                              <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"TemplateElement\"</span>,\n                              <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-number\">262</span>,\n                              <span class=\"hljs-attr\">\"end\"</span>: <span class=\"hljs-number\">266</span>,\n                              <span class=\"hljs-attr\">\"value\"</span>: {\n                                <span class=\"hljs-attr\">\"raw\"</span>: <span class=\"hljs-string\">\"Tip \"</span>,\n                                <span class=\"hljs-attr\">\"cooked\"</span>: <span class=\"hljs-string\">\"Tip \"</span>\n                              },\n                              <span class=\"hljs-attr\">\"tail\"</span>: <span class=\"hljs-literal\">false</span>\n                            },\n                            {\n                              <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"TemplateElement\"</span>,\n                              <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-number\">270</span>,\n                              <span class=\"hljs-attr\">\"end\"</span>: <span class=\"hljs-number\">271</span>,\n                              <span class=\"hljs-attr\">\"value\"</span>: {\n                                <span class=\"hljs-attr\">\"raw\"</span>: <span class=\"hljs-string\">\":\"</span>,\n                                <span class=\"hljs-attr\">\"cooked\"</span>: <span class=\"hljs-string\">\":\"</span>\n                              },\n                              <span class=\"hljs-attr\">\"tail\"</span>: <span class=\"hljs-literal\">true</span>\n                            }\n                          ]\n                        },\n                        <span class=\"hljs-attr\">\"operator\"</span>: <span class=\"hljs-string\">\"+\"</span>,\n                        <span class=\"hljs-attr\">\"right\"</span>: {\n                          <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"Identifier\"</span>,\n                          <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-number\">275</span>,\n                          <span class=\"hljs-attr\">\"end\"</span>: <span class=\"hljs-number\">278</span>,\n                          <span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"tip\"</span>\n                        }\n                      }\n                    ]\n                  }\n                }\n              ]\n            }\n          }\n        ]\n      }\n    }\n  ],\n  <span class=\"hljs-attr\">\"sourceType\"</span>: <span class=\"hljs-string\">\"module\"</span>\n}\n</code></div></pre>\n<p>我们看到，AST 结果除了表达出变量赋值 VariableDeclaration 信息以外，对函数声明 FunctionDeclaration 也做了精确的“解剖”，哪里出现了一个花括号，哪里实现了 API 调用，通过 AST 全部一览无余。</p>\n<p>设想一下，有了这样的语法树，开发者便可以针对源文件进行一些“分析、加工或转换”操作。</p>\n<h4><a id=\"compiler__compilation_294\"></a>compiler 和 compilation</h4>\n<p>compiler 和 compilation 这两个对象是 webpack 核心原理中最重要的概念。它们是理解 webpack 工作原理、loader 和插件工作的基础。</p>\n<ul>\n<li>compiler 对象：它的实例包含了完整的 webpack 配置，全局只有一个 compiler 实例，因此它就像 webpack 的骨架或神经中枢。当插件被实例化的时候，会收到一个 compiler 对象，通过这个对象可以访问 webpack 的内部环境。</li>\n<li>compilation 对象：当 webpack 以开发模式运行时，每当检测到文件变化，一个新的 compilation 对象将被创建。这个对象包含了当前的模块资源、编译生成资源、变化的文件等信息。也就是说，所有构建过程中产生的构建数据都存储在该对象上，它也掌控着构建过程中的每一个环节。该对象也提供了很多事件回调供插件做扩展。</li>\n</ul>\n<p>两者的关系可以通过以下图示说明：</p>\n<img src=\"https://images.gitbook.cn/97a316a0-4eac-11e9-9566-89cb1d9578c6\" width=300>\n<p>webpack 的构建过程是通过 compiler 控制流程，compilation 进行解析。<strong>在开发插件时，我们可以从 compiler 对象中拿到所有和 webpack 主环境相关的内容，包括事件钩子。</strong> 更多信息我们将在下文介绍。</p>\n<p>compiler 对象和 compilation 对象都继承自 tapable，tapable.js 这个库暴露了所有和事件相关的 pub/sub 的方法。webpack 基于事件流的 tapable 库，不仅能保证插件的有序性，还使得整个系统扩展性更好。</p>\n<p>关于 tapable 库的解读我们到这里不再深入，感兴趣的读者可以参加后续讨论和学习后续文章内容。</p>\n<h3><a id=\"font_color13aa6c_webpack_loaderfont_311\"></a><font color=13aa6c>探秘并编写 webpack loader</font></h3>\n<p>熟悉了概念，我们就来进行实战：了解如何编写一个 webpack loader。事实上，在 webpack 中，loader 是魔法真正发生的阶段之一：Babel 将 ES Next 编译成 ES5，sass-loader 将 SCSS/Sass 编译成 CSS 等，都是由相关 loader 或者 plugin 完成的。因此，直观上理解，<strong>loader 就是接受源文件，对源文件进行处理，返回编译后文件</strong>。如图：</p>\n<img src=\"https://images.gitbook.cn/9e70e110-4eac-11e9-9566-89cb1d9578c6\" width=400>\n<p>我们看到一个 loader 秉承单一职责，完成最小单元的文件转换。当然，<strong>一个源文件可能需要经历多步转换才能正常使用</strong>，比如 Sass 文件先通过 sass-loader 输出 CSS，之后将内容交给 css-loader 处理，甚至 css-loader 输出的内容还需要交给 style-loader 处理，转换成通过脚本加载的 JavaScript 代码。如下使用方式：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-built_in\">module</span>.exports = {\n  ...\n  module: {\n    <span class=\"hljs-attr\">rules</span>: [{\n      <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.less$/</span>,\n      <span class=\"hljs-attr\">use</span>: [{\n        <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-string\">&apos;style-loader&apos;</span> <span class=\"hljs-comment\">// 通过 JS 字符串，创建 style node</span>\n      }, {\n        <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-string\">&apos;css-loader&apos;</span> <span class=\"hljs-comment\">// 编译 css 使其符合 CommonJS 规范</span>\n      }, {\n        <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-string\">&apos;less-loader&apos;</span> <span class=\"hljs-comment\">// 编译 less 为 css</span>\n      }]\n    }]\n  }\n}\n</code></div></pre>\n<p>当我们调用多个 loader 串联去转换一个文件时，每个 loader 会链式地顺序执行。webpack 中，在同一文件存在多个匹配 loader 的情况下，遵循以下原则：</p>\n<ul>\n<li>loader 的执行顺序是和配置顺序相反的，即配置的最后一个 loader 最先执行，第一个 loader 最后执行。</li>\n<li>第一个执行的 loader 接收源文件内容作为参数，其他 loader 接收前一个执行的 loader 的返回值作为参数。最后执行的 loader 会返回最终结果。</li>\n</ul>\n<p>如图，对应上面代码：</p>\n<img src=\"https://images.gitbook.cn/a3934570-4eac-11e9-b0b9-2fcbe141d641\" width=600>\n<p>因此，在你开发一个 loader 时，请保持其职责的单一性，只需关心输入和输出。</p>\n<p>不难理解：loader 本质就是函数，其最简单的结构为：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-built_in\">module</span>.exports = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">source</span>)</span>{\n     <span class=\"hljs-comment\">// some magic...</span>\n     <span class=\"hljs-keyword\">return</span> content\n}\n</code></div></pre>\n<p>loader 就是一个基于 CommonJS 规范的函数模块，它接受内容（这个内容可能是源文件也可能是经过其他 loader 处理后的结果），并返回新的内容。</p>\n<p>更进一步，我们知道在配置 webpack 时，对于 loader 可以增加一些配置，比如著名的 babel-loader 的简单配置：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-built_in\">module</span>:{\n    <span class=\"hljs-attr\">rules</span>:[\n        {\n            <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.js$/</span>,\n            <span class=\"hljs-attr\">exclude</span>: <span class=\"hljs-regexp\">/node_modules/</span>, \n            <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-string\">\"babel-loader\"</span>,\n            <span class=\"hljs-attr\">options</span>: {\n\t            <span class=\"hljs-string\">\"plugins\"</span>: [\n\t                <span class=\"hljs-string\">\"dynamic-import-webpack\"</span>\n\t            ]\n\t        }\n        }\n    ]\n}\n</code></div></pre>\n<p>这样一来，上文简单的 loader 写法便不能满足需求了，因为我们除了 source 以外，还需要根据开发者配置的 options 信息进行处理，以输出最后结果。那么如何获取 options 呢？这时候就需要 loader-utils 模块了：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">const</span> loaderUtils = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"loader-utils\"</span>)\n<span class=\"hljs-built_in\">module</span>.exports = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">source</span>) </span>{\n    <span class=\"hljs-comment\">// 获取开发者配置的 options</span>\n    <span class=\"hljs-keyword\">const</span> options = loaderUtils.getOptions(<span class=\"hljs-keyword\">this</span>)\n    <span class=\"hljs-comment\">// some magic...</span>\n    <span class=\"hljs-keyword\">return</span> content\n}\n</code></div></pre>\n<p>另外，对于 loader 返回的内容，在实际开发中，单纯对 content 进行改写并返回也许是不够的。</p>\n<p>比如，我们想对 loader 处理过程中的错误进行捕获，或者又想导出 sourceMap 等信息，该如何做呢？</p>\n<p>这种情况需要用到 loader 中的 this.callback 进行内容的返回。this.callback 可以传入四个参数，分别是：</p>\n<ul>\n<li>error：Error | null，当 loader 出错时向外抛出一个 error</li>\n<li>content：String | Buffer，经过 loader 编译后需要导出的内容</li>\n<li>sourceMap：为方便调试生成的编译后内容的 source map</li>\n<li>ast：本次编译生成的 AST 静态语法树，之后执行的 loader 可以直接使用这个 AST，进而省去重复生成 AST 的过程</li>\n</ul>\n<p>这样，我们的 loader 代码变得更加复杂，同时也能够处理更多样的需求：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-built_in\">module</span>.exports = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">source</span>) </span>{\n    <span class=\"hljs-comment\">// 获取开发者配置的 options</span>\n    <span class=\"hljs-keyword\">const</span> options = loaderUtils.getOptions(<span class=\"hljs-keyword\">this</span>)\n    <span class=\"hljs-comment\">// some magic...</span>\n    <span class=\"hljs-comment\">// return content</span>\n    <span class=\"hljs-keyword\">this</span>.callback(<span class=\"hljs-literal\">null</span>, content)\n}\n</code></div></pre>\n<div style=\"color:#024727;background:#f9f9f9;\"><p style=\"padding:10px\"><strong>注意</strong>　当我们使用 <code>this.callback</code> 返回内容时，该 loader 必须返回 <code>undefined</code>，这样 webpack 就知道该 loader 返回的结果在 <code>this.callback</code> 中，而不是 return 中。</p></div>\n<p>**细心的读者会问，这里的 this 指向谁？**事实上，这个 this 是一个叫 loaderContext 的 loader-runner 特有对象。如果刨根问底，就要细读 webpack loader 部分相关源码了，这并不是我们的主题，感兴趣的读者可以针对 webpack 源码再进行分析。</p>\n<p>默认情况下，webpack 传给 loader 的内容源都是 UTF-8 格式编码的字符串。但请思考 file-loader 这个常用的 loader，它不是处理文本文件，而是处理二进制文件的，这种情况下，我们可以通过：source instanceof Buffer === true 来判断内容源类型：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-built_in\">module</span>.exports = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">source</span>) </span>{\n    source <span class=\"hljs-keyword\">instanceof</span> Buffer === <span class=\"hljs-literal\">true</span>\n    <span class=\"hljs-keyword\">return</span> source\n}\n</code></div></pre>\n<p>如果自定义的 loader 也会返回二进制文件，需要在文件中显式注明：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-built_in\">module</span>.exports.raw = <span class=\"hljs-literal\">true</span>\n</code></div></pre>\n<p>当然，还存在异步 loader 的情况，即对 source 的处理并不能同步完成，这时候使用简单的 async-await 即可：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-built_in\">module</span>.exports = <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">source</span>) </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">timeout</span>(<span class=\"hljs-params\">delay</span>) </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n            setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n                resolve(source)\n            }, delay)\n        })\n    }\n    <span class=\"hljs-keyword\">const</span> content = <span class=\"hljs-keyword\">await</span> timeout(<span class=\"hljs-number\">1000</span>)\n    <span class=\"hljs-keyword\">this</span>.callback(<span class=\"hljs-literal\">null</span>, content)\n}\n</code></div></pre>\n<p>另一种异步 loader 解决方案是使用 webpack 提供的 this.async，调用 this.async 会返回一个 callback Function，在异步完成之后，我们进行调用。上面的示例代码可以改写为：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-built_in\">module</span>.exports = <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">source</span>) </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">timeout</span>(<span class=\"hljs-params\">delay</span>) </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n            setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n                resolve(source)\n            }, delay)\n        })\n    }\n    <span class=\"hljs-keyword\">const</span> callback = <span class=\"hljs-keyword\">this</span>.async()\n    timeout(<span class=\"hljs-number\">1000</span>).then(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> {\n        callback(<span class=\"hljs-literal\">null</span>, data)\n    })\n}\n</code></div></pre>\n<p>实际上，对于我们熟悉的 less-loader，翻看其源码，就能发现它的核心是利用 less 这个库来解析 less 代码，less 会返回一个 promise，因此 less-loader 是异步的，其实现正是运用了 this.async() 来完成。</p>\n<p>到此，我们了解了 loader 的编写套路，更多细节内容，比如 loader 缓存开关、全程传参 pitch 等用法不再过多讨论，读者可以根据需要进行了解，也欢迎在课程评论区大家一起讨论沟通。</p>\n<h4><a id=\"_470\"></a>实战案例</h4>\n<p>工程师想要进阶，一定要“学以致用”，解决实际问题。我们现在来编写一个 path-replace-loader，这个 loader 将允许自定义替换 require 语句中的 base path 为动态指定 path，使用和配置方式为：</p>\n<pre><code class=\"lang-\">module.exports = {\n\tmodule: {\n\t\trules: [{\n\t\t\ttest: /\\.js$/,\n\t\t\tloader: &apos;path-replace-loader&apos;,\n\t\t\texclude: /(mode_modules)/,\n\t\t\toptions: {\n\t\t\t\tpath: &apos;ORIGINAL_PATH&apos;,\n\t\t\t\treplacePath: &apos;REPLACE_PATH&apos;\n\t\t\t}\n\t\t}]\n\t}\n}\n</code></pre>\n<p>根据上面所介绍内容，我们给出 path-replace-loader 源码如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;fs&apos;</span>)\n<span class=\"hljs-keyword\">const</span> loaderUtils = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&apos;loader-utils&apos;</span>)\n\t\n<span class=\"hljs-built_in\">module</span>.exports = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">source</span>) </span>{\n\t<span class=\"hljs-keyword\">this</span>.cacheable &amp;&amp; <span class=\"hljs-keyword\">this</span>.cacheable()\n\t<span class=\"hljs-keyword\">const</span> callback = <span class=\"hljs-keyword\">this</span>.async()\n\t<span class=\"hljs-keyword\">const</span> options = loaderUtils.getOptions(<span class=\"hljs-keyword\">this</span>)\n\t\n\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.resourcePath.indexOf(options.path) &gt; <span class=\"hljs-number\">-1</span>) {\n\t\t<span class=\"hljs-keyword\">const</span> newPath = <span class=\"hljs-keyword\">this</span>.resourcePath.replace(options.path, options.replacePath)\n\t\n\t\tfs.readFile(newPath, (err, data) =&gt; {\n\t\t\t<span class=\"hljs-keyword\">if</span> (err) {\n\t\t\t\t<span class=\"hljs-keyword\">if</span> (err.code === <span class=\"hljs-string\">&apos;ENOENT&apos;</span>) <span class=\"hljs-keyword\">return</span> callback(<span class=\"hljs-literal\">null</span>, source)\n\t\t\t\t<span class=\"hljs-keyword\">return</span> callback(err)\n\t\t\t}\n\t\n\t\t\t<span class=\"hljs-keyword\">this</span>.addDependency(newPath)\n\t\t\tcallback(<span class=\"hljs-literal\">null</span>, data)\n\t\t})\n\t}\n\t<span class=\"hljs-keyword\">else</span> {\n\t\tcallback(<span class=\"hljs-literal\">null</span>, source)\n\t}\n}\n\t\n<span class=\"hljs-built_in\">module</span>.exports.raw = <span class=\"hljs-literal\">true</span> \n</code></div></pre>\n<p>这只是一个简单的实例，但是涵盖了 loader 编写的不少内容，我们来简单分析一下：这是一个异步 loader，我们使用了下面，</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">const</span> callback = <span class=\"hljs-keyword\">this</span>.async()\n<span class=\"hljs-comment\">// ...</span>\ncallback(<span class=\"hljs-literal\">null</span>, data)\n</code></div></pre>\n<p>的返回方式。通过：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">const</span> options = loaderUtils.getOptions(<span class=\"hljs-keyword\">this</span>)\n<span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-keyword\">const</span> newPath = <span class=\"hljs-keyword\">this</span>.resourcePath.replace(options.path, options.replacePath)\n</code></div></pre>\n<p>获取开发者的配置信息，并与 this.resourcePath（当前资源文件路径）比对，进行路径替换。</p>\n<p>对于错误的处理也很简单：如果新的目标路径文件不存在，则返回原路径文件：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">if</span> (err.code === <span class=\"hljs-string\">&apos;ENOENT&apos;</span>) <span class=\"hljs-keyword\">return</span> callback(<span class=\"hljs-literal\">null</span>, source)\n</code></div></pre>\n<p>其它错误也一并通过 return callback(err) 抛出。</p>\n<p>主逻辑使用了 this.addDependency(newPath) 将新的文件加入到 webpack 依赖当中，并返回内容 callback(null, data)。</p>\n<p>这个过程并不复杂，同时思路非常清晰，通过这个案例，读者可以根据自身团队需求，编写不同复杂度的 wepback loader，实现不同程度的拓展。</p>\n<h3><a id=\"font_color13aa6c_webpack_pluginfont_552\"></a><font color=13aa6c>探秘并编写 webpack plugin</font></h3>\n<p>除了 webpack loader 这个核心概念以外，webpack plugin 是另一个重要话题。loader 和 plugin 就像 webpack 的双子星，有着共同之处，但是分工却很明晰。</p>\n<p>我们反复提到过 webpack <strong>事件流机制</strong>，也就是说在 webpack 构建的生命周期中，会广播许多事件。这时候，开发中注册的各种插件，便可以根据需要监听与自身相关的事件。捕获事件后，在合适的时机通过 webpack 提供的 API 去改变编译输出结果。</p>\n<p>因此，我们可以总结出 loader 和 plugin 的<strong>差异</strong>。</p>\n<ul>\n<li>loader 其实就是一个转换器，执行单纯的文件转换操作。</li>\n<li>plugin 是一个扩展器，它丰富了 webpack 本身，在 loader 过程结束后，webpack 打包的整个过程中，weback plugin 并不直接操作文件，而是基于事件机制工作，监听 webpack 打包过程中的某些事件，见缝插针，修改打包结果。</li>\n</ul>\n<p><strong>究竟应该如何从零开始，编写一个 webpack 插件呢？</strong></p>\n<p>首先我们要清楚当前插件要解决什么问题，根据问题，找到相应的钩子事件，在相关事件中进行操作，改变输出结果。这就需要清楚开发中都有哪些钩子了，下面列举一些常用的，完整内容可以在官网找到：<a href=\"https://webpack.js.org/api/compiler-hooks/\" target=\"_blank\">Compiler 暴露的所有事件钩子</a>。</p>\n<p>我们知道 compiler 对象暴露了和 webpack 整个生命周期相关的钩子，通过如下的方式访问：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-comment\">//基本写法</span>\ncompiler.hooks.someHook.tap(...)\n</code></div></pre>\n<p>例如，如果希望 webpack 在读取 entry 配置完后就执行某项工作，我们可以：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\">compiler.hooks.entryOption.tap(...)\n</code></div></pre>\n<p>因为名字为 entryOption 的 SyncBailHook 类型 hook，就表明了入口配置信息执行完毕的事件，在相关 tap 函数中我们可以在这个时间节点插入操作。</p>\n<p>又如，如果希望在生成的资源输出之前执行某个功能，我们可以：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\">compiler.hooks.emit.tap(...)\n</code></div></pre>\n<p>因为名字为 emit 的 AsyncSeriesHook 类型 hook，就表明了资源输出前的时间节点。</p>\n<p>一个自定义 webpack plugin 的骨架结构就是一个带有 apply 方法的 class（用 prototype 实现同理 CustomPlugin.prototype.apply = function () {…}）：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CustomPlugin</span> </span>{\n    <span class=\"hljs-keyword\">constructor</span>(options) {\n        <span class=\"hljs-keyword\">this</span>.options = options\n    }\n    apply(compiler) {\n        <span class=\"hljs-comment\">// 相关钩子注册回调</span>\n        compiler.hooks.someHook.tap(<span class=\"hljs-string\">&apos;CustomPlugin&apos;</span>, () =&gt; {\n            <span class=\"hljs-comment\">// magic here...</span>\n        })\n        \n        <span class=\"hljs-comment\">// 打印出此时 compiler 暴露的钩子</span>\n        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> hook <span class=\"hljs-keyword\">of</span> <span class=\"hljs-built_in\">Object</span>.keys(compiler.hooks)){\n            <span class=\"hljs-built_in\">console</span>.log(hook)\n        }\n    }\n}\n\t\n<span class=\"hljs-built_in\">module</span>.exports = customPlugin\n</code></div></pre>\n<p>除了 compiler 暴露了与 webpack 整体构建生命周期相关的钩子以外，compilation 也暴露了与模块和依赖有关的粒度更小的钩子，读者可以参考：<a href=\"https://webpack.js.org/api/compilation-hooks/\" target=\"_blank\">compilation 暴露的所有事件钩子</a>，找到合适的时机插入自定义行为。</p>\n<p>其实 compilation 是 compiler 生命周期中的一个步骤，使用 compilation 相关钩子的通用写法为：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CustomPlugin</span> </span>{\n    <span class=\"hljs-keyword\">constructor</span>(options) {\n        <span class=\"hljs-keyword\">this</span>.options = options\n    }\n    apply(compiler) {\n        compiler.hooks.compilation.tap(<span class=\"hljs-string\">&apos;CustomPlugin&apos;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">compilation, callback</span>) </span>{\n\t\t    compilation.hooks.someOtherHook.tap(<span class=\"hljs-string\">&apos;SomePlugin&apos;</span>,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n\t\t        <span class=\"hljs-comment\">// some magic here</span>\n\t\t    })\n\t\t})\n    }\n}\n\t\n<span class=\"hljs-built_in\">module</span>.exports = customPlugin\n</code></div></pre>\n<p>最终，我们可以总结一下 webpack 插件的<strong>套路</strong>。</p>\n<ul>\n<li>定义一个 JavaScript class 函数，或在函数原型（prototype）中定义一个以 compiler 对象为参数的 apply 方法。</li>\n<li>apply 函数中通过 compiler 插入指定的事件钩子，在钩子回调中拿到 compilation 对象。</li>\n<li>使用 compilation 操纵修改 webapack 打包内容。</li>\n</ul>\n<p>当然，plugin 也存在异步的情况，一些事件钩子是异步的。相应地，我们可以使用 tapAsync 和 tapPromise 方法来处理：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CustomAsyncPlugin</span> </span>{\n    <span class=\"hljs-keyword\">constructor</span>(options) {\n        <span class=\"hljs-keyword\">this</span>.options = options\n    }\n    apply(compiler) {\n        compiler.hooks.emit.tapAsync(<span class=\"hljs-string\">&apos;CustomAsyncPlugin&apos;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">compilation, callback</span>) </span>{\n\t\t    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n\t\t    \tcallback()\n\t\t    }, <span class=\"hljs-number\">1000</span>)\n\t\t})\n\t\n\t\tcompiler.hooks.emit.tapPromise(<span class=\"hljs-string\">&apos;CustomAsyncPlugin&apos;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">compilation, callback</span>) </span>{\n\t\t    <span class=\"hljs-keyword\">return</span> asyncFun().then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n\t\t\t\t<span class=\"hljs-comment\">//...</span>\n\t\t    })\n\t\t})\n    }\n}\n</code></div></pre>\n<h4><a id=\"_663\"></a>实战案例</h4>\n<p>接下来，我们来编写一个简单的 webpack 插件。相信不少 React 开发者了解：在使用 <a href=\"https://github.com/facebook/create-react-app\" target=\"_blank\">create-react-app</a> 开发项目时，如果发生错误，会出现 error overlay 提示。我们来开发一个类似的功能，使用如下代码：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-built_in\">module</span>.exports = {\n\t<span class=\"hljs-comment\">// ...</span>\n\tplugins: [<span class=\"hljs-keyword\">new</span> ErrorOverlayPlugin()],\n\t<span class=\"hljs-attr\">devtool</span>: <span class=\"hljs-string\">&apos;cheap-module-source-map&apos;</span>,\n\t<span class=\"hljs-attr\">devServer</span>: {}\n}\n</code></div></pre>\n<p>我们借助 errorOverlayMiddleware 中间件来进行错误拦截并展示：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">import</span> errorOverlayMiddleware fomt <span class=\"hljs-string\">&apos;react-dev-utils/errorOverlayMiddleware&apos;</span>\n\t\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ErrorOverlayPlugin</span> </span>{\n\tapply(compiler) {\n\t\t<span class=\"hljs-keyword\">const</span> className = <span class=\"hljs-keyword\">this</span>.constructor.name\n\t\t<span class=\"hljs-keyword\">if</span> (compiler.options.mode !== <span class=\"hljs-string\">&apos;development&apos;</span>) <span class=\"hljs-keyword\">return</span>\n\t\n\t\tcompiler.hooks.entryOption.tap(className, (context, entry) =&gt; {\n\t\t\t<span class=\"hljs-keyword\">const</span> chunkPath = <span class=\"hljs-built_in\">require</span>.resolve(<span class=\"hljs-string\">&apos;./entry&apos;</span>)\n\t\t\tadjustEntry(entry, chunkPath)\n\t\t}) \n\t\n\t\tcompiler.hooks.afterResolvers.tap(className, ({ options }) =&gt; {\n\t\t\t<span class=\"hljs-keyword\">if</span> (options.devServer) {\n\t\t\t\t<span class=\"hljs-keyword\">const</span> originalBefore = options.devServer.before\n\t\t\t\toption.devServer.before = <span class=\"hljs-function\">(<span class=\"hljs-params\">app, server</span>) =&gt;</span> {\n\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (originalBefore) {\n\t\t\t\t\t\toriginalBefore(app, server)\n\t\t\t\t\t}\n\t\t\t\t\tapp.use(errorOverlayMiddleware())\n\t\t\t\t}\n\t\n\t\t\t}\n\t\t}) \n\t}\n}\n\t\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">adjustEntry</span>(<span class=\"hljs-params\">entry, chunkPath</span>) </span>{\n\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Array</span>.isArray(entry)) {\n\t\t<span class=\"hljs-keyword\">if</span> (!entry.includes(chunkPath)) {\n\t\t\tentry.unshift(chunkPath)\n\t\t}\n\t}\n\t<span class=\"hljs-keyword\">else</span> {\n\t\t<span class=\"hljs-built_in\">Object</span>.keys(entry).forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">entryName</span> =&gt;</span> {\n\t\t\tentry[name] = adjustEntry(entry[entryName], chunkPath)\n\t\t})\n\t}\n}\n\t\n<span class=\"hljs-built_in\">module</span>.exports = ErrorOverlayPlugin\n</code></div></pre>\n<p>参考实现源码，我们发现，编写一个 webpack plugin 确实并不困难，只需要开发者了解相关步骤，熟记相关钩子，并多加尝试即可。</p>\n<p>简单分析一下上面代码，在非生产环境下，不打开错误窗口，而是直接返回，以免影响线上体验：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">if</span> (compiler.options.mode !== <span class=\"hljs-string\">&apos;development&apos;</span>) <span class=\"hljs-keyword\">return</span>\n</code></div></pre>\n<p>在 entryOption hook 中，获取开发者配置的 entry 并通过 adjustEntry 方法获取正确的入口模块，该方法支持 entry 配置为 array 和 object 两种形式。在 afterResolvers hook 中，判断开发者是否开启 devServer，并对相关中间件进行调用 app.use(errorOverlayMiddleware())。</p>\n<p>实际生产环境当中，webpack pulgin 生态丰富多样，一般已有插件就可以满足大部分开发需求。如果团队结合自身业务需求，自主编写 webpack plugin，进而反哺生态，非常值得鼓励。</p>\n<h4><a id=\"webpack_plugin__734\"></a>webpack plugin 开发重点</h4>\n<p>本节目前为止所介绍的内容已经可以带领大家入门插件开发。学习过程中我们会发现，webpack 插件开发重点在于对 compilation 和 compiler 以及两者对应钩子事件的理解、运用。我们提到 webpack 的事件机制基于 tapable 库，因此想完全理解 webpack 事件和钩子，有必要学习 tapable 。</p>\n<p>事实上，tapable 更加复杂而“神通广大”，它除了提供同步和异步类型的钩子以外，又根据执行方式，串行/并行，衍生出 Bail、Waterfall、Loop 多种类型。站在 tapable 等的肩膀上，webpack 插件的开发更加灵活，可扩张性更强。</p>\n<p>学习的目的在于应用。相信通过本小节的学习，读者已经能够理解 webpack 开发插件的流程。根据项目需要和业务特点，手握 webpack 插件开发的理论钥匙，在实践中多摸索、多尝试，每个人都一定会有所收获。</p>\n<h3><a id=\"font_color13aa6cwebpack_VS_Rollupfont_742\"></a><font color=13aa6c>webpack VS Rollup</font></h3>\n<p>Rollup 号称下一代打包方案，它的功能和特点非常突出：</p>\n<ul>\n<li>依赖解析，打包构建</li>\n<li>仅支持 ES Next 模块</li>\n<li>Tree shaking</li>\n</ul>\n<p>Rollup 凭借其清新且友好的配置，以及强大的功能横空出世，吸睛无数。</p>\n<p>可以说，Webpack 算得上目前最流行的打包方案，而 Rollup 是下一代打包方案，两者有何区别？目前业界对两者的定位，可以总结为一句话：<strong>建库使用 Rollup，其他场景使用 webpack。</strong></p>\n<p>为什么这么说呢？还记得我们在前面提的 webpack 打包结果吗？从结果上看，webpack 方案会生成比较多的冗余代码，这对于业务代码来说没什么问题，能保证较强的程序健硕性和语法还原度，兼容性保障更有利。也许开发者会关心代码量多带来的冗余问题，但衡量其优缺点和开发效率性价比，webpack 始终是业务开发的首选；但对于库来说就不一样了，相同的脚本，使用 Rollup 产出，复杂的模块冗余会完全消失。Rollup 通过将代码顺序引入同一个文件来解决模块依赖问题，因此，Rollup 做拆包的话就会有问题，原因是模块完全透明了，而在复杂应用中我们往往需要进行拆包，在库的编写中很少用到这样的功能。</p>\n<p>当然，“库使用 Rollup，其他场景使用 webpack”——这不是一个绝对的原则。如果你需要代码拆分（Code Splitting），或者有很多静态资源需要处理，或者你构建的项目需要引入很多 CommonJS 规范的模块，再或者你需要拥有相对更大的社区支持，那么 webpack 是不错的选择。</p>\n<p>如果你的代码库基于 ES Next 模块，且希望自己写的代码能够被其他人直接使用，那么，你需要的打包工具可能就是 Rollup 。</p>\n<p>我们借用前面小节的代码，来看看经过 Rollup 编译之后的代码会成什么样子。</p>\n<p>main.js：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">import</span> sayHello <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&apos;./hello.js&apos;</span>\n<span class=\"hljs-built_in\">console</span>.log(sayHello(<span class=\"hljs-string\">&apos;lucas&apos;</span>))\n</code></div></pre>\n<p>hello.js：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">const</span> sayHello = <span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> <span class=\"hljs-string\">`hello <span class=\"hljs-subst\">${name}</span>`</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> sayHello\n</code></div></pre>\n<p>编译结果非常简单：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">const</span> sayHello = <span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> <span class=\"hljs-string\">`hello <span class=\"hljs-subst\">${name}</span>`</span>\n<span class=\"hljs-built_in\">console</span>.log(sayHello(<span class=\"hljs-string\">&apos;lucas&apos;</span>))\n</code></div></pre>\n<p>这与 webpack 的打包产出形成了鲜明差异。这种打包方式，天然支持 tree shaking，我们改写上例，加入一个没有用到的 sayHi 函数：</p>\n<p>main.js：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">import</span> { sayHello } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&apos;./hello.js&apos;</span>\n\n<span class=\"hljs-built_in\">console</span>.log( sayHello( <span class=\"hljs-string\">&apos;lucas&apos;</span> ) )\n</code></div></pre>\n<p>hello.js：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> sayHi = <span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> <span class=\"hljs-string\">`hi <span class=\"hljs-subst\">${name}</span>`</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> sayHello = <span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> <span class=\"hljs-string\">`hello <span class=\"hljs-subst\">${name}</span>`</span>\n</code></div></pre>\n<p>打包结果：</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-meta\">&apos;use strict&apos;</span>;\n\n<span class=\"hljs-keyword\">const</span> sayHello = <span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> <span class=\"hljs-string\">`hello <span class=\"hljs-subst\">${name}</span>`</span>;\n<span class=\"hljs-built_in\">console</span>.log( sayHello( <span class=\"hljs-string\">&apos;lucas&apos;</span> ) );\n</code></div></pre>\n<p>通过顺序引入依赖，非常简单、清晰，并且自动做到了 tree shaking，其中的原理和更多话题我们将在“深入浅出模块化”相关内容继续说明。</p>\n<h3><a id=\"font_color13aa6cfont_812\"></a><font color=13aa6c>综合运用</font></h3>\n<p>至此，我们对于 webpack 已经有了较为深入的理解。但是，以上实战代码都是些较小型的 demo，综合运用这些知识到底能解决哪些问题呢？</p>\n<p>我这里有一个很好的例子。</p>\n<p>我们知道，2018 年号称小程序元年。以微信小程序为首，百度智能小程序、支付宝小程序、头条小程序纷纷入局。作为开发人员应该注意到，在带给开发无限红利的同时，由于各平台小程序的开发语法和技术方案不尽相同，因而也带来了巨大的多端开发成本。</p>\n<p>如果团队能够实现这样一个脚手架：<strong>以微信小程序为基础，将微信小程序的代码平滑转换为各端小程序，岂不大幅提高开发效率？</strong></p>\n<p>可是技术方案上，应该如何实现呢？受 <a href=\"https://github.com/cantonjs\" target=\"_blank\">cantonjs</a> 启发，我们团队打造了一款跨多端小程序脚手架，其<strong>基本原理</strong>正是以 webpack 开发架构为基础，对于微信小程序的规范化打包，以及不同平台的差异化编译，主要依靠自定义实现 webpack loader 和 webpack plugin 来填平。</p>\n<p>在这套脚手架基础上，开发者可以选择任何一套小程序源代码（基于微信小程序/支付宝小程序/百度小程序）来开发多端小程序。脚手架支持自动编译 wxml 文件（微信小程序）为 axml 文件（支付宝小程序）或 swan 文件（百度小程序），能够转换基础平台 API： wx（微信小程序核心对象） 为 my（支付宝小程序核心对象） 或 swan（百度小程序核心对象），反之亦然。对于个别接口在平台上的天生差异，开发者可以通过 <code>__WECHAT__</code>  或 <code>__ALIPAY__</code> 或 <code>__BAIDU__</code> 来动态处理。</p>\n<p>具体细节，我们可以通过 DefinePlugin 这个 webpack 内置插件在 webpack 编译阶段注册全局变量： <code>__WECHAT__</code>  或 <code>__ALIPAY__</code> 或 <code>__BAIDU__</code>。</p>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">new</span> webpack.DefinePlugin({\n  <span class=\"hljs-comment\">// Definitions...</span>\n})\n</code></div></pre>\n<p>通过 webpack loader 使 webpack 能编译或处理 *.wxml 上引用的文件，并将原 App 中的 API 进行转换，使用方式与正常的 webpack 配置 loader 完全相同：</p>\n<pre><code class=\"lang-\">{\n  test: /\\.wxml$/,\n  include: /src/,\n  use: [\n    {\n      loader: &apos;file-loader&apos;,\n      options: {\n        name: &apos;[name].[ext]&apos;,\n        useRelativePath: true,\n        context: resolve(&apos;src&apos;),\n      },\n    },\n    {\n      loader: &apos;mini-program-loader&apos;,\n      options: {\n        root: resolve(&apos;src&apos;),\n        enforceRelativePath: true,\n      },\n    },\n  ],\n}\n</code></pre>\n<p>注意，我们声明 loader 的顺序表明先通过 mini-program-loader 处理，其结果交给 file-loader 处理。mini-program-loader 的实现并不复杂，我们通过 <a href=\"https://www.npmjs.com/package/sax\" target=\"_blank\">sax.js</a> 解析 wxml （XML 风格）文件，进行 API 转换。sax.js 是解析 XML 或者 HTML 的基础库，正好适用于我们各端小程序的主文档文件（wxml、swan、axml）。</p>\n<p>通过 webpack-plugin 插件实现自动分析 ./app.js 入口文件，并智能打包，同时抹平 API 差异。</p>\n<pre><code class=\"lang-\">import MiniProgramWebpackPlugin from &apos;mini-program-webpack-plugin&apos;\nexport default {\n  // ...configs,\n  plugins: [\n    // ...other,\n    new MiniProgramWebpackPlugin(options)\n  ],\n}\n</code></pre>\n<p>在这两个 loader 和 plugin 的基础上，我们实现的这个脚手架构建，通过 script 脚本，启动不同目标的小程序平台编译：yarn start、yarn start:alipay、yarn start:baidu，同时开发者可以根据自身项目特点，添加 prettier 和 lint 标准等。</p>\n<p>到此，一个基于 webpack、webpack loader、webpack plugin 的脚手架综合应用从场景到实现已经简要介绍完毕。</p>\n<p>通过这个案例，我们发现 webpack 的能力边界是无穷的，以高级前端工程师为目标的程序员，应该尽最大努力来开发 webpack 的潜能。</p>\n<h3><a id=\"font_color13aa6cfont_881\"></a><font color=13aa6c>总结</font></h3>\n<p>正如本课程的标题所示：<strong>webpack 工程师 &gt; 前端工程师</strong>。 webpack 要求的不仅仅是“配置工程师”那么简单，其后蕴含的 Node.js 知识、AST 知识、架构设计、代码设计原则等非常值得玩味。我们不应该畏难，社区为我们提供了大量的开箱即用工具，借助这些工具，希望大家能够掌握这方面的知识，并在此基础上运用自如。</p>\n<p>课程代码仓库：<a href=\"https://github.com/HOUCe/lucas-gitchat-courses\">https://github.com/HOUCe/lucas-gitchat-courses</a></p>\n<h3><a id=\"font_color13aa6cfont_887\"></a><font color=13aa6c>分享交流</font></h3>\n<p>请大家留言分享自己开发实践中「前端工程化」相关的趣事。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后会抽空解答）。<strong>你的分享不仅帮助他人，更会提升自己。</strong></p>\n<p>你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。</p>\n<blockquote>\n<p><strong>为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。</strong></p>\n</blockquote>\n","readingStatistics":1,"createdAt":"2019-03-26T03:24:32.067Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":26,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FoThASW9dVEPMEo9nP-zaOfbKyLZ"},{"_id":"5c99bd37ccb24267c1d01ac7","communication_start_time":null,"type":1,"audioPath":"","abstract":"","content":"通过上一节的学习，我们看到了前端构建工具及其背后蕴含的技术设计。前端工程化包罗万象，本节课，我们将分析项目组织设计的相关话题，包括：\n\n<img src=\"https://images.gitbook.cn/a8f63cd0-4ece-11e9-aba8-d90fcdb25340\" width=500>\n\n接下来，我们通过 2 节内容来学习这个主题。希望结束这个主题后大家可以从更高的视角看待项目管理和代码组织设计。\n\n### <font color=13aa6c>大型前端项目的组织设计</font>\n\n随着业务复杂度的直线上升，前端项目不管是从代码量上，还是从依赖关系上都爆炸式增长。同时，**团队中一般不止有一个业务项目，多个项目之间如何配合，如何维护相互关系？公司自己的公共库版本如何管理？这些话题随着业务扩展，纷纷浮出水面**。一名合格的高级前端工程师，在宏观上必需能妥善处理这些问题。\n\n当然，不是每个开发者都有机会接触项目设计。如果读者没有面对过上述难题，也许并不容易理解这些问题究竟意味着什么。举个例子，团队主业务项目名为：App-project，这个仓库依赖了组件库：Component-lib，因此 App-project 项目的 package.json 会有类似的代码：\n\n```\n{\n\t\"name\": \"App-project\",\n\t\"version\": \"1.0.0\",\n\t\"description\": \"This is our main app project\",\n\t\"main\": \"index.js\",\n\t\"scripts\": {\n\t\t\"test\": \"echo \\\\\"Error: no test specified\\\\\" && exit 1\"\n\t},\n\t\"dependencies\": {\n\t\t\"Component-lib\": \"^1.0.0\"\n\t}\n}\n```\n\n这时新的需求来了，产品经理需要更改 Component-lib 组件库中的 modal 组件样式及交互行为。作为开发者，我们需要切换到 Component-lib 项目，进行相关需求开发，开发完毕后进行测试。这里的测试包括 Component-lib 当中的单元测试，当然也包括在实际项目中进行效果验收。为方便调试，有经验的开发者也许会使用 npm link/yarn link 来开发和调试效果。当确认一切没问题后，我们还需要 npm 发包 Component-lib 项目，并提升版本为 1.0.1。在所有这些都顺利完成的基础上，才能在 App-project 项目中进行升级：\n\n```\n{\n\t//...\n\t\"dependencies\": {\n\t\t\"Component-lib\": \"^1.0.1\"\n\t}\n}\n```\n\n这个过程已经比较复杂了。如果中间环节出现任何纰漏，我们都要重复上述所有步骤。另外，这只是单一依赖关系，现实中 App-project 不可能只依赖 Component-lib。这种项目管理的方式无疑是低效且痛苦的。那么在项目设计哲学上，有更好的方式吗？\n\n#### monorepo 和 multirepo\n\n**答案是肯定的，管理组织代码的方式主要分为两种：**\n\n- multirepo\n- monorepo\n\n顾名思义，multirepo 就是将应用按照模块分别在不同的仓库中进行管理，即上述 App-project 和 Component-lib 项目的管理模式；而 monorepo 就是将应用中所有的模块一股脑全部放在同一个项目中，这样自然就完全规避了前文描述的困扰，不需要单独发包、测试，且所有代码都在一个项目中管理，一同部署上线，在开发阶段能够更早地复现 bug，暴露问题。\n\n这就是项目代码在组织上的不同哲学：**一种倡导分而治之，一种倡导集中管理**。究竟是把鸡蛋放在同一个篮子里，还是倡导多元化，这就要根据团队的风格以及面临的实际场景进行选型。\n\n我试着从 multirepo 和 monorepo 两种处理方式的**弊端说起**，希望给读者更多的参考和建议。\n\n**multirepo 存在以下问题：**\n\n- 开发调试以及版本更新效率低下\n- 团队技术选型分散，不同的库实现风格可能存在较大差异（比如有的库依赖 Vue，有的依赖 React）\n- changelog 梳理困难，issues 管理混乱（对于开源库来说）\n\n**而 monorepo 缺点也非常明显：**\n\n- 库体积超大，目录结构复杂度上升\n- 需要使用维护 monorepo 的工具，这就意味着学习成本比较高\n\n清楚了不同项目组织管理的缺点，我们再来看一下社区上的经典选型案例。\n\nBabel 和 React 都是典型的 monorepo，其 issues 和 pull requests 都集中到唯一的项目中，changelog 可以简单地从一份 commits 列表梳理出来。我们参看 React 项目仓库，从目录结构即可看出其强烈的 monorepo 风格：\n\n```\nreact-16.2.0/\n  packages/\n    react/\n    react-art/\n    react-.../\n```\n\n因此，[react](https://www.npmjs.com/package/react) 和 [react-dom](https://www.npmjs.com/package/react-dom) 在 npm 上是两个不同的库，它们只不过在 React 项目中通过 monorepo 的方式进行管理。至于为什么 react 和 react-dom 是两个包，我把这个问题留给读者。\n\n而著名的 Rollup 目前是 multirepo 方式。对于 monorepo 和 multirepo，选择了 monorepo 的 Babel 贡献了文章：[Why is Babel a monorepo?](https://github.com/babel/babel/blob/master/doc/design/monorepo.md)， 其中提到：\n\n**monorepo 的优势：**\n\n* 所有项目拥有一致的 lint，以及构建、测试、发布流程\n* 不同项目之间容易调试、协作\n* 方便处理 issues\n* 容易初始化开发环境\n* 易于发现 bug\n\n**monorepo 的劣势：**\n\n* 源代码不易理解\n* 项目体积过大\n\n这些分析与我们前文提到的类似。但是，从业内技术发展来看，monorepo 目前越来越受欢迎。了解了 monorepo 的利弊，我们应该如何实现 monorepo 呢？\n\n### <font color=13aa6c>使用 Lerna 实现 monorepo</font>\n\nLerna 是 Babel 管理自身项目并开源的工具，官网对 Lerna 的定位非常简单直接：\n\n> A tool for managing JavaScript projects with multiple packages.\n\n我们来建立一个简单的 demo，首先安装依赖，并创建项目：\n\n```\nmkdir new-monorepo && cd new-monorepo\nnpm init -y\nnpm i -g lerna（有需要的话要 sudo）\ngit init new-monorepo\nlerna init\n```\n\n成功后，Lerna 会在 new-monorepo 项目下自动添加以下三个文件目录：\n\n- packages\n- lerna.json\n- package.json\n\n我们添加第一个项目 module-1：\n\n```\ncd packages\nmkdir module-1\ncd module-1\nnpm init -y\n```\n\n这样，我们在 ./packages 目录下新建了第一个项目：module-1，并在 module-1 中添加了一些依赖，模拟更加真实的场景。同样的方式，建立 module-2 以及 module-3。\n\n此时，读者可以自行观察 new-monorepo 项目下的目录结构为：\n\n```\npackages/\n  module-1/\n    package.json\n  module-2/\n    package.json\n  module-3/\n    package.json\n```\n\n接下来，我们退到主目录下，安装依赖：\n\n```\ncd ..\nlerna bootstrap\n```\n\n关于该命令的作用，官网直述为：\n\n> Bootstrap the packages in the current Lerna repo. Installs all of their dependencies and links any cross-dependencies.\t\n>\n> 也就是说，假设我们在 module-1 项目中添加了依赖 module-2，那么执行 lerna bootstrap 命令后，会在 module-1 项目的 node_modules 下创建软链接直接指向 module-2 目录。也就是说 lerna bootstrap 命令会建立整个项目内子 repo 之间的依赖关系，这种建立方式不是通过“硬安装”，而是通过软链接指向相关依赖。\n\n\nLinux 中关于硬链接和软链接的区别，可以参考文章：[linux 硬链接与软链接](https://www.cnblogs.com/crazylqy/p/5821105.html)。\n\n在正确连接了 Git 远程仓库后，我们可以发布：\n\n```\nlerna publish\n```\n\n这条命令将各个 package 一步步发布到 npm 当中。Lerna 还可以支持自动生成 changelog 等功能。这里我们不再统一介绍。\n\n到这里，你可能觉得 Lerna 还挺简单。但其实里面还是有更多学问，比如 Lerna 支持下面两种模式。\n\n- **Fixed/Locked 模式**\n\nBabel 便采用了这样的模式。这个模式的特点是，开发者执行 lerna publish 后，Lerna 会在 lerna.json 中找到指定 version 版本号。如果这一次发布包含某个项目的更新，那么会自动更新 `version` 版本号。对于各个项目相关联的场景，这样的模式非常有利，任何一个项目大版本升级，其他项目的大版本号也会更新。\n\n- **Independent 模式**\n\n不同于 Fixed/Locked 模式，Independent 模式下，各个项目相互独立。开发者需要独立管理多个包的版本更新。也就是说，我们可以具体到更新每个包的版本。每次发布，Lerna 会配合 Git，检查相关包文件的变动，只发布有改动的 package。\n\n开发者可以根据团队需求进行模式选择。\n\n我们也可以使用 Lerna 安装依赖，该命令可以在项目下的任何文件夹中执行：\n\n```\nlerna add dependencyName\n```\n\nLerna 默认支持 hoist 选项，即默认在 lerna.json 中：\n\n```\n{ bootstrap: { hoist: true } }\n```\n\n这样项目中所有的 package 下 package.json 都会出现 dependencyName 包：\n\n```\n  packages/\n  module-1/\n    package.json(+ dependencyName)\n    node_modules\n  module-2/\n    package.json(+ dependencyName)\n    node_modules\n  module-3/\n    package.json(+ dependencyName)\n    node_modules\n  node_modules\n  \t dependencyName\n```\n\n这种方式，会在父文件夹的 node_modules 中高效安装 dependencyName（Node.js 会向上在祖先文件夹中查找依赖）。对于未开启 hoist 的情况，执行 lerna add 后，需要执行：\n\n```\nlerna bootstrap --hoist\n```\n\n如果我们想有选择地升级某个依赖，比如只想为 module-1 升级 dependencyName 版本，可以使用 scope 参数：\n\n```\nlerna add dependencyName --scope=module-1\n```\n\n这时候 module-1 文件夹下会有一个 node_modules，其中包含了 dependencyName 的最新版本。\n\n### <font color=13aa6c>分析一个项目迁移案例</font>\n\n**接下来，我选取一个正在线上运行的 multirepo 项目，并演示使用 Lerna 将其迁移到 monorepo 的过程**。此案例来自 [mitter.io](http://mitter.io/)，该团队以往一直以 multirepo 的形式维护以下几个项目：\n\n- @mitter-io/core，mitter.io SDK 核心基础库\n- @mitter-io/models，TypeScript models 库\n- @mitter-io/web，Web 端 SDK 应用\n- @mitter-io/react-native，React Native 端 SDK 应用\n- @mitter-io/node，Node.js 端 SDK 应用\n- @mitter-io/react-scl，React.js 组件库\n\n#### 背景介绍\n\n项目使用 TypeScript 和 Rollup 工具，以及 TypeDoc 生成规范化文档。在使用 Lerna 做 monorepo 化之前，这样的技术方案带来的困扰显而易见，我们来分析一下当前技术栈的弊端，以及 monorepo 化能为这些项目带来哪些收益。\n\n- 如果 @mitter-io/core 中出现任何一处改动，其他所有的包都需要升级到 @mitter-io/core 最新版本，不管这些改动是 feature 还是 bug fix，成本都比较大\n- 如果所有这些包能共同分享版本，那么带来的收益也是非常巨大的\n- 这些不同的仓库之间，由于技术栈近似，一些构建脚本大体相同，部署流程也都一致，如果能够将这些脚本统一抽象，也将带来便利\n\n#### 迁移步骤\n\n我们运用 Lerna 构建 monorepo 项目，第一步：\n\n```\nmkdir my-new-monorepo && cd my-new-monorepo\ngit init .\nlerna init\n```\n\n不同于之前的示例，这是从现有项目中导入，因此我们可以使用命令：\n\n```\nlerna import ~/projects/my-single-repo-package-1 --flatten\n```\n\n这行命令不仅可以导入项目，同时也会将已有项目中的 git commit 一并搬迁过来。我们可以放心地在新 monorepo 仓库中使用 git blame 来进行回溯。\n\n如此一来，得到了这样的项目结构：\n\n```\npackages/\n  core/\n  models/\n  node/\n  react-native/\n  web/\nlerna.json\npackage.json\n```\n\n接下来，运行熟悉的：\n\n```\nlerna boostrap\nlerna publish\n```\n\n进行依赖维护和发布。注意并不是每次都需要执行 lerna bootstrap，只需要在第一次切换到项目，安装所有依赖时运行。\n\n对于每一个 package 来说，其 pacakge.json 文件中都有以下雷同的 npm script 声明。\n\n```\n\"scripts\": {\n    ...\n    \"prepare\": \"yarn run build\",\n    \"prepublishOnly\": \"./../../ci-scripts/publish-tsdocs.sh\",\n    ...\n    \"build\": \"tsc --module commonjs && rollup -c rollup.config.ts && typedoc --out docs --target es6 --theme minimal --mode file src\"\n}\n```\n\n受益于 monorepo，所有项目得以集中管理在一个仓库中，这样我们将所有 package 公共的 npm 脚本移到 ./scripts 文件中。在单一的 monorepo 项目里，我们就可以在不同 package 之间共享构建脚本了 。\n\n运行公共脚本时，有时候有必要知道当前运行的项目信息。npm 是能够读取到每个 package.json 信息的。因此，对每个 package，在其 package.json 中添加以下信息：\n\n```\n{\n    \"name\": \"@mitter-io/core\",\n    \"version\": \"0.6.28\",\n    \"repository\": {\n        \"type\": \"git\"\n    }\n}\n```\n\n之后，如下变量都可以被 npm script 使用：\n\n```\nnpm_package_name = @mitter-io/core\nnpm_package_version = 0.6.28\nnpm_package_repository_type = git\n```\n\n#### 流程优化\n\n团队中正常的开发流程是每个程序员新建一个 git branch，通过代码审核之后进行合并。整套流程在 monorepo 架构下变得非常清晰，我们来梳理一下。\n\n- step1：当开发完成后，我们计划进行版本升级，只需要运行：lerna version\n- step2：Lerna 会提供交互式 prompt，对下一版本进行序号升级\n\n```\n\tlerna version --force-publish\n\tlerna notice cli v3.8.1\n\tlerna info current version 0.6.2\n\tlerna info Looking for changed packages since v0.6.2\n\t? Select a new version (currently 0.6.2) (Use arrow keys)\n\t❯ Patch (0.6.3)\n\tMinor (0.7.0)\n\tMajor (1.0.0)\n\tPrepatch (0.6.3-alpha.0)\n\tPreminor (0.7.0-alpha.0)\n\tPremajor (1.0.0-alpha.0)\n\tCustom Prerelease\n\tCustom Version\n```\n\n新版本被选定之后，Lerna 会自动改变每个 package 的版本号，在远程仓库中创建一个新的 tag，并将所有的改动推送到 GitLab 实例当中。\n\n接下来，CI 构建实际上只需要两步：\n\n- Build 构建\n- Publish 发布\n\n构建实际就是运行：\n\n```\nlerna bootstrap\nlerna run build\n```\n\n而发布也不复杂，需要执行：\n\n```\ngit checkout master\nlerna bootstrap\ngit reset --hard\nlerna publish from-package --yes\n```\n\n注意，这里我们使用了 lerna publish from-package，而不是简单的 lerna publish。因为开发者在本地已经运行了 lerna version，这时候再运行 lerna publish 会收到“当前版本已经发布”的提示。而 from-package 参数会告诉 Lerna 发布所有非当前 npm package 版本的项目。\n\n通过这个案例，我们了解了 Lerna 构建 monorepo 的经典套路，Lerna 还封装了更多的 API 来支持更加灵活的 monorepo 的创建，感兴趣的读者可以自行研究，欢迎在评论区留言讨论，或者直接向我提问。个人认为，未来 monorepo 和 multirepo 将会持续并存，每个开发者都应该根据项目特点来进行选择。\n\n到此，我们分析了 multirepo 和 monorepo 方案的各自特点，通过实例和项目迁移了解了如何构建 monorepo 项目。但是，项目组织不光这些内容，下一节我们将讨论依赖关系这一话题。\n\n### <font color=13aa6c>总结</font>\n\nmonorepo 目前来看是一个流行趋势，笔者为项目团队引入了 monorepo 的架构方案之后收益非常明显，我们也是国内最早采用 monorepo 架构的团队之一。\n\n但是这篇课程难以做到面面俱到，并且任何一个项目都有自己的独立性和特殊性，究竟该如何组织调配、生产部署，需要每一个开发者开动脑筋。\n\n比如：monorepo 方式会导致整个项目体积变大，在上线部署时，用时更长，甚至难以忍受。在工程中如何解决这类问题？针对于此，我设计了增量部署构建方案，通过分析项目依赖以及拓扑排序，优化项目编译构建，这里不再多做介绍。\n\n如果对工程化话题格外感兴趣的读者较多，我会专门进行讲解。希望大家一起讨论。 \n\n### <font color=13aa6c>分享交流</font>\n\n请大家留言分享自己开发实践中「项目组织」相关的难忘事件，你可以继续学习下一节等全部完结这个主题之后再分享。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后会抽空解答）。**你的分享不仅帮助他人，更会提升自己。**\n\n同时，欢迎说说自己最想了解的主题，课程内容会根据大家的意见和建议迭代和完善。\n\n>**为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。**","pdfUrl":"","reader":"","duration":"","title":"前端工程化背后的项目组织设计（上）","column":"5c91c813968b1d64b1e08fde","isNotification":false,"htmlContent":"<p>通过上一节的学习，我们看到了前端构建工具及其背后蕴含的技术设计。前端工程化包罗万象，本节课，我们将分析项目组织设计的相关话题，包括：</p>\n<img src=\"https://images.gitbook.cn/a8f63cd0-4ece-11e9-aba8-d90fcdb25340\" width=500>\n<p>接下来，我们通过 2 节内容来学习这个主题。希望结束这个主题后大家可以从更高的视角看待项目管理和代码组织设计。</p>\n<h3><a id=\"font_color13aa6cfont_6\"></a><font color=13aa6c>大型前端项目的组织设计</font></h3>\n<p>随着业务复杂度的直线上升，前端项目不管是从代码量上，还是从依赖关系上都爆炸式增长。同时，<strong>团队中一般不止有一个业务项目，多个项目之间如何配合，如何维护相互关系？公司自己的公共库版本如何管理？这些话题随着业务扩展，纷纷浮出水面</strong>。一名合格的高级前端工程师，在宏观上必需能妥善处理这些问题。</p>\n<p>当然，不是每个开发者都有机会接触项目设计。如果读者没有面对过上述难题，也许并不容易理解这些问题究竟意味着什么。举个例子，团队主业务项目名为：App-project，这个仓库依赖了组件库：Component-lib，因此 App-project 项目的 package.json 会有类似的代码：</p>\n<pre><code class=\"lang-\">{\n\t&quot;name&quot;: &quot;App-project&quot;,\n\t&quot;version&quot;: &quot;1.0.0&quot;,\n\t&quot;description&quot;: &quot;This is our main app project&quot;,\n\t&quot;main&quot;: &quot;index.js&quot;,\n\t&quot;scripts&quot;: {\n\t\t&quot;test&quot;: &quot;echo \\\\&quot;Error: no test specified\\\\&quot; &amp;&amp; exit 1&quot;\n\t},\n\t&quot;dependencies&quot;: {\n\t\t&quot;Component-lib&quot;: &quot;^1.0.0&quot;\n\t}\n}\n</code></pre>\n<p>这时新的需求来了，产品经理需要更改 Component-lib 组件库中的 modal 组件样式及交互行为。作为开发者，我们需要切换到 Component-lib 项目，进行相关需求开发，开发完毕后进行测试。这里的测试包括 Component-lib 当中的单元测试，当然也包括在实际项目中进行效果验收。为方便调试，有经验的开发者也许会使用 npm link/yarn link 来开发和调试效果。当确认一切没问题后，我们还需要 npm 发包 Component-lib 项目，并提升版本为 1.0.1。在所有这些都顺利完成的基础上，才能在 App-project 项目中进行升级：</p>\n<pre><code class=\"lang-\">{\n\t//...\n\t&quot;dependencies&quot;: {\n\t\t&quot;Component-lib&quot;: &quot;^1.0.1&quot;\n\t}\n}\n</code></pre>\n<p>这个过程已经比较复杂了。如果中间环节出现任何纰漏，我们都要重复上述所有步骤。另外，这只是单一依赖关系，现实中 App-project 不可能只依赖 Component-lib。这种项目管理的方式无疑是低效且痛苦的。那么在项目设计哲学上，有更好的方式吗？</p>\n<h4><a id=\"monorepo__multirepo_40\"></a>monorepo 和 multirepo</h4>\n<p><strong>答案是肯定的，管理组织代码的方式主要分为两种：</strong></p>\n<ul>\n<li>multirepo</li>\n<li>monorepo</li>\n</ul>\n<p>顾名思义，multirepo 就是将应用按照模块分别在不同的仓库中进行管理，即上述 App-project 和 Component-lib 项目的管理模式；而 monorepo 就是将应用中所有的模块一股脑全部放在同一个项目中，这样自然就完全规避了前文描述的困扰，不需要单独发包、测试，且所有代码都在一个项目中管理，一同部署上线，在开发阶段能够更早地复现 bug，暴露问题。</p>\n<p>这就是项目代码在组织上的不同哲学：<strong>一种倡导分而治之，一种倡导集中管理</strong>。究竟是把鸡蛋放在同一个篮子里，还是倡导多元化，这就要根据团队的风格以及面临的实际场景进行选型。</p>\n<p>我试着从 multirepo 和 monorepo 两种处理方式的<strong>弊端说起</strong>，希望给读者更多的参考和建议。</p>\n<p><strong>multirepo 存在以下问题：</strong></p>\n<ul>\n<li>开发调试以及版本更新效率低下</li>\n<li>团队技术选型分散，不同的库实现风格可能存在较大差异（比如有的库依赖 Vue，有的依赖 React）</li>\n<li>changelog 梳理困难，issues 管理混乱（对于开源库来说）</li>\n</ul>\n<p><strong>而 monorepo 缺点也非常明显：</strong></p>\n<ul>\n<li>库体积超大，目录结构复杂度上升</li>\n<li>需要使用维护 monorepo 的工具，这就意味着学习成本比较高</li>\n</ul>\n<p>清楚了不同项目组织管理的缺点，我们再来看一下社区上的经典选型案例。</p>\n<p>Babel 和 React 都是典型的 monorepo，其 issues 和 pull requests 都集中到唯一的项目中，changelog 可以简单地从一份 commits 列表梳理出来。我们参看 React 项目仓库，从目录结构即可看出其强烈的 monorepo 风格：</p>\n<pre><code class=\"lang-\">react-16.2.0/\n  packages/\n    react/\n    react-art/\n    react-.../\n</code></pre>\n<p>因此，<a href=\"https://www.npmjs.com/package/react\" target=\"_blank\">react</a> 和 <a href=\"https://www.npmjs.com/package/react-dom\" target=\"_blank\">react-dom</a> 在 npm 上是两个不同的库，它们只不过在 React 项目中通过 monorepo 的方式进行管理。至于为什么 react 和 react-dom 是两个包，我把这个问题留给读者。</p>\n<p>而著名的 Rollup 目前是 multirepo 方式。对于 monorepo 和 multirepo，选择了 monorepo 的 Babel 贡献了文章：<a href=\"https://github.com/babel/babel/blob/master/doc/design/monorepo.md\" target=\"_blank\">Why is Babel a monorepo?</a>， 其中提到：</p>\n<p><strong>monorepo 的优势：</strong></p>\n<ul>\n<li>所有项目拥有一致的 lint，以及构建、测试、发布流程</li>\n<li>不同项目之间容易调试、协作</li>\n<li>方便处理 issues</li>\n<li>容易初始化开发环境</li>\n<li>易于发现 bug</li>\n</ul>\n<p><strong>monorepo 的劣势：</strong></p>\n<ul>\n<li>源代码不易理解</li>\n<li>项目体积过大</li>\n</ul>\n<p>这些分析与我们前文提到的类似。但是，从业内技术发展来看，monorepo 目前越来越受欢迎。了解了 monorepo 的利弊，我们应该如何实现 monorepo 呢？</p>\n<h3><a id=\"font_color13aa6c_Lerna__monorepofont_95\"></a><font color=13aa6c>使用 Lerna 实现 monorepo</font></h3>\n<p>Lerna 是 Babel 管理自身项目并开源的工具，官网对 Lerna 的定位非常简单直接：</p>\n<blockquote>\n<p>A tool for managing JavaScript projects with multiple packages.</p>\n</blockquote>\n<p>我们来建立一个简单的 demo，首先安装依赖，并创建项目：</p>\n<pre><code class=\"lang-\">mkdir new-monorepo &amp;&amp; cd new-monorepo\nnpm init -y\nnpm i -g lerna（有需要的话要 sudo）\ngit init new-monorepo\nlerna init\n</code></pre>\n<p>成功后，Lerna 会在 new-monorepo 项目下自动添加以下三个文件目录：</p>\n<ul>\n<li>packages</li>\n<li>lerna.json</li>\n<li>package.json</li>\n</ul>\n<p>我们添加第一个项目 module-1：</p>\n<pre><code class=\"lang-\">cd packages\nmkdir module-1\ncd module-1\nnpm init -y\n</code></pre>\n<p>这样，我们在 ./packages 目录下新建了第一个项目：module-1，并在 module-1 中添加了一些依赖，模拟更加真实的场景。同样的方式，建立 module-2 以及 module-3。</p>\n<p>此时，读者可以自行观察 new-monorepo 项目下的目录结构为：</p>\n<pre><code class=\"lang-\">packages/\n  module-1/\n    package.json\n  module-2/\n    package.json\n  module-3/\n    package.json\n</code></pre>\n<p>接下来，我们退到主目录下，安装依赖：</p>\n<pre><code class=\"lang-\">cd ..\nlerna bootstrap\n</code></pre>\n<p>关于该命令的作用，官网直述为：</p>\n<blockquote>\n<p>Bootstrap the packages in the current Lerna repo. Installs all of their dependencies and links any cross-dependencies.</p>\n<p>也就是说，假设我们在 module-1 项目中添加了依赖 module-2，那么执行 lerna bootstrap 命令后，会在 module-1 项目的 node_modules 下创建软链接直接指向 module-2 目录。也就是说 lerna bootstrap 命令会建立整个项目内子 repo 之间的依赖关系，这种建立方式不是通过“硬安装”，而是通过软链接指向相关依赖。</p>\n</blockquote>\n<p>Linux 中关于硬链接和软链接的区别，可以参考文章：<a href=\"https://www.cnblogs.com/crazylqy/p/5821105.html\" target=\"_blank\">linux 硬链接与软链接</a>。</p>\n<p>在正确连接了 Git 远程仓库后，我们可以发布：</p>\n<pre><code class=\"lang-\">lerna publish\n</code></pre>\n<p>这条命令将各个 package 一步步发布到 npm 当中。Lerna 还可以支持自动生成 changelog 等功能。这里我们不再统一介绍。</p>\n<p>到这里，你可能觉得 Lerna 还挺简单。但其实里面还是有更多学问，比如 Lerna 支持下面两种模式。</p>\n<ul>\n<li><strong>Fixed/Locked 模式</strong></li>\n</ul>\n<p>Babel 便采用了这样的模式。这个模式的特点是，开发者执行 lerna publish 后，Lerna 会在 lerna.json 中找到指定 version 版本号。如果这一次发布包含某个项目的更新，那么会自动更新 <code>version</code> 版本号。对于各个项目相关联的场景，这样的模式非常有利，任何一个项目大版本升级，其他项目的大版本号也会更新。</p>\n<ul>\n<li><strong>Independent 模式</strong></li>\n</ul>\n<p>不同于 Fixed/Locked 模式，Independent 模式下，各个项目相互独立。开发者需要独立管理多个包的版本更新。也就是说，我们可以具体到更新每个包的版本。每次发布，Lerna 会配合 Git，检查相关包文件的变动，只发布有改动的 package。</p>\n<p>开发者可以根据团队需求进行模式选择。</p>\n<p>我们也可以使用 Lerna 安装依赖，该命令可以在项目下的任何文件夹中执行：</p>\n<pre><code class=\"lang-\">lerna add dependencyName\n</code></pre>\n<p>Lerna 默认支持 hoist 选项，即默认在 lerna.json 中：</p>\n<pre><code class=\"lang-\">{ bootstrap: { hoist: true } }\n</code></pre>\n<p>这样项目中所有的 package 下 package.json 都会出现 dependencyName 包：</p>\n<pre><code class=\"lang-\">  packages/\n  module-1/\n    package.json(+ dependencyName)\n    node_modules\n  module-2/\n    package.json(+ dependencyName)\n    node_modules\n  module-3/\n    package.json(+ dependencyName)\n    node_modules\n  node_modules\n  \t dependencyName\n</code></pre>\n<p>这种方式，会在父文件夹的 node_modules 中高效安装 dependencyName（Node.js 会向上在祖先文件夹中查找依赖）。对于未开启 hoist 的情况，执行 lerna add 后，需要执行：</p>\n<pre><code class=\"lang-\">lerna bootstrap --hoist\n</code></pre>\n<p>如果我们想有选择地升级某个依赖，比如只想为 module-1 升级 dependencyName 版本，可以使用 scope 参数：</p>\n<pre><code class=\"lang-\">lerna add dependencyName --scope=module-1\n</code></pre>\n<p>这时候 module-1 文件夹下会有一个 node_modules，其中包含了 dependencyName 的最新版本。</p>\n<h3><a id=\"font_color13aa6cfont_219\"></a><font color=13aa6c>分析一个项目迁移案例</font></h3>\n<p><strong>接下来，我选取一个正在线上运行的 multirepo 项目，并演示使用 Lerna 将其迁移到 monorepo 的过程</strong>。此案例来自 <a href=\"http://mitter.io/\" target=\"_blank\">mitter.io</a>，该团队以往一直以 multirepo 的形式维护以下几个项目：</p>\n<ul>\n<li>@mitter-io/core，mitter.io SDK 核心基础库</li>\n<li>@mitter-io/models，TypeScript models 库</li>\n<li>@mitter-io/web，Web 端 SDK 应用</li>\n<li>@mitter-io/react-native，React Native 端 SDK 应用</li>\n<li>@mitter-io/node，Node.js 端 SDK 应用</li>\n<li>@mitter-io/react-scl，React.js 组件库</li>\n</ul>\n<h4><a id=\"_230\"></a>背景介绍</h4>\n<p>项目使用 TypeScript 和 Rollup 工具，以及 TypeDoc 生成规范化文档。在使用 Lerna 做 monorepo 化之前，这样的技术方案带来的困扰显而易见，我们来分析一下当前技术栈的弊端，以及 monorepo 化能为这些项目带来哪些收益。</p>\n<ul>\n<li>如果 @mitter-io/core 中出现任何一处改动，其他所有的包都需要升级到 @mitter-io/core 最新版本，不管这些改动是 feature 还是 bug fix，成本都比较大</li>\n<li>如果所有这些包能共同分享版本，那么带来的收益也是非常巨大的</li>\n<li>这些不同的仓库之间，由于技术栈近似，一些构建脚本大体相同，部署流程也都一致，如果能够将这些脚本统一抽象，也将带来便利</li>\n</ul>\n<h4><a id=\"_238\"></a>迁移步骤</h4>\n<p>我们运用 Lerna 构建 monorepo 项目，第一步：</p>\n<pre><code class=\"lang-\">mkdir my-new-monorepo &amp;&amp; cd my-new-monorepo\ngit init .\nlerna init\n</code></pre>\n<p>不同于之前的示例，这是从现有项目中导入，因此我们可以使用命令：</p>\n<pre><code class=\"lang-\">lerna import ~/projects/my-single-repo-package-1 --flatten\n</code></pre>\n<p>这行命令不仅可以导入项目，同时也会将已有项目中的 git commit 一并搬迁过来。我们可以放心地在新 monorepo 仓库中使用 git blame 来进行回溯。</p>\n<p>如此一来，得到了这样的项目结构：</p>\n<pre><code class=\"lang-\">packages/\n  core/\n  models/\n  node/\n  react-native/\n  web/\nlerna.json\npackage.json\n</code></pre>\n<p>接下来，运行熟悉的：</p>\n<pre><code class=\"lang-\">lerna boostrap\nlerna publish\n</code></pre>\n<p>进行依赖维护和发布。注意并不是每次都需要执行 lerna bootstrap，只需要在第一次切换到项目，安装所有依赖时运行。</p>\n<p>对于每一个 package 来说，其 pacakge.json 文件中都有以下雷同的 npm script 声明。</p>\n<pre><code class=\"lang-\">&quot;scripts&quot;: {\n    ...\n    &quot;prepare&quot;: &quot;yarn run build&quot;,\n    &quot;prepublishOnly&quot;: &quot;./../../ci-scripts/publish-tsdocs.sh&quot;,\n    ...\n    &quot;build&quot;: &quot;tsc --module commonjs &amp;&amp; rollup -c rollup.config.ts &amp;&amp; typedoc --out docs --target es6 --theme minimal --mode file src&quot;\n}\n</code></pre>\n<p>受益于 monorepo，所有项目得以集中管理在一个仓库中，这样我们将所有 package 公共的 npm 脚本移到 ./scripts 文件中。在单一的 monorepo 项目里，我们就可以在不同 package 之间共享构建脚本了 。</p>\n<p>运行公共脚本时，有时候有必要知道当前运行的项目信息。npm 是能够读取到每个 package.json 信息的。因此，对每个 package，在其 package.json 中添加以下信息：</p>\n<pre><code class=\"lang-\">{\n    &quot;name&quot;: &quot;@mitter-io/core&quot;,\n    &quot;version&quot;: &quot;0.6.28&quot;,\n    &quot;repository&quot;: {\n        &quot;type&quot;: &quot;git&quot;\n    }\n}\n</code></pre>\n<p>之后，如下变量都可以被 npm script 使用：</p>\n<pre><code class=\"lang-\">npm_package_name = @mitter-io/core\nnpm_package_version = 0.6.28\nnpm_package_repository_type = git\n</code></pre>\n<h4><a id=\"_312\"></a>流程优化</h4>\n<p>团队中正常的开发流程是每个程序员新建一个 git branch，通过代码审核之后进行合并。整套流程在 monorepo 架构下变得非常清晰，我们来梳理一下。</p>\n<ul>\n<li>step1：当开发完成后，我们计划进行版本升级，只需要运行：lerna version</li>\n<li>step2：Lerna 会提供交互式 prompt，对下一版本进行序号升级</li>\n</ul>\n<pre><code class=\"lang-\">\tlerna version --force-publish\n\tlerna notice cli v3.8.1\n\tlerna info current version 0.6.2\n\tlerna info Looking for changed packages since v0.6.2\n\t? Select a new version (currently 0.6.2) (Use arrow keys)\n\t❯ Patch (0.6.3)\n\tMinor (0.7.0)\n\tMajor (1.0.0)\n\tPrepatch (0.6.3-alpha.0)\n\tPreminor (0.7.0-alpha.0)\n\tPremajor (1.0.0-alpha.0)\n\tCustom Prerelease\n\tCustom Version\n</code></pre>\n<p>新版本被选定之后，Lerna 会自动改变每个 package 的版本号，在远程仓库中创建一个新的 tag，并将所有的改动推送到 GitLab 实例当中。</p>\n<p>接下来，CI 构建实际上只需要两步：</p>\n<ul>\n<li>Build 构建</li>\n<li>Publish 发布</li>\n</ul>\n<p>构建实际就是运行：</p>\n<pre><code class=\"lang-\">lerna bootstrap\nlerna run build\n</code></pre>\n<p>而发布也不复杂，需要执行：</p>\n<pre><code class=\"lang-\">git checkout master\nlerna bootstrap\ngit reset --hard\nlerna publish from-package --yes\n</code></pre>\n<p>注意，这里我们使用了 lerna publish from-package，而不是简单的 lerna publish。因为开发者在本地已经运行了 lerna version，这时候再运行 lerna publish 会收到“当前版本已经发布”的提示。而 from-package 参数会告诉 Lerna 发布所有非当前 npm package 版本的项目。</p>\n<p>通过这个案例，我们了解了 Lerna 构建 monorepo 的经典套路，Lerna 还封装了更多的 API 来支持更加灵活的 monorepo 的创建，感兴趣的读者可以自行研究，欢迎在评论区留言讨论，或者直接向我提问。个人认为，未来 monorepo 和 multirepo 将会持续并存，每个开发者都应该根据项目特点来进行选择。</p>\n<p>到此，我们分析了 multirepo 和 monorepo 方案的各自特点，通过实例和项目迁移了解了如何构建 monorepo 项目。但是，项目组织不光这些内容，下一节我们将讨论依赖关系这一话题。</p>\n<h3><a id=\"font_color13aa6cfont_364\"></a><font color=13aa6c>总结</font></h3>\n<p>monorepo 目前来看是一个流行趋势，笔者为项目团队引入了 monorepo 的架构方案之后收益非常明显，我们也是国内最早采用 monorepo 架构的团队之一。</p>\n<p>但是这篇课程难以做到面面俱到，并且任何一个项目都有自己的独立性和特殊性，究竟该如何组织调配、生产部署，需要每一个开发者开动脑筋。</p>\n<p>比如：monorepo 方式会导致整个项目体积变大，在上线部署时，用时更长，甚至难以忍受。在工程中如何解决这类问题？针对于此，我设计了增量部署构建方案，通过分析项目依赖以及拓扑排序，优化项目编译构建，这里不再多做介绍。</p>\n<p>如果对工程化话题格外感兴趣的读者较多，我会专门进行讲解。希望大家一起讨论。</p>\n<h3><a id=\"font_color13aa6cfont_374\"></a><font color=13aa6c>分享交流</font></h3>\n<p>请大家留言分享自己开发实践中「项目组织」相关的难忘事件，你可以继续学习下一节等全部完结这个主题之后再分享。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后会抽空解答）。<strong>你的分享不仅帮助他人，更会提升自己。</strong></p>\n<p>同时，欢迎说说自己最想了解的主题，课程内容会根据大家的意见和建议迭代和完善。</p>\n<blockquote>\n<p><strong>为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。</strong></p>\n</blockquote>\n","readingStatistics":0,"createdAt":"2019-03-26T05:48:39.237Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":27,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FoThASW9dVEPMEo9nP-zaOfbKyLZ"},{"_id":"5c99c246ccb24267c1d01b4e","communication_start_time":null,"type":1,"audioPath":"","abstract":"","content":"承接上一节的内容，本节来继续学习前端工程化中依赖关系相关的内容。在此之前，先回顾一下「项目组织」主题的知识点：\n\n<img src=\"https://images.gitbook.cn/882d8aa0-b7f4-11e9-94c3-45f5496127b0\" width=450>\n\n说到项目中的依赖关系，我们往往会想到使用 yarn/npm 解决依赖问题。依赖关系大体上可以分为：\n\n- 嵌套依赖\n- 扁平依赖\n\n项目中，我们引用了三个包：PackageA、PackageB、PackageC， 它们都依赖了 PackageD 的不同版本。那么在安装时，如果 PackageA、PackageB、PackageC 在各自的 node\\_modules 目录中分别含有 PackageD，那么我们将其理解为嵌套依赖：\n\n```\nPackageA\n\tnode_modules/PackageD@v1.1\nPackageB\n\tnode_modules/PackageD@v1.2\nPackageC\n\tnode_modules/PackageD@v1.3\n```\n\n如果在安装时，先安装了 PackageA，那么 PackageA 依赖的 PackageD 版本成为主版本，它和 PackageA、PackageB、PackageC 一起平级出现，我们认为这是扁平依赖。此时 PackageB、PackageC 各自的 node\\_modules 目录中也含有各自的 PackageD 版本：\n\n```\nPackageA\nPackageD@v1.1\nPackageB\n\tnode_modules/PackageD@v1.2\nPackageC\n\tnode_modules/PackageD@v1.3\n```\n\nnpm 在安装依赖包时，会将依赖包下载到当前的 node\\_modules 目录中。对于嵌套依赖和扁平依赖的话题，npm 给出了不同的处理方案：npm3 以下版本在依赖安装时，非常直接，它会按照包依赖的树形结构下载到本地 node\\_modules 目录中，也就是说，每个包都会将该包的依赖放到当前包所在的 node\\_modules 目录中。\n\n这么做的原因可以理解：它考虑到了包依赖的版本错综复杂的问题，同一个包因为被依赖的关系原因会出现多个版本，保证树形结构的安装能够简化和统一对于包的安装和删除行为。这样能够简单地解决多版本兼容问题，可是也带来了较大的冗余。\n\nnpm3 则采用了扁平结构，但是更加智能。在安装时，按照 package.json 里声明的顺序依次安装包，遇到新的包就把它放在第一级 node\\_modules 目录。后面再进行安装时，如果遇到一级 node_modules 目录已经存在的包，那么会先判断包版本，如果版本一样则跳过安装，否则会按照 npm2 的方式安装在树形目录结构下。\n\nnpm3 这种安装方式只能够**部分解决**问题，比如：项目里依赖模块 PackageA、PackageB、PackageC、PackageD, 其中 PackageC、PackageB 依赖模块 PackageD v2.0，A 依赖模块 PackageD v1.0。那么可能在安装时，先安装了 PackageD v1.0，然后分别在 PackageC、PackageB 树形结构内部分别安装 PackageD v2.0。这也是一定程度的冗余。为了解决这个问题，因此也就有了 npm dedupe 命令。\n\nnpm 和 yarn 的内容足以单独开讲，我们这里不再展开。\n\n另外，为了保证同一个项目中不同团队成员安装的版本依赖相同，我们往往使用 package-lock.json 或 yarn-lock.json 这类文件通过 git 上传以共享。在安装依赖时，依赖版本将会锁定。\n\n这些内容与开发息息相关，但是往往被开发者所忽视。依赖问题说小很小，说复杂却也很复杂，我们再来看一个循环依赖的问题。\n\n### <font color=13aa6c>复杂依赖关系分析和处理</font>\n\n前端项目，安装依赖非常简单：\n\n```\nnpm install / yarn add\n```\n\n安装一时爽，而带来的依赖关系慢慢地会让人头大。依赖关系的复杂性带来的主要副作用有就是**循环依赖**。\n\n这里我们来重点说一下。简单来说，循环依赖就是模块 A 和模块 B 相互引用，在不同的模块化规范下，对于循环依赖的处理不尽相同。\n\nNode.js 中，我们制造一个简单的循环引用场景。\n\n模块 A：\n\n```\nexports.loaded = false\nconst b = require(&apos;./b&apos;)\nmodule.exports = { \n    bWasLoaded: b.loaded, \n    loaded: true \n}\n```\n\n模块 B：\n\n```\nexports.loaded = false\nconst a = require(&apos;./a&apos;)\nmodule.exports = { \n    aWasLoaded: a.loaded, \n    loaded: true \n}\n```\n\n在 index.js 中调用：\n\n```\nconst a = require(&apos;./a&apos;);\nconst b = require(&apos;./b&apos;) \nconsole.log(a)\nconsole.log(b)\n```\n\n这种情况下，并未出现死循环崩溃的现象，而是输出：\n\n```\n{ bWasLoaded: true, loaded: true }\n{ aWasLoaded: false, loaded: true }\n```\n\n**原因是模块加载过程的缓存机制：Node.js 对模块加载进行了缓存**。按照执行顺序，第一次加载 a 时，走到 const b = require(&apos;./b&apos;)，这样直接进入模块 B 当中，此时模块 B 中 const a = require(&apos;./a&apos;)，模块 A 已经被缓存，因此模块 B 返回的结果为：\n\n```\n{\n    aWasLoaded: false,\n    loaded: true\n}\n```\n\n模块 B 加载完成，回到模块 A 中继续执行，模块 A 返回的结果为：\n\n```\n{\n\taWasLoaded: true,\n\tloaded: true\n}\n```\n\n据此分析，我们不难理解最终的打印结果。也可以总结为：\n\n<div style=\"color:#024727;background:#f9f9f9;\"><p style=\"padding:10px\">Node.js，或者 CommonJS 规范，得益于其缓存机制，在遇见循环引用时，程序并不会崩溃。但这样的机制，仍然会有问题：它只会输出已执行部分，对于未执行部分，export 内容为 undefined。</p></div>\n\n**ES 模块化与 CommonJS 规范不同，ES 模块不存在缓存机制，而是动态引用依赖的模块。**\n\n[《Exploring ES6》](http://exploringjs.com/es6/ch_modules.html) 一文中的示例很好地阐明了这样的行为：\n\n```\n//------ a.js ------\nimport {bar} from &apos;b&apos;; // (i)\nexport function foo() {\n    bar(); // (ii)\n}\n\n//------ b.js ------\nimport {foo} from &apos;a&apos;; // (iii)\nexport function bar() {\n    if (Math.random()) {\n        foo(); // (iv)\n    }\n}\n```\n\n这样的代码，如果在 commonJS 规范中：\n\n```\n//------ a.js ------\nvar b = require(&apos;b&apos;);\nfunction foo() {\n    b.bar();\n}\nexports.foo = foo;\n\n//------ b.js ------\nvar a = require(&apos;a&apos;);\nfunction bar() {\n    if (Math.random()) {\n        a.foo();\n    }\n}\nexports.bar = bar;\n```\n\n如果模块 a.js 先被执行，a.js 依赖 b.js，在 b.js 中，因为 a.js 此刻还并没有暴漏出任何内容，因此如果在 b.js 中，对于顶层 a.foo() 的调用，会得到报错。但是如果 a.js 模块执行完毕后，再调用 b.bar()，b.bar() 当中的 a.foo() 可以正常运行。\n\n但是这样的方式的局限性：\n\n如果 a.js 采用 module.exports = function () { ··· } 的方式，那么 b.js 当中的 a 变量在赋值之后不会二次更新。\n\nESM 不会存在这样的局限性。ESM 加载的变量，都是动态引用其所在的模块。只要引用是存在的，代码就能执行。回到：\n\n```\n//------ a.js ------\nimport {bar} from &apos;b&apos;; // (i)\nexport function foo() {\n    bar(); // (ii)\n}\n\n//------ b.js ------\nimport {foo} from &apos;a&apos;; // (iii)\nexport function bar() {\n    if (Math.random()) {\n        foo(); // (iv)\n    }\n}\n```\n\n代码，第 ii 行和第 iv 行，bar 和 foo 都指向原始模块数据的引用。ESM 的设计目的之一就是支持循环引用。\n\n**ES 的设计思想是：尽量静态化，这样在编译时就能确定模块之间的依赖关系。这也是 import 命令一定要出现在模块开头部分的原因。在模块中，import 实际上不会直接执行模块，而是只生成一个引用。在模块内真正引用依赖逻辑时，再到模块里取值**。这样的设计非常有利于 tree shaking 技术的实现，我们在《深入浅出模块化相关话题（含 tree shaking）》课程中继续展开。\n\n在工程实践中，循环引用的出现往往是由设计不合理造成的。如果使用 webpack 进行项目构建，可以使用 webpack 插件 [circular-dependency-plugin](https://www.npmjs.com/package/circular-dependency-plugin) 来帮助检测项目中存在的所有循环依赖。循环依赖这个问题说大不大，说小不小，我们应该尽可能在设计源头规避。\n\n另外复杂的依赖关系还会带来以下等问题：\n\n- 依赖版本不一致\n- 依赖丢失\n\n针对此，需要开发者根据真实情况进行处理，同时，合理使用 npm/yarn 工具，也能起到非常关键的作用。\n\n笔者团队中通过：\n\n```\n\"scripts\": {\n\t// ...\n\t\"analyzeDeps\": \"scripts analyzeDeps\",\n\t\"graph\": \"scripts graph\",\n\t// ...\n}\n```\n\n即\n\n```\nyarn run analyzeDeps\n```\n\n来对依赖进行分析。具体流程是 analyzeDeps 脚本会对依赖版本冲突和依赖丢失的情况进行处理，这个过程依赖 missingDepsAnalyze 和 versionConflictsAnalyze 两个任务：\n\n其中 missingDepsAnalyze 依赖 [depcheck](https://www.npmjs.com/package/depcheck)，depcheck 可以找出哪些依赖是没有用到的，或者对比 package.json 声明中缺少的依赖项。\n\n同时 missingDepsAnalyze 会读取 lerna.json 配置，获得项目中所有 package，接着对所有 package 中的 package.json 进行遍历，检查是否存在相关依赖，如果不存在则自动执行 yarn add XXXX 进行安装。\n\nversionConflictsAnalyze 任务类似，只不过在获得每个 package 的 package.json 中定义的依赖之后，检查同一个依赖是否有重复声明且存在版本不一致的情况。对于版本冲突，采用交互式命令行，让开发者选择正确的版本。\n​\t\n相关代码并不难实现，感兴趣的读者可以在评论区交流或者向我提问，出于隐私原因，这里不再贴出。\n\n### <font color=13aa6c>使用 yarn workspace 管理依赖关系</font>\n\nmonorepo 项目中依赖管理问题值得重视。现在我们来看一下非常流行的 yarn workspace 如何处理这种问题。\n\nworkspace 的定位为：\n\n> It allows you to setup multiple packages in such a way that you only need to run yarn install once to install all of them in a single pass. \n\n翻译过来，workspace 能帮助你更好地管理有多个子 package 的 monorepo。开发者既可以在每个子 package 下使用独立的 package.json 管理依赖，又可以享受一条 yarn 命令安装或者升级所有依赖的便利。\n\n引入 workspace 之后，在根目录执行：\n\n```\nyarn install / yarn updrade XX\n```\n\n所有的依赖都会被安装或者更新。\n\n当然，如果只想更新某一个包内的版本，可以通过以下代码完成：\n\n```\nyarn workspace <workspace-name> upgrade XX\n```\n\n在使用 yarn 的项目中，如果想使用 yarn workspace，我们不需要安装其他的包，只要简单更改 package.json 便可以工作：\n\n```\n// package.json\n{\n  \"private\": true,\n  \"workspaces\": [\"workspace-1\", \"workspace-2\"]\n}\n```\n\n需要注意的是，**如果需要启用 workspace，那么这里的 private 字段必须设置成 true。** 同时 workspaces 这个字段值对应一个数组，数组每一项是个字符串，表示一个 workspace（可以理解为一个 repo）。\n\n接着，我们可以在 workspace-1 和 workspace-2 项目中分别添加 package.json 内容：\n\n```\n{\n  \"name\": \"workspace-1\",\n  \"version\": \"1.0.0\",\n\t\n  \"dependencies\": {\n    \"react\": \"16.2.3\"\n  }\n}\n```\n\n以及：\n\n```\n{\n  \"name\": \"workspace-2\",\n  \"version\": \"1.0.0\",\n\t\n  \"dependencies\": {\n    \"react\": \"16.2.3\",\n    \"workspace-1\": \"1.0.0\"\n  }\n}\n```\n\n执行 yarn install 之后，发现项目根目录下的 node\\_modules 内已经包含所有声明的依赖，且各个子 package 的 node\\_modules 里面不会重复存在依赖，只会有针对根目录下 node\\_modules 中的 React 引用。\n\n我们发现，yarn workspace 跟 Lerna 有很多共同之处，解决的问题也部分重叠。**下面我们对比一下 workspace 和 Lerna。**\n\n- yarn workspace 寄存于 yarn，不需要开发者额外安装工具，同时它的使用也非常简单，只需要在 package.json 中进行相关的配置，不像 Learn 那样提供了大量 API\n- yarn workspace 只能在根目录中引入，不需要在各个子项目中引入\n\n**事实上，Lerna 可以与 workspace 共存，搭配使用能够发挥更大作用。在我们团队中：Lerna 负责版本管理与发布，依靠其强大的 API 和设置，做到灵活细致；workspace 负责依赖管理，整个流程非常清晰。**\n\n在 Lerna 中使用 workspace，首先需要修改 lerna.json 中的设置：\n\n```\n{\n    ...\n    \"npmClient\": \"yarn\",\n    \"useWorkspaces\": true,\n    ...\n}\n```\n\n然后将根目录下的 package.json 中的 workspaces 字段设置为 Lerna 标准 packages 目录：\n\n```\n{\n  ...\n  \"private\": true,\n  \"workspaces\": [\n    \"packages/*\"\n  ],\n  ...\n}\n```\n\n注意：如果我们开启了 workspace 功能，lerna.json 中的 packages 值便不再生效。原因是 Lerna 会将 package.json 中 workspaces 中所设置的 workspaces 数组作为 lerna packages 的路径，也就是各个子 repo 的路径。换句话说，Lerna 会优先使用 package.json 中的 workspaces 字段，在不存在该字段的情况下，再使用 lerna.json 中的 packages 字段。如果未开启 workspace 功能，lerna.json 配置为：\n\n```\n{\n  \"npmClient\": \"yarn\",\n  \"useWorkspaces\": false,\n  \"packages\": [\n    \"packages/11/*\",\n    \"packages/12/*\"\n  ]\n}\n```\n\n根目录下的 package.json 配置为：\n\n```\n{\n\t\"private\": true,\n\t\"workspaces\": [\n\t  \"packages/21/*\",\n\t  \"packages/22/*\",\n\t],\n\t  ...\n}\n```\n\n那么这就意味着使用 yarn 管理的是 package.json 中 workspaces 所对应的项目路径下的依赖：`packages/21/*` 以及 `packages/22/*`。而 Leran 管理的是 lerna.json 中 packages 所对应的 `packages/11/*` 以及 `packages/12/*` 的项目。\n\n### <font color=13aa6c>总结</font>\n\n本节主要抛出了大型前端项目的组织选型问题，着重分析了 monorepo 方案，内容注重实战。对于大型代码库的组织，本节梳理出一条完善的工作流程。找到适合自己团队的风格，是一名合格的开发者所需要具备的技能。\n\n但是关于 npm 和 yarn 以及所牵扯出的依赖问题、monorepo 设计问题仍然将是挑战，其中的话题仍然值得深挖和系统展开。具体工程化项目的代码组织选型和设计，开发者一定要通过动手来理解。在此学习过程中，有任何疑问和想法，都欢迎与我交流，也希望能有更多机会和大家交流。\n\n### <font color=13aa6c>分享交流</font>\n\n请大家留言分享自己开发实践中「项目组织」相关的难忘事件。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空解答）。**你的分享不仅帮助他人，更会提升自己。**\n\n你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。\n\n>**为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。**","pdfUrl":"","reader":"","duration":"","title":"前端工程化背后的项目组织设计（下）","column":"5c91c813968b1d64b1e08fde","isNotification":false,"htmlContent":"<p>承接上一节的内容，本节来继续学习前端工程化中依赖关系相关的内容。在此之前，先回顾一下「项目组织」主题的知识点：</p>\n<img src=\"https://images.gitbook.cn/882d8aa0-b7f4-11e9-94c3-45f5496127b0\" width=450>\n<p>说到项目中的依赖关系，我们往往会想到使用 yarn/npm 解决依赖问题。依赖关系大体上可以分为：</p>\n<ul>\n<li>嵌套依赖</li>\n<li>扁平依赖</li>\n</ul>\n<p>项目中，我们引用了三个包：PackageA、PackageB、PackageC， 它们都依赖了 PackageD 的不同版本。那么在安装时，如果 PackageA、PackageB、PackageC 在各自的 node_modules 目录中分别含有 PackageD，那么我们将其理解为嵌套依赖：</p>\n<pre><code class=\"lang-\">PackageA\n\tnode_modules/PackageD@v1.1\nPackageB\n\tnode_modules/PackageD@v1.2\nPackageC\n\tnode_modules/PackageD@v1.3\n</code></pre>\n<p>如果在安装时，先安装了 PackageA，那么 PackageA 依赖的 PackageD 版本成为主版本，它和 PackageA、PackageB、PackageC 一起平级出现，我们认为这是扁平依赖。此时 PackageB、PackageC 各自的 node_modules 目录中也含有各自的 PackageD 版本：</p>\n<pre><code class=\"lang-\">PackageA\nPackageD@v1.1\nPackageB\n\tnode_modules/PackageD@v1.2\nPackageC\n\tnode_modules/PackageD@v1.3\n</code></pre>\n<p>npm 在安装依赖包时，会将依赖包下载到当前的 node_modules 目录中。对于嵌套依赖和扁平依赖的话题，npm 给出了不同的处理方案：npm3 以下版本在依赖安装时，非常直接，它会按照包依赖的树形结构下载到本地 node_modules 目录中，也就是说，每个包都会将该包的依赖放到当前包所在的 node_modules 目录中。</p>\n<p>这么做的原因可以理解：它考虑到了包依赖的版本错综复杂的问题，同一个包因为被依赖的关系原因会出现多个版本，保证树形结构的安装能够简化和统一对于包的安装和删除行为。这样能够简单地解决多版本兼容问题，可是也带来了较大的冗余。</p>\n<p>npm3 则采用了扁平结构，但是更加智能。在安装时，按照 package.json 里声明的顺序依次安装包，遇到新的包就把它放在第一级 node_modules 目录。后面再进行安装时，如果遇到一级 node_modules 目录已经存在的包，那么会先判断包版本，如果版本一样则跳过安装，否则会按照 npm2 的方式安装在树形目录结构下。</p>\n<p>npm3 这种安装方式只能够<strong>部分解决</strong>问题，比如：项目里依赖模块 PackageA、PackageB、PackageC、PackageD, 其中 PackageC、PackageB 依赖模块 PackageD v2.0，A 依赖模块 PackageD v1.0。那么可能在安装时，先安装了 PackageD v1.0，然后分别在 PackageC、PackageB 树形结构内部分别安装 PackageD v2.0。这也是一定程度的冗余。为了解决这个问题，因此也就有了 npm dedupe 命令。</p>\n<p>npm 和 yarn 的内容足以单独开讲，我们这里不再展开。</p>\n<p>另外，为了保证同一个项目中不同团队成员安装的版本依赖相同，我们往往使用 package-lock.json 或 yarn-lock.json 这类文件通过 git 上传以共享。在安装依赖时，依赖版本将会锁定。</p>\n<p>这些内容与开发息息相关，但是往往被开发者所忽视。依赖问题说小很小，说复杂却也很复杂，我们再来看一个循环依赖的问题。</p>\n<h3><a id=\"font_color13aa6cfont_45\"></a><font color=13aa6c>复杂依赖关系分析和处理</font></h3>\n<p>前端项目，安装依赖非常简单：</p>\n<pre><code class=\"lang-\">npm install / yarn add\n</code></pre>\n<p>安装一时爽，而带来的依赖关系慢慢地会让人头大。依赖关系的复杂性带来的主要副作用有就是<strong>循环依赖</strong>。</p>\n<p>这里我们来重点说一下。简单来说，循环依赖就是模块 A 和模块 B 相互引用，在不同的模块化规范下，对于循环依赖的处理不尽相同。</p>\n<p>Node.js 中，我们制造一个简单的循环引用场景。</p>\n<p>模块 A：</p>\n<pre><code class=\"lang-\">exports.loaded = false\nconst b = require(&apos;./b&apos;)\nmodule.exports = { \n    bWasLoaded: b.loaded, \n    loaded: true \n}\n</code></pre>\n<p>模块 B：</p>\n<pre><code class=\"lang-\">exports.loaded = false\nconst a = require(&apos;./a&apos;)\nmodule.exports = { \n    aWasLoaded: a.loaded, \n    loaded: true \n}\n</code></pre>\n<p>在 index.js 中调用：</p>\n<pre><code class=\"lang-\">const a = require(&apos;./a&apos;);\nconst b = require(&apos;./b&apos;) \nconsole.log(a)\nconsole.log(b)\n</code></pre>\n<p>这种情况下，并未出现死循环崩溃的现象，而是输出：</p>\n<pre><code class=\"lang-\">{ bWasLoaded: true, loaded: true }\n{ aWasLoaded: false, loaded: true }\n</code></pre>\n<p><strong>原因是模块加载过程的缓存机制：Node.js 对模块加载进行了缓存</strong>。按照执行顺序，第一次加载 a 时，走到 const b = require(’./b’)，这样直接进入模块 B 当中，此时模块 B 中 const a = require(’./a’)，模块 A 已经被缓存，因此模块 B 返回的结果为：</p>\n<pre><code class=\"lang-\">{\n    aWasLoaded: false,\n    loaded: true\n}\n</code></pre>\n<p>模块 B 加载完成，回到模块 A 中继续执行，模块 A 返回的结果为：</p>\n<pre><code class=\"lang-\">{\n\taWasLoaded: true,\n\tloaded: true\n}\n</code></pre>\n<p>据此分析，我们不难理解最终的打印结果。也可以总结为：</p>\n<div style=\"color:#024727;background:#f9f9f9;\"><p style=\"padding:10px\">Node.js，或者 CommonJS 规范，得益于其缓存机制，在遇见循环引用时，程序并不会崩溃。但这样的机制，仍然会有问题：它只会输出已执行部分，对于未执行部分，export 内容为 undefined。</p></div>\n<p><strong>ES 模块化与 CommonJS 规范不同，ES 模块不存在缓存机制，而是动态引用依赖的模块。</strong></p>\n<p><a href=\"http://exploringjs.com/es6/ch_modules.html\" target=\"_blank\">《Exploring ES6》</a> 一文中的示例很好地阐明了这样的行为：</p>\n<pre><code class=\"lang-\">//------ a.js ------\nimport {bar} from &apos;b&apos;; // (i)\nexport function foo() {\n    bar(); // (ii)\n}\n\n//------ b.js ------\nimport {foo} from &apos;a&apos;; // (iii)\nexport function bar() {\n    if (Math.random()) {\n        foo(); // (iv)\n    }\n}\n</code></pre>\n<p>这样的代码，如果在 commonJS 规范中：</p>\n<pre><code class=\"lang-\">//------ a.js ------\nvar b = require(&apos;b&apos;);\nfunction foo() {\n    b.bar();\n}\nexports.foo = foo;\n\n//------ b.js ------\nvar a = require(&apos;a&apos;);\nfunction bar() {\n    if (Math.random()) {\n        a.foo();\n    }\n}\nexports.bar = bar;\n</code></pre>\n<p>如果模块 a.js 先被执行，a.js 依赖 b.js，在 b.js 中，因为 a.js 此刻还并没有暴漏出任何内容，因此如果在 b.js 中，对于顶层 a.foo() 的调用，会得到报错。但是如果 a.js 模块执行完毕后，再调用 b.bar()，b.bar() 当中的 a.foo() 可以正常运行。</p>\n<p>但是这样的方式的局限性：</p>\n<p>如果 a.js 采用 module.exports = function () { ··· } 的方式，那么 b.js 当中的 a 变量在赋值之后不会二次更新。</p>\n<p>ESM 不会存在这样的局限性。ESM 加载的变量，都是动态引用其所在的模块。只要引用是存在的，代码就能执行。回到：</p>\n<pre><code class=\"lang-\">//------ a.js ------\nimport {bar} from &apos;b&apos;; // (i)\nexport function foo() {\n    bar(); // (ii)\n}\n\n//------ b.js ------\nimport {foo} from &apos;a&apos;; // (iii)\nexport function bar() {\n    if (Math.random()) {\n        foo(); // (iv)\n    }\n}\n</code></pre>\n<p>代码，第 ii 行和第 iv 行，bar 和 foo 都指向原始模块数据的引用。ESM 的设计目的之一就是支持循环引用。</p>\n<p><strong>ES 的设计思想是：尽量静态化，这样在编译时就能确定模块之间的依赖关系。这也是 import 命令一定要出现在模块开头部分的原因。在模块中，import 实际上不会直接执行模块，而是只生成一个引用。在模块内真正引用依赖逻辑时，再到模块里取值</strong>。这样的设计非常有利于 tree shaking 技术的实现，我们在《深入浅出模块化相关话题（含 tree shaking）》课程中继续展开。</p>\n<p>在工程实践中，循环引用的出现往往是由设计不合理造成的。如果使用 webpack 进行项目构建，可以使用 webpack 插件 <a href=\"https://www.npmjs.com/package/circular-dependency-plugin\" target=\"_blank\">circular-dependency-plugin</a> 来帮助检测项目中存在的所有循环依赖。循环依赖这个问题说大不大，说小不小，我们应该尽可能在设计源头规避。</p>\n<p>另外复杂的依赖关系还会带来以下等问题：</p>\n<ul>\n<li>依赖版本不一致</li>\n<li>依赖丢失</li>\n</ul>\n<p>针对此，需要开发者根据真实情况进行处理，同时，合理使用 npm/yarn 工具，也能起到非常关键的作用。</p>\n<p>笔者团队中通过：</p>\n<pre><code class=\"lang-\">&quot;scripts&quot;: {\n\t// ...\n\t&quot;analyzeDeps&quot;: &quot;scripts analyzeDeps&quot;,\n\t&quot;graph&quot;: &quot;scripts graph&quot;,\n\t// ...\n}\n</code></pre>\n<p>即</p>\n<pre><code class=\"lang-\">yarn run analyzeDeps\n</code></pre>\n<p>来对依赖进行分析。具体流程是 analyzeDeps 脚本会对依赖版本冲突和依赖丢失的情况进行处理，这个过程依赖 missingDepsAnalyze 和 versionConflictsAnalyze 两个任务：</p>\n<p>其中 missingDepsAnalyze 依赖 <a href=\"https://www.npmjs.com/package/depcheck\" target=\"_blank\">depcheck</a>，depcheck 可以找出哪些依赖是没有用到的，或者对比 package.json 声明中缺少的依赖项。</p>\n<p>同时 missingDepsAnalyze 会读取 lerna.json 配置，获得项目中所有 package，接着对所有 package 中的 package.json 进行遍历，检查是否存在相关依赖，如果不存在则自动执行 yarn add XXXX 进行安装。</p>\n<p>versionConflictsAnalyze 任务类似，只不过在获得每个 package 的 package.json 中定义的依赖之后，检查同一个依赖是否有重复声明且存在版本不一致的情况。对于版本冲突，采用交互式命令行，让开发者选择正确的版本。<br />\n​\t<br />\n相关代码并不难实现，感兴趣的读者可以在评论区交流或者向我提问，出于隐私原因，这里不再贴出。</p>\n<h3><a id=\"font_color13aa6c_yarn_workspace_font_223\"></a><font color=13aa6c>使用 yarn workspace 管理依赖关系</font></h3>\n<p>monorepo 项目中依赖管理问题值得重视。现在我们来看一下非常流行的 yarn workspace 如何处理这种问题。</p>\n<p>workspace 的定位为：</p>\n<blockquote>\n<p>It allows you to setup multiple packages in such a way that you only need to run yarn install once to install all of them in a single pass.</p>\n</blockquote>\n<p>翻译过来，workspace 能帮助你更好地管理有多个子 package 的 monorepo。开发者既可以在每个子 package 下使用独立的 package.json 管理依赖，又可以享受一条 yarn 命令安装或者升级所有依赖的便利。</p>\n<p>引入 workspace 之后，在根目录执行：</p>\n<pre><code class=\"lang-\">yarn install / yarn updrade XX\n</code></pre>\n<p>所有的依赖都会被安装或者更新。</p>\n<p>当然，如果只想更新某一个包内的版本，可以通过以下代码完成：</p>\n<pre><code class=\"lang-\">yarn workspace &lt;workspace-name&gt; upgrade XX\n</code></pre>\n<p>在使用 yarn 的项目中，如果想使用 yarn workspace，我们不需要安装其他的包，只要简单更改 package.json 便可以工作：</p>\n<pre><code class=\"lang-\">// package.json\n{\n  &quot;private&quot;: true,\n  &quot;workspaces&quot;: [&quot;workspace-1&quot;, &quot;workspace-2&quot;]\n}\n</code></pre>\n<p>需要注意的是，<strong>如果需要启用 workspace，那么这里的 private 字段必须设置成 true。</strong> 同时 workspaces 这个字段值对应一个数组，数组每一项是个字符串，表示一个 workspace（可以理解为一个 repo）。</p>\n<p>接着，我们可以在 workspace-1 和 workspace-2 项目中分别添加 package.json 内容：</p>\n<pre><code class=\"lang-\">{\n  &quot;name&quot;: &quot;workspace-1&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n\t\n  &quot;dependencies&quot;: {\n    &quot;react&quot;: &quot;16.2.3&quot;\n  }\n}\n</code></pre>\n<p>以及：</p>\n<pre><code class=\"lang-\">{\n  &quot;name&quot;: &quot;workspace-2&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n\t\n  &quot;dependencies&quot;: {\n    &quot;react&quot;: &quot;16.2.3&quot;,\n    &quot;workspace-1&quot;: &quot;1.0.0&quot;\n  }\n}\n</code></pre>\n<p>执行 yarn install 之后，发现项目根目录下的 node_modules 内已经包含所有声明的依赖，且各个子 package 的 node_modules 里面不会重复存在依赖，只会有针对根目录下 node_modules 中的 React 引用。</p>\n<p>我们发现，yarn workspace 跟 Lerna 有很多共同之处，解决的问题也部分重叠。<strong>下面我们对比一下 workspace 和 Lerna。</strong></p>\n<ul>\n<li>yarn workspace 寄存于 yarn，不需要开发者额外安装工具，同时它的使用也非常简单，只需要在 package.json 中进行相关的配置，不像 Learn 那样提供了大量 API</li>\n<li>yarn workspace 只能在根目录中引入，不需要在各个子项目中引入</li>\n</ul>\n<p><strong>事实上，Lerna 可以与 workspace 共存，搭配使用能够发挥更大作用。在我们团队中：Lerna 负责版本管理与发布，依靠其强大的 API 和设置，做到灵活细致；workspace 负责依赖管理，整个流程非常清晰。</strong></p>\n<p>在 Lerna 中使用 workspace，首先需要修改 lerna.json 中的设置：</p>\n<pre><code class=\"lang-\">{\n    ...\n    &quot;npmClient&quot;: &quot;yarn&quot;,\n    &quot;useWorkspaces&quot;: true,\n    ...\n}\n</code></pre>\n<p>然后将根目录下的 package.json 中的 workspaces 字段设置为 Lerna 标准 packages 目录：</p>\n<pre><code class=\"lang-\">{\n  ...\n  &quot;private&quot;: true,\n  &quot;workspaces&quot;: [\n    &quot;packages/*&quot;\n  ],\n  ...\n}\n</code></pre>\n<p>注意：如果我们开启了 workspace 功能，lerna.json 中的 packages 值便不再生效。原因是 Lerna 会将 package.json 中 workspaces 中所设置的 workspaces 数组作为 lerna packages 的路径，也就是各个子 repo 的路径。换句话说，Lerna 会优先使用 package.json 中的 workspaces 字段，在不存在该字段的情况下，再使用 lerna.json 中的 packages 字段。如果未开启 workspace 功能，lerna.json 配置为：</p>\n<pre><code class=\"lang-\">{\n  &quot;npmClient&quot;: &quot;yarn&quot;,\n  &quot;useWorkspaces&quot;: false,\n  &quot;packages&quot;: [\n    &quot;packages/11/*&quot;,\n    &quot;packages/12/*&quot;\n  ]\n}\n</code></pre>\n<p>根目录下的 package.json 配置为：</p>\n<pre><code class=\"lang-\">{\n\t&quot;private&quot;: true,\n\t&quot;workspaces&quot;: [\n\t  &quot;packages/21/*&quot;,\n\t  &quot;packages/22/*&quot;,\n\t],\n\t  ...\n}\n</code></pre>\n<p>那么这就意味着使用 yarn 管理的是 package.json 中 workspaces 所对应的项目路径下的依赖：<code>packages/21/*</code> 以及 <code>packages/22/*</code>。而 Leran 管理的是 lerna.json 中 packages 所对应的 <code>packages/11/*</code> 以及 <code>packages/12/*</code> 的项目。</p>\n<h3><a id=\"font_color13aa6cfont_347\"></a><font color=13aa6c>总结</font></h3>\n<p>本节主要抛出了大型前端项目的组织选型问题，着重分析了 monorepo 方案，内容注重实战。对于大型代码库的组织，本节梳理出一条完善的工作流程。找到适合自己团队的风格，是一名合格的开发者所需要具备的技能。</p>\n<p>但是关于 npm 和 yarn 以及所牵扯出的依赖问题、monorepo 设计问题仍然将是挑战，其中的话题仍然值得深挖和系统展开。具体工程化项目的代码组织选型和设计，开发者一定要通过动手来理解。在此学习过程中，有任何疑问和想法，都欢迎与我交流，也希望能有更多机会和大家交流。</p>\n<h3><a id=\"font_color13aa6cfont_353\"></a><font color=13aa6c>分享交流</font></h3>\n<p>请大家留言分享自己开发实践中「项目组织」相关的难忘事件。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空解答）。<strong>你的分享不仅帮助他人，更会提升自己。</strong></p>\n<p>你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。</p>\n<blockquote>\n<p><strong>为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。</strong></p>\n</blockquote>\n","readingStatistics":0,"createdAt":"2019-03-26T06:10:14.037Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":28,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FoThASW9dVEPMEo9nP-zaOfbKyLZ"},{"_id":"5c99b21accb24267c1d01a05","communication_start_time":null,"type":1,"audioPath":"","abstract":"","content":"不管是团队的扩张还是业务的发展，都会导致项目代码量出现爆炸式增长。为了防止“野蛮生长”现象，我们需要有一个良好的技术选型和成熟的架构做支撑，也需要团队中每一个开发者都能用心维护项目。在此方向上除了人工 code review 以外，相信大家对于一些规范工具并不陌生。\n\n作为一名前端工程师，**在使用现代化工具的基础上，如何尽可能发挥其能量？在必要的情况下，如何开发适合自己团队需求的工具？** 本节将围绕这些问题展开，我们重点分析：\n\n<img src=\"https://images.gitbook.cn/725e5a90-4ec9-11e9-b0b8-a9c8a3696845\" width=500>\n\n接下来，我们通过 2 节内容来学习这个主题。\n\n### <font color=13aa6c>自动化工具巡礼</font>\n\n现代前端开发，“武器”都已经非常自动化了。不同工具分工不同，我们的目标是合理结合各种工具，打造一条完善的自动化流水线，以高效率、低投入的方式，为我们的代码质量提供有效保障。\n\n#### prettier\n\n首先从 prettier 说起，英文单词 prettier 是 pretty 的比较级，pretty 译为“漂亮、美化”。顾名思义，prettier 这个工具能够美化我们的代码，或者说格式化、规范化代码，使其更加工整。它一般不会检查我们代码具体的写法，而是在“可读性”上做文章。目前支持包括 JavaScript、JSX、Angular、Vue、Flow、TypeScript、CSS（Less、SCSS）、JSON 等多种语言、数据交换格式、语法规范扩展。总结一下，它能够将原始代码风格移除，并替换为团队统一配置的代码风格。虽然几乎所有团队都在使用这款工具，不过我们还是简单分析一下使用它的原因吧：\n\n- 构建并统一代码风格\n- 帮助团队新成员快速融入团队\n- 开发者可以完全聚焦业务开发，不必在代码整理上花费过多心思\n- 方便低成本灵活接入，并快速发挥作用\n- 清理并规范已有代码\n- 减少潜在 Bug\n- 丰富强大的社区支持\n\n我们来看一个从零开始的简单 demo，首先创建一个项目（该 demo 引用自系列文章 [Prettier-Eslinst-Editor-Config-Article](https://gist.github.com/adeelibr/3d71c39436fc0d9721330d0b66a5790c)）：\n\n```\nmkdir prettier-demo && cd prettier-demo\n```\n\n进行项目初始化：\n\n```\nyarn init -y\n```\n\n安装依赖：\n\n```\nyarn add prettier --dev --exact\n```\n\n在 package.json 中加入 script：\n\n```\n{\n    \"name\": \"prettier-demo\",\n    \"version\": \"1.0.0\",\n    \"scripts\": {\n        \"prettier\": \"prettier --write src/index.js\"\n    },\n}\n```\n\nprettier --write src/index.js 意思是运行 prettier，并对 src/index.js 文件进行处理：--write 标识告诉 prettier 要把格式化好的内容保存到当前文件中。\n\n我们在 ./src 目录中新建 index.js 文件，键入一些格式缺失的代码：\n\n```\n\tlet person = {\n\t  \t\tname: \"Yoda\",\n\tdesignation: &apos;Jedi Master &apos;\n\t}\n\t\n\t\tfunction trainJedi (jediWarrion) {\n\t  if (jediWarrion.name === &apos;Yoda&apos;) {\n\t   console.log(&apos;No need! already trained&apos;)\n\t  }\n\tconsole.log(`Training ${jediWarrion.name} complete`)\n\t}\n\t\n\t\t\t\ttrainJedi(person)\n\ttrainJedi({ name: &apos;Adeel&apos;,\tdesignation: &apos;padawan&apos;})\n```\n\n同时在根文件中创建 prettier.config.js 文件，添加 prettier 规则：\n\n```\nmodule.exports = {\n    printWidth: 100,\n    singleQuote: true,\n    trailingComma: &apos;all&apos;,\n    bracketSpacing: true,\n    jsxBracketSameLine: false,\n    tabWidth: 2,\n    semi: true,\n}\n```\n\nprettier 读取这些规则 ，并按照以上规则配置美化代码。对于这些规则，我们看其命名便能理解大概，更多内容留给大家去官网寻找。\n\n现在运行：\n\n```\nyarn prettier\n```\n\n代码就会自动被格式化了。\n\n当然，prettier 也可以与编辑器结合，在开发者保存后立即进行美化，也可以集成到 CI 环境中，或者 git pre-commit 的 hook 阶段。比如使用 [pretty-quick](https://www.npmjs.com/package/pretty-quick)：\n\n```\nyarn add prettier pretty-quick husky --dev\n```\n\n并在 package.json 中配置：\n\n```\n{\n\t\"husky\": {\n\t\t\"hooks\": {\n\t\t\t\"pre-commit\": \"pretty-quick --staged\"\n\t\t}\n\t}\n}\n```\n\nhusky 中，定义 pre-commit 阶段，对变化的文件运行 prettier，--staged 参数表示 pre-commit 模式：只对 staged 的文件进行格式化。\n\n这里我们使用了官方推荐的 [pretty-quick](https://www.npmjs.com/package/pretty-quick) 来实现 pre-commit 阶段的美化。这只是实现方式之一，还可以通过 lint-staged 来实现，我们会在下面介绍 ESLint 和 husky 当中介绍。\n​\t\n通过 demo 我们能看出，prettier 确实很灵活，且自动化程度很高，接入项目也十分方便。\n\n#### ESLint\n\n下面来看一下以 ESLint 为代表的 linter。code linting 表示基于静态分析代码原理，找出代码反模式的这过程。多数编程语言都有 linter，它们往往被集成在编译阶段，完成 coding linting 的任务。\n\n对于 JavaScript 这种动态、松类型的语言来说，开发者更容易犯错。由于 JavaScript 不具备先天编译流程，往往在运行时暴露错误，而 linter，尤其最具代表性的 ESLint 的出现，允许开发者在执行前发现代码错误或不合理的写法。\n\nESLint 最重要的几点哲学思想：\n\n- 所有规则都插件化\n- 所有规则都可插拔（随时开关）\n- 所有设计都透明化\n- 使用 espree 进行 JavaScript 解析\n- 使用 AST 分析语法\n\n最后两点我们将在「工具背后的技术原理和设计」一小节进行分析。下面我们简单配置一个 ESLint 规则：\n\n初始化项目：\n\n```\nyarn init -y\n```\n\n安装依赖：\n\n```\nyarn add eslint --dev\n```\n\n并执行：\n\n```\nnpx eslint --init\n```\n\n之后，我们就可以对任意文件进行 lint：\n\n```\neslint XXX.js\n```\n\n当然，想要顺利执行 eslint，还需要安装应用规则插件。\n\n那么如何声明并应用规则呢？在根目录中打开 .eslintrc 配置文件，我们在该文件中加入：\n\n```\t\n{\n\t\"rules\": {\n\t\t\"semi\": [\"error\", \"always\"],\n\t\t\"quote\": [\"error\", \"double\"]\n\t}\n}\n```\n\nsemi、quote 就是 ESLint 规则的名称，其值对应的数组第一项可以为：off/0、warn/1、error/2，分别表示关闭规则、以 warning 形式打开规则、以 error 形式打开规则。\n\n- off/0：关闭规则\n- warn/1：以 warning 形式打开规则\n- error/2：以 error 形式打开规则\n\n同样我们还会在 .eslintrc 文件中发现：\n\n```\n\"extends\": \"eslint:recommended\"\n```\n\n这行表示 ESLint 默认的规则都将会被打开。当然，我们也可以选取其他规则集合，比较出名的有：\n\n- [Google JavaScript Style Guide](https://google.github.io/styleguide/jsguide.html)\n- [Airbnb JavaScript Style Guide](https://github.com/airbnb/javascript#table-of-contents)\n\n我们继续拆分 .eslintrc 文件，其实它主要由六个字段组成：\n\n```\nmodule.exports = { \n   env: {}, \n   extends: {}, \n   plugins: {}, \n   parser: {}, \n   parserOptions: {}, \n   rules: {},\n}\n```\n\n - env：表示指定想启用的环境\n - extends：指定额外配置的选项，如 [&apos;airbnb&apos;] 表示使用 Airbnb 的 linting 规则\n - plugins：设置规则插件\n - parser：默认情况下 ESLint 使用 espree 进行解析\n - parserOptions：如果将默认解析器更改，需要制定 parserOptions\n - rules：定义拓展并通过插件添加的所有规则\n\n注意，上文中 .eslintrc 文件我们采用了 .eslintrc.js 的 JavaScript 文件格式，此外还可以采用 .yaml、.json、yml 等格式。如果项目中含有多种配置文件格式，优先级顺序为：\n\n```\n.eslintrc.js\n.eslintrc.yaml\n.eslintrc.yml\n.eslintrc.json\n.eslintrc\npackage.json\n```\n\n最终，我们在 package.json 中可以添加 script：\n\n```\n\"scripts\": {\n    \"lint\": \"eslint --debug src/\",\n    \"lint:write\": \"eslint --debug src/ --fix\"\n },\n```\n\n- lint 这个命令将遍历所有文件，并在每个找到错误的文件中提供详细日志，但需要开发者手动打开这些文件并更正错误。\n\n- lint:write 与上类似，但这个命令可以自动纠正错误。\n\n#### linter VS prettier\n\n我们应该如何对比以 ESLint 为代表的 linter 和 prettier 呢，它们到底是什么关系？就像开篇所提到的那样，它们解决不同的问题，定位不同，但是又可以相辅相成。\n\n所有的 linter 类似 ESLint，其规则都可以划分为两类。\n\n- 格式化规则（formatting rules）\n\n这类“格式化规则“典型的有 max-len、no-mixed-spaces-and-tabs、keyword-spacing、comma-style，它们“限制一行的最大长度”、“禁止使用空格和 tab 混合缩进”等代码格式方面的规范。事实上，即便开发者写出的代码违反了这类规则，如果在 lint 阶段前，先经过 prettier 处理，这些问题会先在 prettier 阶段被纠正，因此 linter 不会抛出提醒，非常省心，这属于 linter 和 prettier 重叠的地方。\n\n- 代码质量规则（code quality rules）\n\n这类“代码质量规则”类似 no-unused-vars、no-extra-bind、no-implicit-globals、prefer-promise-reject-errors，它们限制“声明未使用变量”，“不必要的函数绑定” 等代码写法规范。这个时候，prettier 对这些规则无能为力。而这些规则对于代码质量和强健性至关重要，还是需要 linter 来保障的。\n\n如同 prettier，ESLint 也可以集成到编辑器或者 git pre-commit 阶段。前文已经演示过了 prettier 搭配 husky，下面我们来介绍一下 husky 到底是什么。\n\n#### husky 和 lint-staged\n\n其实，husky 就是 git 的一个钩子，在 git 进行到某一时段时，可以交给开发者完成某些特定的操作。安装 husky：\n\n```\nyarn add --dev husky\n```\n\n然后在 package.json 文件中添加：\n\n```\n\"husky\": {    \n    \"hooks\": {      \n\t     \"pre-commit\": \"YOUR_SCRIPT\", \n\t     \"pre-push\": \"YOUR_SCRIPT\"   \n    }  \n},\n```\n\n这样每次提交（commit 阶段）或者推送（push 阶段）代码时，就可以执行相关 npm 脚本。需要注意的是，在整个项目上运行 lint 会很慢，我们一般只想对更改的文件进行检查，这时候就需要使用到 lint-staged：\n\n```\nyarn add --dev lint-staged\n```\n\n然后在 package.json 添加：\n\n```\n\"lint-staged\": {    \n\t\"*.(js|jsx)\": [\"npm run lint:write\", \"git add\"]  \n},\n```\n\n最终代码为：\n\n```\n\"scripts\": {\n    \"lint\": \"eslint --debug src/\",\n    \"lint:write\": \"eslint --debug src/ --fix\",\n    \"prettier\": \"prettier --write src/**/*.js\"\n},\n\"husky\": {\n    \"hooks\": {\n        \"pre-commit\": \"lint-staged\"\n    }\n},\n\"lint-staged\": {\n    \"*.(js|jsx)\": [\"npm run lint:write\", \"npm run prettier\", \"git add\"]\n},\n```\n\n它表示在 pre-commit 阶段对于 js 或者 jsx 后缀且修改的文件执行 ESLint 和 prettier 操作，通过之后再进行 git add 添加到暂存区。\n\n俗话说“工欲善其事，必先利其器”，本节课我们对常用工具进行了“巡礼”，请读者们亲自动手实践，了解其中奥秘。\n\n### <font color=13aa6c>分享交流</font>\n\n请大家留言分享「代码规范」相关的个人经验心得，你也可以阅读完下一节全部完成这个主题之后再来总结。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空解答）。**你的分享不仅帮助他人，更会提升自己。**\n\n同时，欢迎说说自己最想了解的主题，课程内容会根据大家的意见和建议迭代和完善。\n\n>**为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。**","pdfUrl":"","reader":"","duration":"","title":"代码规范工具及背后技术设计（上）","column":"5c91c813968b1d64b1e08fde","isNotification":false,"htmlContent":"<p>不管是团队的扩张还是业务的发展，都会导致项目代码量出现爆炸式增长。为了防止“野蛮生长”现象，我们需要有一个良好的技术选型和成熟的架构做支撑，也需要团队中每一个开发者都能用心维护项目。在此方向上除了人工 code review 以外，相信大家对于一些规范工具并不陌生。</p>\n<p>作为一名前端工程师，<strong>在使用现代化工具的基础上，如何尽可能发挥其能量？在必要的情况下，如何开发适合自己团队需求的工具？</strong> 本节将围绕这些问题展开，我们重点分析：</p>\n<img src=\"https://images.gitbook.cn/725e5a90-4ec9-11e9-b0b8-a9c8a3696845\" width=500>\n<p>接下来，我们通过 2 节内容来学习这个主题。</p>\n<h3><a id=\"font_color13aa6cfont_8\"></a><font color=13aa6c>自动化工具巡礼</font></h3>\n<p>现代前端开发，“武器”都已经非常自动化了。不同工具分工不同，我们的目标是合理结合各种工具，打造一条完善的自动化流水线，以高效率、低投入的方式，为我们的代码质量提供有效保障。</p>\n<h4><a id=\"prettier_12\"></a>prettier</h4>\n<p>首先从 prettier 说起，英文单词 prettier 是 pretty 的比较级，pretty 译为“漂亮、美化”。顾名思义，prettier 这个工具能够美化我们的代码，或者说格式化、规范化代码，使其更加工整。它一般不会检查我们代码具体的写法，而是在“可读性”上做文章。目前支持包括 JavaScript、JSX、Angular、Vue、Flow、TypeScript、CSS（Less、SCSS）、JSON 等多种语言、数据交换格式、语法规范扩展。总结一下，它能够将原始代码风格移除，并替换为团队统一配置的代码风格。虽然几乎所有团队都在使用这款工具，不过我们还是简单分析一下使用它的原因吧：</p>\n<ul>\n<li>构建并统一代码风格</li>\n<li>帮助团队新成员快速融入团队</li>\n<li>开发者可以完全聚焦业务开发，不必在代码整理上花费过多心思</li>\n<li>方便低成本灵活接入，并快速发挥作用</li>\n<li>清理并规范已有代码</li>\n<li>减少潜在 Bug</li>\n<li>丰富强大的社区支持</li>\n</ul>\n<p>我们来看一个从零开始的简单 demo，首先创建一个项目（该 demo 引用自系列文章 <a href=\"https://gist.github.com/adeelibr/3d71c39436fc0d9721330d0b66a5790c\" target=\"_blank\">Prettier-Eslinst-Editor-Config-Article</a>）：</p>\n<pre><code class=\"lang-\">mkdir prettier-demo &amp;&amp; cd prettier-demo\n</code></pre>\n<p>进行项目初始化：</p>\n<pre><code class=\"lang-\">yarn init -y\n</code></pre>\n<p>安装依赖：</p>\n<pre><code class=\"lang-\">yarn add prettier --dev --exact\n</code></pre>\n<p>在 package.json 中加入 script：</p>\n<pre><code class=\"lang-\">{\n    &quot;name&quot;: &quot;prettier-demo&quot;,\n    &quot;version&quot;: &quot;1.0.0&quot;,\n    &quot;scripts&quot;: {\n        &quot;prettier&quot;: &quot;prettier --write src/index.js&quot;\n    },\n}\n</code></pre>\n<p>prettier --write src/index.js 意思是运行 prettier，并对 src/index.js 文件进行处理：–write 标识告诉 prettier 要把格式化好的内容保存到当前文件中。</p>\n<p>我们在 ./src 目录中新建 index.js 文件，键入一些格式缺失的代码：</p>\n<pre><code class=\"lang-\">\tlet person = {\n\t  \t\tname: &quot;Yoda&quot;,\n\tdesignation: &apos;Jedi Master &apos;\n\t}\n\t\n\t\tfunction trainJedi (jediWarrion) {\n\t  if (jediWarrion.name === &apos;Yoda&apos;) {\n\t   console.log(&apos;No need! already trained&apos;)\n\t  }\n\tconsole.log(`Training ${jediWarrion.name} complete`)\n\t}\n\t\n\t\t\t\ttrainJedi(person)\n\ttrainJedi({ name: &apos;Adeel&apos;,\tdesignation: &apos;padawan&apos;})\n</code></pre>\n<p>同时在根文件中创建 prettier.config.js 文件，添加 prettier 规则：</p>\n<pre><code class=\"lang-\">module.exports = {\n    printWidth: 100,\n    singleQuote: true,\n    trailingComma: &apos;all&apos;,\n    bracketSpacing: true,\n    jsxBracketSameLine: false,\n    tabWidth: 2,\n    semi: true,\n}\n</code></pre>\n<p>prettier 读取这些规则 ，并按照以上规则配置美化代码。对于这些规则，我们看其命名便能理解大概，更多内容留给大家去官网寻找。</p>\n<p>现在运行：</p>\n<pre><code class=\"lang-\">yarn prettier\n</code></pre>\n<p>代码就会自动被格式化了。</p>\n<p>当然，prettier 也可以与编辑器结合，在开发者保存后立即进行美化，也可以集成到 CI 环境中，或者 git pre-commit 的 hook 阶段。比如使用 <a href=\"https://www.npmjs.com/package/pretty-quick\" target=\"_blank\">pretty-quick</a>：</p>\n<pre><code class=\"lang-\">yarn add prettier pretty-quick husky --dev\n</code></pre>\n<p>并在 package.json 中配置：</p>\n<pre><code class=\"lang-\">{\n\t&quot;husky&quot;: {\n\t\t&quot;hooks&quot;: {\n\t\t\t&quot;pre-commit&quot;: &quot;pretty-quick --staged&quot;\n\t\t}\n\t}\n}\n</code></pre>\n<p>husky 中，定义 pre-commit 阶段，对变化的文件运行 prettier，–staged 参数表示 pre-commit 模式：只对 staged 的文件进行格式化。</p>\n<p>这里我们使用了官方推荐的 <a href=\"https://www.npmjs.com/package/pretty-quick\" target=\"_blank\">pretty-quick</a> 来实现 pre-commit 阶段的美化。这只是实现方式之一，还可以通过 lint-staged 来实现，我们会在下面介绍 ESLint 和 husky 当中介绍。<br />\n​\t<br />\n通过 demo 我们能看出，prettier 确实很灵活，且自动化程度很高，接入项目也十分方便。</p>\n<h4><a id=\"ESLint_123\"></a>ESLint</h4>\n<p>下面来看一下以 ESLint 为代表的 linter。code linting 表示基于静态分析代码原理，找出代码反模式的这过程。多数编程语言都有 linter，它们往往被集成在编译阶段，完成 coding linting 的任务。</p>\n<p>对于 JavaScript 这种动态、松类型的语言来说，开发者更容易犯错。由于 JavaScript 不具备先天编译流程，往往在运行时暴露错误，而 linter，尤其最具代表性的 ESLint 的出现，允许开发者在执行前发现代码错误或不合理的写法。</p>\n<p>ESLint 最重要的几点哲学思想：</p>\n<ul>\n<li>所有规则都插件化</li>\n<li>所有规则都可插拔（随时开关）</li>\n<li>所有设计都透明化</li>\n<li>使用 espree 进行 JavaScript 解析</li>\n<li>使用 AST 分析语法</li>\n</ul>\n<p>最后两点我们将在「工具背后的技术原理和设计」一小节进行分析。下面我们简单配置一个 ESLint 规则：</p>\n<p>初始化项目：</p>\n<pre><code class=\"lang-\">yarn init -y\n</code></pre>\n<p>安装依赖：</p>\n<pre><code class=\"lang-\">yarn add eslint --dev\n</code></pre>\n<p>并执行：</p>\n<pre><code class=\"lang-\">npx eslint --init\n</code></pre>\n<p>之后，我们就可以对任意文件进行 lint：</p>\n<pre><code class=\"lang-\">eslint XXX.js\n</code></pre>\n<p>当然，想要顺利执行 eslint，还需要安装应用规则插件。</p>\n<p>那么如何声明并应用规则呢？在根目录中打开 .eslintrc 配置文件，我们在该文件中加入：</p>\n<pre><code class=\"lang-\">{\n\t&quot;rules&quot;: {\n\t\t&quot;semi&quot;: [&quot;error&quot;, &quot;always&quot;],\n\t\t&quot;quote&quot;: [&quot;error&quot;, &quot;double&quot;]\n\t}\n}\n</code></pre>\n<p>semi、quote 就是 ESLint 规则的名称，其值对应的数组第一项可以为：off/0、warn/1、error/2，分别表示关闭规则、以 warning 形式打开规则、以 error 形式打开规则。</p>\n<ul>\n<li>off/0：关闭规则</li>\n<li>warn/1：以 warning 形式打开规则</li>\n<li>error/2：以 error 形式打开规则</li>\n</ul>\n<p>同样我们还会在 .eslintrc 文件中发现：</p>\n<pre><code class=\"lang-\">&quot;extends&quot;: &quot;eslint:recommended&quot;\n</code></pre>\n<p>这行表示 ESLint 默认的规则都将会被打开。当然，我们也可以选取其他规则集合，比较出名的有：</p>\n<ul>\n<li><a href=\"https://google.github.io/styleguide/jsguide.html\" target=\"_blank\">Google JavaScript Style Guide</a></li>\n<li><a href=\"https://github.com/airbnb/javascript#table-of-contents\" target=\"_blank\">Airbnb JavaScript Style Guide</a></li>\n</ul>\n<p>我们继续拆分 .eslintrc 文件，其实它主要由六个字段组成：</p>\n<pre><code class=\"lang-\">module.exports = { \n   env: {}, \n   extends: {}, \n   plugins: {}, \n   parser: {}, \n   parserOptions: {}, \n   rules: {},\n}\n</code></pre>\n<ul>\n<li>env：表示指定想启用的环境</li>\n<li>extends：指定额外配置的选项，如 [‘airbnb’] 表示使用 Airbnb 的 linting 规则</li>\n<li>plugins：设置规则插件</li>\n<li>parser：默认情况下 ESLint 使用 espree 进行解析</li>\n<li>parserOptions：如果将默认解析器更改，需要制定 parserOptions</li>\n<li>rules：定义拓展并通过插件添加的所有规则</li>\n</ul>\n<p>注意，上文中 .eslintrc 文件我们采用了 .eslintrc.js 的 JavaScript 文件格式，此外还可以采用 .yaml、.json、yml 等格式。如果项目中含有多种配置文件格式，优先级顺序为：</p>\n<pre><code class=\"lang-\">.eslintrc.js\n.eslintrc.yaml\n.eslintrc.yml\n.eslintrc.json\n.eslintrc\npackage.json\n</code></pre>\n<p>最终，我们在 package.json 中可以添加 script：</p>\n<pre><code class=\"lang-\">&quot;scripts&quot;: {\n    &quot;lint&quot;: &quot;eslint --debug src/&quot;,\n    &quot;lint:write&quot;: &quot;eslint --debug src/ --fix&quot;\n },\n</code></pre>\n<ul>\n<li>\n<p>lint 这个命令将遍历所有文件，并在每个找到错误的文件中提供详细日志，但需要开发者手动打开这些文件并更正错误。</p>\n</li>\n<li>\n<p>lint:write 与上类似，但这个命令可以自动纠正错误。</p>\n</li>\n</ul>\n<h4><a id=\"linter_VS_prettier_237\"></a>linter VS prettier</h4>\n<p>我们应该如何对比以 ESLint 为代表的 linter 和 prettier 呢，它们到底是什么关系？就像开篇所提到的那样，它们解决不同的问题，定位不同，但是又可以相辅相成。</p>\n<p>所有的 linter 类似 ESLint，其规则都可以划分为两类。</p>\n<ul>\n<li>格式化规则（formatting rules）</li>\n</ul>\n<p>这类“格式化规则“典型的有 max-len、no-mixed-spaces-and-tabs、keyword-spacing、comma-style，它们“限制一行的最大长度”、“禁止使用空格和 tab 混合缩进”等代码格式方面的规范。事实上，即便开发者写出的代码违反了这类规则，如果在 lint 阶段前，先经过 prettier 处理，这些问题会先在 prettier 阶段被纠正，因此 linter 不会抛出提醒，非常省心，这属于 linter 和 prettier 重叠的地方。</p>\n<ul>\n<li>代码质量规则（code quality rules）</li>\n</ul>\n<p>这类“代码质量规则”类似 no-unused-vars、no-extra-bind、no-implicit-globals、prefer-promise-reject-errors，它们限制“声明未使用变量”，“不必要的函数绑定” 等代码写法规范。这个时候，prettier 对这些规则无能为力。而这些规则对于代码质量和强健性至关重要，还是需要 linter 来保障的。</p>\n<p>如同 prettier，ESLint 也可以集成到编辑器或者 git pre-commit 阶段。前文已经演示过了 prettier 搭配 husky，下面我们来介绍一下 husky 到底是什么。</p>\n<h4><a id=\"husky__lintstaged_253\"></a>husky 和 lint-staged</h4>\n<p>其实，husky 就是 git 的一个钩子，在 git 进行到某一时段时，可以交给开发者完成某些特定的操作。安装 husky：</p>\n<pre><code class=\"lang-\">yarn add --dev husky\n</code></pre>\n<p>然后在 package.json 文件中添加：</p>\n<pre><code class=\"lang-\">&quot;husky&quot;: {    \n    &quot;hooks&quot;: {      \n\t     &quot;pre-commit&quot;: &quot;YOUR_SCRIPT&quot;, \n\t     &quot;pre-push&quot;: &quot;YOUR_SCRIPT&quot;   \n    }  \n},\n</code></pre>\n<p>这样每次提交（commit 阶段）或者推送（push 阶段）代码时，就可以执行相关 npm 脚本。需要注意的是，在整个项目上运行 lint 会很慢，我们一般只想对更改的文件进行检查，这时候就需要使用到 lint-staged：</p>\n<pre><code class=\"lang-\">yarn add --dev lint-staged\n</code></pre>\n<p>然后在 package.json 添加：</p>\n<pre><code class=\"lang-\">&quot;lint-staged&quot;: {    \n\t&quot;*.(js|jsx)&quot;: [&quot;npm run lint:write&quot;, &quot;git add&quot;]  \n},\n</code></pre>\n<p>最终代码为：</p>\n<pre><code class=\"lang-\">&quot;scripts&quot;: {\n    &quot;lint&quot;: &quot;eslint --debug src/&quot;,\n    &quot;lint:write&quot;: &quot;eslint --debug src/ --fix&quot;,\n    &quot;prettier&quot;: &quot;prettier --write src/**/*.js&quot;\n},\n&quot;husky&quot;: {\n    &quot;hooks&quot;: {\n        &quot;pre-commit&quot;: &quot;lint-staged&quot;\n    }\n},\n&quot;lint-staged&quot;: {\n    &quot;*.(js|jsx)&quot;: [&quot;npm run lint:write&quot;, &quot;npm run prettier&quot;, &quot;git add&quot;]\n},\n</code></pre>\n<p>它表示在 pre-commit 阶段对于 js 或者 jsx 后缀且修改的文件执行 ESLint 和 prettier 操作，通过之后再进行 git add 添加到暂存区。</p>\n<p>俗话说“工欲善其事，必先利其器”，本节课我们对常用工具进行了“巡礼”，请读者们亲自动手实践，了解其中奥秘。</p>\n<h3><a id=\"font_color13aa6cfont_308\"></a><font color=13aa6c>分享交流</font></h3>\n<p>请大家留言分享「代码规范」相关的个人经验心得，你也可以阅读完下一节全部完成这个主题之后再来总结。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空解答）。<strong>你的分享不仅帮助他人，更会提升自己。</strong></p>\n<p>同时，欢迎说说自己最想了解的主题，课程内容会根据大家的意见和建议迭代和完善。</p>\n<blockquote>\n<p><strong>为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。</strong></p>\n</blockquote>\n","readingStatistics":0,"createdAt":"2019-03-26T05:01:14.065Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":29,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FoThASW9dVEPMEo9nP-zaOfbKyLZ"},{"_id":"5c99b2e5ccb24267c1d01a14","communication_start_time":null,"type":1,"audioPath":"","abstract":"","content":"上一节课，我们主要介绍了代码规范工具，了解了它们的配置、使用方式。这一节，我们将深入原理，并根据其实现和扩展能力，开发更加灵活的工具集。\n\n在此之前，我们先回顾一下「代码规范」主题的知识点：\n\n<img src=\"https://images.gitbook.cn/725e5a90-4ec9-11e9-b0b8-a9c8a3696845\" width=500>\n\n### <font color=13aa6c>工具背后的技术原理和设计</font>\n\n这一小节，我们挑选实现更为复杂精妙的 ESLint 来分析。大家都清楚 ESLint 是基于静态语法分析（AST）进行工作的，AST 已经不是一个新鲜话题，我们在 webpack 章节就有介绍。ESLint 使用 Espree 来解析 JavaScript 语句，生成 AST。有了完整的解析树，我们就可以基于解析树对代码进行检测和修改。\n\nESLint 的灵魂是每一条 rule，每条规则都是独立且插件化的，我们挑一个比较简单的“禁止块级注释规则”源码来分析：\n\n```\nmodule.exports = {\n  meta: {\n    docs: {\n      description: &apos;禁止块级注释&apos;,\n      category: &apos;Stylistic Issues&apos;,\n      recommended: true\t\n    }\n  },\n  create (context) {\n    const sourceCode = context.getSourceCode()\n    return {\n      Program () {\n        const comments = sourceCode.getAllComments()\n        const blockComments = comments.filter(({ type }) => type === &apos;Block&apos;)\n        blockComments.length && context.report({\n          message: &apos;No block comments&apos;\n        })\n      }\n    }\n  }\n}\n```\n\n从中我们看出，一条规则就是一个 node 模块，它由 meta 和 create 组成。meta 包含了该条规则的文档描述，相对简单。而 create 接受一个 context 参数，返回一个对象：\n\n```\n{\n    meta: {\n        docs: {\n            description: &apos;禁止块级注释&apos;,\n            category: &apos;Stylistic Issues&apos;,\n            recommended: true \n        }\n    },\n    create (context) {\n        // ...\n        return {\n\n        }\n    }\n}\n```\n\n从 context 对象上我们可以取得当前执行扫描到的代码，并通过选择器获取当前需要的内容。如上代码，我们获取代码的所有 comments（sourceCode.getAllComments()），如果 blockComments 长度大于 0，则 report No block comments 信息。\n\n我们再来看一个 no-console rule 的实现：\n\n```\n\"use strict\";\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow the use of `console`\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-console\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allow: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        },\n                        minItems: 1,\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpected: \"Unexpected console statement.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const allowed = options.allow || [];\n\n        /**\n         * Checks whether the given reference is &apos;console&apos; or not.\n         *\n         * @param {eslint-scope.Reference} reference - The reference to check.\n         * @returns {boolean} `true` if the reference is &apos;console&apos;.\n         */\n        function isConsole(reference) {\n            const id = reference.identifier;\n\n            return id && id.name === \"console\";\n        }\n\n        /**\n         * Checks whether the property name of the given MemberExpression node\n         * is allowed by options or not.\n         *\n         * @param {ASTNode} node - The MemberExpression node to check.\n         * @returns {boolean} `true` if the property name of the node is allowed.\n         */\n        function isAllowed(node) {\n            const propertyName = astUtils.getStaticPropertyName(node);\n\n            return propertyName && allowed.indexOf(propertyName) !== -1;\n        }\n\n        /**\n         * Checks whether the given reference is a member access which is not\n         * allowed by options or not.\n         *\n         * @param {eslint-scope.Reference} reference - The reference to check.\n         * @returns {boolean} `true` if the reference is a member access which\n         *      is not allowed by options.\n         */\n        function isMemberAccessExceptAllowed(reference) {\n            const node = reference.identifier;\n            const parent = node.parent;\n\n            return (\n                parent.type === \"MemberExpression\" &&\n                parent.object === node &&\n                !isAllowed(parent)\n            );\n        }\n\n        /**\n         * Reports the given reference as a violation.\n         *\n         * @param {eslint-scope.Reference} reference - The reference to report.\n         * @returns {void}\n         */\n        function report(reference) {\n            const node = reference.identifier.parent;\n\n            context.report({\n                node,\n                loc: node.loc,\n                messageId: \"unexpected\"\n            });\n        }\n\n        return {\n            \"Program:exit\"() {\n                const scope = context.getScope();\n                const consoleVar = astUtils.getVariableByName(scope, \"console\");\n                const shadowed = consoleVar && consoleVar.defs.length > 0;\n\n                /*\n                 * &apos;scope.through&apos; includes all references to undefined\n                 * variables. If the variable &apos;console&apos; is not defined, it uses\n                 * &apos;scope.through&apos;.\n                 */\n                const references = consoleVar\n                    ? consoleVar.references\n                    : scope.through.filter(isConsole);\n\n                if (!shadowed) {\n                    references\n                        .filter(isMemberAccessExceptAllowed)\n                        .forEach(report);\n                }\n            }\n        };\n    }\n};\n```\n\n代码中通过 astUtils.getVariableByName(scope, \"console\") 以及 isConsole 函数来判别 console 语句的出现，通过 allowed.indexOf(propertyName) !== -1 来过滤白名单。\n\n实现非常简单，了解了这些，相信你也能写出 no-alert，no-debugger 的规则内容。\n\n我们再来看一下 no-duplicate-case 规则，它监测 switch...case 中是否存在相同的 case 分支：\n\n```\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow duplicate case labels\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-duplicate-case\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: \"Duplicate case label.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            SwitchStatement(node) {\n                const mapping = {};\n\n                node.cases.forEach(switchCase => {\n                    const key = sourceCode.getText(switchCase.test);\n\n                    if (mapping[key]) {\n                        context.report({ node: switchCase, messageId: \"unexpected\" });\n                    } else {\n                        mapping[key] = switchCase;\n                    }\n                });\n            }\n        };\n    }\n};\n``` \n\n代码非常简单，只是初始化时使用一个空的 mapping，每次添加 case 是进行对 mapping 的扩充，如果存在相同的 case 则 report。\n\n虽然 ESLint 背后的技术内容比较复杂，但是基于 AST 技术，它已经给开发者提供了较为成熟的 APIs。写一条自己的规则并不是很难，只需要开发者找到相关的 AST 选择器，比如上面代码中的 getAllComments()，更多的选择器可以参考：[Selectors - ESLint - Pluggable JavaScript linter](https://eslint.org/docs/developer-guide/selectors)。熟练掌握选择器，将是我们开发插件扩展的关键。\n\n当然，更复杂的场景远不止这么简单，比如，多条规则是如何串联起来生效的？\n\n#### 多条规则串联生效\n\n事实上， **规则可以从多个源来定义，比如代码的注释当中，或者配置文件当中。**\n\nESLint 首先收集到所有规则配置源，将所有规则归并之后，进行多重遍历：遍历由源码生成的 AST，将语法节点传入队列当中；之后遍历所有应用规则，采用事件发布订阅模式（类似 webpack tapable），为所有规则的选择器添加监听事件；在触发事件时执行，如果发现有问题，会将 report message 记录下来。最终记录下来的问题信息将会被输出。\n\n具体 ESLint 的源码如下：\n\n```\nfunction runRules(sourceCode, configuredRules, ruleMapper, parserOptions, parserName, settings, filename) {\n    const emitter = createEmitter();\n    const nodeQueue = [];\n    let currentNode = sourceCode.ast;\n\n    Traverser.traverse(sourceCode.ast, {\n        enter(node, parent) {\n            node.parent = parent;\n            nodeQueue.push({ isEntering: true, node });\n        },\n        leave(node) {\n            nodeQueue.push({ isEntering: false, node });\n        },\n        visitorKeys: sourceCode.visitorKeys\n    });\n\n\n    const lintingProblems = [];\n\n    Object.keys(configuredRules).forEach(ruleId => {\n        const severity = ConfigOps.getRuleSeverity(configuredRules[ruleId]);\n\t\n        if (severity === 0) {\n            return;\n        }\n\n        const rule = ruleMapper(ruleId);\n        const messageIds = rule.meta && rule.meta.messages;\n        let reportTranslator = null;\n        const ruleContext = Object.freeze(\n            Object.assign(\nObject.create(sharedTraversalContext),\n                {\n                    id: ruleId,\n                    options: getRuleOptions(configuredRules[ruleId]),\n                    report(...args) {\n\n                        if (reportTranslator === null) {...}\n                        const problem = reportTranslator(...args);\n                        if (problem.fix && rule.meta && !rule.meta.fixable) {\n                            throw new Error(\"Fixable rules should export a `meta.fixable` property.\");\n                        }\n                        lintingProblems.push(problem);\n                    }\n                }\n            )\n        );\n\n        const ruleListeners = createRuleListeners(rule, ruleContext);\n\n        // add all the selectors from the rule as listeners\n        Object.keys(ruleListeners).forEach(selector => {\n            emitter.on();\n        });\n    });\n\n    const eventGenerator = new CodePathAnalyzer(new NodeEventGenerator(emitter));\n\n    nodeQueue.forEach(traversalInfo => {\n        currentNode = traversalInfo.node;\n        if (traversalInfo.isEntering) {\n            eventGenerator.enterNode(currentNode);\n        } else {\n            eventGenerator.leaveNode(currentNode);\n        }\n    });\n\n    return lintingProblems;\n}\n```\n\n请再思考，我们的程序中免不了有各种条件语句、循环语句，因此 **代码的执行是非顺序的**。相关规则比如：“检测定义但未使用变量”，“switch-case 中避免执行多条 case 语句”，这些规则的实现，就涉及 ESLint 更高级的 code path analysis 概念等。ESLint 将 code path 抽象为 5 个事件。\n\n- onCodePathStart\n- onCodePathEnd\n- onCodePathSegmentStart\n- onCodePathSegmentEnd\n- onCodePathSegmentLoop\n\n利用这 5 个事件，我们可以更加精确地控制检测范围和粒度。更多的 ESLint rule 实现，可以翻看源码进行学习，总之根据这 5 种事件，我们可以监测非顺序性代码，其核心原理还是事件机制。\n\n我们通过 no-unreachable 规则来进行了解，该规则可以通过监测 return，throws，break，continue 的使用，识别出不会被执行的代码，并 report：\n\n```\n/**\n * Checks whether or not a given variable declarator has the initializer.\n * @param {ASTNode} node - A VariableDeclarator node to check.\n * @returns {boolean} `true` if the node has the initializer.\n */\nfunction isInitialized(node) {\n    return Boolean(node.init);\n}\n\n/**\n * Checks whether or not a given code path segment is unreachable.\n * @param {CodePathSegment} segment - A CodePathSegment to check.\n * @returns {boolean} `true` if the segment is unreachable.\n */\nfunction isUnreachable(segment) {\n    return !segment.reachable;\n}\n\n/**\n * The class to distinguish consecutive unreachable statements.\n */\nclass ConsecutiveRange {\n    constructor(sourceCode) {\n        this.sourceCode = sourceCode;\n        this.startNode = null;\n        this.endNode = null;\n    }\n\n    /**\n     * The location object of this range.\n     * @type {Object}\n     */\n    get location() {\n        return {\n            start: this.startNode.loc.start,\n            end: this.endNode.loc.end\n        };\n    }\n\n    /**\n     * `true` if this range is empty.\n     * @type {boolean}\n     */\n    get isEmpty() {\n        return !(this.startNode && this.endNode);\n    }\n\n    /**\n     * Checks whether the given node is inside of this range.\n     * @param {ASTNode|Token} node - The node to check.\n     * @returns {boolean} `true` if the node is inside of this range.\n     */\n    contains(node) {\n        return (\n            node.range[0] >= this.startNode.range[0] &&\n            node.range[1] <= this.endNode.range[1]\n        );\n    }\n\n    /**\n     * Checks whether the given node is consecutive to this range.\n     * @param {ASTNode} node - The node to check.\n     * @returns {boolean} `true` if the node is consecutive to this range.\n     */\n    isConsecutive(node) {\n        return this.contains(this.sourceCode.getTokenBefore(node));\n    }\n\n    /**\n     * Merges the given node to this range.\n     * @param {ASTNode} node - The node to merge.\n     * @returns {void}\n     */\n    merge(node) {\n        this.endNode = node;\n    }\n\n    /**\n     * Resets this range by the given node or null.\n     * @param {ASTNode|null} node - The node to reset, or null.\n     * @returns {void}\n     */\n    reset(node) {\n        this.startNode = this.endNode = node;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow unreachable code after `return`, `throw`, `continue`, and `break` statements\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-unreachable\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        let currentCodePath = null;\n\n        const range = new ConsecutiveRange(context.getSourceCode());\n\n        /**\n         * Reports a given node if it&apos;s unreachable.\n         * @param {ASTNode} node - A statement node to report.\n         * @returns {void}\n         */\n        function reportIfUnreachable(node) {\n            let nextNode = null;\n\n            if (node && currentCodePath.currentSegments.every(isUnreachable)) {\n\n                // Store this statement to distinguish consecutive statements.\n                if (range.isEmpty) {\n                    range.reset(node);\n                    return;\n                }\n\n                // Skip if this statement is inside of the current range.\n                if (range.contains(node)) {\n                    return;\n                }\n\n                // Merge if this statement is consecutive to the current range.\n                if (range.isConsecutive(node)) {\n                    range.merge(node);\n                    return;\n                }\n\n                nextNode = node;\n            }\n\n            /*\n             * Report the current range since this statement is reachable or is\n             * not consecutive to the current range.\n             */\n            if (!range.isEmpty) {\n                context.report({\n                    message: \"Unreachable code.\",\n                    loc: range.location,\n                    node: range.startNode\n                });\n            }\n\n            // Update the current range.\n            range.reset(nextNode);\n        }\n\n        return {\n\n            // Manages the current code path.\n            onCodePathStart(codePath) {\n                currentCodePath = codePath;\n            },\n\n            onCodePathEnd() {\n                currentCodePath = currentCodePath.upper;\n            },\n\n            // Registers for all statement nodes (excludes FunctionDeclaration).\n            BlockStatement: reportIfUnreachable,\n            BreakStatement: reportIfUnreachable,\n            ClassDeclaration: reportIfUnreachable,\n            ContinueStatement: reportIfUnreachable,\n            DebuggerStatement: reportIfUnreachable,\n            DoWhileStatement: reportIfUnreachable,\n            ExpressionStatement: reportIfUnreachable,\n            ForInStatement: reportIfUnreachable,\n            ForOfStatement: reportIfUnreachable,\n            ForStatement: reportIfUnreachable,\n            IfStatement: reportIfUnreachable,\n            ImportDeclaration: reportIfUnreachable,\n            LabeledStatement: reportIfUnreachable,\n            ReturnStatement: reportIfUnreachable,\n            SwitchStatement: reportIfUnreachable,\n            ThrowStatement: reportIfUnreachable,\n            TryStatement: reportIfUnreachable,\n\n            VariableDeclaration(node) {\n                if (node.kind !== \"var\" || node.declarations.some(isInitialized)) {\n                    reportIfUnreachable(node);\n                }\n            },\n\n            WhileStatement: reportIfUnreachable,\n            WithStatement: reportIfUnreachable,\n            ExportNamedDeclaration: reportIfUnreachable,\n            ExportDefaultDeclaration: reportIfUnreachable,\n            ExportAllDeclaration: reportIfUnreachable,\n\n            \"Program:exit\"() {\n                reportIfUnreachable();\n            }\n        };\n    }\n};\n```\n\n实现中，通过 isUnreachable 函数来判别一个 code path 是否无法触及，我提供一些返例帮助大家理解：\n\n```\nfunction foo() {\n    return true;\n    console.log(\"done\");\n}\n\nfunction bar() {\n    throw new Error(\"Oops!\");\n    console.log(\"done\");\n}\n\nwhile(value) {\n    break;\n    console.log(\"done\");\n}\n\nthrow new Error(\"Oops!\");\nconsole.log(\"done\");\n\nfunction baz() {\n    if (Math.random() < 0.5) {\n        return;\n    } else {\n        throw new Error();\n    }\n    console.log(\"done\");\n}\n```\n\n因为 unreachable 的代码需要放在一个区块当中去理解，单条语句无法去进行判别，因此使用 ConsecutiveRange 类来保留连续代码信息。\n\n最后，这种优秀的插件扩展机制对于设计一个库，尤其是设计一个规范工具来说，是非常值得借鉴的模式。事实上，prettier 也会在新的版本中引入插件机制，目前已经在 beta 版，感兴趣的读者可以[尝鲜](https://prettier.io/docs/en/plugins.html#docsNav)。\n\n### <font color=13aa6c>自动化规范与团队建设</font>\n\n自动化规范还有其他一些细节，比如使用 EditorConfig 来保证编辑器的设置统一，确定在制表符空格或换行方面的一致性，又如使用 [commitlint](https://www.npmjs.com/package/@commitlint/config-conventional) 并配合 husky，来保证 commit message 的规范：\n\n```\n# 安装 commitlint cli 和 conventional config\nnpm install --save-dev @commitlint/{config-conventional,cli}\n\t\n# 配置 commitlint\necho \"module.exports = {extends: [&apos;@commitlint/config-conventional&apos;]}\" > commitlint.config.js\n```\n\n并在 commit-msg 的 git hook 阶段进行检查，在 package.json 中添加：\n\n```\n{\n    \"husky\": {\n        \"hooks\": {\n            \"commit-msg\": \"commitlint -E HUSKY_GIT_PARAMS\"\n        }  \n    }\n}\n```\n\n我们也可以根据团队需求做更多定制化的尝试，比如自动规范化或生产 commit message，有了规范的 commit message 之后，就可以提取关键内容，规范化生产 changelog 等。\n\n其他方向上，还可以从团队文档的生产来考虑。举个例子，如果使用 React 开发项目，那么 React 组件文档如何规范化生成？如何提高组件使用的效率，减少学习成本？我在[掘金 AMA](https://juejin.im/pin/5c45dd09092dcb473721710d) 上做客时，有人便提出了这样的问题。\n\n> 我们组内面临着最古老的 React 管理平台重构任务，这次我们想生成关于管理平台的阅读文档（包括常用的样式命名、工具方法、全局组件、复杂 API 交互流程等）。\n>\n> 所以我想提出的问题是：面向 React 代码的可维护性和可持续发展（不要单个功能每个团队成员都实现一遍，当新成员加入的时候知道有哪些功能能从现在代码中复用， 也知道有哪些功能还没有，他可以添加实现进去），业内有哪些工具或 npm 库或开发模式是可以确切能够帮助解决痛点或者改善现状的呢？\n\n**确实，随着项目复杂度的提升，各种组件也“爆炸式”增长。如何让这些组件方便易用，能快速上手，同时不成为负担，又避免重复造轮子现象，良好的组件管理在团队中非常重要。**\n\n关于“React 组件管理文档”，简单梳理一下：总得来说，社区在这方面的探索很多，相关方案也各有特色。\n\n- 最知名的一定是 [storybook](https://storybook.js.org/)，它会生成一个静态页面，专门用来展示组件的实际效果以及用法；缺点是业务侵入性较强，且 story 编写成本较高。\n- 我个人很喜欢的是 [react-docgen](https://github.com/reactjs/react-docgen)，比较极客风格，它能够分析并提取 React 组件信息。原理是使用了 recast 和 @babel/parser AST 分析，最终产出一个 JSON 文档。 [https://github.com/reactjs/react-docgen](https://github.com/reactjs/react-docgen) 是它的网页链接，缺点是它较为轻量，缺乏有效的可视化能力。\n- 那么在 react-docgen 之上，我们可以考虑 [React Styleguidist](https://www.npmjs.com/package/react-styleguidist)，这款 React 组件文档生成器，支持丰富的 demo，可能会更符合需求。\n- 一些小而美的解决方案：比如 react-doc、react-doc-generator、cherrypdoc，都可以考虑尝试。\n\n“自己动手、丰衣足食”，其实开发一个类似的工具并不会太复杂。如果有时间和精力，你可以根据自己的需求，实现一个完全匹配自己团队的 React 组件管理文档，或者其他框架相关、业务相关的文档，这非常有意义。\n\n### <font color=13aa6c>总结</font>\n\n在规范化的道路上，只有你想不到，没有你做不到。\n\n简单的规范化工具用起来非常清爽，但是背后的实现却蕴含了很深的设计与技术细节，值得我们深入学习。\n\n作为前端工程师，我们应该从平时开发的痛点和效率瓶颈入手，敢于尝试，不断探索。保证团队开发的自动化程度，就能减少不必要的麻烦。\n\n除了“偏硬”的强制规范手段，一些“软方向”，比如团队氛围、code review/analyse 等，也直接决定着团队的代码质量。进阶的工程师不仅需要在技术上成长，在团队建设上更需要主动交流。\n\n课程代码仓库：\n<a href=\"https://github.com/HOUCe/lucas-gitchat-courses\">https://github.com/HOUCe/lucas-gitchat-courses</a>\n\n### <font color=13aa6c>分享交流</font>\n\n请大家留言分享「代码规范」相关的个人经验心得。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后会抽空解答）。**你的分享不仅帮助他人，更会提升自己。**\n\n同时，欢迎说说自己最想了解的主题，课程内容会根据大家的意见和建议迭代和完善。\n\n>**为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。**","pdfUrl":"","reader":"","duration":"","title":"代码规范工具及背后技术设计（下）","column":"5c91c813968b1d64b1e08fde","isNotification":false,"htmlContent":"<p>上一节课，我们主要介绍了代码规范工具，了解了它们的配置、使用方式。这一节，我们将深入原理，并根据其实现和扩展能力，开发更加灵活的工具集。</p>\n<p>在此之前，我们先回顾一下「代码规范」主题的知识点：</p>\n<img src=\"https://images.gitbook.cn/725e5a90-4ec9-11e9-b0b8-a9c8a3696845\" width=500>\n<h3><a id=\"font_color13aa6cfont_6\"></a><font color=13aa6c>工具背后的技术原理和设计</font></h3>\n<p>这一小节，我们挑选实现更为复杂精妙的 ESLint 来分析。大家都清楚 ESLint 是基于静态语法分析（AST）进行工作的，AST 已经不是一个新鲜话题，我们在 webpack 章节就有介绍。ESLint 使用 Espree 来解析 JavaScript 语句，生成 AST。有了完整的解析树，我们就可以基于解析树对代码进行检测和修改。</p>\n<p>ESLint 的灵魂是每一条 rule，每条规则都是独立且插件化的，我们挑一个比较简单的“禁止块级注释规则”源码来分析：</p>\n<pre><code class=\"lang-\">module.exports = {\n  meta: {\n    docs: {\n      description: &apos;禁止块级注释&apos;,\n      category: &apos;Stylistic Issues&apos;,\n      recommended: true\t\n    }\n  },\n  create (context) {\n    const sourceCode = context.getSourceCode()\n    return {\n      Program () {\n        const comments = sourceCode.getAllComments()\n        const blockComments = comments.filter(({ type }) =&gt; type === &apos;Block&apos;)\n        blockComments.length &amp;&amp; context.report({\n          message: &apos;No block comments&apos;\n        })\n      }\n    }\n  }\n}\n</code></pre>\n<p>从中我们看出，一条规则就是一个 node 模块，它由 meta 和 create 组成。meta 包含了该条规则的文档描述，相对简单。而 create 接受一个 context 参数，返回一个对象：</p>\n<pre><code class=\"lang-\">{\n    meta: {\n        docs: {\n            description: &apos;禁止块级注释&apos;,\n            category: &apos;Stylistic Issues&apos;,\n            recommended: true \n        }\n    },\n    create (context) {\n        // ...\n        return {\n\n        }\n    }\n}\n</code></pre>\n<p>从 context 对象上我们可以取得当前执行扫描到的代码，并通过选择器获取当前需要的内容。如上代码，我们获取代码的所有 comments（sourceCode.getAllComments()），如果 blockComments 长度大于 0，则 report No block comments 信息。</p>\n<p>我们再来看一个 no-console rule 的实现：</p>\n<pre><code class=\"lang-\">&quot;use strict&quot;;\n\nmodule.exports = {\n    meta: {\n        type: &quot;suggestion&quot;,\n\n        docs: {\n            description: &quot;disallow the use of `console`&quot;,\n            category: &quot;Possible Errors&quot;,\n            recommended: false,\n            url: &quot;https://eslint.org/docs/rules/no-console&quot;\n        },\n\n        schema: [\n            {\n                type: &quot;object&quot;,\n                properties: {\n                    allow: {\n                        type: &quot;array&quot;,\n                        items: {\n                            type: &quot;string&quot;\n                        },\n                        minItems: 1,\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpected: &quot;Unexpected console statement.&quot;\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const allowed = options.allow || [];\n\n        /**\n         * Checks whether the given reference is &apos;console&apos; or not.\n         *\n         * @param {eslint-scope.Reference} reference - The reference to check.\n         * @returns {boolean} `true` if the reference is &apos;console&apos;.\n         */\n        function isConsole(reference) {\n            const id = reference.identifier;\n\n            return id &amp;&amp; id.name === &quot;console&quot;;\n        }\n\n        /**\n         * Checks whether the property name of the given MemberExpression node\n         * is allowed by options or not.\n         *\n         * @param {ASTNode} node - The MemberExpression node to check.\n         * @returns {boolean} `true` if the property name of the node is allowed.\n         */\n        function isAllowed(node) {\n            const propertyName = astUtils.getStaticPropertyName(node);\n\n            return propertyName &amp;&amp; allowed.indexOf(propertyName) !== -1;\n        }\n\n        /**\n         * Checks whether the given reference is a member access which is not\n         * allowed by options or not.\n         *\n         * @param {eslint-scope.Reference} reference - The reference to check.\n         * @returns {boolean} `true` if the reference is a member access which\n         *      is not allowed by options.\n         */\n        function isMemberAccessExceptAllowed(reference) {\n            const node = reference.identifier;\n            const parent = node.parent;\n\n            return (\n                parent.type === &quot;MemberExpression&quot; &amp;&amp;\n                parent.object === node &amp;&amp;\n                !isAllowed(parent)\n            );\n        }\n\n        /**\n         * Reports the given reference as a violation.\n         *\n         * @param {eslint-scope.Reference} reference - The reference to report.\n         * @returns {void}\n         */\n        function report(reference) {\n            const node = reference.identifier.parent;\n\n            context.report({\n                node,\n                loc: node.loc,\n                messageId: &quot;unexpected&quot;\n            });\n        }\n\n        return {\n            &quot;Program:exit&quot;() {\n                const scope = context.getScope();\n                const consoleVar = astUtils.getVariableByName(scope, &quot;console&quot;);\n                const shadowed = consoleVar &amp;&amp; consoleVar.defs.length &gt; 0;\n\n                /*\n                 * &apos;scope.through&apos; includes all references to undefined\n                 * variables. If the variable &apos;console&apos; is not defined, it uses\n                 * &apos;scope.through&apos;.\n                 */\n                const references = consoleVar\n                    ? consoleVar.references\n                    : scope.through.filter(isConsole);\n\n                if (!shadowed) {\n                    references\n                        .filter(isMemberAccessExceptAllowed)\n                        .forEach(report);\n                }\n            }\n        };\n    }\n};\n</code></pre>\n<p>代码中通过 astUtils.getVariableByName(scope, “console”) 以及 isConsole 函数来判别 console 语句的出现，通过 allowed.indexOf(propertyName) !== -1 来过滤白名单。</p>\n<p>实现非常简单，了解了这些，相信你也能写出 no-alert，no-debugger 的规则内容。</p>\n<p>我们再来看一下 no-duplicate-case 规则，它监测 switch…case 中是否存在相同的 case 分支：</p>\n<pre><code class=\"lang-\">module.exports = {\n    meta: {\n        type: &quot;problem&quot;,\n\n        docs: {\n            description: &quot;disallow duplicate case labels&quot;,\n            category: &quot;Possible Errors&quot;,\n            recommended: true,\n            url: &quot;https://eslint.org/docs/rules/no-duplicate-case&quot;\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: &quot;Duplicate case label.&quot;\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            SwitchStatement(node) {\n                const mapping = {};\n\n                node.cases.forEach(switchCase =&gt; {\n                    const key = sourceCode.getText(switchCase.test);\n\n                    if (mapping[key]) {\n                        context.report({ node: switchCase, messageId: &quot;unexpected&quot; });\n                    } else {\n                        mapping[key] = switchCase;\n                    }\n                });\n            }\n        };\n    }\n};\n</code></pre>\n<p>代码非常简单，只是初始化时使用一个空的 mapping，每次添加 case 是进行对 mapping 的扩充，如果存在相同的 case 则 report。</p>\n<p>虽然 ESLint 背后的技术内容比较复杂，但是基于 AST 技术，它已经给开发者提供了较为成熟的 APIs。写一条自己的规则并不是很难，只需要开发者找到相关的 AST 选择器，比如上面代码中的 getAllComments()，更多的选择器可以参考：<a href=\"https://eslint.org/docs/developer-guide/selectors\" target=\"_blank\">Selectors - ESLint - Pluggable JavaScript linter</a>。熟练掌握选择器，将是我们开发插件扩展的关键。</p>\n<p>当然，更复杂的场景远不止这么简单，比如，多条规则是如何串联起来生效的？</p>\n<h4><a id=\"_239\"></a>多条规则串联生效</h4>\n<p>事实上， <strong>规则可以从多个源来定义，比如代码的注释当中，或者配置文件当中。</strong></p>\n<p>ESLint 首先收集到所有规则配置源，将所有规则归并之后，进行多重遍历：遍历由源码生成的 AST，将语法节点传入队列当中；之后遍历所有应用规则，采用事件发布订阅模式（类似 webpack tapable），为所有规则的选择器添加监听事件；在触发事件时执行，如果发现有问题，会将 report message 记录下来。最终记录下来的问题信息将会被输出。</p>\n<p>具体 ESLint 的源码如下：</p>\n<pre><code class=\"lang-\">function runRules(sourceCode, configuredRules, ruleMapper, parserOptions, parserName, settings, filename) {\n    const emitter = createEmitter();\n    const nodeQueue = [];\n    let currentNode = sourceCode.ast;\n\n    Traverser.traverse(sourceCode.ast, {\n        enter(node, parent) {\n            node.parent = parent;\n            nodeQueue.push({ isEntering: true, node });\n        },\n        leave(node) {\n            nodeQueue.push({ isEntering: false, node });\n        },\n        visitorKeys: sourceCode.visitorKeys\n    });\n\n\n    const lintingProblems = [];\n\n    Object.keys(configuredRules).forEach(ruleId =&gt; {\n        const severity = ConfigOps.getRuleSeverity(configuredRules[ruleId]);\n\t\n        if (severity === 0) {\n            return;\n        }\n\n        const rule = ruleMapper(ruleId);\n        const messageIds = rule.meta &amp;&amp; rule.meta.messages;\n        let reportTranslator = null;\n        const ruleContext = Object.freeze(\n            Object.assign(\nObject.create(sharedTraversalContext),\n                {\n                    id: ruleId,\n                    options: getRuleOptions(configuredRules[ruleId]),\n                    report(...args) {\n\n                        if (reportTranslator === null) {...}\n                        const problem = reportTranslator(...args);\n                        if (problem.fix &amp;&amp; rule.meta &amp;&amp; !rule.meta.fixable) {\n                            throw new Error(&quot;Fixable rules should export a `meta.fixable` property.&quot;);\n                        }\n                        lintingProblems.push(problem);\n                    }\n                }\n            )\n        );\n\n        const ruleListeners = createRuleListeners(rule, ruleContext);\n\n        // add all the selectors from the rule as listeners\n        Object.keys(ruleListeners).forEach(selector =&gt; {\n            emitter.on();\n        });\n    });\n\n    const eventGenerator = new CodePathAnalyzer(new NodeEventGenerator(emitter));\n\n    nodeQueue.forEach(traversalInfo =&gt; {\n        currentNode = traversalInfo.node;\n        if (traversalInfo.isEntering) {\n            eventGenerator.enterNode(currentNode);\n        } else {\n            eventGenerator.leaveNode(currentNode);\n        }\n    });\n\n    return lintingProblems;\n}\n</code></pre>\n<p>请再思考，我们的程序中免不了有各种条件语句、循环语句，因此 <strong>代码的执行是非顺序的</strong>。相关规则比如：“检测定义但未使用变量”，“switch-case 中避免执行多条 case 语句”，这些规则的实现，就涉及 ESLint 更高级的 code path analysis 概念等。ESLint 将 code path 抽象为 5 个事件。</p>\n<ul>\n<li>onCodePathStart</li>\n<li>onCodePathEnd</li>\n<li>onCodePathSegmentStart</li>\n<li>onCodePathSegmentEnd</li>\n<li>onCodePathSegmentLoop</li>\n</ul>\n<p>利用这 5 个事件，我们可以更加精确地控制检测范围和粒度。更多的 ESLint rule 实现，可以翻看源码进行学习，总之根据这 5 种事件，我们可以监测非顺序性代码，其核心原理还是事件机制。</p>\n<p>我们通过 no-unreachable 规则来进行了解，该规则可以通过监测 return，throws，break，continue 的使用，识别出不会被执行的代码，并 report：</p>\n<pre><code class=\"lang-\">/**\n * Checks whether or not a given variable declarator has the initializer.\n * @param {ASTNode} node - A VariableDeclarator node to check.\n * @returns {boolean} `true` if the node has the initializer.\n */\nfunction isInitialized(node) {\n    return Boolean(node.init);\n}\n\n/**\n * Checks whether or not a given code path segment is unreachable.\n * @param {CodePathSegment} segment - A CodePathSegment to check.\n * @returns {boolean} `true` if the segment is unreachable.\n */\nfunction isUnreachable(segment) {\n    return !segment.reachable;\n}\n\n/**\n * The class to distinguish consecutive unreachable statements.\n */\nclass ConsecutiveRange {\n    constructor(sourceCode) {\n        this.sourceCode = sourceCode;\n        this.startNode = null;\n        this.endNode = null;\n    }\n\n    /**\n     * The location object of this range.\n     * @type {Object}\n     */\n    get location() {\n        return {\n            start: this.startNode.loc.start,\n            end: this.endNode.loc.end\n        };\n    }\n\n    /**\n     * `true` if this range is empty.\n     * @type {boolean}\n     */\n    get isEmpty() {\n        return !(this.startNode &amp;&amp; this.endNode);\n    }\n\n    /**\n     * Checks whether the given node is inside of this range.\n     * @param {ASTNode|Token} node - The node to check.\n     * @returns {boolean} `true` if the node is inside of this range.\n     */\n    contains(node) {\n        return (\n            node.range[0] &gt;= this.startNode.range[0] &amp;&amp;\n            node.range[1] &lt;= this.endNode.range[1]\n        );\n    }\n\n    /**\n     * Checks whether the given node is consecutive to this range.\n     * @param {ASTNode} node - The node to check.\n     * @returns {boolean} `true` if the node is consecutive to this range.\n     */\n    isConsecutive(node) {\n        return this.contains(this.sourceCode.getTokenBefore(node));\n    }\n\n    /**\n     * Merges the given node to this range.\n     * @param {ASTNode} node - The node to merge.\n     * @returns {void}\n     */\n    merge(node) {\n        this.endNode = node;\n    }\n\n    /**\n     * Resets this range by the given node or null.\n     * @param {ASTNode|null} node - The node to reset, or null.\n     * @returns {void}\n     */\n    reset(node) {\n        this.startNode = this.endNode = node;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: &quot;problem&quot;,\n\n        docs: {\n            description: &quot;disallow unreachable code after `return`, `throw`, `continue`, and `break` statements&quot;,\n            category: &quot;Possible Errors&quot;,\n            recommended: true,\n            url: &quot;https://eslint.org/docs/rules/no-unreachable&quot;\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        let currentCodePath = null;\n\n        const range = new ConsecutiveRange(context.getSourceCode());\n\n        /**\n         * Reports a given node if it&apos;s unreachable.\n         * @param {ASTNode} node - A statement node to report.\n         * @returns {void}\n         */\n        function reportIfUnreachable(node) {\n            let nextNode = null;\n\n            if (node &amp;&amp; currentCodePath.currentSegments.every(isUnreachable)) {\n\n                // Store this statement to distinguish consecutive statements.\n                if (range.isEmpty) {\n                    range.reset(node);\n                    return;\n                }\n\n                // Skip if this statement is inside of the current range.\n                if (range.contains(node)) {\n                    return;\n                }\n\n                // Merge if this statement is consecutive to the current range.\n                if (range.isConsecutive(node)) {\n                    range.merge(node);\n                    return;\n                }\n\n                nextNode = node;\n            }\n\n            /*\n             * Report the current range since this statement is reachable or is\n             * not consecutive to the current range.\n             */\n            if (!range.isEmpty) {\n                context.report({\n                    message: &quot;Unreachable code.&quot;,\n                    loc: range.location,\n                    node: range.startNode\n                });\n            }\n\n            // Update the current range.\n            range.reset(nextNode);\n        }\n\n        return {\n\n            // Manages the current code path.\n            onCodePathStart(codePath) {\n                currentCodePath = codePath;\n            },\n\n            onCodePathEnd() {\n                currentCodePath = currentCodePath.upper;\n            },\n\n            // Registers for all statement nodes (excludes FunctionDeclaration).\n            BlockStatement: reportIfUnreachable,\n            BreakStatement: reportIfUnreachable,\n            ClassDeclaration: reportIfUnreachable,\n            ContinueStatement: reportIfUnreachable,\n            DebuggerStatement: reportIfUnreachable,\n            DoWhileStatement: reportIfUnreachable,\n            ExpressionStatement: reportIfUnreachable,\n            ForInStatement: reportIfUnreachable,\n            ForOfStatement: reportIfUnreachable,\n            ForStatement: reportIfUnreachable,\n            IfStatement: reportIfUnreachable,\n            ImportDeclaration: reportIfUnreachable,\n            LabeledStatement: reportIfUnreachable,\n            ReturnStatement: reportIfUnreachable,\n            SwitchStatement: reportIfUnreachable,\n            ThrowStatement: reportIfUnreachable,\n            TryStatement: reportIfUnreachable,\n\n            VariableDeclaration(node) {\n                if (node.kind !== &quot;var&quot; || node.declarations.some(isInitialized)) {\n                    reportIfUnreachable(node);\n                }\n            },\n\n            WhileStatement: reportIfUnreachable,\n            WithStatement: reportIfUnreachable,\n            ExportNamedDeclaration: reportIfUnreachable,\n            ExportDefaultDeclaration: reportIfUnreachable,\n            ExportAllDeclaration: reportIfUnreachable,\n\n            &quot;Program:exit&quot;() {\n                reportIfUnreachable();\n            }\n        };\n    }\n};\n</code></pre>\n<p>实现中，通过 isUnreachable 函数来判别一个 code path 是否无法触及，我提供一些返例帮助大家理解：</p>\n<pre><code class=\"lang-\">function foo() {\n    return true;\n    console.log(&quot;done&quot;);\n}\n\nfunction bar() {\n    throw new Error(&quot;Oops!&quot;);\n    console.log(&quot;done&quot;);\n}\n\nwhile(value) {\n    break;\n    console.log(&quot;done&quot;);\n}\n\nthrow new Error(&quot;Oops!&quot;);\nconsole.log(&quot;done&quot;);\n\nfunction baz() {\n    if (Math.random() &lt; 0.5) {\n        return;\n    } else {\n        throw new Error();\n    }\n    console.log(&quot;done&quot;);\n}\n</code></pre>\n<p>因为 unreachable 的代码需要放在一个区块当中去理解，单条语句无法去进行判别，因此使用 ConsecutiveRange 类来保留连续代码信息。</p>\n<p>最后，这种优秀的插件扩展机制对于设计一个库，尤其是设计一个规范工具来说，是非常值得借鉴的模式。事实上，prettier 也会在新的版本中引入插件机制，目前已经在 beta 版，感兴趣的读者可以<a href=\"https://prettier.io/docs/en/plugins.html#docsNav\" target=\"_blank\">尝鲜</a>。</p>\n<h3><a id=\"font_color13aa6cfont_573\"></a><font color=13aa6c>自动化规范与团队建设</font></h3>\n<p>自动化规范还有其他一些细节，比如使用 EditorConfig 来保证编辑器的设置统一，确定在制表符空格或换行方面的一致性，又如使用 <a href=\"https://www.npmjs.com/package/@commitlint/config-conventional\" target=\"_blank\">commitlint</a> 并配合 husky，来保证 commit message 的规范：</p>\n<pre><code class=\"lang-\"># 安装 commitlint cli 和 conventional config\nnpm install --save-dev @commitlint/{config-conventional,cli}\n\t\n# 配置 commitlint\necho &quot;module.exports = {extends: [&apos;@commitlint/config-conventional&apos;]}&quot; &gt; commitlint.config.js\n</code></pre>\n<p>并在 commit-msg 的 git hook 阶段进行检查，在 package.json 中添加：</p>\n<pre><code class=\"lang-\">{\n    &quot;husky&quot;: {\n        &quot;hooks&quot;: {\n            &quot;commit-msg&quot;: &quot;commitlint -E HUSKY_GIT_PARAMS&quot;\n        }  \n    }\n}\n</code></pre>\n<p>我们也可以根据团队需求做更多定制化的尝试，比如自动规范化或生产 commit message，有了规范的 commit message 之后，就可以提取关键内容，规范化生产 changelog 等。</p>\n<p>其他方向上，还可以从团队文档的生产来考虑。举个例子，如果使用 React 开发项目，那么 React 组件文档如何规范化生成？如何提高组件使用的效率，减少学习成本？我在<a href=\"https://juejin.im/pin/5c45dd09092dcb473721710d\" target=\"_blank\">掘金 AMA</a> 上做客时，有人便提出了这样的问题。</p>\n<blockquote>\n<p>我们组内面临着最古老的 React 管理平台重构任务，这次我们想生成关于管理平台的阅读文档（包括常用的样式命名、工具方法、全局组件、复杂 API 交互流程等）。</p>\n<p>所以我想提出的问题是：面向 React 代码的可维护性和可持续发展（不要单个功能每个团队成员都实现一遍，当新成员加入的时候知道有哪些功能能从现在代码中复用， 也知道有哪些功能还没有，他可以添加实现进去），业内有哪些工具或 npm 库或开发模式是可以确切能够帮助解决痛点或者改善现状的呢？</p>\n</blockquote>\n<p><strong>确实，随着项目复杂度的提升，各种组件也“爆炸式”增长。如何让这些组件方便易用，能快速上手，同时不成为负担，又避免重复造轮子现象，良好的组件管理在团队中非常重要。</strong></p>\n<p>关于“React 组件管理文档”，简单梳理一下：总得来说，社区在这方面的探索很多，相关方案也各有特色。</p>\n<ul>\n<li>最知名的一定是 <a href=\"https://storybook.js.org/\" target=\"_blank\">storybook</a>，它会生成一个静态页面，专门用来展示组件的实际效果以及用法；缺点是业务侵入性较强，且 story 编写成本较高。</li>\n<li>我个人很喜欢的是 <a href=\"https://github.com/reactjs/react-docgen\" target=\"_blank\">react-docgen</a>，比较极客风格，它能够分析并提取 React 组件信息。原理是使用了 recast 和 @babel/parser AST 分析，最终产出一个 JSON 文档。 <a href=\"https://github.com/reactjs/react-docgen\" target=\"_blank\">https://github.com/reactjs/react-docgen</a> 是它的网页链接，缺点是它较为轻量，缺乏有效的可视化能力。</li>\n<li>那么在 react-docgen 之上，我们可以考虑 <a href=\"https://www.npmjs.com/package/react-styleguidist\" target=\"_blank\">React Styleguidist</a>，这款 React 组件文档生成器，支持丰富的 demo，可能会更符合需求。</li>\n<li>一些小而美的解决方案：比如 react-doc、react-doc-generator、cherrypdoc，都可以考虑尝试。</li>\n</ul>\n<p>“自己动手、丰衣足食”，其实开发一个类似的工具并不会太复杂。如果有时间和精力，你可以根据自己的需求，实现一个完全匹配自己团队的 React 组件管理文档，或者其他框架相关、业务相关的文档，这非常有意义。</p>\n<h3><a id=\"font_color13aa6cfont_616\"></a><font color=13aa6c>总结</font></h3>\n<p>在规范化的道路上，只有你想不到，没有你做不到。</p>\n<p>简单的规范化工具用起来非常清爽，但是背后的实现却蕴含了很深的设计与技术细节，值得我们深入学习。</p>\n<p>作为前端工程师，我们应该从平时开发的痛点和效率瓶颈入手，敢于尝试，不断探索。保证团队开发的自动化程度，就能减少不必要的麻烦。</p>\n<p>除了“偏硬”的强制规范手段，一些“软方向”，比如团队氛围、code review/analyse 等，也直接决定着团队的代码质量。进阶的工程师不仅需要在技术上成长，在团队建设上更需要主动交流。</p>\n<p>课程代码仓库：<br />\n<a href=\"https://github.com/HOUCe/lucas-gitchat-courses\">https://github.com/HOUCe/lucas-gitchat-courses</a></p>\n<h3><a id=\"font_color13aa6cfont_629\"></a><font color=13aa6c>分享交流</font></h3>\n<p>请大家留言分享「代码规范」相关的个人经验心得。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后会抽空解答）。<strong>你的分享不仅帮助他人，更会提升自己。</strong></p>\n<p>同时，欢迎说说自己最想了解的主题，课程内容会根据大家的意见和建议迭代和完善。</p>\n<blockquote>\n<p><strong>为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。</strong></p>\n</blockquote>\n","readingStatistics":0,"createdAt":"2019-03-26T05:04:37.213Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":30,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FoThASW9dVEPMEo9nP-zaOfbKyLZ"},{"_id":"5c99c52fccb24267c1d01b87","communication_start_time":null,"type":1,"audioPath":"","abstract":"","content":"性能始终是前端领域非常重要的话题，它直接决定了产品体验的优劣，重要性无需赘言。我们在体验一个产品时，能够直观感受到其性能，可是如何量化衡量性能的好坏呢？\n\n同时，我们无法保证程序永远不出问题，如何在程序出现问题时及时获得现场数据、还原现场，以做出准确地响应呢？\n\n离开了实际场景谈这些话题都是“耍流氓”，性能数据的监控、错误信息的收集和上报应该都要基于线上真实环境。这对于我们随时掌控线上产品，优化应用体验具有重大意义。\n\n本节课程，我们就聚焦在性能监控和错误收集与上报系统上。希望通过学习，每个人都心中有数，做到不仅能够分析性能数据、处理错误，还能建设一个成熟的配套系统。\n\n本节课主要知识点：\n\n<img src=\"https://images.gitbook.cn/9f1e2980-4ed7-11e9-b0b8-a9c8a3696845\" width=500>\n\n接下来，我们通过 2 节内容来学习这个主题。\n\n### <font color=13aa6c>性能监控指标</font>\n\n既然是性能监控，那我们首先需要明确衡量指标。一般来说，业界认可的常用指标有：\n\n- 首次绘制（FP）和首次有内容绘制（FCP）时间\n- 首次有意义绘制（FMP）时间\n- 首屏时间\n- 用户可交互（TTI）时间\n- 总下载时间\n- 自定义指标\n\n接下来分别看看每个指标的含义。\n\n> **首次绘制（FP）时间**：对于应用页面，用户在视觉上首次出现不同于跳转之前的内容时间点，或者说是页面发生第一次绘制的时间点。\n>\n> **首次有内容绘制（FCP）时间**：指浏览器完成渲染 DOM 中第一个内容的时间点，可能是文本、图像或者其他任何元素，此时用户应该在视觉上有直观的感受。\n>\n> **首次有意义绘制（FMP）时间**：指页面关键元素渲染时间。这个概念并没有标准化定义，因为关键元素可以由开发者自行定义——究竟什么是“有意义”的内容，只有开发者或者产品经理自己了解。\n>\n> **首屏时间**：对于所有网页应用，这是一个非常重要的指标。用大白话来说，就是进入页面之后，应用渲染完整个手机屏幕（未滚动之前）内容的时间。需要注意的是，业界对于这个指标其实同样并没有确切的定论，比如这个时间是否包含手机屏幕内图片的渲染完成时间。　\n\n> **用户可交互时间**：顾名思义，也就是用户可以与应用进行交互的时间。一般来讲，我们认为是 domready 的时间，因为我们通常会在这时候绑定事件操作。如果页面中涉及交互的脚本没有下载完成，那么当然没有到达所谓的用户可交互时间。那么如何定义 domready 时间呢？我推荐参考司徒正美的文章：[何谓 domReady](https://www.cnblogs.com/rubylouvre/p/4536334.html)。\n\n以上时间，我们可以通过下图对比认识：\n\n![enter image description here](https://images.gitbook.cn/ef4f34e0-b8f3-11e9-953b-67880772eeef)\n\n这是我访问 Medium 移动网站分析得到的时序图，读者可根据网页加载的不同时段，体会各个时间节点的变化。更完整的信息由 Chrome DevTool 给出：\n\n![enter image description here](https://images.gitbook.cn/32f5c790-b8f4-11e9-953b-67880772eeef)\n\n通过 Google Lighthouse 分析得到：\n\n![enter image description here](https://images.gitbook.cn/4b3730f0-b8f4-11e9-b842-d54514bdf4a6)\n\n请注意 First Meaningful Paint 和 First Contentful Paint 以及 Time to Interactive（可交互时间）被收录其中。\n\n这里我们先对这些时间节点以及数据有一个感性的认知，后面将会逐步学习如何统计这些时间，做出如上图一样的分析系统。接下来，我们继续学习一些概念。\n\n> **总下载时间**：页面所有资源加载完成所需要的时间。一般可以统计 window.onload 时间，这样可以统计出同步加载的资源全部加载完的耗时。如果页面中存在较多异步渲染，也可以将异步渲染全部完成的时间作为总下载时间。\n>\n> **自定义指标**：由于应用特点不同，我们可以根据需求自定义时间。比如，一个类似 Instagram 的页面，页面由图片瀑布流组成，那么我们可能非常关心屏幕中第一排图片渲染完成的时间。\n\n**这里我们提一下，DOMContentLoaded 与 load 事件的区别**。其实从这两个事件的命名我们就能体会，DOMContentLoaded 指的是文档中 DOM 内容加载完毕的时间，也就是说 HTML 结构已经完整。但是我们知道，很多页面包含图片、特殊字体、视频、音频等其他资源，这些资源由网络请求获取，DOM 内容加载完毕时，由于这些资源往往需要额外的网络请求，还没有请求或者渲染完成。而当页面上所有资源加载完成后，load 事件才会被触发。因此，在时间线上，load 事件往往会落后于 DOMContentLoaded 事件。\n\n如图：\n\n![enter image description here](https://images.gitbook.cn/64c369d0-b8f4-11e9-b842-d54514bdf4a6)\n\n表示页面加载一共请求了 13 个资源，大小为 309 KB，DOMContentLoaded 时间为 2.82 s，load 时间为 2.95 s，页面完全稳定时间 5.38 s 。\n\n### <font color=13aa6c>FMP 的智能获取算法</font>\n\n另外结合自定义指标和首次有意义绘制（FMP）时间，稍做延伸：我们知道首次有意义绘制比较主观，开发者可以自行指定究竟哪些属于有意义的渲染元素。我们也可以通过 **FMP 的智能获取算法**来完成自定义 FMP 时间。该算法实现过程如下。\n\n**首先**，获取有意义的渲染元素，一般认为：\n\n- 体积占比比较大\n- 屏幕内可见占比大\n- 属于资源加载元素（img、svg、video、object、embed、canvas）\n- 主要元素是多个组成的\n\n具备这几个条件的元素，更像是有意义的元素。根据元素对页面视觉的贡献，我们对元素特点的权重进行划分：\n\n```\nconst weightMap = {\n    SVG: 2,\n    IMG: 2,\n    CANVAS: 3,\n    OBJECT: 3,\n    EMBED: 3,\n    VIDEO: 3,\n    OTHER: 1\n}\n```\n\n**接着**，我们对整个页面进行深度优先遍历搜索，之后对每一个元素进行分数计算，具体通过 element.getBoundingClientRect 获取元素的位置和大小，然后通过计算「width * height * weight * 元素在 viewport 的面积占比」的乘积，确定元素的最终得分。接着将该元素的子元素得分之和与其得分进行比较，取较大值，记录得分元素集。这个集合是“可视区域内得分最高的元素的集合”，我们会对这个集合的得分取均值，然后过滤出在平均分之上的元素集合，进行时间计算。这就得到了一个智能的 FMP 时间。\n\n**最终**，代码由 qbright 实现：[fmp-timing](https://github.com/qbright/fmp-timing)，感兴趣的读者可以自行了解细节。\n\n### <font color=13aa6c>性能数据获取</font>\n\n了解了上述性能指标，我们来分析一下这些性能指标数据究竟该如何计算获取。\n\n#### window.performance：强大但有缺点\n\n目前最为流行和靠谱的方案是采用 Performance API，它非常强大：不仅包含了页面性能的相关数据，还带有页面资源加载和异步请求的相关数据。\n\n调用 window.performance.timing 会返回一个对象，这个对象包含各种页面加载和渲染的时间节点。如图：\n\n![enter image description here](https://images.gitbook.cn/ba109250-b8f4-11e9-953b-67880772eeef)\n\n具体解析：\n\n```\nconst window.performance = { \n    memory: {\n        usedJSHeapSize,\n        totalJSHeapSize,\n        jsHeapSizeLimit\n    },\n \n    navigation: {\n        // 页面重定向跳转到当前页面的次数\n        redirectCount,\n        // 以哪种方式进入页面\n        // 0 正常跳转进入\n        // 1 window.location.reload() 重新刷新\n        // 2 通过浏览器历史记录，以及前进后退进入\n        // 255 其他方式进入\n        type,         \n    },\n \n    timing: {\n        // 等于前一个页面 unload 时间，如果没有前一个页面，则等于 fetchStart 时间\n        navigationStart\n        // 前一个页面 unload 时间，如果没有前一个页面或者前一个页面与当前页面不同域，则值为 0\n        unloadEventStart,\n        // 前一个页面 unload 事件绑定的回调函数执行完毕的时间\n        unloadEventEnd,\n        redirectStart,\n        redirectEnd,\n        // 检查缓存前，准备请求第一个资源的时间\n        fetchStart,\n        // 域名查询开始的时间\n        domainLookupStart,\n        // 域名查询结束的时间\n        domainLookupEnd,\n        // HTTP（TCP） 开始建立连接的时间\t        connectStart,\n        // HTTP（TCP）建立连接结束的时间\n        connectEnd,\n        secureConnectionStart,\n        // 连接建立完成后，请求文档开始的时间\n        requestStart,\n        // 连接建立完成后，文档开始返回并收到内容的时间\n        responseStart,\n        // 最后一个字节返回并收到内容的时间\n        responseEnd,\n        // Document.readyState 值为 loading 的时间\n        domLoading,\n        // Document.readyState 值为 interactive\n        domInteractive,\n        // DOMContentLoaded 事件开始时间\n        domContentLoadedEventStart,\n        // DOMContentLoaded 事件结束时间\n        domContentLoadedEventEnd,\n        // Document.readyState 值为 complete 的时间\t        domComplete,\n        // load 事件开始的时间\n        loadEventStart,\n        // load 事件结束的时间\n        loadEventEnd\n    }\n}\n```\n\n根据这些时间节点，我们选择相应的时间两两做差，便可以计算出一些典型指标：\n\n```\nconst calcTime = () => {\n    let times = {}\n    let t = window.performance.timing\n      \n    // 重定向时间\n    times.redirectTime = t.redirectEnd - t.redirectStart\n      \n    // DNS 查询耗时\n    times.dnsTime = t.domainLookupEnd - t.domainLookupStart\n      \n    // TCP 建立连接完成握手的时间\n    connect = t.connectEnd - t.connectStart\n      \n    // TTFB 读取页面第一个字节的时间\n    times.ttfbTime = t.responseStart - t.navigationStart\n      \n    // DNS 缓存时间\n    times.appcacheTime = t.domainLookupStart - t.fetchStart\n      \n    // 卸载页面的时间\n    times.unloadTime = t.unloadEventEnd - t.unloadEventStart\n      \n    // TCP 连接耗时\n    times.tcpTime = t.connectEnd - t.connectStart\n      \n    // request 请求耗时\n    times.reqTime = t.responseEnd - t.responseStart\n      \n    // 解析 DOM 树耗时\n    times.analysisTime = t.domComplete - t.domInteractive\n      \n    // 白屏时间\n    times.blankTime = t.domLoading - t.fetchStart\n      \n    // domReadyTime 即用户可交互时间\n    times.domReadyTime = t.domContentLoadedEventEnd - t.fetchStart\n      \n    // 用户等待页面完全可用的时间\n    times.loadPage = t.loadEventEnd - t.navigationStart\n\n    return times\n}\n```\n\n**这个 API 非常强大，但是并不适用所有场景**。比如：使用 window.performance.timing 所获的数据，在单页应用中改变 URL 但不刷新页面的情况下（单页应用典型路由方案），是不会更新的，还需要开发者重新设计统计方案。同时，可能无法满足一些自定义的数据。下面我们来分析一下部分无法直接获取的性能指标的计算方法。\n\n#### 自定义时间计算\n\n**首屏时间的计算实现方式不尽相同，开发者可以根据自己的需求来确定首屏时间的计算方式。我列举几个典型的方案。**\n\n对于**网页高度小于屏幕**的网站来说，统计首屏时间非常简单，只要在页面底部加上脚本，完成当前时间的打印即可，这个时间再通过与 window.performance.timing.navigationStart 时间做差，即得到首屏渲染耗时。\n\n但网页高度小于屏幕的站点毕竟是少数：对于**网页高度大于一屏**的页面来说，只要在估算接近于一屏幕的最后一个元素的位置后，插入计算脚本即可：\n\n```\nvar time = +new Date() - window.performance.timing.navigationStart\n```\n\n显然上述方案是比较理想化的，我们很难通过自动化工具或者一段集中管理的代码进行统计。开发者直接在页面 DOM 中插入时间统计，不仅代码侵入性太强，而且成本很高。同时，这样的计算方式其实并没有考虑首屏图片加载的情况，也就是说首屏图片未加载完的情况下，我们也认为加载已经完成。如果要考虑首屏图片的加载，建议使用**集中化脚本统计首屏时间**的方法：使用定时器不断检测 img 节点，判断图片是否在首屏且加载完成，找到首屏加载最慢的图片加载完成的时间，从而计算出首屏时间。如果首屏有没有图片，就用 domready 时间：\n\n```\nconst win = window\nconst firstScreenHeight = win.screen.height\nlet firstScreenImgs = []\nlet isFindLastImg = false\nlet allImgLoaded = false\nlet collect = []\n\nconst t = setInterval(() => {\n    let i, img\n    if (isFindLastImg) {\n        if (firstScreenImgs.length) {\n            for (i = 0; i < firstScreenImgs.length; i++) {\n                img = firstScreenImgs[i]\n                if (!img.complete) {\n                    allImgLoaded = false\n                    break\n                } else {\n                    allImgLoaded = true\n                }\n            }\n        } else {\n            allImgLoaded = true\n        }\n        if (allImgLoaded) {\n            collect.push({\n                firstScreenLoaded: startTime - Date.now()\n            })\n            clearInterval(t)\n        }\n    } else {\n        var imgs = body.querySelector(&apos;img&apos;)\n        for (i = 0; i < imgs.length; i++) {\n            img = imgs[i]\n            let imgOffsetTop = getOffsetTop(img)\n            if (imgOffsetTop > firstScreenHeight) {\n                isFindLastImg = true\n                break\n            } else if (imgOffsetTop <= firstScreenHeight \n            && !img.hasPushed) {\n                img.hasPushed = 1\n                firstScreenImgs.push(img)\n            }\n        }\n    }\n}, 0)\n\nconst doc = document\ndoc.addEventListener(&apos;DOMContentLoaded&apos;, () => {\n    const imgs = body.querySelector(&apos;img&apos;)\n    if (!imgs.length) {\n        isFindLastImg = true\n    }\n})\n\nwin.addEventListener(&apos;load&apos;, () => {\n    allImgLoaded = true\n    isFindLastImg = true\n    if (t) {\n        clearInterval(t)\n    }\n})\n```\n\n另外一种方式是不使用定时器，且默认影响首屏时间的主要因素是图片的加载，如果没有图片，纯粹渲染文字是很快的，因此，可以通过统计首屏内图片的加载时间获取首屏渲染完成的时间。\n\n```\n(function logFirstScreen() {\n    let images = document.getElementsByTagName(&apos;img&apos;)\n    let iLen = images.length\n    let curMax = 0\n    let inScreenLen = 0\n    \n    // 图片的加载回调\n    function imageBack() {\n        this.removeEventListener\n        && this.removeEventListener(&apos;load&apos;, imageBack, !1)\n        if (++curMax === inScreenLen) {\n            // 所有在首屏的图片均已加载完成的话，发送日志\n            log()\n        }   \n    } \n    // 对于所有的位于指定区域的图片，绑定回调事件\n    for (var s = 0; s < iLen; s++) {\n        var img = images[s]\n        var offset = {\n            top: 0\n        }\n        var curImg = img\n        while (curImg.offsetParent) {\n            offset.top += curImg.offsetTop\n            curImg = curImg.offsetParent\n        }\n        // 判断图片在不在首屏\n        if (document.documentElement.clientHeight < offset.top) {\n            continue\n        }\n        // 图片还没有加载完成的话\n        if (!img.complete) {\n            inScreenLen++\n            img.addEventListener(&apos;load&apos;, imageBack, !1)\n        }\n    }\n    // 如果首屏没有图片的话，直接发送日志\n    if (inScreenLen === 0) {\n        log()\n    }\n    // 发送日志进行统计\n    function log () {\n        window.logInfo.firstScreen = +new Date() - window.performance.timing.navigationStart\n        console.log(&apos;首屏时间：&apos;, +new Date() - window.performance.timing.navigationStart)\n    }\n})()\n```\n\n可见，除了使用教科书般强大的 Performance API 外，我们也完全拥有自主权来统计各种页面性能数据。这就需要开发者根据具体场景和业务需求，结合社区已有方案，找到完全适合自己的统计采集方式。\n\n这节课我们介绍了性能核心指标以及获取方式，关键在于合理利用强大的 API。与此同时，对于“开放性”数据，我们需要结合实际，灵活进行开发。\n\n### <font color=13aa6c>分享交流</font>\n\n请大家留言分享「性能优化」相关的开发心得，你也可以阅读完下一节全部完成这个主题后再来分享。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空解答）。**你的分享不仅帮助他人，更会提升自己。**\n\n同时，欢迎说说自己最想了解的主题，课程内容会根据大家的意见和建议迭代和完善。\n\n>**为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。**","pdfUrl":"","reader":"","duration":"","title":"性能监控和错误收集与上报（上）","column":"5c91c813968b1d64b1e08fde","isNotification":false,"htmlContent":"<p>性能始终是前端领域非常重要的话题，它直接决定了产品体验的优劣，重要性无需赘言。我们在体验一个产品时，能够直观感受到其性能，可是如何量化衡量性能的好坏呢？</p>\n<p>同时，我们无法保证程序永远不出问题，如何在程序出现问题时及时获得现场数据、还原现场，以做出准确地响应呢？</p>\n<p>离开了实际场景谈这些话题都是“耍流氓”，性能数据的监控、错误信息的收集和上报应该都要基于线上真实环境。这对于我们随时掌控线上产品，优化应用体验具有重大意义。</p>\n<p>本节课程，我们就聚焦在性能监控和错误收集与上报系统上。希望通过学习，每个人都心中有数，做到不仅能够分析性能数据、处理错误，还能建设一个成熟的配套系统。</p>\n<p>本节课主要知识点：</p>\n<img src=\"https://images.gitbook.cn/9f1e2980-4ed7-11e9-b0b8-a9c8a3696845\" width=500>\n<p>接下来，我们通过 2 节内容来学习这个主题。</p>\n<h3><a id=\"font_color13aa6cfont_14\"></a><font color=13aa6c>性能监控指标</font></h3>\n<p>既然是性能监控，那我们首先需要明确衡量指标。一般来说，业界认可的常用指标有：</p>\n<ul>\n<li>首次绘制（FP）和首次有内容绘制（FCP）时间</li>\n<li>首次有意义绘制（FMP）时间</li>\n<li>首屏时间</li>\n<li>用户可交互（TTI）时间</li>\n<li>总下载时间</li>\n<li>自定义指标</li>\n</ul>\n<p>接下来分别看看每个指标的含义。</p>\n<blockquote>\n<p><strong>首次绘制（FP）时间</strong>：对于应用页面，用户在视觉上首次出现不同于跳转之前的内容时间点，或者说是页面发生第一次绘制的时间点。</p>\n<p><strong>首次有内容绘制（FCP）时间</strong>：指浏览器完成渲染 DOM 中第一个内容的时间点，可能是文本、图像或者其他任何元素，此时用户应该在视觉上有直观的感受。</p>\n<p><strong>首次有意义绘制（FMP）时间</strong>：指页面关键元素渲染时间。这个概念并没有标准化定义，因为关键元素可以由开发者自行定义——究竟什么是“有意义”的内容，只有开发者或者产品经理自己了解。</p>\n<p><strong>首屏时间</strong>：对于所有网页应用，这是一个非常重要的指标。用大白话来说，就是进入页面之后，应用渲染完整个手机屏幕（未滚动之前）内容的时间。需要注意的是，业界对于这个指标其实同样并没有确切的定论，比如这个时间是否包含手机屏幕内图片的渲染完成时间。</p>\n</blockquote>\n<blockquote>\n<p><strong>用户可交互时间</strong>：顾名思义，也就是用户可以与应用进行交互的时间。一般来讲，我们认为是 domready 的时间，因为我们通常会在这时候绑定事件操作。如果页面中涉及交互的脚本没有下载完成，那么当然没有到达所谓的用户可交互时间。那么如何定义 domready 时间呢？我推荐参考司徒正美的文章：<a href=\"https://www.cnblogs.com/rubylouvre/p/4536334.html\" target=\"_blank\">何谓 domReady</a>。</p>\n</blockquote>\n<p>以上时间，我们可以通过下图对比认识：</p>\n<p><img src=\"https://images.gitbook.cn/ef4f34e0-b8f3-11e9-953b-67880772eeef\" alt=\"enter image description here\" /></p>\n<p>这是我访问 Medium 移动网站分析得到的时序图，读者可根据网页加载的不同时段，体会各个时间节点的变化。更完整的信息由 Chrome DevTool 给出：</p>\n<p><img src=\"https://images.gitbook.cn/32f5c790-b8f4-11e9-953b-67880772eeef\" alt=\"enter image description here\" /></p>\n<p>通过 Google Lighthouse 分析得到：</p>\n<p><img src=\"https://images.gitbook.cn/4b3730f0-b8f4-11e9-b842-d54514bdf4a6\" alt=\"enter image description here\" /></p>\n<p>请注意 First Meaningful Paint 和 First Contentful Paint 以及 Time to Interactive（可交互时间）被收录其中。</p>\n<p>这里我们先对这些时间节点以及数据有一个感性的认知，后面将会逐步学习如何统计这些时间，做出如上图一样的分析系统。接下来，我们继续学习一些概念。</p>\n<blockquote>\n<p><strong>总下载时间</strong>：页面所有资源加载完成所需要的时间。一般可以统计 window.onload 时间，这样可以统计出同步加载的资源全部加载完的耗时。如果页面中存在较多异步渲染，也可以将异步渲染全部完成的时间作为总下载时间。</p>\n<p><strong>自定义指标</strong>：由于应用特点不同，我们可以根据需求自定义时间。比如，一个类似 Instagram 的页面，页面由图片瀑布流组成，那么我们可能非常关心屏幕中第一排图片渲染完成的时间。</p>\n</blockquote>\n<p><strong>这里我们提一下，DOMContentLoaded 与 load 事件的区别</strong>。其实从这两个事件的命名我们就能体会，DOMContentLoaded 指的是文档中 DOM 内容加载完毕的时间，也就是说 HTML 结构已经完整。但是我们知道，很多页面包含图片、特殊字体、视频、音频等其他资源，这些资源由网络请求获取，DOM 内容加载完毕时，由于这些资源往往需要额外的网络请求，还没有请求或者渲染完成。而当页面上所有资源加载完成后，load 事件才会被触发。因此，在时间线上，load 事件往往会落后于 DOMContentLoaded 事件。</p>\n<p>如图：</p>\n<p><img src=\"https://images.gitbook.cn/64c369d0-b8f4-11e9-b842-d54514bdf4a6\" alt=\"enter image description here\" /></p>\n<p>表示页面加载一共请求了 13 个资源，大小为 309 KB，DOMContentLoaded 时间为 2.82 s，load 时间为 2.95 s，页面完全稳定时间 5.38 s 。</p>\n<h3><a id=\"font_color13aa6cFMP_font_65\"></a><font color=13aa6c>FMP 的智能获取算法</font></h3>\n<p>另外结合自定义指标和首次有意义绘制（FMP）时间，稍做延伸：我们知道首次有意义绘制比较主观，开发者可以自行指定究竟哪些属于有意义的渲染元素。我们也可以通过 <strong>FMP 的智能获取算法</strong>来完成自定义 FMP 时间。该算法实现过程如下。</p>\n<p><strong>首先</strong>，获取有意义的渲染元素，一般认为：</p>\n<ul>\n<li>体积占比比较大</li>\n<li>屏幕内可见占比大</li>\n<li>属于资源加载元素（img、svg、video、object、embed、canvas）</li>\n<li>主要元素是多个组成的</li>\n</ul>\n<p>具备这几个条件的元素，更像是有意义的元素。根据元素对页面视觉的贡献，我们对元素特点的权重进行划分：</p>\n<pre><code class=\"lang-\">const weightMap = {\n    SVG: 2,\n    IMG: 2,\n    CANVAS: 3,\n    OBJECT: 3,\n    EMBED: 3,\n    VIDEO: 3,\n    OTHER: 1\n}\n</code></pre>\n<p><strong>接着</strong>，我们对整个页面进行深度优先遍历搜索，之后对每一个元素进行分数计算，具体通过 element.getBoundingClientRect 获取元素的位置和大小，然后通过计算「width * height * weight * 元素在 viewport 的面积占比」的乘积，确定元素的最终得分。接着将该元素的子元素得分之和与其得分进行比较，取较大值，记录得分元素集。这个集合是“可视区域内得分最高的元素的集合”，我们会对这个集合的得分取均值，然后过滤出在平均分之上的元素集合，进行时间计算。这就得到了一个智能的 FMP 时间。</p>\n<p><strong>最终</strong>，代码由 qbright 实现：<a href=\"https://github.com/qbright/fmp-timing\" target=\"_blank\">fmp-timing</a>，感兴趣的读者可以自行了解细节。</p>\n<h3><a id=\"font_color13aa6cfont_94\"></a><font color=13aa6c>性能数据获取</font></h3>\n<p>了解了上述性能指标，我们来分析一下这些性能指标数据究竟该如何计算获取。</p>\n<h4><a id=\"windowperformance_98\"></a>window.performance：强大但有缺点</h4>\n<p>目前最为流行和靠谱的方案是采用 Performance API，它非常强大：不仅包含了页面性能的相关数据，还带有页面资源加载和异步请求的相关数据。</p>\n<p>调用 window.performance.timing 会返回一个对象，这个对象包含各种页面加载和渲染的时间节点。如图：</p>\n<p><img src=\"https://images.gitbook.cn/ba109250-b8f4-11e9-953b-67880772eeef\" alt=\"enter image description here\" /></p>\n<p>具体解析：</p>\n<pre><code class=\"lang-\">const window.performance = { \n    memory: {\n        usedJSHeapSize,\n        totalJSHeapSize,\n        jsHeapSizeLimit\n    },\n \n    navigation: {\n        // 页面重定向跳转到当前页面的次数\n        redirectCount,\n        // 以哪种方式进入页面\n        // 0 正常跳转进入\n        // 1 window.location.reload() 重新刷新\n        // 2 通过浏览器历史记录，以及前进后退进入\n        // 255 其他方式进入\n        type,         \n    },\n \n    timing: {\n        // 等于前一个页面 unload 时间，如果没有前一个页面，则等于 fetchStart 时间\n        navigationStart\n        // 前一个页面 unload 时间，如果没有前一个页面或者前一个页面与当前页面不同域，则值为 0\n        unloadEventStart,\n        // 前一个页面 unload 事件绑定的回调函数执行完毕的时间\n        unloadEventEnd,\n        redirectStart,\n        redirectEnd,\n        // 检查缓存前，准备请求第一个资源的时间\n        fetchStart,\n        // 域名查询开始的时间\n        domainLookupStart,\n        // 域名查询结束的时间\n        domainLookupEnd,\n        // HTTP（TCP） 开始建立连接的时间\t        connectStart,\n        // HTTP（TCP）建立连接结束的时间\n        connectEnd,\n        secureConnectionStart,\n        // 连接建立完成后，请求文档开始的时间\n        requestStart,\n        // 连接建立完成后，文档开始返回并收到内容的时间\n        responseStart,\n        // 最后一个字节返回并收到内容的时间\n        responseEnd,\n        // Document.readyState 值为 loading 的时间\n        domLoading,\n        // Document.readyState 值为 interactive\n        domInteractive,\n        // DOMContentLoaded 事件开始时间\n        domContentLoadedEventStart,\n        // DOMContentLoaded 事件结束时间\n        domContentLoadedEventEnd,\n        // Document.readyState 值为 complete 的时间\t        domComplete,\n        // load 事件开始的时间\n        loadEventStart,\n        // load 事件结束的时间\n        loadEventEnd\n    }\n}\n</code></pre>\n<p>根据这些时间节点，我们选择相应的时间两两做差，便可以计算出一些典型指标：</p>\n<pre><code class=\"lang-\">const calcTime = () =&gt; {\n    let times = {}\n    let t = window.performance.timing\n      \n    // 重定向时间\n    times.redirectTime = t.redirectEnd - t.redirectStart\n      \n    // DNS 查询耗时\n    times.dnsTime = t.domainLookupEnd - t.domainLookupStart\n      \n    // TCP 建立连接完成握手的时间\n    connect = t.connectEnd - t.connectStart\n      \n    // TTFB 读取页面第一个字节的时间\n    times.ttfbTime = t.responseStart - t.navigationStart\n      \n    // DNS 缓存时间\n    times.appcacheTime = t.domainLookupStart - t.fetchStart\n      \n    // 卸载页面的时间\n    times.unloadTime = t.unloadEventEnd - t.unloadEventStart\n      \n    // TCP 连接耗时\n    times.tcpTime = t.connectEnd - t.connectStart\n      \n    // request 请求耗时\n    times.reqTime = t.responseEnd - t.responseStart\n      \n    // 解析 DOM 树耗时\n    times.analysisTime = t.domComplete - t.domInteractive\n      \n    // 白屏时间\n    times.blankTime = t.domLoading - t.fetchStart\n      \n    // domReadyTime 即用户可交互时间\n    times.domReadyTime = t.domContentLoadedEventEnd - t.fetchStart\n      \n    // 用户等待页面完全可用的时间\n    times.loadPage = t.loadEventEnd - t.navigationStart\n\n    return times\n}\n</code></pre>\n<p><strong>这个 API 非常强大，但是并不适用所有场景</strong>。比如：使用 window.performance.timing 所获的数据，在单页应用中改变 URL 但不刷新页面的情况下（单页应用典型路由方案），是不会更新的，还需要开发者重新设计统计方案。同时，可能无法满足一些自定义的数据。下面我们来分析一下部分无法直接获取的性能指标的计算方法。</p>\n<h4><a id=\"_218\"></a>自定义时间计算</h4>\n<p><strong>首屏时间的计算实现方式不尽相同，开发者可以根据自己的需求来确定首屏时间的计算方式。我列举几个典型的方案。</strong></p>\n<p>对于<strong>网页高度小于屏幕</strong>的网站来说，统计首屏时间非常简单，只要在页面底部加上脚本，完成当前时间的打印即可，这个时间再通过与 window.performance.timing.navigationStart 时间做差，即得到首屏渲染耗时。</p>\n<p>但网页高度小于屏幕的站点毕竟是少数：对于<strong>网页高度大于一屏</strong>的页面来说，只要在估算接近于一屏幕的最后一个元素的位置后，插入计算脚本即可：</p>\n<pre><code class=\"lang-\">var time = +new Date() - window.performance.timing.navigationStart\n</code></pre>\n<p>显然上述方案是比较理想化的，我们很难通过自动化工具或者一段集中管理的代码进行统计。开发者直接在页面 DOM 中插入时间统计，不仅代码侵入性太强，而且成本很高。同时，这样的计算方式其实并没有考虑首屏图片加载的情况，也就是说首屏图片未加载完的情况下，我们也认为加载已经完成。如果要考虑首屏图片的加载，建议使用<strong>集中化脚本统计首屏时间</strong>的方法：使用定时器不断检测 img 节点，判断图片是否在首屏且加载完成，找到首屏加载最慢的图片加载完成的时间，从而计算出首屏时间。如果首屏有没有图片，就用 domready 时间：</p>\n<pre><code class=\"lang-\">const win = window\nconst firstScreenHeight = win.screen.height\nlet firstScreenImgs = []\nlet isFindLastImg = false\nlet allImgLoaded = false\nlet collect = []\n\nconst t = setInterval(() =&gt; {\n    let i, img\n    if (isFindLastImg) {\n        if (firstScreenImgs.length) {\n            for (i = 0; i &lt; firstScreenImgs.length; i++) {\n                img = firstScreenImgs[i]\n                if (!img.complete) {\n                    allImgLoaded = false\n                    break\n                } else {\n                    allImgLoaded = true\n                }\n            }\n        } else {\n            allImgLoaded = true\n        }\n        if (allImgLoaded) {\n            collect.push({\n                firstScreenLoaded: startTime - Date.now()\n            })\n            clearInterval(t)\n        }\n    } else {\n        var imgs = body.querySelector(&apos;img&apos;)\n        for (i = 0; i &lt; imgs.length; i++) {\n            img = imgs[i]\n            let imgOffsetTop = getOffsetTop(img)\n            if (imgOffsetTop &gt; firstScreenHeight) {\n                isFindLastImg = true\n                break\n            } else if (imgOffsetTop &lt;= firstScreenHeight \n            &amp;&amp; !img.hasPushed) {\n                img.hasPushed = 1\n                firstScreenImgs.push(img)\n            }\n        }\n    }\n}, 0)\n\nconst doc = document\ndoc.addEventListener(&apos;DOMContentLoaded&apos;, () =&gt; {\n    const imgs = body.querySelector(&apos;img&apos;)\n    if (!imgs.length) {\n        isFindLastImg = true\n    }\n})\n\nwin.addEventListener(&apos;load&apos;, () =&gt; {\n    allImgLoaded = true\n    isFindLastImg = true\n    if (t) {\n        clearInterval(t)\n    }\n})\n</code></pre>\n<p>另外一种方式是不使用定时器，且默认影响首屏时间的主要因素是图片的加载，如果没有图片，纯粹渲染文字是很快的，因此，可以通过统计首屏内图片的加载时间获取首屏渲染完成的时间。</p>\n<pre><code class=\"lang-\">(function logFirstScreen() {\n    let images = document.getElementsByTagName(&apos;img&apos;)\n    let iLen = images.length\n    let curMax = 0\n    let inScreenLen = 0\n    \n    // 图片的加载回调\n    function imageBack() {\n        this.removeEventListener\n        &amp;&amp; this.removeEventListener(&apos;load&apos;, imageBack, !1)\n        if (++curMax === inScreenLen) {\n            // 所有在首屏的图片均已加载完成的话，发送日志\n            log()\n        }   \n    } \n    // 对于所有的位于指定区域的图片，绑定回调事件\n    for (var s = 0; s &lt; iLen; s++) {\n        var img = images[s]\n        var offset = {\n            top: 0\n        }\n        var curImg = img\n        while (curImg.offsetParent) {\n            offset.top += curImg.offsetTop\n            curImg = curImg.offsetParent\n        }\n        // 判断图片在不在首屏\n        if (document.documentElement.clientHeight &lt; offset.top) {\n            continue\n        }\n        // 图片还没有加载完成的话\n        if (!img.complete) {\n            inScreenLen++\n            img.addEventListener(&apos;load&apos;, imageBack, !1)\n        }\n    }\n    // 如果首屏没有图片的话，直接发送日志\n    if (inScreenLen === 0) {\n        log()\n    }\n    // 发送日志进行统计\n    function log () {\n        window.logInfo.firstScreen = +new Date() - window.performance.timing.navigationStart\n        console.log(&apos;首屏时间：&apos;, +new Date() - window.performance.timing.navigationStart)\n    }\n})()\n</code></pre>\n<p>可见，除了使用教科书般强大的 Performance API 外，我们也完全拥有自主权来统计各种页面性能数据。这就需要开发者根据具体场景和业务需求，结合社区已有方案，找到完全适合自己的统计采集方式。</p>\n<p>这节课我们介绍了性能核心指标以及获取方式，关键在于合理利用强大的 API。与此同时，对于“开放性”数据，我们需要结合实际，灵活进行开发。</p>\n<h3><a id=\"font_color13aa6cfont_351\"></a><font color=13aa6c>分享交流</font></h3>\n<p>请大家留言分享「性能优化」相关的开发心得，你也可以阅读完下一节全部完成这个主题后再来分享。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空解答）。<strong>你的分享不仅帮助他人，更会提升自己。</strong></p>\n<p>同时，欢迎说说自己最想了解的主题，课程内容会根据大家的意见和建议迭代和完善。</p>\n<blockquote>\n<p><strong>为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。</strong></p>\n</blockquote>\n","readingStatistics":0,"createdAt":"2019-03-26T06:22:39.857Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":31,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FoThASW9dVEPMEo9nP-zaOfbKyLZ"},{"_id":"5c99c5dbccb24267c1d01b98","communication_start_time":null,"type":1,"audioPath":"","abstract":"","content":"上一节课我们学习了性能监控方面的知识。这一节来深入了解关于错误和异常的收集，并学习如何统一将这些信息进行上报。\n\n在此之前，我们先回顾一下这个主题的知识点：\n\n<img src=\"https://images.gitbook.cn/9f1e2980-4ed7-11e9-b0b8-a9c8a3696845\" width=550>\n\n### <font color=13aa6c>错误信息收集</font>\n\n提到错误收集方案，大家应该会首先想到两种：try catch 捕获错误和 window.onerror 监听。\n\n####  认识 try catch 方案\n\n我们先看一下 try catch 方案：\n\n```\ntry {\n    // 代码块\n} catch(e) {\n    // 错误处理\n    // 在这里，我们可以将错误信息发送给服务端\n}\n```\n\n这种方式需要开发者对预估有错误风险的代码进行包裹，这个包裹过程可以手动添加，也可以通过自动化工具或类库完成。自动化方案的基本原理是 AST 技术：比如 UglifyJS 就提供操作 AST 的 API，我们可以对每个函数添加 try catch，社区上 [foio](https://github.com/foio/try-catch-global.js/blob/master/try-catch-global.js) 的实现，就是一个很好的例子：\n\n```\nconst fs = require(&apos;fs&apos;)\nconst _ = require(&apos;lodash&apos;)\nconst UglifyJS = require(&apos;uglify-js&apos;)\n    \nconst isASTFunctionNode =  node => node instanceof UglifyJS.AST_Defun || node instanceof UglifyJS.AST_Function\n​   \nconst globalFuncTryCatch = (source, errorHandler) => {\n    if (!_.isFunction(errorHandler)) {\n        throw &apos;errorHandler should be a valid function&apos;\n    }\n    \n    const errorHandlerSource = errorHandler.toString()\n    const errorHandlerAST = UglifyJS.parse(&apos;(&apos; + errorHandlerSource + &apos;)(error);&apos;)\n    var tryCatchAST = UglifyJS.parse(&apos;try{}catch(error){}&apos;)\n    const sourceAST = UglifyJS.parse(source)\n    var topFuncScope = []\n    \n    tryCatchAST.body[0].catch.body[0] = errorHandlerAST\n    \n    const walker = new UglifyJS.TreeWalker(function (node) {\n        if (isASTFunctionNode(node)) {\n            topFuncScope.push(node)\n        }\n    })\n    sourceAST.walk(walker)\n    sourceAST.transform(transfer)\n\n    const transfer = new UglifyJS.TreeTransformer(null,\n        node => {\n            if (isASTFunctionNode(node) && _.includes(topFuncScope, node)) {\n                var stream = UglifyJS.OutputStream()\n                for (var i = 0; i < node.body.length; i++) {\n                    node.body[i].print(stream)\n                }\n                var innerFuncCode = stream.toString()\n                tryCatchAST.body[0].body.splice(0, tryCatchAST.body[0].body.length)\n                var innerTyrCatchNode = UglifyJS.parse(innerFuncCode, {toplevel: tryCatchAST.body[0]})\n                node.body.splice(0, node.body.length)\n                return UglifyJS.parse(innerTyrCatchNode.print_to_string(), {toplevel: node});\n            }\n        })\n    const outputCode = sourceAST.print_to_string({beautify: true})\n    return outputCode\n}\n    \nmodule.exports.globalFuncTryCatch = globalFuncTryCatch\n```\n\n我们从 globalFuncTryCatch 函数的第一个参数中获得目标代码 source，将其转换为 AST：\n\n```\nconst sourceAST = UglifyJS.parse(source)\n```\n\nglobalFuncTryCatch 函数的第二个参数为开发者定义的在出现错误时的响应函数，我们将其字符串化并转为 AST，并插入到 catch 块当中：\n\n```\nvar tryCatchAST = UglifyJS.parse(&apos;try{}catch(error){}&apos;)\nconst errorHandlerSource = errorHandler.toString()\nconst errorHandlerAST = UglifyJS.parse(&apos;(&apos; + errorHandlerSource + &apos;)(error);&apos;)\ntryCatchAST.body[0].catch.body[0] = errorHandlerAST\n```\n\n这样，借助于 globalFuncTryCatch，我们可以对每个函数添加 try catch 语句，并根据 globalFuncTryCatch 的第二个参数，传入自定义的错误处理函数（可以在该函数中进行错误上报）：\n\n```\nglobalFuncTryCatch(inputCode, function (error) {\n    // 此处是异常处理代码，可以上报并记录日志\n    // ...\n})\n```\n\n关键之处在于使用 UglifyJS 的能力，对 AST 语法树进行遍历，并转换：\n\n```\nconst walker = new UglifyJS.TreeWalker(function (node) {\n    if (isASTFunctionNode(node)) {\n        topFuncScope.push(node)\n    }\n})\nsourceAST.walk(walker)\nsourceAST.transform(transfer)\n```\n\n最终再返回经过处理后的代码：\n\n```\nconst outputCode = sourceAST.print_to_string({beautify: true})\nreturn outputCode\n```\n\n使用 try catch，我们可以保证页面不崩溃，并对错误进行兜底处理，这是一个非常好的习惯。\n\n#### try catch 方案的局限性\n\n但是 try catch 处理异常的能力有限，对于运行时非异步错误，它并没有问题。但是对于：\n\n- 语法错误\n- 异步错误\n\ntry catch 就无法 cover 了。我们来看一个运行时非异步错误：\n\n```\ntry {\n    a // 未定义变量 \n} catch(e) {\n    console.log(e)\n}\n```\n\n可以被 try catch 处理。但是，将上述代码改动为语法错误：\n\n```\ntry {\n    var a =\\ &apos;a&apos;\n} catch(e) {\n    console.log(e);\n}\n```\n\n就无法捕获。\n\n我们再看一下异步的情况：\n\n```\ntry {\n    setTimeout(() => {\n        a\n    })\n} catch(e) {\n    console.log(e)\n}\n```\n\n也无法捕获。\n\n![enter image description here](https://images.gitbook.cn/b674d7f0-bfd9-11e9-8e2c-3b4fd17ad6da)\n\n除非在 setTimeout 中再加一层 try catch：\n\n![enter image description here](https://images.gitbook.cn/d1bc0740-bfd9-11e9-a5f2-bfb3232fc8ba)\n\n总结一下，**try catch 能力有限，且对于代码的侵入性较强。**\n\n#### 认识 window.onerror\n\n我们再看一下 window.onerror 对错误进行处理的方案：开发者只需要给 window 添加 onerror 事件监听，同时**注意需要将 window.onerror 放在所有脚本之前，这样才能对语法异常和运行异常进行处理。**\n\n```\nwindow.onerror = function (message, source, lineno, colno, error) { \n\t// ... \n}\n```\n\n这里的参数较为重要，包含稍后需要上传的信息：\n\n- mesage 为错误信息提示\n- source 为错误脚本地址\n- lineno 为错误的代码所在行号\n- colno 为错误的代码所在列号\n- error 为错误的对象信息，比如 error.stack 获取错误的堆栈信息\n\nwindow.onerror 这种方式对代码侵入性较小，也就不必涉及 AST 自动插入脚本。除了对语法错误和网络错误（因为**网络请求异常不会事件冒泡**）无能为力以外，无论是异步还是非异步，onerror 都能捕获到运行时错误。\n\n但是需要注意的是，如果想使用 window.onerror 函数消化错误，需要显示返回 true，以保证错误不会向上抛出，控制台也就不会看到一堆错误提示。\n\n#### 跨域脚本的错误处理\n\n千万不要以为掌握了这些，就万事大吉了。现实场景多种多样，比如**一种情况是：加载不同域的 JavaScript 脚本**，这样的场景较为常见，比如加载第三方内容，以展示广告，进行性能测试、错误统计，或者想用第三方服务等。\n\n对于不同域的 JavaScript 文件，window.onerror 不能保证获取有效信息。由于安全原因，不同浏览器返回的错误信息参数可能并不一致。比如，跨域之后 window.onerror 在很多浏览器中是无法捕获异常信息的，要统一返回 Script error，这就需要 script 脚本设置为：\n\n```\ncrossorigin=\"anonymous\"\n```\n\n同时服务器添加 Access-Control-Allow-Origin 以指定允许哪些域的请求访问。\n\n#### 使用 source map 进行错误还原\n\n到目前为止，我们已经学习了获取错误信息的“十八般武艺”。但是，如果错误脚本是经过压缩的，那么纵使你有千般本领，也无用武之地了，因为这样捕获到的错误信息的位置（行列号）就会出现较大偏差，错误代码也经过压缩而难以辨认。这时候就需要启用 source map。很多构建工具都支持 source map，比如我们利用 webpack 打包压缩生成的一份对应脚本的 map 文件进行追踪，在 webpack 中开启 source map 功能：\n\n```\nmodule.exports = {\n    // ...\n    devtool: &apos;#source-map&apos;,\n    // ...\n}\n```\n\n更多 source map 的内容，感兴趣的读者还可以参考以下资料：\n\n- [JavaScript Source Map 详解](http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html)\n- [Using source maps](https://webpack.js.org/guides/development/#using-source-maps)\n\nWebpack sourcemap 这里不是我们的重点，就不再展开。\n\n#### 对 Promise 错误处理\n\n**我们再来看一下针对 Promise 的错误收集与处理**。我们都提倡养成写 Promise 的时候最后写上 catch 函数的习惯。ESLint 插件 eslint-plugin-promise 会帮我们完成这项工作，使用规则：catch-or-return 来保障代码中所有的 promise（被显式返回的除外）都有相应的 catch 处理。比如这样的写法：\n\n```\nvar p = new Promise()\np.then(fn1)\np.then(fn1, fn2)\nfunction fn1() {\n\tp.then(doSomething)\n}\n```\n\n是无法通过代码检查的。\n\n这类 ESLint 插件基于 AST 实现，逻辑也很简单：\n\n```\nmodule.exports = {\n  meta: {\n    docs: {\n      // ...\n    },\n    messages: {\n       // ...\n    }\n  },\n  create(context) {\n    const options = context.options[0] || {}\n    const allowThen = options.allowThen\n    let terminationMethod = options.terminationMethod || &apos;catch&apos;\n\t\n    if (typeof terminationMethod === &apos;string&apos;) {\n      terminationMethod = [terminationMethod]\n    }\n\t\n    return {\n      ExpressionStatement(node) {\n        if (!isPromise(node.expression)) {\n          return\n        }\n\t\n        if (\n          allowThen &&\n          node.expression.type === &apos;CallExpression&apos; &&\n          node.expression.callee.type === &apos;MemberExpression&apos; &&\n          node.expression.callee.property.name === &apos;then&apos; &&\n          node.expression.arguments.length === 2\n        ) {\n          return\n        }\n\t\n        if (\n          node.expression.type === &apos;CallExpression&apos; &&\n          node.expression.callee.type === &apos;MemberExpression&apos; &&\n          terminationMethod.indexOf(node.expression.callee.property.name) !== -1\n        ) {\n          return\n        }\n\t\n        if (\n          node.expression.type === &apos;CallExpression&apos; &&\n          node.expression.callee.type === &apos;MemberExpression&apos; &&\n          node.expression.callee.property.type === &apos;Literal&apos; &&\n          node.expression.callee.property.value === &apos;catch&apos;\n        ) {\n          return\n        }\n\t\n        context.report({\n          node,\n          messageId: &apos;terminationMethod&apos;,\n          data: { terminationMethod }\n        })\n      }\n    }\n  }\n}\n```\n\n如果读者对于 AST 和 ESLint 相关内容感兴趣，请关注课程《代码风格规范和背后技术设计》，会展开分析这方面的话题。\n\n可能大家会想到，promise 实例的 then 方法中的第二个 onRejected 函数也能处理错误，这个和上面提到的 catch 方法有什么差别呢？事实上，我更加推荐 catch 方法，请看下面代码：\n\n```\nnew Promise((resolve, reject) => {\n    throw new Error()\n}).then( () => {\n    console.log(&apos;resolved&apos;)\n}, err => {\n    console.log(&apos;rejected&apos;)\n    throw err\n}).catch(err => {\n    console.log(err, &apos;catch&apos;)\n})\n```\n\n输出：rejected，在有 onRejected 的情况下，onRejected 发挥作用，catch 并未被调用。 而当：\n\n```\nnew Promise((resolve, reject) => {\n\tresolve()\n}).then(() => {\n\tthrow new Error()\n    console.log(&apos;resolved&apos;)\n}, err => {\n    console.log(&apos;rejected&apos;)\n    throw err\n}).catch(err => {\n    console.log(err, &apos;catch&apos;)\n})\n```\n\n输出：`VM705:10 Error at Promise.then (<anonymous>:4:9) \"catch\"`，此时 onRejected 并不能捕获 then 方法中第一个参数 onResolved 函数中的错误。一经对比，也许 catch 是进行错误处理更好的选择。但是，这两种方式各有特点，还是需要读者对 Promise 有较为深入的认识。\n\n除此之外，对于 Promise 的错误处理，我们还可以注册对 Promise 全局异常的捕获事件 unhandledrejection：\n\n```\nwindow.addEventListener(\"unhandledrejection\",  e => {\n    e.preventDefault()\n    console.log(e.reason)\n    return true\n})\n```\n\n这对于集中管理和错误收集更加友好。\n\n#### 处理网络加载错误\n\n前面介绍的处理方式都是对已经在浏览器端的脚本逻辑错误进行的，我们设想用 script 标签，link 标签进行脚本或者其他资源加载时，由于某种原因（可能是服务器错误，也可能是网络不稳定），导致了脚本请求失败，网络加载错误。\n\n```\n<script src=\"***.js\"></script>\n<link rel=\"stylesheet\" href=\"***.css\">\n```\n\n为了捕获这些加载异常，我们可以：\n\n```\n<script src=\"***.js\"  onerror=\"errorHandler(this)\"></script>\n<link rel=\"stylesheet\" href=\"***.css\" onerror=\"errorHandler(this)\">\n```\n\n除此之外，也可以使用 window.addEventListener(&apos;error&apos;) 方式对加载异常进行处理，注意这时候我们无法使用 window.onerror 进行处理，**因为 window.onerror 事件是通过事件冒泡获取 error 信息的，而网络加载错误是不会进行事件冒泡的。**\n\n这里多提一下，**不支持冒泡的事件还有**：鼠标聚焦 / 失焦（focus / blur）、鼠标移动相关事件（mouseleave / mouseenter）、一些 UI 事件（如 scroll、resize 等）。\n\n因此，我们也就知道 **window.addEventListener 不同于 window.onerror，它通过事件捕获获取 error 信息，从而可以对网络资源的加载异常进行处理：**\n\n```\nwindow.addEventListener(&apos;error&apos;, error => {\n    console.log(error)\n}, true)\n```\n\n**那么，怎么区分网络资源加载错误和其他一般错误呢**？这里有个小技巧，普通错误的 error 对象中会有一个 error.message 属性，表示错误信息，而资源加载错误对应的 error 对象却没有，因此可以根据下面代码进行判断：\n\n```\nwindow.addEventListener(&apos;error&apos;, error => {\n\tif (!error.message) {\n\t    // 网络资源加载错误\n\t\tconsole.log(error)\n\t}\n}, true)\n```\n\n但是，也因为没有 error.message 属性，我们也就没有额外信息获取具体加载的错误细节，现阶段也无法具体区分加载的错误类别：比如是 404 资源不存在还是服务端错误等，只能配合后端日志进行排查。\n\n**到这里，我们简单做一个总结，分析 window.onerror 和 window.addEventListener(&apos;error&apos;) 的区别。**\n\n- window.onerror 需要进行函数赋值：window.onerror = function() {//...}，因此重复声明后会被替换，后续赋值会覆盖之前的值。这是一个弊端。\n\n请看下图示例：\n\n![enter image description here](https://images.gitbook.cn/f275ddd0-bfd9-11e9-8e2c-3b4fd17ad6da)\n\n- 而 window.addEventListener(&apos;error&apos;) 可以绑定多个回调函数，按照绑定顺序依次执行，请看下图示例：\n\n![enter image description here](https://images.gitbook.cn/0be789d0-bfda-11e9-98b2-fde9741b330a)\n\n#### 页面崩溃收集和处理\n\n一个成熟的系统还需要收集崩溃和卡顿，对此我们可以监听 window 对象的 load 和 beforeunload 事件，并结合 sessionStorage 对网页崩溃实施监控：\n\n```\nwindow.addEventListener(&apos;load&apos;, () => {\n\tsessionStorage.setItem(&apos;good_exit&apos;, &apos;pending&apos;)\n})\n\t\nwindow.addEventListener(&apos;beforeunload&apos;, () => {\n\tsessionStorage.setItem(&apos;good_exit&apos;, &apos;true&apos;)\n})\n\t\nif(sessionStorage.getItem(&apos;good_exit&apos;) &&\n\tsessionStorage.getItem(&apos;good_exit&apos;) !== &apos;true&apos;) {\n\t// 捕获到页面崩溃\n}\n```\n\n代码很简单，思路是首先在网页 load 事件的回调里：利用 sessionStorage 记录 good\\_exit 值为 pending；接下来，在页面无异常退出前，即 beforeunload 事件回调中，修改 sessionStorage 记录的 good\\_exit 值为 true。因此，如果页面没有崩溃的话，good\\_exit 值都会在离开前设置为 true，否则就可以通过 sessionStorage.getItem(&apos;good_exit&apos;) && sessionStorage.getItem(&apos;good\\_exit&apos;) !== &apos;true&apos; 判断出页面崩溃，并进行处理。\n\n如果你的应用部署了 PWA，那么便可以享受 service worker 带来的福利！在这里，可以通过 service worker 来完成网页崩溃的处理工作。基本原理在于：service worker 和网页的主线程独立。因此，即便网页发生了崩溃现象，也不会影响 service worker 所在线程的工作。我们在监控网页的状态时，通过 navigator.serviceWorker.controller.postMessage API 来进行信息的获取和记录。\n\n#### 框架的错误处理\n\n对于框架来说，React 16 版本之前，使用  unstable_handleError 来处理捕获的错误；16 版本之后，使用著名的 componentDidCatch 来处理错误。Vue 中，提供了 Vue.config.errorHandler 来处理捕获到的错误，如果开发者没有配置 Vue.config.errorHandler，那么捕获到的错误会以 console.error 的方式输出。具体 API 的使用方式和框架特点，这里不再赘述。\n\n上面提到框架会用 console.error 的方法抛出错误，因此可以劫持 console.error，捕获框架中的错误并做出处理：\n\n```\nconst nativeConsoleError = window.console.error\nwindow.console.error = (...args) => nativeConsoleError.apply(this, [`I got ${args}`])\n```\n\n如下图：\n\n![enter image description here](https://images.gitbook.cn/2027dd50-bfda-11e9-98b2-fde9741b330a)\n\n最后总结一下，我们大概处理了以下错误或者异常：\n\n- JavaScript 语法错误、代码异常\n- AJAX 请求异常（xhr.addEventListener(&apos;error&apos;, function (e) { //... })）\n- 静态资源加载异常\n- Promise 异常\n- 跨域 Script error\n- 页面崩溃\n- 框架错误\n\n在真实生产环境中，错误和异常多种多样，需要开发者格外留心，并对每一种情况进行覆盖。另外，除了性能和错误信息，一些额外信息，比如页面停留时间、长任务处理耗时等往往对分析网页表现非常重要。所有这些话题，欢迎大家在评论区展开讨论，也可以直接向我提问。对于错误信息采集和处理的介绍到此为止，接下来看一下数据的上报和系统设计。\n\n### <font color=13aa6c>性能数据和错误信息上报</font>\n\n数据都有了，我们该如何上报呢？可能有的开发者会想：“不就是一个 AJAX 请求吗？”，实际上还真没有这么简单，有一些细节需要考虑。\n\n##### **上报采用单独域名是否更好**\n\n我们发现，成熟的网站数据上报的域名往往与业务域名并不相同。这样做的好处主要有两点：\n\n- 使用单独域名，可以防止对主业务服务器的压力，能够避免日志相关处理逻辑和数据在主业务服务器的堆积；\n- 另外，很多浏览器对同一个域名的请求量有并发数的限制，单独域名能够充分利用现代浏览器的并发设置。\n\n##### **独立域名的跨域问题**\n\n对于单独的日志域名，肯定会涉及跨域问题。我们经常发现页面使用“构造空的 Image 对象的方式”进行数据上报。原因是请求图片并不涉及跨域的问题：\n\n```\nlet url = &apos;xxx&apos;\nlet img = new Image()\nimg.src = url\n```\n\n我们可以将数据进行序列化，作为 URL 参数传递：\n\n```\nlet url = &apos;xxx?data=&apos; + JSON.stringify(data)\nlet img = new Image()\nimg.src = url\n```\n\n##### **何时上报数据**\n\n页面加载性能数据可以在页面稳定后进行上报。\n\n一次上报就是一次访问，对于其他错误和异常数据的上报，假设我们的应用日志量很大，则有必要合并日志在统一时间，统一上报。那么什么情况下上报性能数据呢？一般合适的场景为：\n\n- 页面加载和重新刷新\n- 页面切换路由\n- 页面所在的 Tab 标签重新变得可见\n- 页面关闭\n\n但是，对于越来越多的单页应用来说，需要格外注意数据上报时机，请看下文。\n\n#### 单页应用上报\n\n如果切换路由是通过改变 hash 值来实现的，那么只需要监听 hashchange 事件，如果是通过 history API 来改变 URL，那么需要使用 pushState 和 replaceState 事件。当然一劳永逸的做法是进行 monkey patch，结合发布订阅模式，为相关事件的触发添加处理：\n\n```\nconst patchMethod = type => \n    () => {\n       const result = history[type].apply(this, arguments)\n       const event = new Event(type)\n       event.arguments = arguments\n       window.dispatchEvent(event)\n       return result\n   \t}\n\n\nhistory.pushState = patchMethod(&apos;pushState&apos;)\nhistory.replaceState = patchMethod(&apos;replaceState&apos;)\n```\n\n我们通过重写 history.pushState 和 history.replaceState 方法，添加并触发 pushState 和 replaceState 事件。这样一来 history.pushState 和 history.replaceState 事件触发时，可以添加订阅函数，进行上报：\n\n```\nwindow.addEventListener(&apos;replaceState&apos;, e => {\n    // report...\n})\nwindow.addEventListener(&apos;pushState&apos;, e => {\n    // report...\n})\n```\n\n##### **何时以及如何上报**\n\n如果是在页面离开时进行数据发送，那么在页面卸载期间是否能够安全地发送完数据是一个难题：因为页面跳转，进入下一个页面，就难以保证异步数据的发送了。如果使用同步的 AJAX：\n\n```\nwindow.addEventListener(&apos;unload&apos;, logData, false);\nconst logData = () => {\n    var client = new XMLHttpRequest()\n    client.open(\"POST\", \"/log\", false) // 第三个参数表明是同步的 XHR\n    client.setRequestHeader(\"Content-Type\", \"text/plain;charset=UTF-8\")\n    client.send(data)\n}\n```\n\n又会对页面跳转流畅程度和用户体验造成影响。\n\n这时候给大家推荐一下 sendBeacon 方法：\n\n```\nwindow.addEventListener(&apos;unload&apos;, logData, false)\n\t\nconst logData = () => {\n    navigator.sendBeacon(\"/log\", data)\n}\n```\n\nnavigator.sendBeacon 就是天生来解决“页离开时的请求发送”问题的。它的几个特点决定了对应问题的解决方案：\n\n- 它的行为是异步的，也就是说请求的发送不会阻塞向下一个页面的跳转，因此可以保证跳转的流畅度；\n- 它在不受到极端“数据 size 和队列总数”的限制下，优先返回 true 以保证请求的发送成功。\n\n目前 Google Analytics 使用 navigator.sendBeacon 来上报数据，请参考：[Google Analytics added sendBeacon functionality to Universal Analytics JavaScript API](https://www.thyngster.com/google-analytics-added-sendbeacon-functionality-universal-analytics-javascript-api/)。通过这篇文章，我们看到 Google Analytics 通过动态创建 img 标签，在 img.src 中拼接 URL 的方式发送请求，不存在跨域限制。如果 URL 太长，就会采用 sendBeacon 的方式发送请求，如果 sendBeacon 方法不兼容，则发送 AJAX post 同步请求。类似：\n\n```\nconst reportData = url => {\n    // ...\n    if (urlLength < 2083) {\n        imgReport(url, times)\n    } else if (navigator.sendBeacon) {\n        sendBeacon(url, times)\n    } else {\n        xmlLoadData(url, times)\n    }\n}\n```\n\n最后，如果网页访问量很大，那么一个错误发送的信息就非常多，我们可以给上报设置一个采集率：\n\n```\n const reportData = url => {\n    // 只采集 30%\n    if (Math.random() < 0.3) {\n        send(data)\n    }\n}\n```\n\n这个采集率当然可以通过具体实际的情况来设定，方法多种多样。\n\n### <font color=13aa6c>无侵入和性能友好的方案设计</font>\n\n目前为止，我们已经了解了性能监控和错误收集的所有必要知识点。那么根据这些知识点，如何设计一个好的系统方案呢？\n\n首先，这样的系统大致可分为四个阶段：\n\n<img src=\"https://images.gitbook.cn/d0ebda50-4eac-11e9-8d6d-edc0eec9ca99\" width=500>\n\n针对这几个阶段，我们聊一下关键方面的核心细节。\n\n**数据上报优化方面**　\n\n借助 HTTP 2.0 带来的新特性，我们可以持续优化上报性能。比如：采用 HTTP 2.0 头部压缩，以减少数据传送大小；采用 HTTP 2.0 多路复用技术，以充分利用链接资源。\n\n**接口和智能化设计方面**　\n\n我们可以考虑以下方面：\n\n- 识别周高峰和节假日，动态设置上报采样率；\n- 增强数据清洗能力，提高数据的可用性，对一些垃圾信息进行过滤；\n- 通过配置化，减少业务接入成本；\n- 如果用户一直触发错误，相同的错误内容会不停上报，这时可以考虑是否需要做一个短时间滤重。\n\n**实时性方面**　\n\n目前我们对系统数据的分析都是后置的，如何做到实时提醒呢？这就要依赖后端服务，将超过阈值的情况进行邮件或短信发送。\n\n在这个链路中，所有细节单独拿出来都是一个值得玩味的话题。打个比方，报警阈值如何设定。我们的应用可能在不同的时段和日期，流量差别很大，比如“点评”类应用，或“酒店预订”类应用，在节假日流量远远高于平时。如果报警阈值不做特殊处理，报警过于敏感，也许运维或开发者就要收到“骚扰”。业界上流行 3-sigma 的阈值设置，这是一个统计学概念。它表示对于一个正态分布或近似正态分布来说，数值分布在（μ-3σ,μ+3σ) 中属于正常范围区间。这方面更多内容可以参考：\n\n- [https://www.investopedia.com/terms/t/three-sigma-limits.asp](https://www.investopedia.com/terms/t/three-sigma-limits.asp)\n- [What does a 1-sigma, a 3-sigma or a 5-sigma detection mean](https://thecuriousastronomer.wordpress.com/2014/06/26/what-does-a-1-sigma-3-sigma-or-5-sigma-detection-mean/)\n\n最后，我收集了业界几个性能监控和错误收集上报系统的分享，这些分享方案有的以 PPT 形式呈现，有的以源码分析实现，希望大家能够继续了解学习：\n\n- [前端异常监控解决方案研究](https://cdc.tencent.com/2018/09/13/frontend-exception-monitor-research/)\n- [解密 ARMS 前端监控数据上报技术内幕](https://zhuanlan.zhihu.com/p/37275225)\n- [别再让你的 Web 页面在用户浏览器端裸奔](https://mp.weixin.qq.com/s/Z8daa96JD5NbjTPn9mGPPg)\n- [把前端监控做到极致](https://zhuanlan.zhihu.com/p/32262716?utm_medium=social&amp;utm_source=wechat_session&amp;from=singlemessage&amp;isappinstalled=0)\n- [浏览器端 JS 异常监控探索与实践](https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&mid=2247485669&amp;idx=1&amp;sn=a4d4aee73b606d412aba71abafb88325&source=41#wechat_redirect)\n\n### <font color=13aa6c>总结</font>\n\n本节梳理了性能监控和错误收集上报方方面面的内容。前端业务场景和浏览器的兼容性千差万别，因此数据监控上报系统要兼容多种情况。页面生命周期、业务逻辑复杂性也决定了成熟稳定的系统不是一蹴而就的。我们也要持续打磨，结合新技术和老经验，同时对比类似 Sentry 这样的巨型方案，探索更稳定高效的系统。\n\n课程代码仓库：\n\n<a href=\"https://github.com/HOUCe/lucas-gitchat-courses\">https://github.com/HOUCe/lucas-gitchat-courses</a>\n\n### <font color=13aa6c>分享交流</font>\n\n请大家留言分享「性能监控和错误上报」相关的经验心得。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问。**你的分享不仅帮助他人，更会提升自己。**\n\n你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。\n\n>**为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。**","pdfUrl":"","reader":"","duration":"","title":"性能监控和错误收集与上报（下）","column":"5c91c813968b1d64b1e08fde","isNotification":false,"htmlContent":"<p>上一节课我们学习了性能监控方面的知识。这一节来深入了解关于错误和异常的收集，并学习如何统一将这些信息进行上报。</p>\n<p>在此之前，我们先回顾一下这个主题的知识点：</p>\n<img src=\"https://images.gitbook.cn/9f1e2980-4ed7-11e9-b0b8-a9c8a3696845\" width=550>\n<h3><a id=\"font_color13aa6cfont_6\"></a><font color=13aa6c>错误信息收集</font></h3>\n<p>提到错误收集方案，大家应该会首先想到两种：try catch 捕获错误和 window.onerror 监听。</p>\n<h4><a id=\"_try_catch__10\"></a>认识 try catch 方案</h4>\n<p>我们先看一下 try catch 方案：</p>\n<pre><code class=\"lang-\">try {\n    // 代码块\n} catch(e) {\n    // 错误处理\n    // 在这里，我们可以将错误信息发送给服务端\n}\n</code></pre>\n<p>这种方式需要开发者对预估有错误风险的代码进行包裹，这个包裹过程可以手动添加，也可以通过自动化工具或类库完成。自动化方案的基本原理是 AST 技术：比如 UglifyJS 就提供操作 AST 的 API，我们可以对每个函数添加 try catch，社区上 <a href=\"https://github.com/foio/try-catch-global.js/blob/master/try-catch-global.js\" target=\"_blank\">foio</a> 的实现，就是一个很好的例子：</p>\n<pre><code class=\"lang-\">const fs = require(&apos;fs&apos;)\nconst _ = require(&apos;lodash&apos;)\nconst UglifyJS = require(&apos;uglify-js&apos;)\n    \nconst isASTFunctionNode =  node =&gt; node instanceof UglifyJS.AST_Defun || node instanceof UglifyJS.AST_Function\n​   \nconst globalFuncTryCatch = (source, errorHandler) =&gt; {\n    if (!_.isFunction(errorHandler)) {\n        throw &apos;errorHandler should be a valid function&apos;\n    }\n    \n    const errorHandlerSource = errorHandler.toString()\n    const errorHandlerAST = UglifyJS.parse(&apos;(&apos; + errorHandlerSource + &apos;)(error);&apos;)\n    var tryCatchAST = UglifyJS.parse(&apos;try{}catch(error){}&apos;)\n    const sourceAST = UglifyJS.parse(source)\n    var topFuncScope = []\n    \n    tryCatchAST.body[0].catch.body[0] = errorHandlerAST\n    \n    const walker = new UglifyJS.TreeWalker(function (node) {\n        if (isASTFunctionNode(node)) {\n            topFuncScope.push(node)\n        }\n    })\n    sourceAST.walk(walker)\n    sourceAST.transform(transfer)\n\n    const transfer = new UglifyJS.TreeTransformer(null,\n        node =&gt; {\n            if (isASTFunctionNode(node) &amp;&amp; _.includes(topFuncScope, node)) {\n                var stream = UglifyJS.OutputStream()\n                for (var i = 0; i &lt; node.body.length; i++) {\n                    node.body[i].print(stream)\n                }\n                var innerFuncCode = stream.toString()\n                tryCatchAST.body[0].body.splice(0, tryCatchAST.body[0].body.length)\n                var innerTyrCatchNode = UglifyJS.parse(innerFuncCode, {toplevel: tryCatchAST.body[0]})\n                node.body.splice(0, node.body.length)\n                return UglifyJS.parse(innerTyrCatchNode.print_to_string(), {toplevel: node});\n            }\n        })\n    const outputCode = sourceAST.print_to_string({beautify: true})\n    return outputCode\n}\n    \nmodule.exports.globalFuncTryCatch = globalFuncTryCatch\n</code></pre>\n<p>我们从 globalFuncTryCatch 函数的第一个参数中获得目标代码 source，将其转换为 AST：</p>\n<pre><code class=\"lang-\">const sourceAST = UglifyJS.parse(source)\n</code></pre>\n<p>globalFuncTryCatch 函数的第二个参数为开发者定义的在出现错误时的响应函数，我们将其字符串化并转为 AST，并插入到 catch 块当中：</p>\n<pre><code class=\"lang-\">var tryCatchAST = UglifyJS.parse(&apos;try{}catch(error){}&apos;)\nconst errorHandlerSource = errorHandler.toString()\nconst errorHandlerAST = UglifyJS.parse(&apos;(&apos; + errorHandlerSource + &apos;)(error);&apos;)\ntryCatchAST.body[0].catch.body[0] = errorHandlerAST\n</code></pre>\n<p>这样，借助于 globalFuncTryCatch，我们可以对每个函数添加 try catch 语句，并根据 globalFuncTryCatch 的第二个参数，传入自定义的错误处理函数（可以在该函数中进行错误上报）：</p>\n<pre><code class=\"lang-\">globalFuncTryCatch(inputCode, function (error) {\n    // 此处是异常处理代码，可以上报并记录日志\n    // ...\n})\n</code></pre>\n<p>关键之处在于使用 UglifyJS 的能力，对 AST 语法树进行遍历，并转换：</p>\n<pre><code class=\"lang-\">const walker = new UglifyJS.TreeWalker(function (node) {\n    if (isASTFunctionNode(node)) {\n        topFuncScope.push(node)\n    }\n})\nsourceAST.walk(walker)\nsourceAST.transform(transfer)\n</code></pre>\n<p>最终再返回经过处理后的代码：</p>\n<pre><code class=\"lang-\">const outputCode = sourceAST.print_to_string({beautify: true})\nreturn outputCode\n</code></pre>\n<p>使用 try catch，我们可以保证页面不崩溃，并对错误进行兜底处理，这是一个非常好的习惯。</p>\n<h4><a id=\"try_catch__119\"></a>try catch 方案的局限性</h4>\n<p>但是 try catch 处理异常的能力有限，对于运行时非异步错误，它并没有问题。但是对于：</p>\n<ul>\n<li>语法错误</li>\n<li>异步错误</li>\n</ul>\n<p>try catch 就无法 cover 了。我们来看一个运行时非异步错误：</p>\n<pre><code class=\"lang-\">try {\n    a // 未定义变量 \n} catch(e) {\n    console.log(e)\n}\n</code></pre>\n<p>可以被 try catch 处理。但是，将上述代码改动为语法错误：</p>\n<pre><code class=\"lang-\">try {\n    var a =\\ &apos;a&apos;\n} catch(e) {\n    console.log(e);\n}\n</code></pre>\n<p>就无法捕获。</p>\n<p>我们再看一下异步的情况：</p>\n<pre><code class=\"lang-\">try {\n    setTimeout(() =&gt; {\n        a\n    })\n} catch(e) {\n    console.log(e)\n}\n</code></pre>\n<p>也无法捕获。</p>\n<p><img src=\"https://images.gitbook.cn/b674d7f0-bfd9-11e9-8e2c-3b4fd17ad6da\" alt=\"enter image description here\" /></p>\n<p>除非在 setTimeout 中再加一层 try catch：</p>\n<p><img src=\"https://images.gitbook.cn/d1bc0740-bfd9-11e9-a5f2-bfb3232fc8ba\" alt=\"enter image description here\" /></p>\n<p>总结一下，<strong>try catch 能力有限，且对于代码的侵入性较强。</strong></p>\n<h4><a id=\"_windowonerror_170\"></a>认识 window.onerror</h4>\n<p>我们再看一下 window.onerror 对错误进行处理的方案：开发者只需要给 window 添加 onerror 事件监听，同时<strong>注意需要将 window.onerror 放在所有脚本之前，这样才能对语法异常和运行异常进行处理。</strong></p>\n<pre><code class=\"lang-\">window.onerror = function (message, source, lineno, colno, error) { \n\t// ... \n}\n</code></pre>\n<p>这里的参数较为重要，包含稍后需要上传的信息：</p>\n<ul>\n<li>mesage 为错误信息提示</li>\n<li>source 为错误脚本地址</li>\n<li>lineno 为错误的代码所在行号</li>\n<li>colno 为错误的代码所在列号</li>\n<li>error 为错误的对象信息，比如 error.stack 获取错误的堆栈信息</li>\n</ul>\n<p>window.onerror 这种方式对代码侵入性较小，也就不必涉及 AST 自动插入脚本。除了对语法错误和网络错误（因为<strong>网络请求异常不会事件冒泡</strong>）无能为力以外，无论是异步还是非异步，onerror 都能捕获到运行时错误。</p>\n<p>但是需要注意的是，如果想使用 window.onerror 函数消化错误，需要显示返回 true，以保证错误不会向上抛出，控制台也就不会看到一堆错误提示。</p>\n<h4><a id=\"_192\"></a>跨域脚本的错误处理</h4>\n<p>千万不要以为掌握了这些，就万事大吉了。现实场景多种多样，比如<strong>一种情况是：加载不同域的 JavaScript 脚本</strong>，这样的场景较为常见，比如加载第三方内容，以展示广告，进行性能测试、错误统计，或者想用第三方服务等。</p>\n<p>对于不同域的 JavaScript 文件，window.onerror 不能保证获取有效信息。由于安全原因，不同浏览器返回的错误信息参数可能并不一致。比如，跨域之后 window.onerror 在很多浏览器中是无法捕获异常信息的，要统一返回 Script error，这就需要 script 脚本设置为：</p>\n<pre><code class=\"lang-\">crossorigin=&quot;anonymous&quot;\n</code></pre>\n<p>同时服务器添加 Access-Control-Allow-Origin 以指定允许哪些域的请求访问。</p>\n<h4><a id=\"_source_map__204\"></a>使用 source map 进行错误还原</h4>\n<p>到目前为止，我们已经学习了获取错误信息的“十八般武艺”。但是，如果错误脚本是经过压缩的，那么纵使你有千般本领，也无用武之地了，因为这样捕获到的错误信息的位置（行列号）就会出现较大偏差，错误代码也经过压缩而难以辨认。这时候就需要启用 source map。很多构建工具都支持 source map，比如我们利用 webpack 打包压缩生成的一份对应脚本的 map 文件进行追踪，在 webpack 中开启 source map 功能：</p>\n<pre><code class=\"lang-\">module.exports = {\n    // ...\n    devtool: &apos;#source-map&apos;,\n    // ...\n}\n</code></pre>\n<p>更多 source map 的内容，感兴趣的读者还可以参考以下资料：</p>\n<ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html\" target=\"_blank\">JavaScript Source Map 详解</a></li>\n<li><a href=\"https://webpack.js.org/guides/development/#using-source-maps\" target=\"_blank\">Using source maps</a></li>\n</ul>\n<p>Webpack sourcemap 这里不是我们的重点，就不再展开。</p>\n<h4><a id=\"_Promise__223\"></a>对 Promise 错误处理</h4>\n<p><strong>我们再来看一下针对 Promise 的错误收集与处理</strong>。我们都提倡养成写 Promise 的时候最后写上 catch 函数的习惯。ESLint 插件 eslint-plugin-promise 会帮我们完成这项工作，使用规则：catch-or-return 来保障代码中所有的 promise（被显式返回的除外）都有相应的 catch 处理。比如这样的写法：</p>\n<pre><code class=\"lang-\">var p = new Promise()\np.then(fn1)\np.then(fn1, fn2)\nfunction fn1() {\n\tp.then(doSomething)\n}\n</code></pre>\n<p>是无法通过代码检查的。</p>\n<p>这类 ESLint 插件基于 AST 实现，逻辑也很简单：</p>\n<pre><code class=\"lang-\">module.exports = {\n  meta: {\n    docs: {\n      // ...\n    },\n    messages: {\n       // ...\n    }\n  },\n  create(context) {\n    const options = context.options[0] || {}\n    const allowThen = options.allowThen\n    let terminationMethod = options.terminationMethod || &apos;catch&apos;\n\t\n    if (typeof terminationMethod === &apos;string&apos;) {\n      terminationMethod = [terminationMethod]\n    }\n\t\n    return {\n      ExpressionStatement(node) {\n        if (!isPromise(node.expression)) {\n          return\n        }\n\t\n        if (\n          allowThen &amp;&amp;\n          node.expression.type === &apos;CallExpression&apos; &amp;&amp;\n          node.expression.callee.type === &apos;MemberExpression&apos; &amp;&amp;\n          node.expression.callee.property.name === &apos;then&apos; &amp;&amp;\n          node.expression.arguments.length === 2\n        ) {\n          return\n        }\n\t\n        if (\n          node.expression.type === &apos;CallExpression&apos; &amp;&amp;\n          node.expression.callee.type === &apos;MemberExpression&apos; &amp;&amp;\n          terminationMethod.indexOf(node.expression.callee.property.name) !== -1\n        ) {\n          return\n        }\n\t\n        if (\n          node.expression.type === &apos;CallExpression&apos; &amp;&amp;\n          node.expression.callee.type === &apos;MemberExpression&apos; &amp;&amp;\n          node.expression.callee.property.type === &apos;Literal&apos; &amp;&amp;\n          node.expression.callee.property.value === &apos;catch&apos;\n        ) {\n          return\n        }\n\t\n        context.report({\n          node,\n          messageId: &apos;terminationMethod&apos;,\n          data: { terminationMethod }\n        })\n      }\n    }\n  }\n}\n</code></pre>\n<p>如果读者对于 AST 和 ESLint 相关内容感兴趣，请关注课程《代码风格规范和背后技术设计》，会展开分析这方面的话题。</p>\n<p>可能大家会想到，promise 实例的 then 方法中的第二个 onRejected 函数也能处理错误，这个和上面提到的 catch 方法有什么差别呢？事实上，我更加推荐 catch 方法，请看下面代码：</p>\n<pre><code class=\"lang-\">new Promise((resolve, reject) =&gt; {\n    throw new Error()\n}).then( () =&gt; {\n    console.log(&apos;resolved&apos;)\n}, err =&gt; {\n    console.log(&apos;rejected&apos;)\n    throw err\n}).catch(err =&gt; {\n    console.log(err, &apos;catch&apos;)\n})\n</code></pre>\n<p>输出：rejected，在有 onRejected 的情况下，onRejected 发挥作用，catch 并未被调用。 而当：</p>\n<pre><code class=\"lang-\">new Promise((resolve, reject) =&gt; {\n\tresolve()\n}).then(() =&gt; {\n\tthrow new Error()\n    console.log(&apos;resolved&apos;)\n}, err =&gt; {\n    console.log(&apos;rejected&apos;)\n    throw err\n}).catch(err =&gt; {\n    console.log(err, &apos;catch&apos;)\n})\n</code></pre>\n<p>输出：<code>VM705:10 Error at Promise.then (&lt;anonymous&gt;:4:9) &quot;catch&quot;</code>，此时 onRejected 并不能捕获 then 方法中第一个参数 onResolved 函数中的错误。一经对比，也许 catch 是进行错误处理更好的选择。但是，这两种方式各有特点，还是需要读者对 Promise 有较为深入的认识。</p>\n<p>除此之外，对于 Promise 的错误处理，我们还可以注册对 Promise 全局异常的捕获事件 unhandledrejection：</p>\n<pre><code class=\"lang-\">window.addEventListener(&quot;unhandledrejection&quot;,  e =&gt; {\n    e.preventDefault()\n    console.log(e.reason)\n    return true\n})\n</code></pre>\n<p>这对于集中管理和错误收集更加友好。</p>\n<h4><a id=\"_350\"></a>处理网络加载错误</h4>\n<p>前面介绍的处理方式都是对已经在浏览器端的脚本逻辑错误进行的，我们设想用 script 标签，link 标签进行脚本或者其他资源加载时，由于某种原因（可能是服务器错误，也可能是网络不稳定），导致了脚本请求失败，网络加载错误。</p>\n<pre><code class=\"lang-\">&lt;script src=&quot;***.js&quot;&gt;&lt;/script&gt;\n&lt;link rel=&quot;stylesheet&quot; href=&quot;***.css&quot;&gt;\n</code></pre>\n<p>为了捕获这些加载异常，我们可以：</p>\n<pre><code class=\"lang-\">&lt;script src=&quot;***.js&quot;  onerror=&quot;errorHandler(this)&quot;&gt;&lt;/script&gt;\n&lt;link rel=&quot;stylesheet&quot; href=&quot;***.css&quot; onerror=&quot;errorHandler(this)&quot;&gt;\n</code></pre>\n<p>除此之外，也可以使用 window.addEventListener(‘error’) 方式对加载异常进行处理，注意这时候我们无法使用 window.onerror 进行处理，<strong>因为 window.onerror 事件是通过事件冒泡获取 error 信息的，而网络加载错误是不会进行事件冒泡的。</strong></p>\n<p>这里多提一下，<strong>不支持冒泡的事件还有</strong>：鼠标聚焦 / 失焦（focus / blur）、鼠标移动相关事件（mouseleave / mouseenter）、一些 UI 事件（如 scroll、resize 等）。</p>\n<p>因此，我们也就知道 <strong>window.addEventListener 不同于 window.onerror，它通过事件捕获获取 error 信息，从而可以对网络资源的加载异常进行处理：</strong></p>\n<pre><code class=\"lang-\">window.addEventListener(&apos;error&apos;, error =&gt; {\n    console.log(error)\n}, true)\n</code></pre>\n<p><strong>那么，怎么区分网络资源加载错误和其他一般错误呢</strong>？这里有个小技巧，普通错误的 error 对象中会有一个 error.message 属性，表示错误信息，而资源加载错误对应的 error 对象却没有，因此可以根据下面代码进行判断：</p>\n<pre><code class=\"lang-\">window.addEventListener(&apos;error&apos;, error =&gt; {\n\tif (!error.message) {\n\t    // 网络资源加载错误\n\t\tconsole.log(error)\n\t}\n}, true)\n</code></pre>\n<p>但是，也因为没有 error.message 属性，我们也就没有额外信息获取具体加载的错误细节，现阶段也无法具体区分加载的错误类别：比如是 404 资源不存在还是服务端错误等，只能配合后端日志进行排查。</p>\n<p><strong>到这里，我们简单做一个总结，分析 window.onerror 和 window.addEventListener(‘error’) 的区别。</strong></p>\n<ul>\n<li>window.onerror 需要进行函数赋值：window.onerror = function() {//…}，因此重复声明后会被替换，后续赋值会覆盖之前的值。这是一个弊端。</li>\n</ul>\n<p>请看下图示例：</p>\n<p><img src=\"https://images.gitbook.cn/f275ddd0-bfd9-11e9-8e2c-3b4fd17ad6da\" alt=\"enter image description here\" /></p>\n<ul>\n<li>而 window.addEventListener(‘error’) 可以绑定多个回调函数，按照绑定顺序依次执行，请看下图示例：</li>\n</ul>\n<p><img src=\"https://images.gitbook.cn/0be789d0-bfda-11e9-98b2-fde9741b330a\" alt=\"enter image description here\" /></p>\n<h4><a id=\"_403\"></a>页面崩溃收集和处理</h4>\n<p>一个成熟的系统还需要收集崩溃和卡顿，对此我们可以监听 window 对象的 load 和 beforeunload 事件，并结合 sessionStorage 对网页崩溃实施监控：</p>\n<pre><code class=\"lang-\">window.addEventListener(&apos;load&apos;, () =&gt; {\n\tsessionStorage.setItem(&apos;good_exit&apos;, &apos;pending&apos;)\n})\n\t\nwindow.addEventListener(&apos;beforeunload&apos;, () =&gt; {\n\tsessionStorage.setItem(&apos;good_exit&apos;, &apos;true&apos;)\n})\n\t\nif(sessionStorage.getItem(&apos;good_exit&apos;) &amp;&amp;\n\tsessionStorage.getItem(&apos;good_exit&apos;) !== &apos;true&apos;) {\n\t// 捕获到页面崩溃\n}\n</code></pre>\n<p>代码很简单，思路是首先在网页 load 事件的回调里：利用 sessionStorage 记录 good_exit 值为 pending；接下来，在页面无异常退出前，即 beforeunload 事件回调中，修改 sessionStorage 记录的 good_exit 值为 true。因此，如果页面没有崩溃的话，good_exit 值都会在离开前设置为 true，否则就可以通过 sessionStorage.getItem(‘good_exit’) &amp;&amp; sessionStorage.getItem(‘good_exit’) !== ‘true’ 判断出页面崩溃，并进行处理。</p>\n<p>如果你的应用部署了 PWA，那么便可以享受 service worker 带来的福利！在这里，可以通过 service worker 来完成网页崩溃的处理工作。基本原理在于：service worker 和网页的主线程独立。因此，即便网页发生了崩溃现象，也不会影响 service worker 所在线程的工作。我们在监控网页的状态时，通过 navigator.serviceWorker.controller.postMessage API 来进行信息的获取和记录。</p>\n<h4><a id=\"_426\"></a>框架的错误处理</h4>\n<p>对于框架来说，React 16 版本之前，使用  unstable_handleError 来处理捕获的错误；16 版本之后，使用著名的 componentDidCatch 来处理错误。Vue 中，提供了 Vue.config.errorHandler 来处理捕获到的错误，如果开发者没有配置 Vue.config.errorHandler，那么捕获到的错误会以 console.error 的方式输出。具体 API 的使用方式和框架特点，这里不再赘述。</p>\n<p>上面提到框架会用 console.error 的方法抛出错误，因此可以劫持 console.error，捕获框架中的错误并做出处理：</p>\n<pre><code class=\"lang-\">const nativeConsoleError = window.console.error\nwindow.console.error = (...args) =&gt; nativeConsoleError.apply(this, [`I got ${args}`])\n</code></pre>\n<p>如下图：</p>\n<p><img src=\"https://images.gitbook.cn/2027dd50-bfda-11e9-98b2-fde9741b330a\" alt=\"enter image description here\" /></p>\n<p>最后总结一下，我们大概处理了以下错误或者异常：</p>\n<ul>\n<li>JavaScript 语法错误、代码异常</li>\n<li>AJAX 请求异常（xhr.addEventListener(‘error’, function (e) { //… })）</li>\n<li>静态资源加载异常</li>\n<li>Promise 异常</li>\n<li>跨域 Script error</li>\n<li>页面崩溃</li>\n<li>框架错误</li>\n</ul>\n<p>在真实生产环境中，错误和异常多种多样，需要开发者格外留心，并对每一种情况进行覆盖。另外，除了性能和错误信息，一些额外信息，比如页面停留时间、长任务处理耗时等往往对分析网页表现非常重要。所有这些话题，欢迎大家在评论区展开讨论，也可以直接向我提问。对于错误信息采集和处理的介绍到此为止，接下来看一下数据的上报和系统设计。</p>\n<h3><a id=\"font_color13aa6cfont_453\"></a><font color=13aa6c>性能数据和错误信息上报</font></h3>\n<p>数据都有了，我们该如何上报呢？可能有的开发者会想：“不就是一个 AJAX 请求吗？”，实际上还真没有这么简单，有一些细节需要考虑。</p>\n<h5><a id=\"_457\"></a><strong>上报采用单独域名是否更好</strong></h5>\n<p>我们发现，成熟的网站数据上报的域名往往与业务域名并不相同。这样做的好处主要有两点：</p>\n<ul>\n<li>使用单独域名，可以防止对主业务服务器的压力，能够避免日志相关处理逻辑和数据在主业务服务器的堆积；</li>\n<li>另外，很多浏览器对同一个域名的请求量有并发数的限制，单独域名能够充分利用现代浏览器的并发设置。</li>\n</ul>\n<h5><a id=\"_464\"></a><strong>独立域名的跨域问题</strong></h5>\n<p>对于单独的日志域名，肯定会涉及跨域问题。我们经常发现页面使用“构造空的 Image 对象的方式”进行数据上报。原因是请求图片并不涉及跨域的问题：</p>\n<pre><code class=\"lang-\">let url = &apos;xxx&apos;\nlet img = new Image()\nimg.src = url\n</code></pre>\n<p>我们可以将数据进行序列化，作为 URL 参数传递：</p>\n<pre><code class=\"lang-\">let url = &apos;xxx?data=&apos; + JSON.stringify(data)\nlet img = new Image()\nimg.src = url\n</code></pre>\n<h5><a id=\"_482\"></a><strong>何时上报数据</strong></h5>\n<p>页面加载性能数据可以在页面稳定后进行上报。</p>\n<p>一次上报就是一次访问，对于其他错误和异常数据的上报，假设我们的应用日志量很大，则有必要合并日志在统一时间，统一上报。那么什么情况下上报性能数据呢？一般合适的场景为：</p>\n<ul>\n<li>页面加载和重新刷新</li>\n<li>页面切换路由</li>\n<li>页面所在的 Tab 标签重新变得可见</li>\n<li>页面关闭</li>\n</ul>\n<p>但是，对于越来越多的单页应用来说，需要格外注意数据上报时机，请看下文。</p>\n<h4><a id=\"_495\"></a>单页应用上报</h4>\n<p>如果切换路由是通过改变 hash 值来实现的，那么只需要监听 hashchange 事件，如果是通过 history API 来改变 URL，那么需要使用 pushState 和 replaceState 事件。当然一劳永逸的做法是进行 monkey patch，结合发布订阅模式，为相关事件的触发添加处理：</p>\n<pre><code class=\"lang-\">const patchMethod = type =&gt; \n    () =&gt; {\n       const result = history[type].apply(this, arguments)\n       const event = new Event(type)\n       event.arguments = arguments\n       window.dispatchEvent(event)\n       return result\n   \t}\n\n\nhistory.pushState = patchMethod(&apos;pushState&apos;)\nhistory.replaceState = patchMethod(&apos;replaceState&apos;)\n</code></pre>\n<p>我们通过重写 history.pushState 和 history.replaceState 方法，添加并触发 pushState 和 replaceState 事件。这样一来 history.pushState 和 history.replaceState 事件触发时，可以添加订阅函数，进行上报：</p>\n<pre><code class=\"lang-\">window.addEventListener(&apos;replaceState&apos;, e =&gt; {\n    // report...\n})\nwindow.addEventListener(&apos;pushState&apos;, e =&gt; {\n    // report...\n})\n</code></pre>\n<h5><a id=\"_525\"></a><strong>何时以及如何上报</strong></h5>\n<p>如果是在页面离开时进行数据发送，那么在页面卸载期间是否能够安全地发送完数据是一个难题：因为页面跳转，进入下一个页面，就难以保证异步数据的发送了。如果使用同步的 AJAX：</p>\n<pre><code class=\"lang-\">window.addEventListener(&apos;unload&apos;, logData, false);\nconst logData = () =&gt; {\n    var client = new XMLHttpRequest()\n    client.open(&quot;POST&quot;, &quot;/log&quot;, false) // 第三个参数表明是同步的 XHR\n    client.setRequestHeader(&quot;Content-Type&quot;, &quot;text/plain;charset=UTF-8&quot;)\n    client.send(data)\n}\n</code></pre>\n<p>又会对页面跳转流畅程度和用户体验造成影响。</p>\n<p>这时候给大家推荐一下 sendBeacon 方法：</p>\n<pre><code class=\"lang-\">window.addEventListener(&apos;unload&apos;, logData, false)\n\t\nconst logData = () =&gt; {\n    navigator.sendBeacon(&quot;/log&quot;, data)\n}\n</code></pre>\n<p>navigator.sendBeacon 就是天生来解决“页离开时的请求发送”问题的。它的几个特点决定了对应问题的解决方案：</p>\n<ul>\n<li>它的行为是异步的，也就是说请求的发送不会阻塞向下一个页面的跳转，因此可以保证跳转的流畅度；</li>\n<li>它在不受到极端“数据 size 和队列总数”的限制下，优先返回 true 以保证请求的发送成功。</li>\n</ul>\n<p>目前 Google Analytics 使用 navigator.sendBeacon 来上报数据，请参考：<a href=\"https://www.thyngster.com/google-analytics-added-sendbeacon-functionality-universal-analytics-javascript-api/\" target=\"_blank\">Google Analytics added sendBeacon functionality to Universal Analytics JavaScript API</a>。通过这篇文章，我们看到 Google Analytics 通过动态创建 img 标签，在 img.src 中拼接 URL 的方式发送请求，不存在跨域限制。如果 URL 太长，就会采用 sendBeacon 的方式发送请求，如果 sendBeacon 方法不兼容，则发送 AJAX post 同步请求。类似：</p>\n<pre><code class=\"lang-\">const reportData = url =&gt; {\n    // ...\n    if (urlLength &lt; 2083) {\n        imgReport(url, times)\n    } else if (navigator.sendBeacon) {\n        sendBeacon(url, times)\n    } else {\n        xmlLoadData(url, times)\n    }\n}\n</code></pre>\n<p>最后，如果网页访问量很大，那么一个错误发送的信息就非常多，我们可以给上报设置一个采集率：</p>\n<pre><code class=\"lang-\"> const reportData = url =&gt; {\n    // 只采集 30%\n    if (Math.random() &lt; 0.3) {\n        send(data)\n    }\n}\n</code></pre>\n<p>这个采集率当然可以通过具体实际的情况来设定，方法多种多样。</p>\n<h3><a id=\"font_color13aa6cfont_584\"></a><font color=13aa6c>无侵入和性能友好的方案设计</font></h3>\n<p>目前为止，我们已经了解了性能监控和错误收集的所有必要知识点。那么根据这些知识点，如何设计一个好的系统方案呢？</p>\n<p>首先，这样的系统大致可分为四个阶段：</p>\n<img src=\"https://images.gitbook.cn/d0ebda50-4eac-11e9-8d6d-edc0eec9ca99\" width=500>\n<p>针对这几个阶段，我们聊一下关键方面的核心细节。</p>\n<p><strong>数据上报优化方面</strong></p>\n<p>借助 HTTP 2.0 带来的新特性，我们可以持续优化上报性能。比如：采用 HTTP 2.0 头部压缩，以减少数据传送大小；采用 HTTP 2.0 多路复用技术，以充分利用链接资源。</p>\n<p><strong>接口和智能化设计方面</strong></p>\n<p>我们可以考虑以下方面：</p>\n<ul>\n<li>识别周高峰和节假日，动态设置上报采样率；</li>\n<li>增强数据清洗能力，提高数据的可用性，对一些垃圾信息进行过滤；</li>\n<li>通过配置化，减少业务接入成本；</li>\n<li>如果用户一直触发错误，相同的错误内容会不停上报，这时可以考虑是否需要做一个短时间滤重。</li>\n</ul>\n<p><strong>实时性方面</strong></p>\n<p>目前我们对系统数据的分析都是后置的，如何做到实时提醒呢？这就要依赖后端服务，将超过阈值的情况进行邮件或短信发送。</p>\n<p>在这个链路中，所有细节单独拿出来都是一个值得玩味的话题。打个比方，报警阈值如何设定。我们的应用可能在不同的时段和日期，流量差别很大，比如“点评”类应用，或“酒店预订”类应用，在节假日流量远远高于平时。如果报警阈值不做特殊处理，报警过于敏感，也许运维或开发者就要收到“骚扰”。业界上流行 3-sigma 的阈值设置，这是一个统计学概念。它表示对于一个正态分布或近似正态分布来说，数值分布在（μ-3σ,μ+3σ) 中属于正常范围区间。这方面更多内容可以参考：</p>\n<ul>\n<li><a href=\"https://www.investopedia.com/terms/t/three-sigma-limits.asp\" target=\"_blank\">https://www.investopedia.com/terms/t/three-sigma-limits.asp</a></li>\n<li><a href=\"https://thecuriousastronomer.wordpress.com/2014/06/26/what-does-a-1-sigma-3-sigma-or-5-sigma-detection-mean/\" target=\"_blank\">What does a 1-sigma, a 3-sigma or a 5-sigma detection mean</a></li>\n</ul>\n<p>最后，我收集了业界几个性能监控和错误收集上报系统的分享，这些分享方案有的以 PPT 形式呈现，有的以源码分析实现，希望大家能够继续了解学习：</p>\n<ul>\n<li><a href=\"https://cdc.tencent.com/2018/09/13/frontend-exception-monitor-research/\" target=\"_blank\">前端异常监控解决方案研究</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/37275225\" target=\"_blank\">解密 ARMS 前端监控数据上报技术内幕</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/Z8daa96JD5NbjTPn9mGPPg\" target=\"_blank\">别再让你的 Web 页面在用户浏览器端裸奔</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/32262716?utm_medium=social&amp;utm_source=wechat_session&amp;from=singlemessage&amp;isappinstalled=0\" target=\"_blank\">把前端监控做到极致</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&amp;mid=2247485669&amp;idx=1&amp;sn=a4d4aee73b606d412aba71abafb88325&amp;source=41#wechat_redirect\" target=\"_blank\">浏览器端 JS 异常监控探索与实践</a></li>\n</ul>\n<h3><a id=\"font_color13aa6cfont_624\"></a><font color=13aa6c>总结</font></h3>\n<p>本节梳理了性能监控和错误收集上报方方面面的内容。前端业务场景和浏览器的兼容性千差万别，因此数据监控上报系统要兼容多种情况。页面生命周期、业务逻辑复杂性也决定了成熟稳定的系统不是一蹴而就的。我们也要持续打磨，结合新技术和老经验，同时对比类似 Sentry 这样的巨型方案，探索更稳定高效的系统。</p>\n<p>课程代码仓库：</p>\n<p><a href=\"https://github.com/HOUCe/lucas-gitchat-courses\">https://github.com/HOUCe/lucas-gitchat-courses</a></p>\n<h3><a id=\"font_color13aa6cfont_632\"></a><font color=13aa6c>分享交流</font></h3>\n<p>请大家留言分享「性能监控和错误上报」相关的经验心得。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问。<strong>你的分享不仅帮助他人，更会提升自己。</strong></p>\n<p>你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。</p>\n<blockquote>\n<p><strong>为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。</strong></p>\n</blockquote>\n","readingStatistics":0,"createdAt":"2019-03-26T06:25:31.576Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":32,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FoThASW9dVEPMEo9nP-zaOfbKyLZ"},{"_id":"5c99c3a5ccb24267c1d01b63","communication_start_time":null,"type":1,"audioPath":"","abstract":"","content":"一直以来，性能优化是前端的重要课题，不仅实实在在影响产品性能，在面试环节也会被反复提及。无论应聘者是初入前端的新手，还是工作经验丰富的老司机，面试官都能在性能方面找到合适的切入点，对候选人进行考察。作为程序员，应该如何在平时学习、工作中积累性能优化方面的经验，保障产品顺畅体验？作为面试者，如何在面试流程中出色地回答性能相关问题？\n\n**前端性能是一个太过宽泛的话题，脱离场景和需求谈性能往往毫无意义**。我相信很少有面试官会直接把：“前端如何优化性能？”——这样一个空架子问题抛出的。也不会有技术经理直接丢给你“把产品性能提升一些”这样的项目。毕竟这样的问题过大，根本让人无处下手。我们还需要针对具体场景和瓶颈来分析。\n\n但是，如果真的有面试官这么问了呢？\n\n如果是我，我也许会这样回答：\n\n> 前端性能涉及方方面面，优化角度切入点都有所不同。我认为，主要可以分为：页面工程优化和代码细节优化两大方向。\n\n**页面工程优化**从页面请求开始，涉及网络协议、资源配置、浏览器性能、缓存等；**代码细节优化**上相对零散，比如 JavaScript 对 DOM 操作，宿主环境的单线程相关内容等。\n\n也正如上所答，本节课程也会基于以下两个大方向的相关知识进行梳理：\n\n- **页面工程优化**\n- **代码细节优化**\n\n为了更好地还原真实场景，这两方面我都将配合两类面试题目来解析：\n\n- 开放例题实战\n- 代码例题实战\n\n这个主题的知识点如下：\n\n<img src=\"https://images.gitbook.cn/a4889460-4ecc-11e9-8044-3de24c2bc492\" width=550>\n\n接下来，我们通过 2 节内容来学习这个主题。\n\n### <font color=13aa6c>开放例题实战</font>\n\n如上分析，面试官往往会根据面试者的实际经验或者性能的某一细分方向，进行深度提问，以了解候选人的知识储备以及在以往项目中的表现。\n\n作为一个面试者，包括在蚂蚁金服、阿里淘宝某团队、头条、美团以及其他公司的多次面试流程中，我曾经被问到过：**“在平时工作中做过哪些性能优化方面的项目？”**\n\n我是这样回答的：\n\n> 因为我服务的是有亿级流量的 To C 型产品，因此平时工作中，在性能优化方面一直持续进行探索和迭代。除了代码细节方面外，较大型工程优化主要有 WebP 图片格式替换、资源打包和逆向代码拆分（按需加载）等。\n\n#### WebP 图片优化\n\n因为并不知道面试官需要考察的程度，以上回答可以避免自己“侃侃而谈”浪费时间的尴尬。在这样的面试场景中，我往往会把主动权交给面试官。大部分面试官会继续追问，比如他对 WebP 图片格式优化项目感兴趣，**那我会从项目的立项、实施、收益的角度进行解答，表现作为一个项目负责人对优化项目的理解**：\n\n> 我们的产品页面中，往往存在大量的图片内容，因此图片的性能优化是瓶颈和重点。除了传统的图片懒加载手段以外，我调研并实施了 WebP 图片格式的替换。由于可能会有潜在兼容性的问题，因而具体做法是先进行兼容性嗅探。这一手段借鉴了社区一贯做法，利用 <code>img</code> 标签加载一张 base64 的 WebP 图片，并将结果存入 <code>localStorage</code> 中防止重复判断。如果该终端支持，则再对图片格式进行替换。这个兼容性嗅探过程，也封装成 promise 化的通用接口。\n\n相关代码片段如下：\n\n```\nconst supportWebp = () => new Promise(resolve => {\n\tconst image = new Image()\n\timage.onerror = () => resolve(false)\n\timage.onload = () => resolve(image.width === 1)\n\timage.src = &apos;data:image/webp;base64,UklGRiQAAABXRUJQVlA4IBgAAAAwAQCdASoBAAEAAwA0JaQAA3AA/vuUAAA=&apos;\n}).catch(() => false)\n```\n\n这时候，面试官往往会进一步关心项目收益情况。这就需要面试者根据实情作答，仍然以这个项目为例：\n\n> 在具体上线时，我对 10% 的流量进行了分组切分。5% 为对照组，仍然采用传统格式；另外 5% 为实验组，进行 WebP 格式试验。 **最终结果显示收益非常有限**。\n> 为此我进行分析：认为出现近似零收益的原因是图片服务的缓存问题。新转换的一批 WebP 格式图片由于没有缓存，因而在性能上打了折扣。为了验证猜想，我决定继续进行扩量试验并观察结果。果然，后续排除缓存问题之后，收益提升 25%~30% 左右。\n\n这里，我们就涉及了工程优化中的一个重要环节：网络请求和缓存。这些内容我们会在后续课程网络环节《第 8-1课：缓存谁都懂，一问都哑口》中具体展开。\n\n通过以上回答，我如实讲述了出现的非预期 case，并说明遇见问题时，如何进行分析进而解决问题的一系列过程。这样的回答能明确表现出我确实做过该项目并进行了思考分析，最终落地。这类思路也更容易被面试官所接受。\n\n更多关于 WebP 的好文章：\n\n- [WebP Support - It&apos;s More Than You Think](https://www.keycdn.com/support/webp-support)\n- [从零开始带你认识最新的图片格式 WebP](http://www.uisdc.com/image-format-webp-introduction)\n- [把网站的图片升级到 WebP 格式吧](https://segmentfault.com/a/1190000007482148)\n\n也由此看出，性能优化其实并不难做，重要的是解决问题的思路，以及解决过程中对于项目的把控和推荐。这些内容我们称之为“软素质”。\n\n#### 按需加载优化\n\n如果面试官围绕着刚才列举的“资源打包和逆向拆分（按需加载）”方向提问，我仍然会采用同样的“思路”进行回答：\n\n> 我接手项目之后，发现历史原有的资源打包配置并不合理，严重影响了性能表现。因此借助构建工具，对资源进行合并打包。但是，需要注意的是，我的策略并不是大刀阔斧地进行资源合并，因为这样会让 bundle.js 的 size 越来越大，所以也进行了逆向过程。\n>\n> 以实际页面为例：\n>\n> ![enter image description here](https://images.gitbook.cn/6f5fc910-bff2-11e9-8e2c-3b4fd17ad6da)\n>\n> 如上，当点击左图播放按钮之后，页面出现视频列表浮层（右侧所示，仍为同一页面，类似单页应用）。视频列表浮层包含了滚动处理、视频播放等多项复杂逻辑，因此关于这个浮层的脚本我并没有进行打包合并，而是单独进行拆分。当用户点击浮层触发按钮后，再执行对这一部分脚本的请求。\n\n工程化性能优化不仅需要做，还要用数据证明做法的合理性：\n\n> 同时，我对用户点击触发按钮的概率进行统计，发现进入页面的用户只有 10% 左右会点击按钮，从而触发视频列表浮层。也就是说，大部分用户（90%）并不会看到这一浮层，延迟按需加载是有统计数据支持的。\n\n通过这个案例，我们发现性能优化其实是一个开放式问题，非常依赖实践。读者可根据上面的例子，结合自己的项目进行回答。\n\n虽然没有涉及代码实施，但是建立起项目意识和方向意识，这在工程化性能上非常难能可贵。上面提到的借助构建工具进行“按需加载”等内容，前面章节如《webpack 工程师 > 前端工程师》都会具体从代码角度给出示例。\n\n当然上述举例的按需加载，我们并不是使用成熟的 webpack 工具链，而是采用公司内部封装的工程化工具。在几年前，这样的方案并不成熟，因此我写了一些按需加载的差距，配合自己的工程化工具使用。这一方面内容，很多面试官会很感兴趣，话题也可以延伸到 FIS 和 webpack 的比较，工程化工具的设计等话题。\n\n#### 讲不完的工程化优化\n\n此外，工程优化方向还包括：\n\n- 图片懒加载\n- 雪碧图\n- 合理设置缓存策略\n- 使用 prefetch / preload 预加载等新特性\n- 以 tree shaking 手段为主的代码瘦身\n\n这里不再一一举例，欢迎订阅此课程的同学结合自己的经历在评论区留言讨论或者直接向我提问，我会尽量拿出时间跟大家一起进行项目分析、描述。\n\n以上是**工程化**性能的实际题目，总结一下：工程师需要对日常项目进行深入总结，结合产品角度、研发角度描述。在面试前就需要做到“心中有数，胸有成竹”。\n\n另外，在具体的实现方向上，关于性能优化的切入点也有很多。比如：\n\n- 动画性能方向\n- 操作 DOM 方向\n- 浏览器加载、渲染性能方向\n- 性能测量、监控方向\n\n这些方向并不是相互独立的，它们彼此依存，比如**动画性能方向与浏览器渲染性能息息相关**。这里我用一道经典的面试题来分析：**“如果发现页面动画效果卡顿，你会从哪些角度解决问题？”**\n\n首先从动画实现入手：\n\n> - 一般 CSS3 动画会比基于 JavaScript 实现的动画效率要高，因此优先使用 CSS3 实现效果（这一点并不绝对）\n> - 在使用 CSS3 实现动画时，考虑开启 GPU 加速（这一点也并不总是正向效果）\n> - 优先使用消耗最低的 transform 和 opacity 两个属性\n> - 使用 will-change 属性\n> - 独立合成层，减少绘制区域\n> - 对于只能使用 JavaScript 实现动画效果的情况，考虑 requestAnimationFrame、requestIdleCallback API\n> - 批量进行样式变换，减少布局抖动\n\n事实上，上面每一点的背后都包含着很多知识点，例如：\n\n- 如何理解 requestAnimationFrame 和 60 fps\n- 如何实现 requestAnimationFrame polyfill\n- 哪些操作会触发浏览器 reflow（重排）或者 repaint（重绘）\n- 对于给出的代码，如何进行优化\n- 如何实现滚动时的节流、防抖函数\n\n这些问题，我们会拿出其中几个在下一节分析。同时，订阅课程的朋友们，都可以在下节课末尾彩蛋区获得我在这些主题方向上收藏的文章。\n\n### 总结\n\n工程化优化是一个太大的话题了，本节课我们只是在“大面上”进行方向指引，以面试为角度抛砖引玉，更多具体代码细节实例，下节课我们会继续探讨。\n\n另外，正因为这个话题的特殊性，一千个项目，就有一千个优化场景，也欢迎大家拿出来项目中的具体情况，跟我讨论。\n\n### <font color=13aa6c>分享交流</font>\n\n请大家留言分享「性能优化」方面的经验心得，也可以继续学习下一节等全部完结这个主题之后再分享。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后会抽空解答）。**你的分享不仅帮助他人，更会提升自己。**\n\n同时，说说自己最想了解的主题，课程内容会根据大家的意见和建议迭代和完善。\n\n>**为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。**","pdfUrl":"","reader":"","duration":"","title":"性能优化问题，老司机如何解决（上）","column":"5c91c813968b1d64b1e08fde","isNotification":false,"htmlContent":"<p>一直以来，性能优化是前端的重要课题，不仅实实在在影响产品性能，在面试环节也会被反复提及。无论应聘者是初入前端的新手，还是工作经验丰富的老司机，面试官都能在性能方面找到合适的切入点，对候选人进行考察。作为程序员，应该如何在平时学习、工作中积累性能优化方面的经验，保障产品顺畅体验？作为面试者，如何在面试流程中出色地回答性能相关问题？</p>\n<p><strong>前端性能是一个太过宽泛的话题，脱离场景和需求谈性能往往毫无意义</strong>。我相信很少有面试官会直接把：“前端如何优化性能？”——这样一个空架子问题抛出的。也不会有技术经理直接丢给你“把产品性能提升一些”这样的项目。毕竟这样的问题过大，根本让人无处下手。我们还需要针对具体场景和瓶颈来分析。</p>\n<p>但是，如果真的有面试官这么问了呢？</p>\n<p>如果是我，我也许会这样回答：</p>\n<blockquote>\n<p>前端性能涉及方方面面，优化角度切入点都有所不同。我认为，主要可以分为：页面工程优化和代码细节优化两大方向。</p>\n</blockquote>\n<p><strong>页面工程优化</strong>从页面请求开始，涉及网络协议、资源配置、浏览器性能、缓存等；<strong>代码细节优化</strong>上相对零散，比如 JavaScript 对 DOM 操作，宿主环境的单线程相关内容等。</p>\n<p>也正如上所答，本节课程也会基于以下两个大方向的相关知识进行梳理：</p>\n<ul>\n<li><strong>页面工程优化</strong></li>\n<li><strong>代码细节优化</strong></li>\n</ul>\n<p>为了更好地还原真实场景，这两方面我都将配合两类面试题目来解析：</p>\n<ul>\n<li>开放例题实战</li>\n<li>代码例题实战</li>\n</ul>\n<p>这个主题的知识点如下：</p>\n<img src=\"https://images.gitbook.cn/a4889460-4ecc-11e9-8044-3de24c2bc492\" width=550>\n<p>接下来，我们通过 2 节内容来学习这个主题。</p>\n<h3><a id=\"font_color13aa6cfont_28\"></a><font color=13aa6c>开放例题实战</font></h3>\n<p>如上分析，面试官往往会根据面试者的实际经验或者性能的某一细分方向，进行深度提问，以了解候选人的知识储备以及在以往项目中的表现。</p>\n<p>作为一个面试者，包括在蚂蚁金服、阿里淘宝某团队、头条、美团以及其他公司的多次面试流程中，我曾经被问到过：<strong>“在平时工作中做过哪些性能优化方面的项目？”</strong></p>\n<p>我是这样回答的：</p>\n<blockquote>\n<p>因为我服务的是有亿级流量的 To C 型产品，因此平时工作中，在性能优化方面一直持续进行探索和迭代。除了代码细节方面外，较大型工程优化主要有 WebP 图片格式替换、资源打包和逆向代码拆分（按需加载）等。</p>\n</blockquote>\n<h4><a id=\"WebP__38\"></a>WebP 图片优化</h4>\n<p>因为并不知道面试官需要考察的程度，以上回答可以避免自己“侃侃而谈”浪费时间的尴尬。在这样的面试场景中，我往往会把主动权交给面试官。大部分面试官会继续追问，比如他对 WebP 图片格式优化项目感兴趣，<strong>那我会从项目的立项、实施、收益的角度进行解答，表现作为一个项目负责人对优化项目的理解</strong>：</p>\n<blockquote>\n<p>我们的产品页面中，往往存在大量的图片内容，因此图片的性能优化是瓶颈和重点。除了传统的图片懒加载手段以外，我调研并实施了 WebP 图片格式的替换。由于可能会有潜在兼容性的问题，因而具体做法是先进行兼容性嗅探。这一手段借鉴了社区一贯做法，利用 <code>img</code> 标签加载一张 base64 的 WebP 图片，并将结果存入 <code>localStorage</code> 中防止重复判断。如果该终端支持，则再对图片格式进行替换。这个兼容性嗅探过程，也封装成 promise 化的通用接口。</p>\n</blockquote>\n<p>相关代码片段如下：</p>\n<pre><code class=\"lang-\">const supportWebp = () =&gt; new Promise(resolve =&gt; {\n\tconst image = new Image()\n\timage.onerror = () =&gt; resolve(false)\n\timage.onload = () =&gt; resolve(image.width === 1)\n\timage.src = &apos;data:image/webp;base64,UklGRiQAAABXRUJQVlA4IBgAAAAwAQCdASoBAAEAAwA0JaQAA3AA/vuUAAA=&apos;\n}).catch(() =&gt; false)\n</code></pre>\n<p>这时候，面试官往往会进一步关心项目收益情况。这就需要面试者根据实情作答，仍然以这个项目为例：</p>\n<blockquote>\n<p>在具体上线时，我对 10% 的流量进行了分组切分。5% 为对照组，仍然采用传统格式；另外 5% 为实验组，进行 WebP 格式试验。 <strong>最终结果显示收益非常有限</strong>。<br />\n为此我进行分析：认为出现近似零收益的原因是图片服务的缓存问题。新转换的一批 WebP 格式图片由于没有缓存，因而在性能上打了折扣。为了验证猜想，我决定继续进行扩量试验并观察结果。果然，后续排除缓存问题之后，收益提升 25%~30% 左右。</p>\n</blockquote>\n<p>这里，我们就涉及了工程优化中的一个重要环节：网络请求和缓存。这些内容我们会在后续课程网络环节《第 8-1课：缓存谁都懂，一问都哑口》中具体展开。</p>\n<p>通过以上回答，我如实讲述了出现的非预期 case，并说明遇见问题时，如何进行分析进而解决问题的一系列过程。这样的回答能明确表现出我确实做过该项目并进行了思考分析，最终落地。这类思路也更容易被面试官所接受。</p>\n<p>更多关于 WebP 的好文章：</p>\n<ul>\n<li><a href=\"https://www.keycdn.com/support/webp-support\" target=\"_blank\">WebP Support - It’s More Than You Think</a></li>\n<li><a href=\"http://www.uisdc.com/image-format-webp-introduction\" target=\"_blank\">从零开始带你认识最新的图片格式 WebP</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000007482148\" target=\"_blank\">把网站的图片升级到 WebP 格式吧</a></li>\n</ul>\n<p>也由此看出，性能优化其实并不难做，重要的是解决问题的思路，以及解决过程中对于项目的把控和推荐。这些内容我们称之为“软素质”。</p>\n<h4><a id=\"_72\"></a>按需加载优化</h4>\n<p>如果面试官围绕着刚才列举的“资源打包和逆向拆分（按需加载）”方向提问，我仍然会采用同样的“思路”进行回答：</p>\n<blockquote>\n<p>我接手项目之后，发现历史原有的资源打包配置并不合理，严重影响了性能表现。因此借助构建工具，对资源进行合并打包。但是，需要注意的是，我的策略并不是大刀阔斧地进行资源合并，因为这样会让 bundle.js 的 size 越来越大，所以也进行了逆向过程。</p>\n<p>以实际页面为例：</p>\n<p><img src=\"https://images.gitbook.cn/6f5fc910-bff2-11e9-8e2c-3b4fd17ad6da\" alt=\"enter image description here\" /></p>\n<p>如上，当点击左图播放按钮之后，页面出现视频列表浮层（右侧所示，仍为同一页面，类似单页应用）。视频列表浮层包含了滚动处理、视频播放等多项复杂逻辑，因此关于这个浮层的脚本我并没有进行打包合并，而是单独进行拆分。当用户点击浮层触发按钮后，再执行对这一部分脚本的请求。</p>\n</blockquote>\n<p>工程化性能优化不仅需要做，还要用数据证明做法的合理性：</p>\n<blockquote>\n<p>同时，我对用户点击触发按钮的概率进行统计，发现进入页面的用户只有 10% 左右会点击按钮，从而触发视频列表浮层。也就是说，大部分用户（90%）并不会看到这一浮层，延迟按需加载是有统计数据支持的。</p>\n</blockquote>\n<p>通过这个案例，我们发现性能优化其实是一个开放式问题，非常依赖实践。读者可根据上面的例子，结合自己的项目进行回答。</p>\n<p>虽然没有涉及代码实施，但是建立起项目意识和方向意识，这在工程化性能上非常难能可贵。上面提到的借助构建工具进行“按需加载”等内容，前面章节如《webpack 工程师 &gt; 前端工程师》都会具体从代码角度给出示例。</p>\n<p>当然上述举例的按需加载，我们并不是使用成熟的 webpack 工具链，而是采用公司内部封装的工程化工具。在几年前，这样的方案并不成熟，因此我写了一些按需加载的差距，配合自己的工程化工具使用。这一方面内容，很多面试官会很感兴趣，话题也可以延伸到 FIS 和 webpack 的比较，工程化工具的设计等话题。</p>\n<h4><a id=\"_94\"></a>讲不完的工程化优化</h4>\n<p>此外，工程优化方向还包括：</p>\n<ul>\n<li>图片懒加载</li>\n<li>雪碧图</li>\n<li>合理设置缓存策略</li>\n<li>使用 prefetch / preload 预加载等新特性</li>\n<li>以 tree shaking 手段为主的代码瘦身</li>\n</ul>\n<p>这里不再一一举例，欢迎订阅此课程的同学结合自己的经历在评论区留言讨论或者直接向我提问，我会尽量拿出时间跟大家一起进行项目分析、描述。</p>\n<p>以上是<strong>工程化</strong>性能的实际题目，总结一下：工程师需要对日常项目进行深入总结，结合产品角度、研发角度描述。在面试前就需要做到“心中有数，胸有成竹”。</p>\n<p>另外，在具体的实现方向上，关于性能优化的切入点也有很多。比如：</p>\n<ul>\n<li>动画性能方向</li>\n<li>操作 DOM 方向</li>\n<li>浏览器加载、渲染性能方向</li>\n<li>性能测量、监控方向</li>\n</ul>\n<p>这些方向并不是相互独立的，它们彼此依存，比如<strong>动画性能方向与浏览器渲染性能息息相关</strong>。这里我用一道经典的面试题来分析：<strong>“如果发现页面动画效果卡顿，你会从哪些角度解决问题？”</strong></p>\n<p>首先从动画实现入手：</p>\n<blockquote>\n<ul>\n<li>一般 CSS3 动画会比基于 JavaScript 实现的动画效率要高，因此优先使用 CSS3 实现效果（这一点并不绝对）</li>\n<li>在使用 CSS3 实现动画时，考虑开启 GPU 加速（这一点也并不总是正向效果）</li>\n<li>优先使用消耗最低的 transform 和 opacity 两个属性</li>\n<li>使用 will-change 属性</li>\n<li>独立合成层，减少绘制区域</li>\n<li>对于只能使用 JavaScript 实现动画效果的情况，考虑 requestAnimationFrame、requestIdleCallback API</li>\n<li>批量进行样式变换，减少布局抖动</li>\n</ul>\n</blockquote>\n<p>事实上，上面每一点的背后都包含着很多知识点，例如：</p>\n<ul>\n<li>如何理解 requestAnimationFrame 和 60 fps</li>\n<li>如何实现 requestAnimationFrame polyfill</li>\n<li>哪些操作会触发浏览器 reflow（重排）或者 repaint（重绘）</li>\n<li>对于给出的代码，如何进行优化</li>\n<li>如何实现滚动时的节流、防抖函数</li>\n</ul>\n<p>这些问题，我们会拿出其中几个在下一节分析。同时，订阅课程的朋友们，都可以在下节课末尾彩蛋区获得我在这些主题方向上收藏的文章。</p>\n<h3><a id=\"_137\"></a>总结</h3>\n<p>工程化优化是一个太大的话题了，本节课我们只是在“大面上”进行方向指引，以面试为角度抛砖引玉，更多具体代码细节实例，下节课我们会继续探讨。</p>\n<p>另外，正因为这个话题的特殊性，一千个项目，就有一千个优化场景，也欢迎大家拿出来项目中的具体情况，跟我讨论。</p>\n<h3><a id=\"font_color13aa6cfont_143\"></a><font color=13aa6c>分享交流</font></h3>\n<p>请大家留言分享「性能优化」方面的经验心得，也可以继续学习下一节等全部完结这个主题之后再分享。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后会抽空解答）。<strong>你的分享不仅帮助他人，更会提升自己。</strong></p>\n<p>同时，说说自己最想了解的主题，课程内容会根据大家的意见和建议迭代和完善。</p>\n<blockquote>\n<p><strong>为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。</strong></p>\n</blockquote>\n","readingStatistics":0,"createdAt":"2019-03-26T06:16:05.786Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":33,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FoThASW9dVEPMEo9nP-zaOfbKyLZ"},{"_id":"5c99c858ccb24267c1d01bd6","communication_start_time":null,"type":1,"audioPath":"","abstract":"","content":"上一节课，我们从宏观上讲述了性能优化的概念。这一节，我们直接来“手写代码”。\n\n在此之前，我们先回顾一下「性能优化」主题的知识点：\n\n<img src=\"https://images.gitbook.cn/a4889460-4ecc-11e9-8044-3de24c2bc492\" width=550>\n\n### <font color=13aa6c>代码例题实战</font>\n\n“白板写代码”是考察候选人基础能力、思维能力的有效手段。这一部分，我们列举几个性能相关的代码片段，供读者体会。\n\n#### 实战 1：初步解决布局抖动问题\n\n请候选人对以下代码进行优化：\n\n```\nvar h1 = element1.clientHeight\nelement1.style.height = (h1 * 2) + &apos;px&apos;\n\t\nvar h2 = element2.clientHeight\nelement2.style.height = (h2 * 2) + &apos;px&apos;\n\t\nvar h3 = element3.clientHeight\nelement3.style.height = (h3 * 2) + &apos;px&apos;\n```\n\n这是一道较为基础的题目，上面的代码，会造成典型的布局抖动问题。\n\n**布局抖动**是指 DOM 元素被 JavaScript 多次反复读写，导致文档多次无意义重排。我们知道浏览器很“懒”，它会收集（batch）当前操作，统一进行重排。可是，如果在当前操作完成前，从 DOM 元素中获取值，这会迫使浏览器提早执行布局操作，这称为**强制同步布局**。这样的副作用对于低配置的移动设备来说，后果是不堪设想的。\n\n我们对 element1 进行读、写操作之后，又企图去获取 element2 的值，浏览器为了获取正确的值，只能进行重排。优化思路为：\n\n```\n// 读\nvar h1 = element1.clientHeight\nvar h2 = element2.clientHeight\nvar h3 = element3.clientHeight\n \n// 写（无效布局）\nelement1.style.height = (h1 * 2) + &apos;px&apos;\nelement2.style.height = (h2 * 2) + &apos;px&apos;\nelement3.style.height = (h3 * 2) + &apos;px&apos;\n```\n\n#### 实战 2：使用 window.requestAnimationFrame 对上述代码优化\n\n如果读者对 window.requestAnimationFrame 不熟悉的话，我们先来看一下 MDN 上的说明：\n\n> 该方法告诉浏览器你希望执行的操作，并请求浏览器在下一次重绘之前调用指定的函数来更新。\n\n语法：\n\n```\nwindow.requestAnimationFrame(callback)\n```\n\n也就是说，当你需要更新屏幕画面时就可以调用此方法。在浏览器下次重绘前统一执行回调函数，优化方案：\n\n```\n// 读\nvar h1 = element1.clientHeight\n// 写\nrequestAnimationFrame(() => {\n\telement1.style.height = (h1 * 2) + &apos;px&apos;\n})\n \n// 读\nvar h2 = element2.clientHeight\n// 写\nrequestAnimationFrame(() => {\n\telement2.style.height = (h2 * 2) + &apos;px&apos;\n})\n\t\n// 读\nvar h3 = element3.clientHeight\n// 写\nrequestAnimationFrame(() => {\n\telement3.style.height = (h3 * 2) + &apos;px&apos;\n})\n```\n\n我们将代码中所有 DOM 的写操作在下一帧一起执行，保留所有 DOM 的读操作在当前同步状态。这样有效减少了无意义的重排，显然效率更高。\n\n#### 实战 3：延伸题目，实现 window.requestAnimationFrame 的 polyfill\n\npolyfill 就是我们常说的垫片，此处指在浏览器兼容性不支持的情况下，备选实现方案。\n\nwindow.requestAnimationFrame 在一些老版本浏览器中无法兼容，为了让代码在老机器也能运行不报错，请用代码实现：\n\n```\nif (!window.requestAnimationFrame) window.requestAnimationFrame = (callback, element) => {\n    const id = window.setTimeout(() => {\n        callback()\n    }, 1000 / 60)\n    return id\n}\nif (!window.cancelAnimationFrame) window.cancelAnimationFrame = id => {\n    clearTimeout(id)\n}\n```\n\n上面的代码按照 1 秒钟 60 次（大约每 16.7 毫秒一次），并使用 window.setTimeout 来进行模拟。这是一种粗略的实现，并没有考虑统一浏览器前缀和 callback 参数等问题。一般需求中，实现上面的答案已经可以符合要求了。\n\n#### 实战 4：为以下每个 li 添加点击事件\n\n```\n<div>\n    <ul>\n        <li>1</li>\n        <li>2</li>\n        <li>3</li>\n        <li>4</li>\n        <li>5</li>\n        <li>6</li>\n        <li>7</li>\n        <li>8</li>\n        <li>9</li>\n        <li>10</li>\n    </ul>\n</div>\n```\n\n这道题目非常基础，但是实现方式上需要注意是否使用了**事件委托**。如果候选人直接对 li 进行绑定处理，那么很容易给面试官留下「平时代码习惯不好」的印象，造成潜在性能负担。更好的做法显然是：\n\n```\nwindow.onload = () => {\n    const ul = document.getElementsByTagName(&apos;ul&apos;)[0]\n    const liList = document.getElementsByTagName(&apos;li&apos;)\n\t\n    ul.onclick = e => {\n        const normalizeE = e || window.event\n        const target = normalizeE.target || normalizeE.srcElement\n\t\n        if (target.nodeName.toLowerCase() == \"li\") {\n            alert(target.innerHTML)\n        }\n    }\n}\n```\n\n一般情况下，作为面试官，我不会提示候选人采用事件委托的写法，而是观察候选人的第一反应，对其代码习惯进行考察。如果候选人没有采用事件委托的写法，才会进一步追问。\n\n#### 实战 5：实现节流、防抖\n\n我们知道，鼠标滚动（scroll）、调整窗口大小（resize）、敲击键盘（keyup）这类事件在触发时往往频率极高。这时候事件对应的回调函数也会在极短时间内反复执行。想象一下，如果这些回调函数内的逻辑涉及复杂的计算，或者对 DOM 操作非常频繁，从而造成大量布局操作、绘制操作，那么就存在阻塞主线程的危险，直接后果就是掉帧，用户能够感受到明显的卡顿。\n\n有经验的程序员为了规避这样的问题，往往会使用节流（throttle）或者防抖（debounce）来进行处理。因此节流和防抖已经成为非常常见的优化手段，现如今也是面试的必考题型之一。\n\n**节流和防抖总是一起出现，那么它们有什么不同呢？** \n\n回答这个问题，我们首先要知道它们解决的问题相同，方向类似：**两者并不会减少事件的触发，而是减少事件触发时回调函数的执行次数**。为了达成这个目的，节流和防抖采用的手段有所差别。\n\n- 防抖：抖动现象本质就是指短时间内高频次触发。因此，我们可以把短时间内的多个连续调用合并成一次，也就是只触发一次回调函数。\n- 节流：顾名思义，就是将短时间的函数调用以一个固定的频率间隔执行，这就如同水龙头开关限制出水口流量。\n\n<a href=\"http://caiogondim.github.io/js-debounce-throttle-visual-explanation/\">这个例子</a>可以很形象地展示节流与防抖的区别。\n\n另外，请参考防抖图示：\n\n<img src=\"https://images.gitbook.cn/e1a88550-4eac-11e9-8d6d-edc0eec9ca99\" width=600>\n\n节流图示：\n\n<img src=\"https://images.gitbook.cn/e773acd0-4eac-11e9-b1fa-0757868d211c\" width=650>\n\n了解了原理，我们先来实现事件防抖：\n\n```\n// 简单的防抖动函数\nconst debounce = (func, wait, immediate) => {\n\tlet timeout\n\treturn function () {\n\t\tconst context = this\n\t\tconst args = arguments\n\t\t\t\n\t\tconst callNow = immediate & !timeout\n\t\t\t\n\t\ttimeout && clearTimeout(timeout)\n\t\t\t\n\t\ttimeout = setTimeout(function() {\n\t\t\ttimeout = null\n\t\t\tif (!immediate) func.apply(context, args)\n\t\t}, wait)\n\t\t\t\n\t\tif (callNow) func.apply(context, args)\n\t}\n}\n\t\n// 采用了防抖动\nwindow.addEventListener(&apos;scroll&apos;, debounce(() => {\n\tconsole.log(&apos;scroll&apos;)\n}, 500))\n\t\n// 没采用防抖动\nwindow.addEventListener(&apos;scroll&apos;, () => {\n\tconsole.log(&apos;scroll&apos;)\n})\n```\n\n如代码所示，我们使用 setTimeout 在 500ms 后执行事件回调，如果在这 500ms 内又有相关事件触发，则通过 clearTimeout(timeout) 取消上一次设置的回调。因此在 500ms 内没有连续触发多次 scroll 事件，才会真正触发 scroll 回调函数——或者说，500ms 内的多次调用被归并成了一次，在最后一次“抖动”后，进行回调执行。同时，我们设置了 immediate 参数，用以立即执行。关于 func.apply 的用法，学习过《第 1-1 课：一网打尽 this，对执行上下文说 Yes》的读者应该不会陌生。\n\n关于事件节流：\n\n```\nconst throttle = (func, wait) => {\n\tlet startTime = 0\n\treturn function() {\n\t\tlet handleTime = +new Date()\n\t\tlet context = this\n\t\tconst args = arguments\n\t\t\t\n\t\tif (handleTime - startTime >= wait) {\n\t\t\tfunc.apply(context, args)\n\t\t\tstartTime = handleTime\n\t\t}\n\t}\n}\n\t\nwindow.addEventListener(&apos;scroll&apos;, throttle(() => {\n\tconsole.log(&apos;scroll&apos;)\n}, 500))\n\n```\n\n当然，我们同样可以用 setTimeout 来实现：\n\n```\nconst throttle = (func, wait) => {\n\tlet timeout \n\t\n\treturn function () {\n\t\tconst context = this\n\t\tconst args = arguments\n\t\tif (!timeout) {\n\t\t\ttimeout = setTimeout(function() {\n\t\t\t\tfunc.apply(context, args)\n\t\t   \t\ttimeout = null\n\t\t  }, wait)\n\t\t}\n\t}\n}\n```\n\n与防抖相比，少了 clearTimeout 的操作，请读者细心对比。\n\n要准确理解节流和防抖，需要多动手实践。这里也建议大家有时间研究研究 lodash 库关于节流和防抖的实现。事实上，这个话题还可以玩出很多花来，比如如何暴露给开发者 cancelDebounce，又如上述 throttle 的两种方式各有哪些瑕疵，针对这些瑕疵，是否可以结合两种实现优化？感兴趣的读者请在评论区留言探讨，或者在文末彩蛋部分找到相关内容。\n\n### <font color=13aa6c>总结</font>\n\n性能优化，实在是一个极大的话题，需要我们在平时工作学习中不断积累。对于准备面试的朋友，在面试前，除了时刻注意代码习惯、掌握常见考点以外，还要整理、回顾、复盘平时的性能相关项目。\n\n这一节课难以覆盖性能优化的方方面面，本课程的其他章节，还会有这个话题的相关渗透，如网络协议、缓存策略、数据结构和算法等，这些内容和性能息息相关。请大家持续关注学习，同时欢迎在评论区和其他小伙伴讨论以及向我提问。\n\n课程代码仓库：\n<a href=\"https://github.com/HOUCe/lucas-gitchat-courses\">https://github.com/HOUCe/lucas-gitchat-courses</a>\n\n### <font color=13aa6c>彩蛋分享</font>\n\n#### 节流和防抖相关\n\n- [Debouncing and Throttling Explained Through Examples](https://css-tricks.com/debouncing-throttling-explained-examples/)\n- [谈谈 JS 中的函数节流](https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651551467&idx=2&sn=2ce4ce1ec06c32aa698451128985b870&chksm=8025a12ab752283c66f1e529664fcc9fe272d5d500f8daedcc35e85f79baa69b62a208b2235a&scene=0#wechat_redirect)\n- [JavaScript 函数节流和函数防抖之间的区别](https://juejin.im/entry/58a3911b570c35006cdc2d6a)\n- [高性能滚动 scroll 及页面渲染优化](https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651552107&idx=1&sn=7ea1a6d4b3cf1c8a99b50f703e4c41f1&chksm=8025aeaab75227bc3bae46270d175bd1444f4983c9472eb93de5fc9c19951416e239dcc4860f&mpshare=1&scene=1&srcid=0419s6nwU8LrOAy4BP2TH3wO&key=14e4edd6ca5f2a5d9d86be4c9f83873bba1ae3395ad7d51553704ab7d15851bb129ead9ae2751548d6e530fcdfb471b1b7fdc9d4576bac260e706ef288ada0c02f31962f40314318bb69347d0284f0c2&ascene=0&uin=NjI4NTQ2ODIx&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.4+build(14E46)&version=12020110&nettype=WIFI&fontScale=100&pass_ticket=OxCcOonsw3hgntyvXy%2FSYPn%2Fw9jx2Hv%2FheV8seAGt987cQT%2FygphdRBJ0UyMTQvc)\n- [从 lodash 源码学习节流与防抖](https://juejin.im/post/5b043309f265da0ba77015e7)\n- [理解并优化函数节流 Throttle](https://juejin.im/post/5be24d76e51d451def13cca2)\n\n#### 浏览器引擎渲染性能相关\n\n- [Inside look at modern web browser](https://developers.google.com/web/resources/contributors/kosamari)\n- [How Browsers Work: Behind the scenes of modern web browsers](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/)\n- [How browsers work](http://taligarsiel.com/Projects/howbrowserswork1.htm)\n- [How browser rendering works — behind the scenes](https://blog.logrocket.com/how-browser-rendering-works-behind-the-scenes-6782b0e8fb10)\n- [What Every Frontend Developer Should Know About Webpage Rendering](http://frontendbabel.info/articles/webpage-rendering-101/)\n- [前端文摘：深入解析浏览器的幕后工作原理](https://www.cnblogs.com/lhb25/p/how-browsers-work.html)\n- [从 Chrome 源码看浏览器如何加载资源](https://zhuanlan.zhihu.com/p/30558018)\n- [浏览器内核渲染：重建引擎](https://juejin.im/post/5bbaa7da6fb9a05d3761aafe)\n- [体现工匠精神的 Resource Hints](https://juejin.im/entry/5c26d05d5188257a937fb6b2)\n- [浏览器页面渲染机制，你真的弄懂了吗](https://www.itcodemonkey.com/article/10417.html)\n- [前端不止：Web 性能优化 – 关键渲染路径以及优化策略](https://insights.thoughtworks.cn/critical-rendering-path-and-optimization-strategy/)\n- [浏览器前端优化](https://zcfy.cc/article/optimising-the-front-end-for-the-browser-hacker-noon-2847.html)\n- [浅析前端页面渲染机制](https://mp.weixin.qq.com/s/1kQ-cyQmLfLcYiLiJ_ViwA?)\n- [浅析渲染引擎与前端优化](https://juejin.im/entry/5893fbe88d6d8100582e8b7f)\n- [渲染性能](https://github.com/sundway/blog/issues/2)\n- [Repaint 、Reflow 的基本认识和优化 (2)](https://segmentfault.com/a/1190000002629708)\n\n#### 动画性能相关\n\n- [Timing control for script-based animations](https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/dev-guides/hh920765(v=vs.85))\n- [Gain Motion Superpowers with requestAnimationFrame](https://medium.com/@bdc/gain-motion-superpowers-with-requestanimationframe-ecc6d5b0d9a4)\n- [CSS Animation 性能优化](https://github.com/amfe/article/issues/47)\n- [GSAP的动画快于 jQuery 吗？为何？](https://segmentfault.com/a/1190000000391529)\n- [Javascript 高性能动画与页面渲染](https://juejin.im/entry/58b0187c1b69e60058a09faf)\n- [也许你不知道，JS animation 比 CSS 更快！](https://mp.weixin.qq.com/s?__biz=MzA5NzkwNDk3MQ==&mid=2650585331&amp;idx=1&amp;sn=c2d55ab4c5458d3dcda25188fd608079&source=41#wechat_redirect)\n- [渐进式动画解决方案](https://www.w3cplus.com/animation/progressive-web-animation.html)\n- [你应该知道的 requestIdleCallback](https://juejin.im/post/5ad71f39f265da239f07e862)\n- [无线性能优化：Composite](http://taobaofed.org/blog/2016/04/25/performance-composite/)\n- [优化动画卡顿：卡顿原因分析及优化方案](https://juejin.im/post/5c8a1db15188257e9044ec52)\n- [一篇文章说清浏览器解析和 CSS（GPU）动画优化](https://mp.weixin.qq.com/s/kC7RmozaG5bWjIqdiZat7A?)\n\n#### 实战案例相关\n\n- [Building the Google Photos Web UI](https://medium.com/google-design/google-photos-45b714dfbed1)\n- [A Netflix Web Performance Case Study](https://medium.com/dev-channel/a-netflix-web-performance-case-study-c0bcde26a9d9)\n- [The Cost Of JavaScript In 2018](https://medium.com/@addyosmani/the-cost-of-javascript-in-2018-7d8950fbb5d4)\n- [How we reduced our initial JS/CSS size by 67%](https://dev.to/goenning/how-we-reduced-our-initial-jscss-size-by-67-3ac0?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more?add=add)\n- [Front-End Performance Checklist 2019](https://www.smashingmagazine.com/2019/01/front-end-performance-checklist-2019-pdf-pages/)\n- [网站性能优化实战——从 12.67s 到 1.06s 的故事](https://imweb.io/topic/5b6fd3c13cb5a02f33c013bd)\n- [前端黑科技：美团网页首帧优化实践](https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&mid=2247489935&idx=1&sn=f59537133b8548caf5a513ee95ecc1be&chksm=f951acccce2625da71bacdb5cd814bcdc8900c293c56662bbad6e39af40ebd451837d3866404&token=1623409489&lang=zh_CN&scene=21#wechat_redirect)\n- [Web 字体图标-自动化方案](https://juejin.im/post/5c398a81e51d4551e13b88f3?add=asd)\n- [JS 加载慢？谷歌大神带你飞!](https://mp.weixin.qq.com/s/uWuzwE1jPHbd73Y3UiyezA)\n- [前端性能优化（三） 移动端浏览器前端优化策略](https://my.oschina.net/zhangstephen/blog/1601383?from=juejin)\n- [CSS @font-face 性能优化](https://juejin.im/post/5c7e578de51d4541c11413fc)\n- [移动 Web 性能优化从入门到进阶](https://juejin.im/post/5c931c4a6fb9a070dc28923b)\n- [记一次惊心动魄的前端性能优化之旅](https://segmentfault.com/a/1190000005147979)\n\n### <font color=13aa6c>分享交流</font>\n\n请大家留言分享「性能优化」方面的经验心得。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到会抽空解答）。**你的分享不仅帮助他人，更会提升自己。**\n\n你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。\n\n>**为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。**","pdfUrl":"","reader":"","duration":"","title":"性能优化问题，老司机如何解决（下）","column":"5c91c813968b1d64b1e08fde","isNotification":false,"htmlContent":"<p>上一节课，我们从宏观上讲述了性能优化的概念。这一节，我们直接来“手写代码”。</p>\n<p>在此之前，我们先回顾一下「性能优化」主题的知识点：</p>\n<img src=\"https://images.gitbook.cn/a4889460-4ecc-11e9-8044-3de24c2bc492\" width=550>\n<h3><a id=\"font_color13aa6cfont_6\"></a><font color=13aa6c>代码例题实战</font></h3>\n<p>“白板写代码”是考察候选人基础能力、思维能力的有效手段。这一部分，我们列举几个性能相关的代码片段，供读者体会。</p>\n<h4><a id=\"_1_10\"></a>实战 1：初步解决布局抖动问题</h4>\n<p>请候选人对以下代码进行优化：</p>\n<pre><code class=\"lang-\">var h1 = element1.clientHeight\nelement1.style.height = (h1 * 2) + &apos;px&apos;\n\t\nvar h2 = element2.clientHeight\nelement2.style.height = (h2 * 2) + &apos;px&apos;\n\t\nvar h3 = element3.clientHeight\nelement3.style.height = (h3 * 2) + &apos;px&apos;\n</code></pre>\n<p>这是一道较为基础的题目，上面的代码，会造成典型的布局抖动问题。</p>\n<p><strong>布局抖动</strong>是指 DOM 元素被 JavaScript 多次反复读写，导致文档多次无意义重排。我们知道浏览器很“懒”，它会收集（batch）当前操作，统一进行重排。可是，如果在当前操作完成前，从 DOM 元素中获取值，这会迫使浏览器提早执行布局操作，这称为<strong>强制同步布局</strong>。这样的副作用对于低配置的移动设备来说，后果是不堪设想的。</p>\n<p>我们对 element1 进行读、写操作之后，又企图去获取 element2 的值，浏览器为了获取正确的值，只能进行重排。优化思路为：</p>\n<pre><code class=\"lang-\">// 读\nvar h1 = element1.clientHeight\nvar h2 = element2.clientHeight\nvar h3 = element3.clientHeight\n \n// 写（无效布局）\nelement1.style.height = (h1 * 2) + &apos;px&apos;\nelement2.style.height = (h2 * 2) + &apos;px&apos;\nelement3.style.height = (h3 * 2) + &apos;px&apos;\n</code></pre>\n<h4><a id=\"_2_windowrequestAnimationFrame__43\"></a>实战 2：使用 window.requestAnimationFrame 对上述代码优化</h4>\n<p>如果读者对 window.requestAnimationFrame 不熟悉的话，我们先来看一下 MDN 上的说明：</p>\n<blockquote>\n<p>该方法告诉浏览器你希望执行的操作，并请求浏览器在下一次重绘之前调用指定的函数来更新。</p>\n</blockquote>\n<p>语法：</p>\n<pre><code class=\"lang-\">window.requestAnimationFrame(callback)\n</code></pre>\n<p>也就是说，当你需要更新屏幕画面时就可以调用此方法。在浏览器下次重绘前统一执行回调函数，优化方案：</p>\n<pre><code class=\"lang-\">// 读\nvar h1 = element1.clientHeight\n// 写\nrequestAnimationFrame(() =&gt; {\n\telement1.style.height = (h1 * 2) + &apos;px&apos;\n})\n \n// 读\nvar h2 = element2.clientHeight\n// 写\nrequestAnimationFrame(() =&gt; {\n\telement2.style.height = (h2 * 2) + &apos;px&apos;\n})\n\t\n// 读\nvar h3 = element3.clientHeight\n// 写\nrequestAnimationFrame(() =&gt; {\n\telement3.style.height = (h3 * 2) + &apos;px&apos;\n})\n</code></pre>\n<p>我们将代码中所有 DOM 的写操作在下一帧一起执行，保留所有 DOM 的读操作在当前同步状态。这样有效减少了无意义的重排，显然效率更高。</p>\n<h4><a id=\"_3_windowrequestAnimationFrame__polyfill_82\"></a>实战 3：延伸题目，实现 window.requestAnimationFrame 的 polyfill</h4>\n<p>polyfill 就是我们常说的垫片，此处指在浏览器兼容性不支持的情况下，备选实现方案。</p>\n<p>window.requestAnimationFrame 在一些老版本浏览器中无法兼容，为了让代码在老机器也能运行不报错，请用代码实现：</p>\n<pre><code class=\"lang-\">if (!window.requestAnimationFrame) window.requestAnimationFrame = (callback, element) =&gt; {\n    const id = window.setTimeout(() =&gt; {\n        callback()\n    }, 1000 / 60)\n    return id\n}\nif (!window.cancelAnimationFrame) window.cancelAnimationFrame = id =&gt; {\n    clearTimeout(id)\n}\n</code></pre>\n<p>上面的代码按照 1 秒钟 60 次（大约每 16.7 毫秒一次），并使用 window.setTimeout 来进行模拟。这是一种粗略的实现，并没有考虑统一浏览器前缀和 callback 参数等问题。一般需求中，实现上面的答案已经可以符合要求了。</p>\n<h4><a id=\"_4_li__102\"></a>实战 4：为以下每个 li 添加点击事件</h4>\n<pre><code class=\"lang-\">&lt;div&gt;\n    &lt;ul&gt;\n        &lt;li&gt;1&lt;/li&gt;\n        &lt;li&gt;2&lt;/li&gt;\n        &lt;li&gt;3&lt;/li&gt;\n        &lt;li&gt;4&lt;/li&gt;\n        &lt;li&gt;5&lt;/li&gt;\n        &lt;li&gt;6&lt;/li&gt;\n        &lt;li&gt;7&lt;/li&gt;\n        &lt;li&gt;8&lt;/li&gt;\n        &lt;li&gt;9&lt;/li&gt;\n        &lt;li&gt;10&lt;/li&gt;\n    &lt;/ul&gt;\n&lt;/div&gt;\n</code></pre>\n<p>这道题目非常基础，但是实现方式上需要注意是否使用了<strong>事件委托</strong>。如果候选人直接对 li 进行绑定处理，那么很容易给面试官留下「平时代码习惯不好」的印象，造成潜在性能负担。更好的做法显然是：</p>\n<pre><code class=\"lang-\">window.onload = () =&gt; {\n    const ul = document.getElementsByTagName(&apos;ul&apos;)[0]\n    const liList = document.getElementsByTagName(&apos;li&apos;)\n\t\n    ul.onclick = e =&gt; {\n        const normalizeE = e || window.event\n        const target = normalizeE.target || normalizeE.srcElement\n\t\n        if (target.nodeName.toLowerCase() == &quot;li&quot;) {\n            alert(target.innerHTML)\n        }\n    }\n}\n</code></pre>\n<p>一般情况下，作为面试官，我不会提示候选人采用事件委托的写法，而是观察候选人的第一反应，对其代码习惯进行考察。如果候选人没有采用事件委托的写法，才会进一步追问。</p>\n<h4><a id=\"_5_141\"></a>实战 5：实现节流、防抖</h4>\n<p>我们知道，鼠标滚动（scroll）、调整窗口大小（resize）、敲击键盘（keyup）这类事件在触发时往往频率极高。这时候事件对应的回调函数也会在极短时间内反复执行。想象一下，如果这些回调函数内的逻辑涉及复杂的计算，或者对 DOM 操作非常频繁，从而造成大量布局操作、绘制操作，那么就存在阻塞主线程的危险，直接后果就是掉帧，用户能够感受到明显的卡顿。</p>\n<p>有经验的程序员为了规避这样的问题，往往会使用节流（throttle）或者防抖（debounce）来进行处理。因此节流和防抖已经成为非常常见的优化手段，现如今也是面试的必考题型之一。</p>\n<p><strong>节流和防抖总是一起出现，那么它们有什么不同呢？</strong></p>\n<p>回答这个问题，我们首先要知道它们解决的问题相同，方向类似：<strong>两者并不会减少事件的触发，而是减少事件触发时回调函数的执行次数</strong>。为了达成这个目的，节流和防抖采用的手段有所差别。</p>\n<ul>\n<li>防抖：抖动现象本质就是指短时间内高频次触发。因此，我们可以把短时间内的多个连续调用合并成一次，也就是只触发一次回调函数。</li>\n<li>节流：顾名思义，就是将短时间的函数调用以一个固定的频率间隔执行，这就如同水龙头开关限制出水口流量。</li>\n</ul>\n<p><a href=\"http://caiogondim.github.io/js-debounce-throttle-visual-explanation/\">这个例子</a>可以很形象地展示节流与防抖的区别。</p>\n<p>另外，请参考防抖图示：</p>\n<img src=\"https://images.gitbook.cn/e1a88550-4eac-11e9-8d6d-edc0eec9ca99\" width=600>\n<p>节流图示：</p>\n<img src=\"https://images.gitbook.cn/e773acd0-4eac-11e9-b1fa-0757868d211c\" width=650>\n<p>了解了原理，我们先来实现事件防抖：</p>\n<pre><code class=\"lang-\">// 简单的防抖动函数\nconst debounce = (func, wait, immediate) =&gt; {\n\tlet timeout\n\treturn function () {\n\t\tconst context = this\n\t\tconst args = arguments\n\t\t\t\n\t\tconst callNow = immediate &amp; !timeout\n\t\t\t\n\t\ttimeout &amp;&amp; clearTimeout(timeout)\n\t\t\t\n\t\ttimeout = setTimeout(function() {\n\t\t\ttimeout = null\n\t\t\tif (!immediate) func.apply(context, args)\n\t\t}, wait)\n\t\t\t\n\t\tif (callNow) func.apply(context, args)\n\t}\n}\n\t\n// 采用了防抖动\nwindow.addEventListener(&apos;scroll&apos;, debounce(() =&gt; {\n\tconsole.log(&apos;scroll&apos;)\n}, 500))\n\t\n// 没采用防抖动\nwindow.addEventListener(&apos;scroll&apos;, () =&gt; {\n\tconsole.log(&apos;scroll&apos;)\n})\n</code></pre>\n<p>如代码所示，我们使用 setTimeout 在 500ms 后执行事件回调，如果在这 500ms 内又有相关事件触发，则通过 clearTimeout(timeout) 取消上一次设置的回调。因此在 500ms 内没有连续触发多次 scroll 事件，才会真正触发 scroll 回调函数——或者说，500ms 内的多次调用被归并成了一次，在最后一次“抖动”后，进行回调执行。同时，我们设置了 immediate 参数，用以立即执行。关于 func.apply 的用法，学习过《第 1-1 课：一网打尽 this，对执行上下文说 Yes》的读者应该不会陌生。</p>\n<p>关于事件节流：</p>\n<pre><code class=\"lang-\">const throttle = (func, wait) =&gt; {\n\tlet startTime = 0\n\treturn function() {\n\t\tlet handleTime = +new Date()\n\t\tlet context = this\n\t\tconst args = arguments\n\t\t\t\n\t\tif (handleTime - startTime &gt;= wait) {\n\t\t\tfunc.apply(context, args)\n\t\t\tstartTime = handleTime\n\t\t}\n\t}\n}\n\t\nwindow.addEventListener(&apos;scroll&apos;, throttle(() =&gt; {\n\tconsole.log(&apos;scroll&apos;)\n}, 500))\n\n</code></pre>\n<p>当然，我们同样可以用 setTimeout 来实现：</p>\n<pre><code class=\"lang-\">const throttle = (func, wait) =&gt; {\n\tlet timeout \n\t\n\treturn function () {\n\t\tconst context = this\n\t\tconst args = arguments\n\t\tif (!timeout) {\n\t\t\ttimeout = setTimeout(function() {\n\t\t\t\tfunc.apply(context, args)\n\t\t   \t\ttimeout = null\n\t\t  }, wait)\n\t\t}\n\t}\n}\n</code></pre>\n<p>与防抖相比，少了 clearTimeout 的操作，请读者细心对比。</p>\n<p>要准确理解节流和防抖，需要多动手实践。这里也建议大家有时间研究研究 lodash 库关于节流和防抖的实现。事实上，这个话题还可以玩出很多花来，比如如何暴露给开发者 cancelDebounce，又如上述 throttle 的两种方式各有哪些瑕疵，针对这些瑕疵，是否可以结合两种实现优化？感兴趣的读者请在评论区留言探讨，或者在文末彩蛋部分找到相关内容。</p>\n<h3><a id=\"font_color13aa6cfont_246\"></a><font color=13aa6c>总结</font></h3>\n<p>性能优化，实在是一个极大的话题，需要我们在平时工作学习中不断积累。对于准备面试的朋友，在面试前，除了时刻注意代码习惯、掌握常见考点以外，还要整理、回顾、复盘平时的性能相关项目。</p>\n<p>这一节课难以覆盖性能优化的方方面面，本课程的其他章节，还会有这个话题的相关渗透，如网络协议、缓存策略、数据结构和算法等，这些内容和性能息息相关。请大家持续关注学习，同时欢迎在评论区和其他小伙伴讨论以及向我提问。</p>\n<p>课程代码仓库：<br />\n<a href=\"https://github.com/HOUCe/lucas-gitchat-courses\">https://github.com/HOUCe/lucas-gitchat-courses</a></p>\n<h3><a id=\"font_color13aa6cfont_255\"></a><font color=13aa6c>彩蛋分享</font></h3>\n<h4><a id=\"_257\"></a>节流和防抖相关</h4>\n<ul>\n<li><a href=\"https://css-tricks.com/debouncing-throttling-explained-examples/\" target=\"_blank\">Debouncing and Throttling Explained Through Examples</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651551467&amp;idx=2&amp;sn=2ce4ce1ec06c32aa698451128985b870&amp;chksm=8025a12ab752283c66f1e529664fcc9fe272d5d500f8daedcc35e85f79baa69b62a208b2235a&amp;scene=0#wechat_redirect\" target=\"_blank\">谈谈 JS 中的函数节流</a></li>\n<li><a href=\"https://juejin.im/entry/58a3911b570c35006cdc2d6a\" target=\"_blank\">JavaScript 函数节流和函数防抖之间的区别</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651552107&amp;idx=1&amp;sn=7ea1a6d4b3cf1c8a99b50f703e4c41f1&amp;chksm=8025aeaab75227bc3bae46270d175bd1444f4983c9472eb93de5fc9c19951416e239dcc4860f&amp;mpshare=1&amp;scene=1&amp;srcid=0419s6nwU8LrOAy4BP2TH3wO&amp;key=14e4edd6ca5f2a5d9d86be4c9f83873bba1ae3395ad7d51553704ab7d15851bb129ead9ae2751548d6e530fcdfb471b1b7fdc9d4576bac260e706ef288ada0c02f31962f40314318bb69347d0284f0c2&amp;ascene=0&amp;uin=NjI4NTQ2ODIx&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.4+build(14E46)&amp;version=12020110&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=OxCcOonsw3hgntyvXy%2FSYPn%2Fw9jx2Hv%2FheV8seAGt987cQT%2FygphdRBJ0UyMTQvc\" target=\"_blank\">高性能滚动 scroll 及页面渲染优化</a></li>\n<li><a href=\"https://juejin.im/post/5b043309f265da0ba77015e7\" target=\"_blank\">从 lodash 源码学习节流与防抖</a></li>\n<li><a href=\"https://juejin.im/post/5be24d76e51d451def13cca2\" target=\"_blank\">理解并优化函数节流 Throttle</a></li>\n</ul>\n<h4><a id=\"_266\"></a>浏览器引擎渲染性能相关</h4>\n<ul>\n<li><a href=\"https://developers.google.com/web/resources/contributors/kosamari\" target=\"_blank\">Inside look at modern web browser</a></li>\n<li><a href=\"https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/\" target=\"_blank\">How Browsers Work: Behind the scenes of modern web browsers</a></li>\n<li><a href=\"http://taligarsiel.com/Projects/howbrowserswork1.htm\" target=\"_blank\">How browsers work</a></li>\n<li><a href=\"https://blog.logrocket.com/how-browser-rendering-works-behind-the-scenes-6782b0e8fb10\" target=\"_blank\">How browser rendering works — behind the scenes</a></li>\n<li><a href=\"http://frontendbabel.info/articles/webpage-rendering-101/\" target=\"_blank\">What Every Frontend Developer Should Know About Webpage Rendering</a></li>\n<li><a href=\"https://www.cnblogs.com/lhb25/p/how-browsers-work.html\" target=\"_blank\">前端文摘：深入解析浏览器的幕后工作原理</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/30558018\" target=\"_blank\">从 Chrome 源码看浏览器如何加载资源</a></li>\n<li><a href=\"https://juejin.im/post/5bbaa7da6fb9a05d3761aafe\" target=\"_blank\">浏览器内核渲染：重建引擎</a></li>\n<li><a href=\"https://juejin.im/entry/5c26d05d5188257a937fb6b2\" target=\"_blank\">体现工匠精神的 Resource Hints</a></li>\n<li><a href=\"https://www.itcodemonkey.com/article/10417.html\" target=\"_blank\">浏览器页面渲染机制，你真的弄懂了吗</a></li>\n<li><a href=\"https://insights.thoughtworks.cn/critical-rendering-path-and-optimization-strategy/\" target=\"_blank\">前端不止：Web 性能优化 – 关键渲染路径以及优化策略</a></li>\n<li><a href=\"https://zcfy.cc/article/optimising-the-front-end-for-the-browser-hacker-noon-2847.html\" target=\"_blank\">浏览器前端优化</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/1kQ-cyQmLfLcYiLiJ_ViwA?\" target=\"_blank\">浅析前端页面渲染机制</a></li>\n<li><a href=\"https://juejin.im/entry/5893fbe88d6d8100582e8b7f\" target=\"_blank\">浅析渲染引擎与前端优化</a></li>\n<li><a href=\"https://github.com/sundway/blog/issues/2\" target=\"_blank\">渲染性能</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000002629708\" target=\"_blank\">Repaint 、Reflow 的基本认识和优化 (2)</a></li>\n</ul>\n<h4><a id=\"_285\"></a>动画性能相关</h4>\n<ul>\n<li><a href=\"https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/dev-guides/hh920765(v=vs.85)\" target=\"_blank\">Timing control for script-based animations</a></li>\n<li><a href=\"https://medium.com/@bdc/gain-motion-superpowers-with-requestanimationframe-ecc6d5b0d9a4\" target=\"_blank\">Gain Motion Superpowers with requestAnimationFrame</a></li>\n<li><a href=\"https://github.com/amfe/article/issues/47\" target=\"_blank\">CSS Animation 性能优化</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000000391529\" target=\"_blank\">GSAP的动画快于 jQuery 吗？为何？</a></li>\n<li><a href=\"https://juejin.im/entry/58b0187c1b69e60058a09faf\" target=\"_blank\">Javascript 高性能动画与页面渲染</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzA5NzkwNDk3MQ==&amp;mid=2650585331&amp;idx=1&amp;sn=c2d55ab4c5458d3dcda25188fd608079&amp;source=41#wechat_redirect\" target=\"_blank\">也许你不知道，JS animation 比 CSS 更快！</a></li>\n<li><a href=\"https://www.w3cplus.com/animation/progressive-web-animation.html\" target=\"_blank\">渐进式动画解决方案</a></li>\n<li><a href=\"https://juejin.im/post/5ad71f39f265da239f07e862\" target=\"_blank\">你应该知道的 requestIdleCallback</a></li>\n<li><a href=\"http://taobaofed.org/blog/2016/04/25/performance-composite/\" target=\"_blank\">无线性能优化：Composite</a></li>\n<li><a href=\"https://juejin.im/post/5c8a1db15188257e9044ec52\" target=\"_blank\">优化动画卡顿：卡顿原因分析及优化方案</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/kC7RmozaG5bWjIqdiZat7A?\" target=\"_blank\">一篇文章说清浏览器解析和 CSS（GPU）动画优化</a></li>\n</ul>\n<h4><a id=\"_299\"></a>实战案例相关</h4>\n<ul>\n<li><a href=\"https://medium.com/google-design/google-photos-45b714dfbed1\" target=\"_blank\">Building the Google Photos Web UI</a></li>\n<li><a href=\"https://medium.com/dev-channel/a-netflix-web-performance-case-study-c0bcde26a9d9\" target=\"_blank\">A Netflix Web Performance Case Study</a></li>\n<li><a href=\"https://medium.com/@addyosmani/the-cost-of-javascript-in-2018-7d8950fbb5d4\" target=\"_blank\">The Cost Of JavaScript In 2018</a></li>\n<li><a href=\"https://dev.to/goenning/how-we-reduced-our-initial-jscss-size-by-67-3ac0?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more?add=add\" target=\"_blank\">How we reduced our initial JS/CSS size by 67%</a></li>\n<li><a href=\"https://www.smashingmagazine.com/2019/01/front-end-performance-checklist-2019-pdf-pages/\" target=\"_blank\">Front-End Performance Checklist 2019</a></li>\n<li><a href=\"https://imweb.io/topic/5b6fd3c13cb5a02f33c013bd\" target=\"_blank\">网站性能优化实战——从 12.67s 到 1.06s 的故事</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&amp;mid=2247489935&amp;idx=1&amp;sn=f59537133b8548caf5a513ee95ecc1be&amp;chksm=f951acccce2625da71bacdb5cd814bcdc8900c293c56662bbad6e39af40ebd451837d3866404&amp;token=1623409489&amp;lang=zh_CN&amp;scene=21#wechat_redirect\" target=\"_blank\">前端黑科技：美团网页首帧优化实践</a></li>\n<li><a href=\"https://juejin.im/post/5c398a81e51d4551e13b88f3?add=asd\" target=\"_blank\">Web 字体图标-自动化方案</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/uWuzwE1jPHbd73Y3UiyezA\" target=\"_blank\">JS 加载慢？谷歌大神带你飞!</a></li>\n<li><a href=\"https://my.oschina.net/zhangstephen/blog/1601383?from=juejin\" target=\"_blank\">前端性能优化（三） 移动端浏览器前端优化策略</a></li>\n<li><a href=\"https://juejin.im/post/5c7e578de51d4541c11413fc\" target=\"_blank\">CSS @font-face 性能优化</a></li>\n<li><a href=\"https://juejin.im/post/5c931c4a6fb9a070dc28923b\" target=\"_blank\">移动 Web 性能优化从入门到进阶</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000005147979\" target=\"_blank\">记一次惊心动魄的前端性能优化之旅</a></li>\n</ul>\n<h3><a id=\"font_color13aa6cfont_315\"></a><font color=13aa6c>分享交流</font></h3>\n<p>请大家留言分享「性能优化」方面的经验心得。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到会抽空解答）。<strong>你的分享不仅帮助他人，更会提升自己。</strong></p>\n<p>你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。</p>\n<blockquote>\n<p><strong>为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。</strong></p>\n</blockquote>\n","readingStatistics":1,"createdAt":"2019-03-26T06:36:08.440Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":34,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FoThASW9dVEPMEo9nP-zaOfbKyLZ"},{"_id":"5cbbf474bbbba80861a35c62","communication_start_time":null,"type":1,"audioPath":"","abstract":"","content":"在上一节课中，我们提到了性能优化。在这个话题上，除了工程化层面的优化和语言层面的优化以外，框架性能也备受瞩目。这一节课，我们就来聊聊框架的性能话题，并以 React 为例进行分析。\n\n主要知识点如下：\n\n![enter image description here](https://images.gitbook.cn/dd24aad0-cbf3-11e9-a9bd-857608719494)\n\n### <font color=13aa6c>框架性能到底指什么</font>\n\n说起框架的性能话题，很多读者可能会想到“不要过早地做优化”这条原则。实际上，大部分应用的复杂度并不会对性能和产品体验构成挑战。毕竟在之前课程中我们学习到，现代化的框架凭借高效的虚拟 DOM diff 算法和（或）响应式理念，以及框架内部引擎，已经做得较为完美了，一般项目需求对性能的压力并不大。\n\n但是对于一些极其复杂的需求，性能优化是无法回避的。如果你开发的是图形处理应用、DNA 检测实验应用、富文本编辑器或者功能丰富的表单型应用，则很容易触碰到性能瓶颈。同样，作为框架的使用者，也需要对性能优化有所了解，这对于理解框架本身也是有很大帮助的。\n\n前端开发自然离不开浏览器，而性能优化大都在和浏览器打交道。我们知道，页面每一帧的变化都是由浏览器绘制出来的，并且这个绘制频率受限于显示器的刷新频率，因此一个重要的性能数据指标是每秒 60 帧的绘制频率。这样进行简单的换算之后，每一帧只有 16.6ms 的绘制时间。\n\n如果一个应用对用户的交互响应处理过慢，则需要花费很长的时间来计算更新数据，这就造成了应用缓慢、性能低下的问题，被用户感知造成极差的用户体验。对于框架来说，以 React 为例，开发者不需要额外关注 DOM 层面的操作。因为 React 通过维护虚拟 DOM 及其高效的 diff 算法，可以决策出每次更新的最小化 DOM batch 操作。**但实际上，使用 React 能完成的性能优化，使用纯原生的 JavaScript 都能做到，甚至做得更好。只不过经过 React 统一处理后，大大节省了开发成本，同时也降低了应用性能对开发者优化技能的依赖。**\n\n**因此现代框架的性能表现，除了想办法缩减自身的 bundle size 之外，主要优化点就在于框架本身运行时对 DOM 层操作的合理性以及自身引擎计算的高效性。**这一点我们会通过两节课程来慢慢展开。\n\n### <font color=13aa6c>React 的虚拟 DOM diff</font>\n\nReact 主要通过以下几种方式来保证虚拟的 DOM diff 算法和更新的高效性能：\n\n- 高效的 diff 算法\n- Batch 操作\n- 摒弃脏检测更新方式\n\n当任何一个组件使用 setState 方法时，React 都会认为该组件变“脏”，触发组件本身的重新渲染（re-render）。同时因其始终维护两套虚拟的 DOM，其中一套是更新后的虚拟的 DOM；另一套是前一个状态的虚拟的 DOM。通过对这两套虚拟的 DOM 的 diff 算法，找到需要变化的最小单元集，然后把这个最小单元集应用在真实的 DOM 当中。\n\n而通过 diff 算法找到这个最小单元集后，React 采用启发式的思路进行了一些假设，将两棵 DOM 树之间的 diff 成本由 O(n3) 缩减到 O(n)。\n\n说到这里，你一定很想知道 React 的那些大胆假设吧：\n\n- DOM 节点跨层级移动忽略不计\n- 拥有相同类的两个组件生成相似的树形结构，拥有不同类的两个组件生成不同的树形结构\n\n根据这些假设，ReactJS 采取的策略如下：\n\n- React 对组件树进行分层比较，两棵树只会对同一层级的节点进行比较\n- 当对同一层级节点进行比较时，对于不同的组件类型，直接将整个组件替换为新类型组件\n\n对于下图所示的组件结构，我们可以想象：如果子组件 B 和 H 的类型同时发生变化，当遍历到 B 组件时，直接进行新组件的替换，减少了不必要的消耗。\n\n![enter image description here](https://images.gitbook.cn/33f3e140-c6d7-11e9-99c1-c37abd23c4b1)\n\n- 当对同一层级节点进行比较时，对于相同的组件类型，如果组件的 state 或 props 发生变化，则直接重新渲染组件本身。开发者可以尝试使用 shouldComponentUpdate 生命周期函数来规避不必要的渲染。\n- 当对同一层级节点进行比较时，开发者可以使用 key 属性来“声明”同一层级节点的更新方式。\n\n另外，setState 方法引发了“蝴蝶效应”，并通过创新的 diff 算法找到需要更新的最小单元集，但是这些变更也并不一定立即同步产生。实际上，React 会进行 setState 的 batch 操作，通俗地讲就是“积攒归并”一批变化后，再统一进行更新。显然这是出于对性能的考虑。\n\n### <font color=13aa6c>提升 React 应用性能的建议</font>\n\n我们知道，React 渲染真实的 DOM 节点的过程由两个主要过程组成：\n\n- 对 React 内部维护的虚拟的 DOM 进行更新\n- 前后两个虚拟 DOM 比对，并将 diff 所得结果应用于真实的 DOM 中的过程\n\n这两步极其关键，设想一下，如果虚拟的 DOM 更新很慢，那么重新渲染势必会很耗时。本节我们就针对此问题，对症下药，来了解更多的性能优化小技巧。\n\n#### 最大限度地减少 re-render\n\n为了提升 React 应用性能，我们首先想到的就是最大限度地规避不必要的 re-render。但是当状态发生变化时，重新渲染是 React 内部的默认行为，我们如何保证不必要的渲染呢？\n\n最先想到的一定是使用 shouldComponentUpdate 生命周期函数，它旨在对比前后状态 state/props 是否出现了变更，根据是否变更来决定组件是否需要重新渲染。\n\n实际上，还有很多方式，开发者都可以给 React 发送“不需要渲染”的信号。\n\n比如，无状态组件返回同一个 element 实例：如果 render 方法返回同一个 element 实例，React 会认为组件并没有发生变化。请参考以下代码：\n\n```\nclass MyComponent extends Component {\n  text = \"\";\n  renderedElement = null;\n  _render() {\n    return <div>{this.props.text}</div>\n  }\n  render() {\n    if (!this.renderedElement || this.props.text !== this.text) {\n      this.text = this.props.text;\n      this.renderedElement = _render();\n    }\n    return this.renderedElement;\n  }\n```\n\n熟悉 lodash 库的读者，可能会想到其带来的 memoize 函数，同样可以用来简化上述代码：\n\n```\nimport memoize from &apos;lodash/memoize&apos;\n\nclass MyComponent extends Component {\n  _render = memoize((text) => <div>{text}</div>)\n  render() {\n    return _render(this.props.text)\n  }\n}\n```\n\n在之前介绍的高阶组件的基础上，我们不妨设想这样一类高阶组件：它能够细粒度地控制组件的渲染行为。比如，某个组件仅仅在某一项 props 变化时才会触发 re-render。这样一来，开发者可以完全掌控组件渲染时机，更有针对性地进行渲染优化。\n\n这样的方法有点类似于农业灌溉上的“滴灌”技术，它规避了代价昂贵的粗暴型灌溉，而是精准地定位需求，从而达到节约水资源的目的。\n\n在社区中，优秀的 recompose 库恰好可以满足我们的需求。请参考如下代码：\n\n```\n@onlyUpdateForKeys([&apos;prop1&apos;, &apos;prop2&apos;])\nclass MyComponent2 extends Component {\n  render() {\n      //...\n  }\n}\n```\n\n使用 @onlyUpdateForKeys 修饰器，MyComponent2  组件只在 prop1 和 prop2 变化时才进行渲染；否则其他的 props 发生任何改变，都不会触发 re-render。\n\n藏在 onlyUpdateForKeys 背后的“黑魔法”其实并不难理解，只需要在高阶组件中调用 shouldComponentUpdate 方法，在 shouldComponentUpdate 方法中比较对象由完整的 props 转为传入的指定 props 即可。有兴趣的读者，可以翻阅 recompose 源码进行了解，其实思路即是如此。\n\n#### 规避  inline function 反模式\n\n我们需要注意一个“反模式”。当使用 render 方法时，要留意 render 方法内创建的函数或者数组等，这些创建可能是显式地，也可能是隐式生成。因为这些新生成的函数或数组，在量大时会造成一定的性能负担。同时 render 方法经常被反复执行多次，也就是说总有新的函数或数组被创建，这样造成内存无意义开销。往往性能更友好的做法只需要它们创建一次即可，而不是每次渲染都被创建。比如：\n\n```\nrender() {\n  return <MyInput onChange={this.props.update.bind(this)} />;\n}\n```\n\n或者：\n\n```\nrender() {\n  return <MyInput onChange={() => this.props.update()} />;\n}\n```\n\n对于 render 方法内产生数组或其他类型的情况，也存在类似问题：\n\n```\nrender() {\n  return <SubComponent items={this.props.items || []}/>\n}\n```\n\n这样做会在每次渲染且 this.props.items 不存在时创建一个空数组。更好的做法是：\n\n```\nconst EMPTY_ARRAY = []\nrender() {\n    return <SubComponent items={this.props.items || EMPTY_ARRAY}/>\n}\n```\n\n事实上，不得不说，这些性能副作用或者优化手段都“微乎其微”，并不是性能恶化的“罪魁祸首”。但是理解这些内容对我们编写出高质量的代码还是有帮助的。我们后续课程会针对这种情况进行框架层面上的启发式探索。\n\n#### 使用 PureComponent 保证开发性能\n\nPureComponent 大体与 Component 相同，唯一不同的地方是 PureComponent 会自动帮助开发者使用 shouldComponentUpdate 生命周期方法。也就是说，当组件 state 或者 props 发生变化时，正常的 Component 都会自动进行 re-render，在这种情况下，shouldComponentUpdate 默认都会返回 true。但是 PureComponent 会先进行对比，即比较前后两次 state 和 props 是否相等。需要注意的是，这种对比是浅比较：\n\n```\nfunction shallowEqual (objA: mixed, objB: mixed) {\n    if (is(objA, objB)) {\n        return true;\n    }\n\n    if (typeof objA !== &apos;object&apos; || objA === null ||\n        typeof objB !== &apos;object&apos; || objB === null) {\n        return false;\n    }\n\n    const keysA = Object.keys(objA);\n    const keysB = Object.keys(objB);\n\n    if (keysA.length !== keysB.length) {\n        return false;\n    }\n\n    for (let i = 0; i < keysA.length; i++) {\n        if (\n        !hasOwnProperty.call(objB, keysA[i]) ||\n        !is(objA[keysA[i]], objB[keysA[i]])\n        ) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```\n\n基于以上代码，我们总结出使用 PureComponent 需要注意如下细节：\n\n- 既然是浅比较，也就是说，当与前一状态下的 props 和 state 比对时，如果比较对象是 JavaScript 基本类型，则会对其值是否相等进行判断；如果比较对象是 JavaScript 引用类型，比如 object 或者 array，则会判断其引用是否相同，而不会进行值比较；\n- 开发者需要避免共享（mutate）带来的问题。\n\n如果在一个父组件中对 object 进行了 mutate 的操作，若子组件依赖此数据，且采用PureComponent 声明，那么子组件将无法进行更新。尽管 props 中的某一项值发生了变化，但是它的引用并没有发生变化，因此 PureComponent 的 shouldComponentUpdate 也就返回了 false。更好的做法是在更新 props 或 state 时，返回一个新的对象或数组。\n\n#### 分析一个真实案例\n\n设想一下，如果应用组件非常复杂，含有一个具有很长 list 的组件，如果只是其中一个子组件发生了变化，那么使用 PureComponent 进行对比，有选择性地进行渲染，一定是比所有列表项目都重新渲染划算很多。\n\n我们来看一个案例：简易实现一个采用 PureComponent 和不采用 PureComponent 的性能差别对比试验。假如在页面中需要渲染非常多的用户信息，所有的用户信息都被维护在一个 users 数组当中，数组的每一项为一个 JavaScript 对象，表示一个用户的基本信息。User 组件负责渲染每一个用户的信息内容：\n\n```\nimport User from &apos;./User&apos;\nconst Users = ({users}) =>\n    <div>\n        {users.map(user => <User {...user} />}\n    </div>\n```\n\n这样做存在的问题是：users 数组作为 Users 组件的 props 出现，users 数组的第 K 项发生变化时，users 数组即发生变化，Users 组件重新渲染导致所有的 User 组件都会进行渲染。某个 User 组件，即使非 K 项并没有发生变化，这个 User 组件不需要重新渲染，但也不得不必要的渲染。\n\n在测试中，我们渲染了一个有 200 项的数组：\n\n```\nconst arraySize = 200;\nconst getUsers = () =>\n  Array(arraySize)\n    .fill(1)\n    .map((_, index) => ({\n      name: &apos;John Doe&apos;,\n      hobby: &apos;Painting&apos;,\n      age: index === 0 ? Math.random() * 100 : 50\n    }));\n```\n\n注意：在 getUsers 方法中，对 age 属性进行了判断，保证每次调用时，getUsers 返回的数组只有第一项的 age 属性不同，其余的全部为 50。在测试组件中，在 componentDidUpdate 中保证数组将会触发 400 次 re-render，并且每一次只改变数组第一项的 age 属性，其他的均保持不变。\n\n```\n  const repeats = 400;\n  componentDidUpdate() {\n    ++this.renderCount;\n    this.dt += performance.now() - this.startTime;\n    if (this.renderCount % repeats === 0) {\n      if (this.componentUnderTestIndex > -1) {\n        this.dts[componentsToTest[this.componentUnderTestIndex]] = this.dt;\n        console.log(\n          &apos;dt&apos;,\n          componentsToTest[this.componentUnderTestIndex],\n          this.dt\n        );\n      }\n      ++this.componentUnderTestIndex;\n      this.dt = 0;\n      this.componentUnderTest = componentsToTest[this.componentUnderTestIndex];\n    }\n    if (this.componentUnderTest) {\n      setTimeout(() => {\n        this.startTime = performance.now();\n        this.setState({ users: getUsers() });\n      }, 0);\n    } \n    else {\n      alert(`\n        Render Performance ArraySize: ${arraySize} Repeats: ${repeats}\n        Functional: ${Math.round(this.dts.Functional)} ms\n        PureComponent: ${Math.round(this.dts.PureComponent)} ms\n        Component: ${Math.round(this.dts.Component)} ms\n      `);\n    }\n  }\n```\n  \n下面对三种组件声明方式进行对比。\n\n- 函数式方式\n\n```\nexport const Functional = ({ name, age, hobby }) => (\n  <div>\n    <span>{name}</span>\n    <span>{age}</span>\n    <span>{hobby}</span>\n  </div>\n)\n```\n\n- PureComponent 方式\n\n```\nexport class PureComponent extends React.PureComponent {\n  render() {\n    const { name, age, hobby } = this.props;\n    return (\n      <div>\n        <span>{name}</span>\n        <span>{age}</span>\n        <span>{hobby}</span>\n      </div>\n    )\n  }\n}\n```\n\n- 经典 class 方式\n\n```\nexport class Component extends React.Component {\n  render() {\n    const { name, age, hobby } = this.props;\n    return (\n      <div>\n        <span>{name}</span>\n        <span>{age}</span>\n        <span>{hobby}</span>\n      </div>\n    )\n  }\n``` \n\n在使用 PureComponent 声明的组件中，会自动在触发渲染前后进行 {name, age, hobby} 对象值比较。如果没有发生变化，则 shouldComponentUpdate 返回 false，以规避不必要的渲染。因此，使用 PureComponent 声明的组件性能明显优于其他方式。在不同的浏览器环境下，可以得出：\n\n- 在 Firefox 下，PureComponent 收益 30%\n- 在 Safari 下，PureComponent 收益 6%\n- 在 Chrome 下，PureComponent 收益 15%\n\n实际上，我们通过定义 changedItems 来表示变化数组的项目，array 表示所需渲染的数组。changedItems.length/array.length 的比值越小，表示数组中变化的元素也越少，React.PureComponent 涉及的性能优化也越有必要实施，因为  React.PureComponent 通过浅比较规避了不必要的更新过程，而浅比较自身的计算成本一般都不值一提，可以节约成本。\n\n当然，PureComponent 也不是万能的，尤其是它的浅比较，需要开发者格外注意。因此在特定情况下，开发者根据需求自己实现 shouldComponentUpdate 中的比较逻辑，将是更高效的选择。\n\n### <font color=13aa6c>总结</font>\n\n性能优化是前端开发中一个永恒的话题，不同框架之间的性能对比也一直是各位开发者关注的方面。性能涉及方方面面，如前端工程化、浏览器解析和渲染、比较算法等。本章主要介绍了 React 框架在性能上的优劣、虚拟的 DOM 思想，以及在开发 React 应用时需要注意的性能优化环节和手段。\n也许不是每个应用都会面临性能的问题，如同社区中所说的：“过早地进行性能优化是毫无必要的，但是开发者在性能优化方面的积累却要时刻先行。”同时，优化手段也在与时俱进，不断更新，需要开发者时刻保持学习。\n\n### <font color=13aa6c>分享交流</font>\n\n请大家留言分享「性能优化」方面的经验心得。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到会抽空解答）。**你的分享不仅帮助他人，更会提升自己。**\n\n你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。\n\n>**为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。**","pdfUrl":"","reader":"","duration":"","title":"以 React 为例，说说框架和性能（上）","column":"5c91c813968b1d64b1e08fde","isNotification":false,"readingStatistics":0,"htmlContent":"<p>在上一节课中，我们提到了性能优化。在这个话题上，除了工程化层面的优化和语言层面的优化以外，框架性能也备受瞩目。这一节课，我们就来聊聊框架的性能话题，并以 React 为例进行分析。</p>\n<p>主要知识点如下：</p>\n<p><img src=\"https://images.gitbook.cn/dd24aad0-cbf3-11e9-a9bd-857608719494\" alt=\"enter image description here\" /></p>\n<h3><a id=\"font_color13aa6cfont_6\"></a><font color=13aa6c>框架性能到底指什么</font></h3>\n<p>说起框架的性能话题，很多读者可能会想到“不要过早地做优化”这条原则。实际上，大部分应用的复杂度并不会对性能和产品体验构成挑战。毕竟在之前课程中我们学习到，现代化的框架凭借高效的虚拟 DOM diff 算法和（或）响应式理念，以及框架内部引擎，已经做得较为完美了，一般项目需求对性能的压力并不大。</p>\n<p>但是对于一些极其复杂的需求，性能优化是无法回避的。如果你开发的是图形处理应用、DNA 检测实验应用、富文本编辑器或者功能丰富的表单型应用，则很容易触碰到性能瓶颈。同样，作为框架的使用者，也需要对性能优化有所了解，这对于理解框架本身也是有很大帮助的。</p>\n<p>前端开发自然离不开浏览器，而性能优化大都在和浏览器打交道。我们知道，页面每一帧的变化都是由浏览器绘制出来的，并且这个绘制频率受限于显示器的刷新频率，因此一个重要的性能数据指标是每秒 60 帧的绘制频率。这样进行简单的换算之后，每一帧只有 16.6ms 的绘制时间。</p>\n<p>如果一个应用对用户的交互响应处理过慢，则需要花费很长的时间来计算更新数据，这就造成了应用缓慢、性能低下的问题，被用户感知造成极差的用户体验。对于框架来说，以 React 为例，开发者不需要额外关注 DOM 层面的操作。因为 React 通过维护虚拟 DOM 及其高效的 diff 算法，可以决策出每次更新的最小化 DOM batch 操作。<strong>但实际上，使用 React 能完成的性能优化，使用纯原生的 JavaScript 都能做到，甚至做得更好。只不过经过 React 统一处理后，大大节省了开发成本，同时也降低了应用性能对开发者优化技能的依赖。</strong></p>\n<p>**因此现代框架的性能表现，除了想办法缩减自身的 bundle size 之外，主要优化点就在于框架本身运行时对 DOM 层操作的合理性以及自身引擎计算的高效性。**这一点我们会通过两节课程来慢慢展开。</p>\n<h3><a id=\"font_color13aa6cReact__DOM_difffont_18\"></a><font color=13aa6c>React 的虚拟 DOM diff</font></h3>\n<p>React 主要通过以下几种方式来保证虚拟的 DOM diff 算法和更新的高效性能：</p>\n<ul>\n<li>高效的 diff 算法</li>\n<li>Batch 操作</li>\n<li>摒弃脏检测更新方式</li>\n</ul>\n<p>当任何一个组件使用 setState 方法时，React 都会认为该组件变“脏”，触发组件本身的重新渲染（re-render）。同时因其始终维护两套虚拟的 DOM，其中一套是更新后的虚拟的 DOM；另一套是前一个状态的虚拟的 DOM。通过对这两套虚拟的 DOM 的 diff 算法，找到需要变化的最小单元集，然后把这个最小单元集应用在真实的 DOM 当中。</p>\n<p>而通过 diff 算法找到这个最小单元集后，React 采用启发式的思路进行了一些假设，将两棵 DOM 树之间的 diff 成本由 O(n3) 缩减到 O(n)。</p>\n<p>说到这里，你一定很想知道 React 的那些大胆假设吧：</p>\n<ul>\n<li>DOM 节点跨层级移动忽略不计</li>\n<li>拥有相同类的两个组件生成相似的树形结构，拥有不同类的两个组件生成不同的树形结构</li>\n</ul>\n<p>根据这些假设，ReactJS 采取的策略如下：</p>\n<ul>\n<li>React 对组件树进行分层比较，两棵树只会对同一层级的节点进行比较</li>\n<li>当对同一层级节点进行比较时，对于不同的组件类型，直接将整个组件替换为新类型组件</li>\n</ul>\n<p>对于下图所示的组件结构，我们可以想象：如果子组件 B 和 H 的类型同时发生变化，当遍历到 B 组件时，直接进行新组件的替换，减少了不必要的消耗。</p>\n<p><img src=\"https://images.gitbook.cn/33f3e140-c6d7-11e9-99c1-c37abd23c4b1\" alt=\"enter image description here\" /></p>\n<ul>\n<li>当对同一层级节点进行比较时，对于相同的组件类型，如果组件的 state 或 props 发生变化，则直接重新渲染组件本身。开发者可以尝试使用 shouldComponentUpdate 生命周期函数来规避不必要的渲染。</li>\n<li>当对同一层级节点进行比较时，开发者可以使用 key 属性来“声明”同一层级节点的更新方式。</li>\n</ul>\n<p>另外，setState 方法引发了“蝴蝶效应”，并通过创新的 diff 算法找到需要更新的最小单元集，但是这些变更也并不一定立即同步产生。实际上，React 会进行 setState 的 batch 操作，通俗地讲就是“积攒归并”一批变化后，再统一进行更新。显然这是出于对性能的考虑。</p>\n<h3><a id=\"font_color13aa6c_React_font_49\"></a><font color=13aa6c>提升 React 应用性能的建议</font></h3>\n<p>我们知道，React 渲染真实的 DOM 节点的过程由两个主要过程组成：</p>\n<ul>\n<li>对 React 内部维护的虚拟的 DOM 进行更新</li>\n<li>前后两个虚拟 DOM 比对，并将 diff 所得结果应用于真实的 DOM 中的过程</li>\n</ul>\n<p>这两步极其关键，设想一下，如果虚拟的 DOM 更新很慢，那么重新渲染势必会很耗时。本节我们就针对此问题，对症下药，来了解更多的性能优化小技巧。</p>\n<h4><a id=\"_rerender_58\"></a>最大限度地减少 re-render</h4>\n<p>为了提升 React 应用性能，我们首先想到的就是最大限度地规避不必要的 re-render。但是当状态发生变化时，重新渲染是 React 内部的默认行为，我们如何保证不必要的渲染呢？</p>\n<p>最先想到的一定是使用 shouldComponentUpdate 生命周期函数，它旨在对比前后状态 state/props 是否出现了变更，根据是否变更来决定组件是否需要重新渲染。</p>\n<p>实际上，还有很多方式，开发者都可以给 React 发送“不需要渲染”的信号。</p>\n<p>比如，无状态组件返回同一个 element 实例：如果 render 方法返回同一个 element 实例，React 会认为组件并没有发生变化。请参考以下代码：</p>\n<pre><code class=\"lang-\">class MyComponent extends Component {\n  text = &quot;&quot;;\n  renderedElement = null;\n  _render() {\n    return &lt;div&gt;{this.props.text}&lt;/div&gt;\n  }\n  render() {\n    if (!this.renderedElement || this.props.text !== this.text) {\n      this.text = this.props.text;\n      this.renderedElement = _render();\n    }\n    return this.renderedElement;\n  }\n</code></pre>\n<p>熟悉 lodash 库的读者，可能会想到其带来的 memoize 函数，同样可以用来简化上述代码：</p>\n<pre><code class=\"lang-\">import memoize from &apos;lodash/memoize&apos;\n\nclass MyComponent extends Component {\n  _render = memoize((text) =&gt; &lt;div&gt;{text}&lt;/div&gt;)\n  render() {\n    return _render(this.props.text)\n  }\n}\n</code></pre>\n<p>在之前介绍的高阶组件的基础上，我们不妨设想这样一类高阶组件：它能够细粒度地控制组件的渲染行为。比如，某个组件仅仅在某一项 props 变化时才会触发 re-render。这样一来，开发者可以完全掌控组件渲染时机，更有针对性地进行渲染优化。</p>\n<p>这样的方法有点类似于农业灌溉上的“滴灌”技术，它规避了代价昂贵的粗暴型灌溉，而是精准地定位需求，从而达到节约水资源的目的。</p>\n<p>在社区中，优秀的 recompose 库恰好可以满足我们的需求。请参考如下代码：</p>\n<pre><code class=\"lang-\">@onlyUpdateForKeys([&apos;prop1&apos;, &apos;prop2&apos;])\nclass MyComponent2 extends Component {\n  render() {\n      //...\n  }\n}\n</code></pre>\n<p>使用 @onlyUpdateForKeys 修饰器，MyComponent2  组件只在 prop1 和 prop2 变化时才进行渲染；否则其他的 props 发生任何改变，都不会触发 re-render。</p>\n<p>藏在 onlyUpdateForKeys 背后的“黑魔法”其实并不难理解，只需要在高阶组件中调用 shouldComponentUpdate 方法，在 shouldComponentUpdate 方法中比较对象由完整的 props 转为传入的指定 props 即可。有兴趣的读者，可以翻阅 recompose 源码进行了解，其实思路即是如此。</p>\n<h4><a id=\"__inline_function__116\"></a>规避  inline function 反模式</h4>\n<p>我们需要注意一个“反模式”。当使用 render 方法时，要留意 render 方法内创建的函数或者数组等，这些创建可能是显式地，也可能是隐式生成。因为这些新生成的函数或数组，在量大时会造成一定的性能负担。同时 render 方法经常被反复执行多次，也就是说总有新的函数或数组被创建，这样造成内存无意义开销。往往性能更友好的做法只需要它们创建一次即可，而不是每次渲染都被创建。比如：</p>\n<pre><code class=\"lang-\">render() {\n  return &lt;MyInput onChange={this.props.update.bind(this)} /&gt;;\n}\n</code></pre>\n<p>或者：</p>\n<pre><code class=\"lang-\">render() {\n  return &lt;MyInput onChange={() =&gt; this.props.update()} /&gt;;\n}\n</code></pre>\n<p>对于 render 方法内产生数组或其他类型的情况，也存在类似问题：</p>\n<pre><code class=\"lang-\">render() {\n  return &lt;SubComponent items={this.props.items || []}/&gt;\n}\n</code></pre>\n<p>这样做会在每次渲染且 this.props.items 不存在时创建一个空数组。更好的做法是：</p>\n<pre><code class=\"lang-\">const EMPTY_ARRAY = []\nrender() {\n    return &lt;SubComponent items={this.props.items || EMPTY_ARRAY}/&gt;\n}\n</code></pre>\n<p>事实上，不得不说，这些性能副作用或者优化手段都“微乎其微”，并不是性能恶化的“罪魁祸首”。但是理解这些内容对我们编写出高质量的代码还是有帮助的。我们后续课程会针对这种情况进行框架层面上的启发式探索。</p>\n<h4><a id=\"_PureComponent__153\"></a>使用 PureComponent 保证开发性能</h4>\n<p>PureComponent 大体与 Component 相同，唯一不同的地方是 PureComponent 会自动帮助开发者使用 shouldComponentUpdate 生命周期方法。也就是说，当组件 state 或者 props 发生变化时，正常的 Component 都会自动进行 re-render，在这种情况下，shouldComponentUpdate 默认都会返回 true。但是 PureComponent 会先进行对比，即比较前后两次 state 和 props 是否相等。需要注意的是，这种对比是浅比较：</p>\n<pre><code class=\"lang-\">function shallowEqual (objA: mixed, objB: mixed) {\n    if (is(objA, objB)) {\n        return true;\n    }\n\n    if (typeof objA !== &apos;object&apos; || objA === null ||\n        typeof objB !== &apos;object&apos; || objB === null) {\n        return false;\n    }\n\n    const keysA = Object.keys(objA);\n    const keysB = Object.keys(objB);\n\n    if (keysA.length !== keysB.length) {\n        return false;\n    }\n\n    for (let i = 0; i &lt; keysA.length; i++) {\n        if (\n        !hasOwnProperty.call(objB, keysA[i]) ||\n        !is(objA[keysA[i]], objB[keysA[i]])\n        ) {\n            return false;\n        }\n    }\n\n    return true;\n}\n</code></pre>\n<p>基于以上代码，我们总结出使用 PureComponent 需要注意如下细节：</p>\n<ul>\n<li>既然是浅比较，也就是说，当与前一状态下的 props 和 state 比对时，如果比较对象是 JavaScript 基本类型，则会对其值是否相等进行判断；如果比较对象是 JavaScript 引用类型，比如 object 或者 array，则会判断其引用是否相同，而不会进行值比较；</li>\n<li>开发者需要避免共享（mutate）带来的问题。</li>\n</ul>\n<p>如果在一个父组件中对 object 进行了 mutate 的操作，若子组件依赖此数据，且采用PureComponent 声明，那么子组件将无法进行更新。尽管 props 中的某一项值发生了变化，但是它的引用并没有发生变化，因此 PureComponent 的 shouldComponentUpdate 也就返回了 false。更好的做法是在更新 props 或 state 时，返回一个新的对象或数组。</p>\n<h4><a id=\"_195\"></a>分析一个真实案例</h4>\n<p>设想一下，如果应用组件非常复杂，含有一个具有很长 list 的组件，如果只是其中一个子组件发生了变化，那么使用 PureComponent 进行对比，有选择性地进行渲染，一定是比所有列表项目都重新渲染划算很多。</p>\n<p>我们来看一个案例：简易实现一个采用 PureComponent 和不采用 PureComponent 的性能差别对比试验。假如在页面中需要渲染非常多的用户信息，所有的用户信息都被维护在一个 users 数组当中，数组的每一项为一个 JavaScript 对象，表示一个用户的基本信息。User 组件负责渲染每一个用户的信息内容：</p>\n<pre><code class=\"lang-\">import User from &apos;./User&apos;\nconst Users = ({users}) =&gt;\n    &lt;div&gt;\n        {users.map(user =&gt; &lt;User {...user} /&gt;}\n    &lt;/div&gt;\n</code></pre>\n<p>这样做存在的问题是：users 数组作为 Users 组件的 props 出现，users 数组的第 K 项发生变化时，users 数组即发生变化，Users 组件重新渲染导致所有的 User 组件都会进行渲染。某个 User 组件，即使非 K 项并没有发生变化，这个 User 组件不需要重新渲染，但也不得不必要的渲染。</p>\n<p>在测试中，我们渲染了一个有 200 项的数组：</p>\n<pre><code class=\"lang-\">const arraySize = 200;\nconst getUsers = () =&gt;\n  Array(arraySize)\n    .fill(1)\n    .map((_, index) =&gt; ({\n      name: &apos;John Doe&apos;,\n      hobby: &apos;Painting&apos;,\n      age: index === 0 ? Math.random() * 100 : 50\n    }));\n</code></pre>\n<p>注意：在 getUsers 方法中，对 age 属性进行了判断，保证每次调用时，getUsers 返回的数组只有第一项的 age 属性不同，其余的全部为 50。在测试组件中，在 componentDidUpdate 中保证数组将会触发 400 次 re-render，并且每一次只改变数组第一项的 age 属性，其他的均保持不变。</p>\n<pre><code class=\"lang-\">  const repeats = 400;\n  componentDidUpdate() {\n    ++this.renderCount;\n    this.dt += performance.now() - this.startTime;\n    if (this.renderCount % repeats === 0) {\n      if (this.componentUnderTestIndex &gt; -1) {\n        this.dts[componentsToTest[this.componentUnderTestIndex]] = this.dt;\n        console.log(\n          &apos;dt&apos;,\n          componentsToTest[this.componentUnderTestIndex],\n          this.dt\n        );\n      }\n      ++this.componentUnderTestIndex;\n      this.dt = 0;\n      this.componentUnderTest = componentsToTest[this.componentUnderTestIndex];\n    }\n    if (this.componentUnderTest) {\n      setTimeout(() =&gt; {\n        this.startTime = performance.now();\n        this.setState({ users: getUsers() });\n      }, 0);\n    } \n    else {\n      alert(`\n        Render Performance ArraySize: ${arraySize} Repeats: ${repeats}\n        Functional: ${Math.round(this.dts.Functional)} ms\n        PureComponent: ${Math.round(this.dts.PureComponent)} ms\n        Component: ${Math.round(this.dts.Component)} ms\n      `);\n    }\n  }\n</code></pre>\n<p>下面对三种组件声明方式进行对比。</p>\n<ul>\n<li>函数式方式</li>\n</ul>\n<pre><code class=\"lang-\">export const Functional = ({ name, age, hobby }) =&gt; (\n  &lt;div&gt;\n    &lt;span&gt;{name}&lt;/span&gt;\n    &lt;span&gt;{age}&lt;/span&gt;\n    &lt;span&gt;{hobby}&lt;/span&gt;\n  &lt;/div&gt;\n)\n</code></pre>\n<ul>\n<li>PureComponent 方式</li>\n</ul>\n<pre><code class=\"lang-\">export class PureComponent extends React.PureComponent {\n  render() {\n    const { name, age, hobby } = this.props;\n    return (\n      &lt;div&gt;\n        &lt;span&gt;{name}&lt;/span&gt;\n        &lt;span&gt;{age}&lt;/span&gt;\n        &lt;span&gt;{hobby}&lt;/span&gt;\n      &lt;/div&gt;\n    )\n  }\n}\n</code></pre>\n<ul>\n<li>经典 class 方式</li>\n</ul>\n<pre><code class=\"lang-\">export class Component extends React.Component {\n  render() {\n    const { name, age, hobby } = this.props;\n    return (\n      &lt;div&gt;\n        &lt;span&gt;{name}&lt;/span&gt;\n        &lt;span&gt;{age}&lt;/span&gt;\n        &lt;span&gt;{hobby}&lt;/span&gt;\n      &lt;/div&gt;\n    )\n  }\n</code></pre>\n<p>在使用 PureComponent 声明的组件中，会自动在触发渲染前后进行 {name, age, hobby} 对象值比较。如果没有发生变化，则 shouldComponentUpdate 返回 false，以规避不必要的渲染。因此，使用 PureComponent 声明的组件性能明显优于其他方式。在不同的浏览器环境下，可以得出：</p>\n<ul>\n<li>在 Firefox 下，PureComponent 收益 30%</li>\n<li>在 Safari 下，PureComponent 收益 6%</li>\n<li>在 Chrome 下，PureComponent 收益 15%</li>\n</ul>\n<p>实际上，我们通过定义 changedItems 来表示变化数组的项目，array 表示所需渲染的数组。changedItems.length/array.length 的比值越小，表示数组中变化的元素也越少，React.PureComponent 涉及的性能优化也越有必要实施，因为  React.PureComponent 通过浅比较规避了不必要的更新过程，而浅比较自身的计算成本一般都不值一提，可以节约成本。</p>\n<p>当然，PureComponent 也不是万能的，尤其是它的浅比较，需要开发者格外注意。因此在特定情况下，开发者根据需求自己实现 shouldComponentUpdate 中的比较逻辑，将是更高效的选择。</p>\n<h3><a id=\"font_color13aa6cfont_319\"></a><font color=13aa6c>总结</font></h3>\n<p>性能优化是前端开发中一个永恒的话题，不同框架之间的性能对比也一直是各位开发者关注的方面。性能涉及方方面面，如前端工程化、浏览器解析和渲染、比较算法等。本章主要介绍了 React 框架在性能上的优劣、虚拟的 DOM 思想，以及在开发 React 应用时需要注意的性能优化环节和手段。<br />\n也许不是每个应用都会面临性能的问题，如同社区中所说的：“过早地进行性能优化是毫无必要的，但是开发者在性能优化方面的积累却要时刻先行。”同时，优化手段也在与时俱进，不断更新，需要开发者时刻保持学习。</p>\n<h3><a id=\"font_color13aa6cfont_324\"></a><font color=13aa6c>分享交流</font></h3>\n<p>请大家留言分享「性能优化」方面的经验心得。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到会抽空解答）。<strong>你的分享不仅帮助他人，更会提升自己。</strong></p>\n<p>你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。</p>\n<blockquote>\n<p><strong>为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。</strong></p>\n</blockquote>\n","createdAt":"2019-04-21T04:41:24.326Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":35,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FoThASW9dVEPMEo9nP-zaOfbKyLZ"},{"_id":"5cbbf49bbbbba80861a35c64","communication_start_time":null,"type":1,"audioPath":"","abstract":"","content":"在上一讲中，我们提到了框架性能优化的一些基本概念，并分析了以 React 框架为代表的常用优化手段。但是这些内容还不够，需要了解更多框架设计底层的性能相关话题。这一讲，我将会以 Vue（未来新版本 3.0）和 React 为主，分析这两个框架在设计层面，而非使用层面的性能考量。\n\n相关知识点如下图所示：\n\n![enter image description here](https://images.gitbook.cn/dd24aad0-cbf3-11e9-a9bd-857608719494)\n\n### <font color=13aa6c>React 性能设计亮点</font>\n\nReact 设计上的性能亮点非常多，除了“老生常谈”的虚拟 DOM 之外，还有很多不为人知的细节，比如事件机制（合成和池化）、React fiber 设计。\n\n#### React 性能设计亮点之事件\n\nReact 事件机制我们前面已经有所介绍，总结一下性能亮点的体现有：\n\n- 将所有事件挂载到 document 节点上，利用事件代理实现优化；\n- 采用合成事件，在原生事件的基础上包装合成事件，并结合池化思路实现内存保护。\n\n前面课程《第 4-2 课：你真的懂 React 吗？》已经介绍过相关内容，这里不再展开。\n\n#### React 性能设计亮点之 setState\n\nsetState 这个谜之 API 我们也有所介绍，其异步（或者叫做 batch 合并）设计也是出于性能的考虑。这种优化思路已经被很多框架所借鉴，Vue 当中也是有类似的设计。\n\n#### React 性能设计亮点之 React fiber \n\n前面两个“亮点”我们在以往的课程中已经有所涉及，这里来重点说一下 React fiber。\n\n通过课程《第 2-1 和 2-2 课：异步不可怕“死记硬背”+ 实战拿下》，我们知道在浏览器主线程中，JavaScript 代码在调用栈 call stack 执行时，可能会调用浏览器的 APIs，对 DOM 进行操作；也可能执行一些异步任务：这些异步任务如果是以回调的方式处理，那么往往会被添加到 event queue 当中；如果是以 promise 处理，就会先放到 job queue 当中。这个涉及到宏任务和微任务，这些异步任务和渲染任务将会在下一个时序当中由调用栈处理执行。\n\n理解了这些，大家就会明白：如果调用栈 call stack 运行一个很耗时的脚本，比如解析一个图片，call stack 就会像北京上下班高峰期的环路入口一样，被这个复杂任务堵塞。主线程其他任务都要排队，进而阻塞 UI 响应。这时候用户点击、输入、页面动画等都没有了响应。\n\n这样的性能瓶颈，就如同阿喀琉斯之踵一样，在一定程度上限制着 JavaScript 的发挥。\n\n我们一般有两种方案突破上文提到的瓶颈，其中之一就是将耗时高、成本高、易阻塞的长任务切片，分成子任务，并异步执行。\n\n这样一来，这些子任务会在不同的 call stack tick 周期执行，进而主线程就可以在子任务间隙当中执行 UI 更新操作。设想一个常见的场景：如果我们需要渲染一个由十万条数据组成的列表，那么相比一次性渲染全部数据，我们可以将数据分段，使用 setTimeout API 去分步处理，构建渲染列表的工作就被分成了不同的子任务在浏览器中执行。在这些子任务间隙，浏览器得以处理 UI 更新。\n\nReact 在 JavaScript 执行层面花费的时间较多，这是因为下面一系列复杂过程所造成的：\n\n> Virtual DOM 构建 → 计算 DOM diff → 生成 render patch\n\n也就是说，在一定程度上：React 著名的调度策略 -- stack reconcile 是 React 的性能瓶颈。因为 React stack reconcile 过程会深度优先遍历所有的 Virtual DOM 节点，进行 diff。整棵 Virtual DOM 树计算完成之后，将任务出栈释放主线程。因此，浏览器主线程被 React 更新状态任务占据的时候，用户与浏览器进行任何交互都不能得到反馈，只有等到任务结束，才能得到浏览器的响应。\n\n我们来看一个典型的场景，来自文章：[React 的新引擎—React Fiber是什么？](https://link.zhihu.com/?target=http%3A//www.infoq.com/cn/articles/what-the-new-engine-of-react)\n\n这个例子会在页面中创建一个输入框、一个按钮、一个 BlockList 组件。BlockList 组件会根据 NUMBER\\_OF\\_BLOCK 数值渲染出对应数量的数字显示框，数字显示框显示点击按钮的次数。\n\n![enter image description here](https://images.gitbook.cn/06d42e30-cd4f-11e9-b3e5-eb0a42842eb1)\n\n在这个例子中，我们可以设置 NUMBER\\_OF\\_BLOCK 的值为 100000，表示渲染 100000 个矩形框。这时候点击按钮，触发 setState，页面开始更新。此时点击输入框，输入一些字符串，比如 “hi，react”，可以看到：页面没有任何响应；等待 7s 之后，输入框中突然出现了之前输入的 “hireact”。同时，BlockList 组件也更新了。\n\n显而易见，这样的用户体验并不好。\n\n浏览器主线程在这 7s 的 performance 如下图所示：\n\n![enter image description here](https://images.gitbook.cn/2dbfb640-cd4f-11e9-a968-ffa0ed414b87)\n\n- 黄色部分：是 JavaScript 执行时间，也是 React 占用主线程的时间。\n- 紫色部分：是浏览器重新计算 DOM Tree 的时间。\n- 绿色部分：是浏览器绘制页面的时间。\n\n这三种任务，总共占用浏览器主线程 7s 的时间，此时间内浏览器无法与用户交互。主要是黄色部分执行时间较长，占用了 6s，即 React 较长时间占用主线程，导致主线程无法响应用户输入。这就是一个典型的例子。\n\nReact 核心团队很早之前就预知性能风险的存在，并且持续探索可解决的方式。基于浏览器对 requestIdleCallback 和 requestAnimationFrame 这两个 API 的支持，React 团队实现新的调度策略 —— Fiber reconcile。\n\n在应用 React Fiber 的场景下，重复刚才的例子，不会再出现页面卡顿，交互自然而顺畅。\n\n浏览器主线程的 performance 如下图所示：\n\n![enter image description here](https://images.gitbook.cn/4b852c00-cd4f-11e9-a968-ffa0ed414b87)\n\n可以看到：在黄色 JavaScript 执行过程中，也就是 React 占用浏览器主线程期间，浏览器也在重新计算 DOM Tree，并且进行重绘。直观来看，黄色和紫色等互相交替，同时页面截图显示，用户输入得以及时响应。简单说，在 React 占用浏览器主线程期间，浏览器也在与用户交互。这显然是“更好的性能”表现。\n\n### <font color=13aa6c>从 Vue 3.0 动静结合的 Dom diff 谈起</font>\n\nVue3.0 提出的动静结合的 DOM diff 思想，我个人认为是 Vue 近几年在“创新”上的一个很好体现。之所以能够做到动静结合的 DOM diff，或者把这个问题放得更大：之所以能够做到预编译优化，是因为 Vue core 可以静态分析 template，在解析模版时，整个 parse 的过程是利用正则表达式顺序解析模板，当解析到开始标签、闭合标签和文本的时候都会分别执行对应的回调函数，来达到构造 AST 树的目的。\n\n![enter image description here](https://images.gitbook.cn/945db370-cd4f-11e9-a6b5-097d100ec5bd)\n\n这个过程换成代码如下：\n\n![enter image description here](https://images.gitbook.cn/4f04c060-cd50-11e9-b604-8f8ee8a124cd)\n\n借助预编译过程，Vue 可以做到的预编译优化就很强大了。比如在预编译时标记出模版中可能变化的组件节点，再次进行渲染前 diff 时就可以跳过“永远不会变化的节点”，而只需要对比“可能会变化的动态节点”。这也就是动静结合的 DOM diff 将 diff 成本与模版大小正相关优化到与动态节点正相关的理论依据。\n\n类似地，我们也可以标记出来一些“快速通道（fast path）”。比如某个复杂的组件之所以 className 发生变化（这个场景很常见，我们根据变量，通过更改 className 来应用不同的样式）。针对这种场景，我们在预编译阶段进行特定的标记，在重新渲染 diff 时只需要更新新的 className 即可。\n\n#### 预编译优化的本质是什么？\n\n我关心的是：React 能否像 Vue 那样进行预编译优化？\n\nVue 需要做数据双向绑定，需要进行数据拦截或代理，那它就需要在预编译阶段静态分析模版，分析出视图依赖了哪些数据，进行响应式处理。而 React 就是局部重新渲染，React 拿到的或者说掌管的，所负责的就是一堆递归 React.createElement 的执行调用，它无法从模版层面进行静态分析。\n\n比如这样的 JSX：\n\n```\n<div>\n\t<p>\n\t\t<span> This is a test </span>\n\t</p>\n</div>\n```\n\n将会被编译为：\n\n```\nReact.createElement(\n  \"div\", null, \n  React.createElement(\n    \"p\", null, \n    React.createElement(\n      \"span\", null, \"This is a test\"\n    )\n  )\n)\n\n```\n\n因此 React JSX 过度的灵活性导致运行时可以用于优化的信息不足。但是，在 React 框架之外，我们作为开发者还是可以通过工程化手段达到类似的目的，因为我们能够接触到 JSX 编译成 React.createElement 的整个过程。开发者在项目中开发 babel 插件，实现 JSX 编译成 React.createElement，那么优化手段就是是从编写 babel 插件开始：\n\n如图：\n\n![enter image description here](https://images.gitbook.cn/883ba9c0-cd50-11e9-b604-8f8ee8a124cd)\n\n那么到底开发者应该怎么做，实现预编译优化呢？\n\n为此我挑出了一些具有代表性的案例，这些案例都是由开发者开发 Babel plugin 实现的 React 预编译手段。\n\n##### **Hoist constant elements**  \n\n将静态不变的节点在预编译阶段就抽象成函数或者静态变量，这个和 Vue 框架内所做的一样，不过需要开发者实现，这样一来就不需要在每次重新渲染时生成多余实例，只需要调用 _ref 变量即可。\n\n```\nconst _ref = <span>Hello World</span>\n\nclass MyComponent extends React.Component {\n  render() {\n    return (\n      <div className={this.props.className}>\n        {_ref}\n      </div>\n    )\n  }\n}\n```\n\n##### **remove propTypes in runtime**\n\nPropTypes 提供了许多验证工具，用来帮助确定 React 组件中 props 数据的有效性。但是，React v15.5 后就被移除了 PropTypes ，因此现在使用 prop-types 库代替。\n\npropTypes 对于业务开发非常有用，帮助我们弥补了 JS 数据类型检查的不足。但是在线上代码中，propTypes 是多余的。\n\n因此在运行时代码删除 propTypes 就变的比较有必要了。\n\n##### **remove inline functions and varaibles**\n\n第三个优化场景是这样的：我们知道组件内如果存在函数生成（箭头函数定义，bind 使用）或者闭包变量的情况下，组件每一次刷新，都会生成一个新的函数或者闭包变量。我们将这种不必要的函数称为 inline functions。\n\n比如下面这段代码中，transformeData 和 onClick 对应的匿名函数，都会随着组件渲染重新生成一个全新的引用。\n\n```\nexport default ({ data, sortComparator, filterPredicate, history }) => {\n\n  const transformedData = data\n    .filter(filterPredicate)\n    .sort(sortComparator)\n\n  return (\n    <div>\n      <button \n        className=\"back-btn\" \n        onClick={() => history.pop()} \n      />\n      <ul className=\"data-list\">\n        {transformedData.map(({ id, value }) => (\n          <Item value={value}>\n        ))}\n      </ul>\n    </div>\n  )\n}\n```\n\n反复生成这些 inline functions 或者数据，这对于 React 运行时性能或多或少会有一点影响，也带来了 GC 压力。\n\n我们在工程中，可以通过插件对 inline functions 或者变量进行内存持久化处理。最终经过预编译优化后的代码为：\n\n```\n let _anonymousFnComponent\n\nexport default ({ data, sortComparator, filterPredicate, history }) => {\n\n  const transformedData = React.useMemo(\n    () =>\n    data.filter(filterPredicate).sort(sortComparator),\n    [data, data.filter, filterPredicate, sortComparator]\n  )\n\n  return React.createElement(_anonymousFnComponent = _anonymousFnComponent || (() => {\n    \n    const _onClick2 = React.useCallback(\n      () => history.pop(), \n      [history, history.pop]\n    )\n\n    return (\n      <div>\n        <button className=\"back-btn\" onClick={_onClick2} />\n        <ul className=\"data-list\">\n          {transformedData.map(({ id, value }) =>\n            React.createElement(\n              //...\n            )\n          )}\n        </ul>\n      </div>\n    )\n  }), null)\n}\n```\n\n我们使用了 React 新特性 useMemo 和 useCallback 将这些变量包裹。\nuseMemo 和 useCallback 都会在组件第一次渲染的时候执行，之后会在其依赖的变量，也就是 useMemo 和 useCallback 的第二个参数数组，数组内的数值发生改变时再次执行；这两个 hooks 都返回缓存的值，useMemo 返回缓存的变量，useCallback 返回缓存的函数。\n\n我们看代码，transformeData 在其数据源：data,data.filter,filterPredicate,sortComparator 发生变化时才会更新，才会重新生成一份 transformeData，函数渲染时只要依赖的data,data.filter,filterPredicate,sortComparator 不变，不会重新生成 transformeData，而是使用缓存的值。onClick 也使用了 useCallback 将函数引用持久化保存，道理一样。\n\n这样一来就避免了在组件重新渲染时，总是生成不必要的 inline functions 和闭包变量的困扰。\n\n##### **transform to stateless function component**\n\n我们知道函数式组件虽然未来会比 class 声明的组件性能更好，并且函数不管是从性能上、可组合性上还是 TS 契合度上，都要要优于 class 使用。\n\n这个例子，我们将符合条件的 class 声明组件自动在预编译阶段转化为函数式组件。\n\n我们的目标是：\n\n```\nclass MyComponent extends React.Component {\n  static propTypes = {\n    className: React.PropTypes.string.isRequired\n  }\n\n  render() {\n    return (\n      <div className={this.props.className}>\n        <span>Hello World</span>\n      </div>\n    )\n  }\n}\n```\n\n在预编译阶段优化为：\n\n```\nconst MyComponent = props => \n  <div className={props.className}>\n    <span>Hello World</span>\n  </div>\n\nMyComponent.propTypes = {\n  className: React.PropTypes.string.isRequired\n}\n```\n\n在这里我们展开实现一下 Babel plugin 的编写，其中会涉及到一些 AST 的内容，读者只需明白思想方向即可。\n\n```\nmodule.exports = function({ types: t }) {\n  return {\n    visitor: {\n      Class(path) {\n        const state = {\n          renderMethod: null,\n          properties: [],\n          thisProps: [],\n          isPure: true\n        }\n\n        path.traverse(bodyVisitor, state)\n\n        let replacement = []\n\n        state.thisProps.forEach(function(thisProp) {\n          thisProp.replaceWith(t.identifier(&apos;props&apos;))\n          thisProp.replaceWith(t.identifier(&apos;props&apos;))\n        })\n\n        replacement.push(\n          t.functionDeclaration(\n            id,\n            [t.identifier(&apos;props&apos;)],\n            state.renderMethod.node.body\n          )\n        )\n\n        state.properties.forEach(prop => {\n          replacement.push(t.expressionStatement(\n            t.assignmentExpression(&apos;=&apos;,\n              t.MemberExpression(id, prop.node.key),\n              prop.node.value\n            )\n          ))\n        })\n\n        if (t.isExpression(path.node)) {\n          replacement.push(t.returnStatement(id))\n\n          replacement = t.callExpression(\n            t.functionExpression(null, [],\n              t.blockStatement(replacement)\n            ),\n            []\n          )\n        }\n\n        path.replaceWithMultiple(\n          replacement\n        )\n      }\n    }\n  }\n\n  const bodyVisitor = {\n    ClassMethod(path) {\n      if (path.node.key.name === &apos;render&apos;) {\n        this.renderMethod = path\n      } else {\n        this.isPure = false\n        path.stop()\n      }\n    },\n\n    ClassProperty(path) {\n      const name = path.node.key.name\n\n      if (path.node.static && (\n        name === &apos;propTypes&apos; ||\n        name === &apos;defaultProps&apos;\n      )) {\n        this.properties.push(path)\n      } else {\n        this.isPure = false\n        this.isPure = false\n      }\n    },\n\n    MemberExpression(path) {\n      this.thisProps.push(path)\n    },\n\n    JSXIdentifier(path) {\n      if (path.node.name === &apos;ref&apos;) {\n        this.isPure = false\n        path.stop()\n      }\n    }\n  }\n}\n```\n\n代码分析：我们先明确，什么样的 class 组件，具备转换成函数式组件的条件？\n\n首先，class 组件不能具有 this.state 的引用，组件不能出现任何生命周期方法，也不能出现 createRef，因为这些特性在函数式组件中并不存在。\n\n满足这样的条件时，我们在进行 JSX 转换过程进行组件替换：通过 AST 进行遍历，\n首先在遍历过程中找到符合条件的 class 组件，是否符合条件我们用 isPure 来进行标记，\n同时在遍历时，对每一个符合条件的 class 组件，储存 render 方法，作为转换函数式组件的返回值；储存 propTypes 和 defaultProps 静态属性，之后会挂载在函数组件函数属性上；同时对 this.props 的用法转为 props, props 作为函数式组件的参数出现\n最后在按照上述规则，修改 AST 树，新的 AST 树相关组件节点会生成函数式组件。\n\n#### Prepack 对于框架的影响\n\nPrepack 同样是 FaceBook 团队的作品。它让你编写普通的 JavaScript 代码，它在构建阶段就试图了解代码将做什么，然后生成等价的代码，减少了运行时的计算量。\n\n我们看一个 fibonacci 数列求和的例子，再经过 prepack 处理之后，直接输出结果，运行时就是一个 610 这么一个结果。这么看 prepack 是一个 JavaScript 的部分求值器（Partial Evaluator），可在编译时执行原本在运行时的计算过程，并通过重写 JavaScript 代码来提高其执行效率。\n\n我就用 Prepack 结合 React 尝了个鲜：\n\n![enter image description here](https://images.gitbook.cn/a720c050-cd50-11e9-a6b5-097d100ec5bd)\n\n![enter image description here](https://images.gitbook.cn/b89d11d0-cd50-11e9-a968-ffa0ed414b87)\n\n上图左边部分是我编写的代码，在不使用 prepack 情况下，运行时代码如右边所示：经过编译之后右边的代码仍然是对数组 list 进行 map，逐条渲染出数组内容。\n\n经过 preack 优化后，运行时代码已经非常轻量了。运行时就减少 map 的计算等，直接用生成的组件内容作为运行时结果。\n\n### <font color=13aa6c>总结</font>\n\n框架的性能实际上要分两方面来学习：一方面是使用层面，我们需要了解框架，进而保证达到性能优化；另一方面需要了解框架实现，思考作者在框架编译时和运行时两个重要环节是如何进行处理，持续进行优化的。\n\n总而言之，框架的性能优化仍然属于语言范畴和浏览器范畴的优化，一些思想具有共通性，希望大家一起积累思考。","pdfUrl":"","reader":"","duration":"","title":"以 React 为例，说说框架和性能（下）","column":"5c91c813968b1d64b1e08fde","isNotification":false,"readingStatistics":0,"htmlContent":"<p>在上一讲中，我们提到了框架性能优化的一些基本概念，并分析了以 React 框架为代表的常用优化手段。但是这些内容还不够，需要了解更多框架设计底层的性能相关话题。这一讲，我将会以 Vue（未来新版本 3.0）和 React 为主，分析这两个框架在设计层面，而非使用层面的性能考量。</p>\n<p>相关知识点如下图所示：</p>\n<p><img src=\"https://images.gitbook.cn/dd24aad0-cbf3-11e9-a9bd-857608719494\" alt=\"enter image description here\" /></p>\n<h3><a id=\"font_color13aa6cReact_font_6\"></a><font color=13aa6c>React 性能设计亮点</font></h3>\n<p>React 设计上的性能亮点非常多，除了“老生常谈”的虚拟 DOM 之外，还有很多不为人知的细节，比如事件机制（合成和池化）、React fiber 设计。</p>\n<h4><a id=\"React__10\"></a>React 性能设计亮点之事件</h4>\n<p>React 事件机制我们前面已经有所介绍，总结一下性能亮点的体现有：</p>\n<ul>\n<li>将所有事件挂载到 document 节点上，利用事件代理实现优化；</li>\n<li>采用合成事件，在原生事件的基础上包装合成事件，并结合池化思路实现内存保护。</li>\n</ul>\n<p>前面课程《第 4-2 课：你真的懂 React 吗？》已经介绍过相关内容，这里不再展开。</p>\n<h4><a id=\"React__setState_19\"></a>React 性能设计亮点之 setState</h4>\n<p>setState 这个谜之 API 我们也有所介绍，其异步（或者叫做 batch 合并）设计也是出于性能的考虑。这种优化思路已经被很多框架所借鉴，Vue 当中也是有类似的设计。</p>\n<h4><a id=\"React__React_fiber_23\"></a>React 性能设计亮点之 React fiber</h4>\n<p>前面两个“亮点”我们在以往的课程中已经有所涉及，这里来重点说一下 React fiber。</p>\n<p>通过课程《第 2-1 和 2-2 课：异步不可怕“死记硬背”+ 实战拿下》，我们知道在浏览器主线程中，JavaScript 代码在调用栈 call stack 执行时，可能会调用浏览器的 APIs，对 DOM 进行操作；也可能执行一些异步任务：这些异步任务如果是以回调的方式处理，那么往往会被添加到 event queue 当中；如果是以 promise 处理，就会先放到 job queue 当中。这个涉及到宏任务和微任务，这些异步任务和渲染任务将会在下一个时序当中由调用栈处理执行。</p>\n<p>理解了这些，大家就会明白：如果调用栈 call stack 运行一个很耗时的脚本，比如解析一个图片，call stack 就会像北京上下班高峰期的环路入口一样，被这个复杂任务堵塞。主线程其他任务都要排队，进而阻塞 UI 响应。这时候用户点击、输入、页面动画等都没有了响应。</p>\n<p>这样的性能瓶颈，就如同阿喀琉斯之踵一样，在一定程度上限制着 JavaScript 的发挥。</p>\n<p>我们一般有两种方案突破上文提到的瓶颈，其中之一就是将耗时高、成本高、易阻塞的长任务切片，分成子任务，并异步执行。</p>\n<p>这样一来，这些子任务会在不同的 call stack tick 周期执行，进而主线程就可以在子任务间隙当中执行 UI 更新操作。设想一个常见的场景：如果我们需要渲染一个由十万条数据组成的列表，那么相比一次性渲染全部数据，我们可以将数据分段，使用 setTimeout API 去分步处理，构建渲染列表的工作就被分成了不同的子任务在浏览器中执行。在这些子任务间隙，浏览器得以处理 UI 更新。</p>\n<p>React 在 JavaScript 执行层面花费的时间较多，这是因为下面一系列复杂过程所造成的：</p>\n<blockquote>\n<p>Virtual DOM 构建 → 计算 DOM diff → 生成 render patch</p>\n</blockquote>\n<p>也就是说，在一定程度上：React 著名的调度策略 – stack reconcile 是 React 的性能瓶颈。因为 React stack reconcile 过程会深度优先遍历所有的 Virtual DOM 节点，进行 diff。整棵 Virtual DOM 树计算完成之后，将任务出栈释放主线程。因此，浏览器主线程被 React 更新状态任务占据的时候，用户与浏览器进行任何交互都不能得到反馈，只有等到任务结束，才能得到浏览器的响应。</p>\n<p>我们来看一个典型的场景，来自文章：<a href=\"https://link.zhihu.com/?target=http%3A//www.infoq.com/cn/articles/what-the-new-engine-of-react\" target=\"_blank\">React 的新引擎—React Fiber是什么？</a></p>\n<p>这个例子会在页面中创建一个输入框、一个按钮、一个 BlockList 组件。BlockList 组件会根据 NUMBER_OF_BLOCK 数值渲染出对应数量的数字显示框，数字显示框显示点击按钮的次数。</p>\n<p><img src=\"https://images.gitbook.cn/06d42e30-cd4f-11e9-b3e5-eb0a42842eb1\" alt=\"enter image description here\" /></p>\n<p>在这个例子中，我们可以设置 NUMBER_OF_BLOCK 的值为 100000，表示渲染 100000 个矩形框。这时候点击按钮，触发 setState，页面开始更新。此时点击输入框，输入一些字符串，比如 “hi，react”，可以看到：页面没有任何响应；等待 7s 之后，输入框中突然出现了之前输入的 “hireact”。同时，BlockList 组件也更新了。</p>\n<p>显而易见，这样的用户体验并不好。</p>\n<p>浏览器主线程在这 7s 的 performance 如下图所示：</p>\n<p><img src=\"https://images.gitbook.cn/2dbfb640-cd4f-11e9-a968-ffa0ed414b87\" alt=\"enter image description here\" /></p>\n<ul>\n<li>黄色部分：是 JavaScript 执行时间，也是 React 占用主线程的时间。</li>\n<li>紫色部分：是浏览器重新计算 DOM Tree 的时间。</li>\n<li>绿色部分：是浏览器绘制页面的时间。</li>\n</ul>\n<p>这三种任务，总共占用浏览器主线程 7s 的时间，此时间内浏览器无法与用户交互。主要是黄色部分执行时间较长，占用了 6s，即 React 较长时间占用主线程，导致主线程无法响应用户输入。这就是一个典型的例子。</p>\n<p>React 核心团队很早之前就预知性能风险的存在，并且持续探索可解决的方式。基于浏览器对 requestIdleCallback 和 requestAnimationFrame 这两个 API 的支持，React 团队实现新的调度策略 —— Fiber reconcile。</p>\n<p>在应用 React Fiber 的场景下，重复刚才的例子，不会再出现页面卡顿，交互自然而顺畅。</p>\n<p>浏览器主线程的 performance 如下图所示：</p>\n<p><img src=\"https://images.gitbook.cn/4b852c00-cd4f-11e9-a968-ffa0ed414b87\" alt=\"enter image description here\" /></p>\n<p>可以看到：在黄色 JavaScript 执行过程中，也就是 React 占用浏览器主线程期间，浏览器也在重新计算 DOM Tree，并且进行重绘。直观来看，黄色和紫色等互相交替，同时页面截图显示，用户输入得以及时响应。简单说，在 React 占用浏览器主线程期间，浏览器也在与用户交互。这显然是“更好的性能”表现。</p>\n<h3><a id=\"font_color13aa6c_Vue_30__Dom_diff_font_73\"></a><font color=13aa6c>从 Vue 3.0 动静结合的 Dom diff 谈起</font></h3>\n<p>Vue3.0 提出的动静结合的 DOM diff 思想，我个人认为是 Vue 近几年在“创新”上的一个很好体现。之所以能够做到动静结合的 DOM diff，或者把这个问题放得更大：之所以能够做到预编译优化，是因为 Vue core 可以静态分析 template，在解析模版时，整个 parse 的过程是利用正则表达式顺序解析模板，当解析到开始标签、闭合标签和文本的时候都会分别执行对应的回调函数，来达到构造 AST 树的目的。</p>\n<p><img src=\"https://images.gitbook.cn/945db370-cd4f-11e9-a6b5-097d100ec5bd\" alt=\"enter image description here\" /></p>\n<p>这个过程换成代码如下：</p>\n<p><img src=\"https://images.gitbook.cn/4f04c060-cd50-11e9-b604-8f8ee8a124cd\" alt=\"enter image description here\" /></p>\n<p>借助预编译过程，Vue 可以做到的预编译优化就很强大了。比如在预编译时标记出模版中可能变化的组件节点，再次进行渲染前 diff 时就可以跳过“永远不会变化的节点”，而只需要对比“可能会变化的动态节点”。这也就是动静结合的 DOM diff 将 diff 成本与模版大小正相关优化到与动态节点正相关的理论依据。</p>\n<p>类似地，我们也可以标记出来一些“快速通道（fast path）”。比如某个复杂的组件之所以 className 发生变化（这个场景很常见，我们根据变量，通过更改 className 来应用不同的样式）。针对这种场景，我们在预编译阶段进行特定的标记，在重新渲染 diff 时只需要更新新的 className 即可。</p>\n<h4><a id=\"_87\"></a>预编译优化的本质是什么？</h4>\n<p>我关心的是：React 能否像 Vue 那样进行预编译优化？</p>\n<p>Vue 需要做数据双向绑定，需要进行数据拦截或代理，那它就需要在预编译阶段静态分析模版，分析出视图依赖了哪些数据，进行响应式处理。而 React 就是局部重新渲染，React 拿到的或者说掌管的，所负责的就是一堆递归 React.createElement 的执行调用，它无法从模版层面进行静态分析。</p>\n<p>比如这样的 JSX：</p>\n<pre><code class=\"lang-\">&lt;div&gt;\n\t&lt;p&gt;\n\t\t&lt;span&gt; This is a test &lt;/span&gt;\n\t&lt;/p&gt;\n&lt;/div&gt;\n</code></pre>\n<p>将会被编译为：</p>\n<pre><code class=\"lang-\">React.createElement(\n  &quot;div&quot;, null, \n  React.createElement(\n    &quot;p&quot;, null, \n    React.createElement(\n      &quot;span&quot;, null, &quot;This is a test&quot;\n    )\n  )\n)\n\n</code></pre>\n<p>因此 React JSX 过度的灵活性导致运行时可以用于优化的信息不足。但是，在 React 框架之外，我们作为开发者还是可以通过工程化手段达到类似的目的，因为我们能够接触到 JSX 编译成 React.createElement 的整个过程。开发者在项目中开发 babel 插件，实现 JSX 编译成 React.createElement，那么优化手段就是是从编写 babel 插件开始：</p>\n<p>如图：</p>\n<p><img src=\"https://images.gitbook.cn/883ba9c0-cd50-11e9-b604-8f8ee8a124cd\" alt=\"enter image description here\" /></p>\n<p>那么到底开发者应该怎么做，实现预编译优化呢？</p>\n<p>为此我挑出了一些具有代表性的案例，这些案例都是由开发者开发 Babel plugin 实现的 React 预编译手段。</p>\n<h5><a id=\"Hoist_constant_elements_128\"></a><strong>Hoist constant elements</strong></h5>\n<p>将静态不变的节点在预编译阶段就抽象成函数或者静态变量，这个和 Vue 框架内所做的一样，不过需要开发者实现，这样一来就不需要在每次重新渲染时生成多余实例，只需要调用 _ref 变量即可。</p>\n<pre><code class=\"lang-\">const _ref = &lt;span&gt;Hello World&lt;/span&gt;\n\nclass MyComponent extends React.Component {\n  render() {\n    return (\n      &lt;div className={this.props.className}&gt;\n        {_ref}\n      &lt;/div&gt;\n    )\n  }\n}\n</code></pre>\n<h5><a id=\"remove_propTypes_in_runtime_146\"></a><strong>remove propTypes in runtime</strong></h5>\n<p>PropTypes 提供了许多验证工具，用来帮助确定 React 组件中 props 数据的有效性。但是，React v15.5 后就被移除了 PropTypes ，因此现在使用 prop-types 库代替。</p>\n<p>propTypes 对于业务开发非常有用，帮助我们弥补了 JS 数据类型检查的不足。但是在线上代码中，propTypes 是多余的。</p>\n<p>因此在运行时代码删除 propTypes 就变的比较有必要了。</p>\n<h5><a id=\"remove_inline_functions_and_varaibles_154\"></a><strong>remove inline functions and varaibles</strong></h5>\n<p>第三个优化场景是这样的：我们知道组件内如果存在函数生成（箭头函数定义，bind 使用）或者闭包变量的情况下，组件每一次刷新，都会生成一个新的函数或者闭包变量。我们将这种不必要的函数称为 inline functions。</p>\n<p>比如下面这段代码中，transformeData 和 onClick 对应的匿名函数，都会随着组件渲染重新生成一个全新的引用。</p>\n<pre><code class=\"lang-\">export default ({ data, sortComparator, filterPredicate, history }) =&gt; {\n\n  const transformedData = data\n    .filter(filterPredicate)\n    .sort(sortComparator)\n\n  return (\n    &lt;div&gt;\n      &lt;button \n        className=&quot;back-btn&quot; \n        onClick={() =&gt; history.pop()} \n      /&gt;\n      &lt;ul className=&quot;data-list&quot;&gt;\n        {transformedData.map(({ id, value }) =&gt; (\n          &lt;Item value={value}&gt;\n        ))}\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre>\n<p>反复生成这些 inline functions 或者数据，这对于 React 运行时性能或多或少会有一点影响，也带来了 GC 压力。</p>\n<p>我们在工程中，可以通过插件对 inline functions 或者变量进行内存持久化处理。最终经过预编译优化后的代码为：</p>\n<pre><code class=\"lang-\"> let _anonymousFnComponent\n\nexport default ({ data, sortComparator, filterPredicate, history }) =&gt; {\n\n  const transformedData = React.useMemo(\n    () =&gt;\n    data.filter(filterPredicate).sort(sortComparator),\n    [data, data.filter, filterPredicate, sortComparator]\n  )\n\n  return React.createElement(_anonymousFnComponent = _anonymousFnComponent || (() =&gt; {\n    \n    const _onClick2 = React.useCallback(\n      () =&gt; history.pop(), \n      [history, history.pop]\n    )\n\n    return (\n      &lt;div&gt;\n        &lt;button className=&quot;back-btn&quot; onClick={_onClick2} /&gt;\n        &lt;ul className=&quot;data-list&quot;&gt;\n          {transformedData.map(({ id, value }) =&gt;\n            React.createElement(\n              //...\n            )\n          )}\n        &lt;/ul&gt;\n      &lt;/div&gt;\n    )\n  }), null)\n}\n</code></pre>\n<p>我们使用了 React 新特性 useMemo 和 useCallback 将这些变量包裹。<br />\nuseMemo 和 useCallback 都会在组件第一次渲染的时候执行，之后会在其依赖的变量，也就是 useMemo 和 useCallback 的第二个参数数组，数组内的数值发生改变时再次执行；这两个 hooks 都返回缓存的值，useMemo 返回缓存的变量，useCallback 返回缓存的函数。</p>\n<p>我们看代码，transformeData 在其数据源：data,data.filter,filterPredicate,sortComparator 发生变化时才会更新，才会重新生成一份 transformeData，函数渲染时只要依赖的data,data.filter,filterPredicate,sortComparator 不变，不会重新生成 transformeData，而是使用缓存的值。onClick 也使用了 useCallback 将函数引用持久化保存，道理一样。</p>\n<p>这样一来就避免了在组件重新渲染时，总是生成不必要的 inline functions 和闭包变量的困扰。</p>\n<h5><a id=\"transform_to_stateless_function_component_228\"></a><strong>transform to stateless function component</strong></h5>\n<p>我们知道函数式组件虽然未来会比 class 声明的组件性能更好，并且函数不管是从性能上、可组合性上还是 TS 契合度上，都要要优于 class 使用。</p>\n<p>这个例子，我们将符合条件的 class 声明组件自动在预编译阶段转化为函数式组件。</p>\n<p>我们的目标是：</p>\n<pre><code class=\"lang-\">class MyComponent extends React.Component {\n  static propTypes = {\n    className: React.PropTypes.string.isRequired\n  }\n\n  render() {\n    return (\n      &lt;div className={this.props.className}&gt;\n        &lt;span&gt;Hello World&lt;/span&gt;\n      &lt;/div&gt;\n    )\n  }\n}\n</code></pre>\n<p>在预编译阶段优化为：</p>\n<pre><code class=\"lang-\">const MyComponent = props =&gt; \n  &lt;div className={props.className}&gt;\n    &lt;span&gt;Hello World&lt;/span&gt;\n  &lt;/div&gt;\n\nMyComponent.propTypes = {\n  className: React.PropTypes.string.isRequired\n}\n</code></pre>\n<p>在这里我们展开实现一下 Babel plugin 的编写，其中会涉及到一些 AST 的内容，读者只需明白思想方向即可。</p>\n<pre><code class=\"lang-\">module.exports = function({ types: t }) {\n  return {\n    visitor: {\n      Class(path) {\n        const state = {\n          renderMethod: null,\n          properties: [],\n          thisProps: [],\n          isPure: true\n        }\n\n        path.traverse(bodyVisitor, state)\n\n        let replacement = []\n\n        state.thisProps.forEach(function(thisProp) {\n          thisProp.replaceWith(t.identifier(&apos;props&apos;))\n          thisProp.replaceWith(t.identifier(&apos;props&apos;))\n        })\n\n        replacement.push(\n          t.functionDeclaration(\n            id,\n            [t.identifier(&apos;props&apos;)],\n            state.renderMethod.node.body\n          )\n        )\n\n        state.properties.forEach(prop =&gt; {\n          replacement.push(t.expressionStatement(\n            t.assignmentExpression(&apos;=&apos;,\n              t.MemberExpression(id, prop.node.key),\n              prop.node.value\n            )\n          ))\n        })\n\n        if (t.isExpression(path.node)) {\n          replacement.push(t.returnStatement(id))\n\n          replacement = t.callExpression(\n            t.functionExpression(null, [],\n              t.blockStatement(replacement)\n            ),\n            []\n          )\n        }\n\n        path.replaceWithMultiple(\n          replacement\n        )\n      }\n    }\n  }\n\n  const bodyVisitor = {\n    ClassMethod(path) {\n      if (path.node.key.name === &apos;render&apos;) {\n        this.renderMethod = path\n      } else {\n        this.isPure = false\n        path.stop()\n      }\n    },\n\n    ClassProperty(path) {\n      const name = path.node.key.name\n\n      if (path.node.static &amp;&amp; (\n        name === &apos;propTypes&apos; ||\n        name === &apos;defaultProps&apos;\n      )) {\n        this.properties.push(path)\n      } else {\n        this.isPure = false\n        this.isPure = false\n      }\n    },\n\n    MemberExpression(path) {\n      this.thisProps.push(path)\n    },\n\n    JSXIdentifier(path) {\n      if (path.node.name === &apos;ref&apos;) {\n        this.isPure = false\n        path.stop()\n      }\n    }\n  }\n}\n</code></pre>\n<p>代码分析：我们先明确，什么样的 class 组件，具备转换成函数式组件的条件？</p>\n<p>首先，class 组件不能具有 this.state 的引用，组件不能出现任何生命周期方法，也不能出现 createRef，因为这些特性在函数式组件中并不存在。</p>\n<p>满足这样的条件时，我们在进行 JSX 转换过程进行组件替换：通过 AST 进行遍历，<br />\n首先在遍历过程中找到符合条件的 class 组件，是否符合条件我们用 isPure 来进行标记，<br />\n同时在遍历时，对每一个符合条件的 class 组件，储存 render 方法，作为转换函数式组件的返回值；储存 propTypes 和 defaultProps 静态属性，之后会挂载在函数组件函数属性上；同时对 this.props 的用法转为 props, props 作为函数式组件的参数出现<br />\n最后在按照上述规则，修改 AST 树，新的 AST 树相关组件节点会生成函数式组件。</p>\n<h4><a id=\"Prepack__370\"></a>Prepack 对于框架的影响</h4>\n<p>Prepack 同样是 FaceBook 团队的作品。它让你编写普通的 JavaScript 代码，它在构建阶段就试图了解代码将做什么，然后生成等价的代码，减少了运行时的计算量。</p>\n<p>我们看一个 fibonacci 数列求和的例子，再经过 prepack 处理之后，直接输出结果，运行时就是一个 610 这么一个结果。这么看 prepack 是一个 JavaScript 的部分求值器（Partial Evaluator），可在编译时执行原本在运行时的计算过程，并通过重写 JavaScript 代码来提高其执行效率。</p>\n<p>我就用 Prepack 结合 React 尝了个鲜：</p>\n<p><img src=\"https://images.gitbook.cn/a720c050-cd50-11e9-a6b5-097d100ec5bd\" alt=\"enter image description here\" /></p>\n<p><img src=\"https://images.gitbook.cn/b89d11d0-cd50-11e9-a968-ffa0ed414b87\" alt=\"enter image description here\" /></p>\n<p>上图左边部分是我编写的代码，在不使用 prepack 情况下，运行时代码如右边所示：经过编译之后右边的代码仍然是对数组 list 进行 map，逐条渲染出数组内容。</p>\n<p>经过 preack 优化后，运行时代码已经非常轻量了。运行时就减少 map 的计算等，直接用生成的组件内容作为运行时结果。</p>\n<h3><a id=\"font_color13aa6cfont_386\"></a><font color=13aa6c>总结</font></h3>\n<p>框架的性能实际上要分两方面来学习：一方面是使用层面，我们需要了解框架，进而保证达到性能优化；另一方面需要了解框架实现，思考作者在框架编译时和运行时两个重要环节是如何进行处理，持续进行优化的。</p>\n<p>总而言之，框架的性能优化仍然属于语言范畴和浏览器范畴的优化，一些思想具有共通性，希望大家一起积累思考。</p>\n","createdAt":"2019-04-21T04:42:03.086Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":36,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FoThASW9dVEPMEo9nP-zaOfbKyLZ"},{"_id":"5cbbf556bbbba80861a35c6e","communication_start_time":null,"type":1,"audioPath":"","abstract":"","content":"设计模式——我认为这是一个一言难尽的概念。维基百科对设计模式的定义为：\n\n> 在软件工程中，设计模式（Design Pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。这个术语是由埃里希·伽玛（Erich Gamma）等人在 1990 年代从建筑设计领域引入到计算机科学的。设计模式并不是直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案。\n\n为什么“一言难尽”呢？首先从设计模式的概念可以看出：这是一套理论，干巴巴的描述其所有内容并没有太大意义。我们不会在面试中提出：“请你解释一下设计模式”、“你会多少种设计模式”这种问题。设计模式一般认为有 23 种，**这 23 种设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性，以及类的关联关系和组合关系的总结应用。**\n\n那么对于 JavaScript 或者前端开发来说，设计模式似乎是一个有些遥远的概念。我们应该如何了解并学习设计模式呢？\n\n**我认为设计模式不能停留在理论上，而是应该结合到实际代码当中**。因此打算通过两讲内容来介绍：本讲内容先介绍基本概念，分享一些经典的设计模式书籍以及相关经验，也许稍微有些“无趣”；第二讲内容将深入结合前端开发，挑选那些我们一直使用的、会用到的设计模式进行讲解。\n\n相关知识点如下：\n\n![enter image description here](https://images.gitbook.cn/cb2e6d60-cbfe-11e9-a9bd-857608719494)\n\n### <font color=13aa6c>设计模式到底是什么</font>\n\n之前提到，设计模式是一种经验总结，它就是一套兵法，一共包含了 23 个套路。最终目的是为了更好的代码重用性、可读性、可靠性、可维护性。\n\n在平常开发中，“也许你不知道，但是已经在使用设计模式了”。在之前课程内容的学习中，我们其实也有所提及，比如单例模式（细心的读者还能找到单例模式实现的课程出处吗？）、发布订阅模式、原型模式等。\n\n如果到此，仍然不明白设计模式到底是指什么，别着急，请继续阅读以下内容。\n\n### <font color=13aa6c>设计模式原则</font>\n\n既然是一套理论，是一种约定和规范，那么设计模式也就有自己的模式原则。总体来说，其六大原则包括：\n\n- 开闭原则\n- 里氏替换原则\n- 依赖反转原则\n- 接口隔离原则\n- 最小知道原则\n- 合成复用原则\n\n如图：\n\n![enter image description here](https://images.gitbook.cn/8112c980-cbfc-11e9-93b3-c35630e1847c)\n\n我们来逐一了解：\n\n- 开闭原则（Open Close Principle）\n\n理解开闭原则，就要了解开和闭。**这里的开是指对扩展开放，闭是说对修改关闭**。想想我们有一套实现、提供一个服务，这样的程序需要能够随时进行扩展、随时支持第三方的自定义配置，但是不能去修改已用的实现代码。\n\n比如我们做了一个 UI 组件轮子，业务方在使用时显然不能够修改我们的代码，但是仍然可以进行扩展。再比如著名的 Draft.js 库，在实现一个编辑器时，提供了灵活的插件机制，实现了热插拔效果，使得整个程序的扩展性好，易于维护和升级。甚至 Redux 库、Koa 库等基本所有库都有开闭原则的体现。\n\n对于面向对象类型的语言来说，想要严格遵守开闭原则，往往需要使用接口和抽象类，这个我们会在具体设计中再次提到。\n\n- 里氏替换原则（Liskov Substitution Principle）\n\n里氏代换原则就稍微有些抽象，但它是面向对象设计的基本原则之一。 \n\n> 里氏代换原则要求，任何基类可以发挥作用的地方，子类一定可以发挥作用。\n\n这句话怎么理解呢？想想我们的继承实现，里氏替换原则就是继承复用的基础。只有当派生类可以随时替换掉其基类，同时功能不被破坏，基类的方法仍然能被使用，这才是真正的继承，继承才能真正地实现复用，当然，派生类也需要随时能够在基类的基础上增加新的行为。\n\n事实上，里氏代换原则是对开闭原则的补充。\n\n- 依赖反转原则（Dependence Inversion Principle）\n\n该原则要求针对接口编程，依赖于抽象。更多理论内容我并不打算展开，后续在程序设计中会结合实例提及。\n\n- 接口隔离原则（Interface Segregation Principle）\n\n接口隔离的意思或者目的是减少耦合的出现。在大型软件架构中，使用多个相互隔离的接口，一定比使用单个大而全的接口要好。\n\n- 最少知道原则，又称迪米特法则（Demeter Principle）\n\n最少知道顾名思义，是指：一个系统的功能模块应该最大限度地不知晓其他模块的出现，减少感知，模块应相对独立。\n\n- 合成复用原则（Composite Reuse Principle）\n\n合成复用原则是指：尽量使用合成 / 聚合的方式，而不是使用继承。这是很有意思的一点，我们在之前的课程中提到过：基于原型的继承在很多程度上“优于”基于类的继承，原因就在于基于原型的继承模式体现了可组合性，能够规避“大猩猩和香蕉”等问题的出现。组合是非常优秀的编程思想，这一点在函数式编程范畴中得到了最大程度的印证。\n\n### <font color=13aa6c>设计模式的三大类型和二十三种套路</font>\n\n设计模式并没有什么困难的，大体上所有的设计模式可以归结为三大类：\n\n- 创建型\n- 结构型\n- 行为型\n\n如图：\n\n![enter image description here](https://images.gitbook.cn/1190fdb0-cbfd-11e9-942c-915593d3f51c)\n\n对于 Java 来说，它还包括了 J2EE 类型设计模式。\n\n我们分别来看：\n\n- 创建型（Creational Patterns）\n\n创建型的五种设计模式提供了更加灵活的对象创建方式，同时可以隐藏创建的具体逻辑。与直接使用 new 运算符实例化对象相比，这些模式具有更强的灵活性以及可定制性。\n\n- 结构型（Structural Patterns）\n\n结构型的七种设计模式关注类和对象的组合，结合继承的概念，这些设计模式能使得对象具有更加灵活的功能设定。\n\n- 行为型（Behavioral Patterns）\n\n行为型的十一种设计模式聚焦于对象和类之间的通信，这是构建大型程序架构必不可少的环节。\n\n### <font color=13aa6c>关于设计模式的学习</font>\n\n设计模式使代码编写真正工程化，我们说设计模式是软件工程的基石脉络，如同大厦的结构一样。其实我认为没有必要刻意地去学习设计模式，因为有关设计模式的思想一定是在实际工程开发中慢慢体会总结的。但是这需要开发者做到“非常有心”，才能够自己去慢慢积累，为了能够培养这种“用心”，读者去专门了解设计模式似乎也是一种捷径和方式。两节课程的设置足以帮助大家培养设计模式思想，同时我再分享一些关于设计模式的经典资料：\n\n- [design-patterns-for-humans](https://github.com/kamranahmedse/design-patterns-for-humans)：这是一本非常著名的设计模式书 pdf\n- [design-patterns-for-humans-cn](https://github.com/guanguans/design-patterns-for-humans-cn)：上本书的中文版 pdf\n- [Learning JavaScript Design Patterns](https://addyosmani.com/resources/essentialjsdesignpatterns/book/)：addyosmani 大神的书 pdf\n- [图说设计模式](https://design-patterns.readthedocs.io/zh_CN/latest/)\n\n其中强烈推荐《Learning JavaScript Design Patterns》，这本书在网上开源免费，其中的内容示例都是用 JavaScript 编写的，而且在代码实例编写当中剖析了很多 jQuery 等经典“轮子”的设计。\n\n同时 GitHub 上也有一个不错的 repo：[JsPattern-ES6](https://github.com/DavidCai1993/JsPattern-ES6)，使用 ES6 重写了《JavaScript 模式》一书中的样例。\n\n还有一个“神器”是：[es6-design-patterns](http://loredanacirstea.github.io/es6-design-patterns/#composite)，如截图：\n\n![enter image description here](https://images.gitbook.cn/765be890-cbfd-11e9-a9bd-857608719494)\n\n这个网站通过 UML 图解释设计模式，同时配以可以运行的代码示例，非常方便对每一种设计模式进行学习。\n\n### <font color=13aa6c>总结</font>\n\n本讲介绍了设计模式的基础理论以及学习方式，其中有一些概念较为抽象，读者不必完全明白，相信通过下一讲的学习，我们结合前端实例，一定会有更深入的体会。","pdfUrl":"","reader":"","duration":"","title":"揭秘前端设计模式（上）","column":"5c91c813968b1d64b1e08fde","isNotification":false,"readingStatistics":0,"htmlContent":"<p>设计模式——我认为这是一个一言难尽的概念。维基百科对设计模式的定义为：</p>\n<blockquote>\n<p>在软件工程中，设计模式（Design Pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。这个术语是由埃里希·伽玛（Erich Gamma）等人在 1990 年代从建筑设计领域引入到计算机科学的。设计模式并不是直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案。</p>\n</blockquote>\n<p>为什么“一言难尽”呢？首先从设计模式的概念可以看出：这是一套理论，干巴巴的描述其所有内容并没有太大意义。我们不会在面试中提出：“请你解释一下设计模式”、“你会多少种设计模式”这种问题。设计模式一般认为有 23 种，<strong>这 23 种设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性，以及类的关联关系和组合关系的总结应用。</strong></p>\n<p>那么对于 JavaScript 或者前端开发来说，设计模式似乎是一个有些遥远的概念。我们应该如何了解并学习设计模式呢？</p>\n<p><strong>我认为设计模式不能停留在理论上，而是应该结合到实际代码当中</strong>。因此打算通过两讲内容来介绍：本讲内容先介绍基本概念，分享一些经典的设计模式书籍以及相关经验，也许稍微有些“无趣”；第二讲内容将深入结合前端开发，挑选那些我们一直使用的、会用到的设计模式进行讲解。</p>\n<p>相关知识点如下：</p>\n<p><img src=\"https://images.gitbook.cn/cb2e6d60-cbfe-11e9-a9bd-857608719494\" alt=\"enter image description here\" /></p>\n<h3><a id=\"font_color13aa6cfont_14\"></a><font color=13aa6c>设计模式到底是什么</font></h3>\n<p>之前提到，设计模式是一种经验总结，它就是一套兵法，一共包含了 23 个套路。最终目的是为了更好的代码重用性、可读性、可靠性、可维护性。</p>\n<p>在平常开发中，“也许你不知道，但是已经在使用设计模式了”。在之前课程内容的学习中，我们其实也有所提及，比如单例模式（细心的读者还能找到单例模式实现的课程出处吗？）、发布订阅模式、原型模式等。</p>\n<p>如果到此，仍然不明白设计模式到底是指什么，别着急，请继续阅读以下内容。</p>\n<h3><a id=\"font_color13aa6cfont_22\"></a><font color=13aa6c>设计模式原则</font></h3>\n<p>既然是一套理论，是一种约定和规范，那么设计模式也就有自己的模式原则。总体来说，其六大原则包括：</p>\n<ul>\n<li>开闭原则</li>\n<li>里氏替换原则</li>\n<li>依赖反转原则</li>\n<li>接口隔离原则</li>\n<li>最小知道原则</li>\n<li>合成复用原则</li>\n</ul>\n<p>如图：</p>\n<p><img src=\"https://images.gitbook.cn/8112c980-cbfc-11e9-93b3-c35630e1847c\" alt=\"enter image description here\" /></p>\n<p>我们来逐一了解：</p>\n<ul>\n<li>开闭原则（Open Close Principle）</li>\n</ul>\n<p>理解开闭原则，就要了解开和闭。<strong>这里的开是指对扩展开放，闭是说对修改关闭</strong>。想想我们有一套实现、提供一个服务，这样的程序需要能够随时进行扩展、随时支持第三方的自定义配置，但是不能去修改已用的实现代码。</p>\n<p>比如我们做了一个 UI 组件轮子，业务方在使用时显然不能够修改我们的代码，但是仍然可以进行扩展。再比如著名的 Draft.js 库，在实现一个编辑器时，提供了灵活的插件机制，实现了热插拔效果，使得整个程序的扩展性好，易于维护和升级。甚至 Redux 库、Koa 库等基本所有库都有开闭原则的体现。</p>\n<p>对于面向对象类型的语言来说，想要严格遵守开闭原则，往往需要使用接口和抽象类，这个我们会在具体设计中再次提到。</p>\n<ul>\n<li>里氏替换原则（Liskov Substitution Principle）</li>\n</ul>\n<p>里氏代换原则就稍微有些抽象，但它是面向对象设计的基本原则之一。</p>\n<blockquote>\n<p>里氏代换原则要求，任何基类可以发挥作用的地方，子类一定可以发挥作用。</p>\n</blockquote>\n<p>这句话怎么理解呢？想想我们的继承实现，里氏替换原则就是继承复用的基础。只有当派生类可以随时替换掉其基类，同时功能不被破坏，基类的方法仍然能被使用，这才是真正的继承，继承才能真正地实现复用，当然，派生类也需要随时能够在基类的基础上增加新的行为。</p>\n<p>事实上，里氏代换原则是对开闭原则的补充。</p>\n<ul>\n<li>依赖反转原则（Dependence Inversion Principle）</li>\n</ul>\n<p>该原则要求针对接口编程，依赖于抽象。更多理论内容我并不打算展开，后续在程序设计中会结合实例提及。</p>\n<ul>\n<li>接口隔离原则（Interface Segregation Principle）</li>\n</ul>\n<p>接口隔离的意思或者目的是减少耦合的出现。在大型软件架构中，使用多个相互隔离的接口，一定比使用单个大而全的接口要好。</p>\n<ul>\n<li>最少知道原则，又称迪米特法则（Demeter Principle）</li>\n</ul>\n<p>最少知道顾名思义，是指：一个系统的功能模块应该最大限度地不知晓其他模块的出现，减少感知，模块应相对独立。</p>\n<ul>\n<li>合成复用原则（Composite Reuse Principle）</li>\n</ul>\n<p>合成复用原则是指：尽量使用合成 / 聚合的方式，而不是使用继承。这是很有意思的一点，我们在之前的课程中提到过：基于原型的继承在很多程度上“优于”基于类的继承，原因就在于基于原型的继承模式体现了可组合性，能够规避“大猩猩和香蕉”等问题的出现。组合是非常优秀的编程思想，这一点在函数式编程范畴中得到了最大程度的印证。</p>\n<h3><a id=\"font_color13aa6cfont_73\"></a><font color=13aa6c>设计模式的三大类型和二十三种套路</font></h3>\n<p>设计模式并没有什么困难的，大体上所有的设计模式可以归结为三大类：</p>\n<ul>\n<li>创建型</li>\n<li>结构型</li>\n<li>行为型</li>\n</ul>\n<p>如图：</p>\n<p><img src=\"https://images.gitbook.cn/1190fdb0-cbfd-11e9-942c-915593d3f51c\" alt=\"enter image description here\" /></p>\n<p>对于 Java 来说，它还包括了 J2EE 类型设计模式。</p>\n<p>我们分别来看：</p>\n<ul>\n<li>创建型（Creational Patterns）</li>\n</ul>\n<p>创建型的五种设计模式提供了更加灵活的对象创建方式，同时可以隐藏创建的具体逻辑。与直接使用 new 运算符实例化对象相比，这些模式具有更强的灵活性以及可定制性。</p>\n<ul>\n<li>结构型（Structural Patterns）</li>\n</ul>\n<p>结构型的七种设计模式关注类和对象的组合，结合继承的概念，这些设计模式能使得对象具有更加灵活的功能设定。</p>\n<ul>\n<li>行为型（Behavioral Patterns）</li>\n</ul>\n<p>行为型的十一种设计模式聚焦于对象和类之间的通信，这是构建大型程序架构必不可少的环节。</p>\n<h3><a id=\"font_color13aa6cfont_101\"></a><font color=13aa6c>关于设计模式的学习</font></h3>\n<p>设计模式使代码编写真正工程化，我们说设计模式是软件工程的基石脉络，如同大厦的结构一样。其实我认为没有必要刻意地去学习设计模式，因为有关设计模式的思想一定是在实际工程开发中慢慢体会总结的。但是这需要开发者做到“非常有心”，才能够自己去慢慢积累，为了能够培养这种“用心”，读者去专门了解设计模式似乎也是一种捷径和方式。两节课程的设置足以帮助大家培养设计模式思想，同时我再分享一些关于设计模式的经典资料：</p>\n<ul>\n<li><a href=\"https://github.com/kamranahmedse/design-patterns-for-humans\" target=\"_blank\">design-patterns-for-humans</a>：这是一本非常著名的设计模式书 pdf</li>\n<li><a href=\"https://github.com/guanguans/design-patterns-for-humans-cn\" target=\"_blank\">design-patterns-for-humans-cn</a>：上本书的中文版 pdf</li>\n<li><a href=\"https://addyosmani.com/resources/essentialjsdesignpatterns/book/\" target=\"_blank\">Learning JavaScript Design Patterns</a>：addyosmani 大神的书 pdf</li>\n<li><a href=\"https://design-patterns.readthedocs.io/zh_CN/latest/\" target=\"_blank\">图说设计模式</a></li>\n</ul>\n<p>其中强烈推荐《Learning JavaScript Design Patterns》，这本书在网上开源免费，其中的内容示例都是用 JavaScript 编写的，而且在代码实例编写当中剖析了很多 jQuery 等经典“轮子”的设计。</p>\n<p>同时 GitHub 上也有一个不错的 repo：<a href=\"https://github.com/DavidCai1993/JsPattern-ES6\" target=\"_blank\">JsPattern-ES6</a>，使用 ES6 重写了《JavaScript 模式》一书中的样例。</p>\n<p>还有一个“神器”是：<a href=\"http://loredanacirstea.github.io/es6-design-patterns/#composite\" target=\"_blank\">es6-design-patterns</a>，如截图：</p>\n<p><img src=\"https://images.gitbook.cn/765be890-cbfd-11e9-a9bd-857608719494\" alt=\"enter image description here\" /></p>\n<p>这个网站通过 UML 图解释设计模式，同时配以可以运行的代码示例，非常方便对每一种设计模式进行学习。</p>\n<h3><a id=\"font_color13aa6cfont_120\"></a><font color=13aa6c>总结</font></h3>\n<p>本讲介绍了设计模式的基础理论以及学习方式，其中有一些概念较为抽象，读者不必完全明白，相信通过下一讲的学习，我们结合前端实例，一定会有更深入的体会。</p>\n","createdAt":"2019-04-21T04:45:10.220Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":37,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FoThASW9dVEPMEo9nP-zaOfbKyLZ"},{"_id":"5cbbf575bbbba80861a35c6f","communication_start_time":null,"type":1,"audioPath":"","abstract":"","content":"在上一讲中，我们介绍了设计模式的一些基本概念。本讲我们来结合实例，结合前端开发，继续讲解这个话题。\n\n回顾一下设计模式的内容：\n\n<img src=\"https://images.gitbook.cn/cb2e6d60-cbfe-11e9-a9bd-857608719494\" width = \"60%\" />\n\n### 工厂模式在前端中的应用\n\n创建型的工厂模式一共分为三种：\n\n- 简单工厂模式（Simple Factory）\n- 工厂方法模式（Factory Method）\n- 抽象工厂模式（Abstract Factory）\n\n顾名思义，工厂模式就是隐藏了创建一个实例的复杂度，只需要提供一个简单的接口调用，直接完成创建实例的目的。而这三种工厂模式的区别我认为没有太大必要去细分，重点还是在于应用。比如一个非常常见的场景，就是 jQuery 的选择器：\n\n```\nclass jQuery {\n    constructor(selector) {\n        super(selector)\n    }\n    //  ....\n}\n\nwindow.$ = function(selector) {\n    return new jQuery(selector)\n}\n```\n\n这样的代码非常明显，我们需要构建一个 jQuery 实例时，只需要：\n\n```\n$(&apos;selector&apos;)\n```\n\n因为 `$` 已经被挂载在 window 上，而 `$` 作为一个函数，它直接返回了 new jQuery(selector)，开发者不需要再麻烦地使用 `new $(&apos;selector&apos;)` 方式。\n\n除了 jQuery 以外，React 开发者常用的 React.createElement 也是工厂模式的体现：\n\n```\nReact.createElement(&apos;span&apos;, null, &apos;Factory Pattern!&apos;),\n```\n\n只要具有组件化思想的类库或者框架，无一例外都会使用工厂模式去创建组件实例，除了提到的 React、jQuery（jQuery UI） 以外，Vue，甚至是更古老的 ExtJS 都不例外。\n\n我们再来看一个例子，请读者体会：\n\n```\nclass Car {\n  constructor(options) {\n    const {doors = 4, state = &apos;new&apos;, color = &apos;black&apos;} = options\n    this.doors = doors\n    this.state = state\n    this.color = color\n  }\n}\n\nclass Truck {\n  constructor(options) {\n    const {wheelSize = &apos;medium&apos;, state = &apos;used&apos;, color = &apos;silver&apos;} = options\n    this.wheelSize = wheelSize\n    this.state = state\n    this.color = color\n  }\n}\n\n\nclass VehicleFactory {\n  createVehicle(options) {\n    switch (options.type) {\n      case &apos;car&apos;:\n        this.vehicleTarget = Car\n        break;\n      case &apos;truck&apos;:\n        this.vehicleTarget = Truck\n        break;\n      default:\n        this.vehicleTarget = Car\n        break;\n    }\n\n    return new this.vehicleTarget(options)\n  }\n}\n\nlet factory = new VehicleFactory()\n\nlet instance1 = factory.createVehicle({\n  type: &apos;car&apos;,\n  color: &apos;yellow&apos;,\n  doors: 4\n})\n\nlet instance2 = factory.createVehicle({\n  type: &apos;truck&apos;,\n  state: &apos;new&apos;,\n  wheelSize: &apos;small&apos;\n})\n\n```\n\n尝试：\n\n```\ninstance1 instanceof Car\ninstance2 instanceof Truck\n```\n\n都会返回 true。理解了这个例子，其实你也就明白了建造者模式。“什么？我还不知道建造者模式是什么！”，没错，设计模式就是这样，重要的不是死记硬背每种模式的概念，而是在实际中应用，其实不经意之间，你一直在使用设计模式。\n\n### 单例模式在前端中的应用\n\n单例模式非常简单，通俗来说就是某个类只能有一个是实例。那么他的应用场景也就非常直观：引用第三方库，全局唯一的对象或者状态管理，全局唯一的插件等。在之前的课程中，我们通过闭包实现了单例模式，这里再次用 ES6 实现：\n\n```\nclass Singleton {\n  constructor() {\n    if (!Singleton.instance) {\n      Singleton.instance = this;\n    }\n\n    return Singleton.instance;\n  }\n}\n```\n\n### 建造者模式在前端中的应用\n\n前面我们提到了建造者模式，这里再深入地进行了解。建造者的精髓在于“分步骤分情况构建一个复杂的对象”。比如我们想实现一个 pizza 类，用于生成 pizza 实例：\n\n```\nclass Pizza {\n    constructor(size, chesse = true, tomato = false, lettuce = false) {\n    }\n}\n```\n\n构建一个 pizza 需要在初始化时传入需要的参数，如果这个 pizza 类变得复杂，比如需要声明是否添加 mushroom、oliver、poulet 等，那么参数就会非常失控：\n\n```\nclass Pizza {\n    constructor(size, mushroom = true, oliver= true, poulet = false, chesse = true, tomato = false, lettuce = false) {\n    }\n}\n```\n\n使用建造者模式：\n\n```\nclass Pizza {\n    constructor(size) {\n        this.size = size\n    }\n\n    addMushroom() {\n        this.mushroom = true\n        return this\n    }\n\n    addOliver() {\n        this.oliver = true\n        return this\n    }\n\n    addPoulet() {\n        this.poulet = true\n        return this\n    }\n\n    addChesse() {\n        this.chesse = true\n        return this\n    }\n    \n    addTomato() {\n        this.tomato = true\n        return this\n    }\n\n    addLettuce() {\n        this.lettuce = true\n        return this\n    }\n\n    build() {\n        return new Pizza(this)\n    }\n}\n```\n\n这样一来，使用就会更加优雅：\n\n```\nnew Pizza(32)\n\t.addOliver()\n\t.addTomato()\n\t.build()\n```\n\n当然，你可以认为参数以对象的形式传入，就能解决参数过多以及参数顺序问题。可是往往构造一个对象并不只是参数的问题。比如构建一个复杂的 DOM 结构，而针对于此 jQuery 利用建造者模式简化了构建 DOM 的过程：\n\n我们可以通过多种方式构造 DOM ：\n\n```\n$( \"<div class= \"foo\">bar</div>\" );\n```\n\n```\n$( \"<p id=\"test\">foo <em>bar</em></p>\").appendTo(\"body\" );\n```\n\n```\nvar newParagraph = $( \"<p />\" ).text( \"Hello world\" );\n```\n\n```\n$( \"<input />\" )\n      .attr({ \"type\": \"text\", \"id\":\"sample\"});\n      .appendTo(\"#container\");\n```\n\n对应 jQuery.prototype 源码：\n\n```\n  // HANDLE: $(html) -> $(array)\n    if ( match[1] ) {\n      context = context instanceof jQuery ? context[0] : context;\n      doc = ( context ? context.ownerDocument || context : document );\n      \n      //如果传入的是单个字符串，并且是单个标记\n      //只需执行 createElement 并跳过其余部分\n    \n      ret = rsingleTag.exec( selector );\n\n      if ( ret ) {\n        if ( jQuery.isPlainObject( context ) ) {\n          selector = [ document.createElement( ret[1] ) ];\n          jQuery.fn.attr.call( selector, context, true );\n\n        } else {\n          selector = [ doc.createElement( ret[1] ) ];\n        }\n\n      } else {\n        ret = jQuery.buildFragment( [ match[1] ], [ doc ] );\n        selector = ( ret.cacheable ? jQuery.clone(ret.fragment) \n        : ret.fragment ).childNodes;\n      }\n\n      return jQuery.merge( this, selector );\n```\n\n### 外观模式在前端中的应用\n\n外观模式的精髓在于对接口进行二次封装，隐藏其内部的复杂度。这种设计在前端开发中也非常常见，比如跨浏览器兼容性的封装，比如事件：\n\n```\nvar addMyEvent = function( el,ev,fn ){\n  if( el.addEventListener ){//存在 DOM2 级方法，则使用并传入事件类型、事件处理程序函数和第3个参数 false（表示冒泡阶段）\n        el.addEventListener( ev,fn, false );\n  }else if(el.attachEvent){ // 为兼容 IE8 及更早浏览器，注意事件类型必须加上\"on\"前缀\n        el.attachEvent( \"on\" + ev, fn );\n  }else{\n       el[\"on\" + ev] = fn;//其他方法都无效，默认采用 DOM0 级方法，使用方括号语法将属性名指定为事件处理程序\n    }\n};\n```\n\n再比如 `$(document).ready` 的用法：\n\n```\nbindReady: function() {\n    ...\n    if ( document.addEventListener ) {\n      // Use the handy event callback\n      document.addEventListener( \"DOMContentLoaded\", DOMContentLoaded, false );\n\n      // A fallback to window.onload, that will always work\n      window.addEventListener( \"load\", jQuery.ready, false );\n\n    // If IE event model is used\n    } else if ( document.attachEvent ) {\n\n      document.attachEvent( \"onreadystatechange\", DOMContentLoaded );\n\n      // A fallback to window.onload, that will always work\n      window.attachEvent( \"onload\", jQuery.ready );\n```\n\n再看一个例子，外观模式和模块化的结合：\n\n```\nvar module = (function() {\n    var _private = {\n        i: 5,\n        get: function() {\n            console.log( \"current value:\" + this.i);\n        },\n        set: function( val ) {\n            this.i = val;\n        },\n        run: function() {\n            console.log( \"running\" );\n        },\n        jump: function(){\n            console.log( \"jumping\" );\n        }\n    };\n \n    return {\n        facade: function( args ) {\n            _private.set(args.val);\n            _private.get();\n            if ( args.run ) {\n                _private.run();\n            }\n        }\n    };\n}());\n \n \n// Outputs: \"current value: 10\" and \"running\"\nmodule.facade( {run: true, val: 10} );\n```\n\n在这个例子中，开发者只需要调用 module.facade( {run: true, val: 10} )，调用后会触发模块当中私有方法，实现对数值的改写，我们并不需要明白 module 内部实现，只需要关心其封装即可。\n\n### 适配器模式在前端中的应用\n\n适配器模式在于适配两个及以上类接口不兼容的问题，和外观模式的核心思路类似。在 jQuery 中也广泛应用，我们知道 opacity 属性在不同浏览器中的表现方式不同。\n\n在 Chrome 4+、FF2+、Saf3.1+、Opera 9+、IE9、iOS 3.2+、Android 2.1+ 中：\n\n```\nopacity: 0.9\n```\n\n是常见用法，但是在 IE6-8，却是：\n\n```\nfilter: alpha(opacity=90)\n```\n\njQuery 利用适配器模式，对这种差异进行了抹平：\n\n```\n// 读\n$( \".container\" ).css( { opacity: .5 } );\n\n// 取\nlet opacity = $( \".container\" ).css( { opacity: .5 } );\n```\n\n其内部实现为：\n\n```\nget: function( elem, computed ) {\n  // IE uses filters for opacity\n  return ropacity.test( (\n        computed && elem.currentStyle ?\n            elem.currentStyle.filter : elem.style.filter) || \"\" ) ?\n    ( parseFloat( RegExp.$1 ) / 100 ) + \"\" :\n    computed ? \"1\" : \"\";\n},\n \nset: function( elem, value ) {\n  var style = elem.style,\n    currentStyle = elem.currentStyle,\n    opacity = jQuery.isNumeric( value ) ?\n          \"alpha(opacity=\" + value * 100 + \")\" : \"\",\n    filter = currentStyle && currentStyle.filter || style.filter || \"\";\n \n  // IE has trouble with opacity if it does not have layout\n  // Force it by setting the zoom level\n  style.zoom = 1;\n \n  // if setting opacity to 1, and no other filters\n  //exist - attempt to remove filter attribute #6652\n  if ( value >= 1 && jQuery.trim( filter.replace( ralpha, \"\" ) ) === \"\" ) {\n \n    // Setting style.filter to null, \"\" & \" \" still leave\n    // \"filter:\" in the cssText if \"filter:\" is present at all,\n    // clearType is disabled, we want to avoid this style.removeAttribute\n    // is IE Only, but so apparently is this code path...\n    style.removeAttribute( \"filter\" );\n \n    // if there there is no filter style applied in a css rule, we are done\n    if ( currentStyle && !currentStyle.filter ) {\n      return;\n    }\n  }\n \n  // otherwise, set new filter values\n  style.filter = ralpha.test( filter ) ?\n    filter.replace( ralpha, opacity ) :\n    filter + \" \" + opacity;\n}\n};\n```\n\n### 享元模式在前端中的应用\n\n我个人认为享元模式非常重要，他是用于性能优化的一种常见模式。它依靠：\n\n- 主减少创建对象实例的数量\n- 运用共享技术来有效支持大量细粒度的对象\n\n这两种方式减少内存占用，以提高性能。在 JavaScript 中，浏览器特别是移动端的浏览器所占有的内存并不算多，因此合理利用享元模式，达到节省内存的目的，就成了一件非常有意义的优化。\n\n在 Java 中有一个关键字：implements，它用于接入接口 interfaces，这在 JavaScript 语言中并不存在，但是我们仍然可以模拟一个：\n\n```\nFunction.prototype.implementsFor = function( parentClassOrObject ){\n    if ( parentClassOrObject.constructor === Function )\n    {\n        // Normal Inheritance\n        this.prototype = new parentClassOrObject();\n        this.prototype.constructor = this;\n        this.prototype.parent = parentClassOrObject.prototype;\n    }\n    else\n    {\n        // Pure Virtual Inheritance\n        this.prototype = parentClassOrObject;\n        this.prototype.constructor = this;\n        this.prototype.parent = parentClassOrObject;\n    }\n    return this;\n};\n```\n\n我们看：implementsFor 作用于一个构造函数，它接受一个父类（function）或者一个 object，并继承该父类构造函数（function）或者指定的 object。上段代码并不难理解，我们看一个应用实例：\n\n```\n// Flyweight object\nvar CoffeeOrder = {\n \n  // Interfaces\n  serveCoffee:function(context){},\n    getFlavor:function(){}\n \n};\n \n \n// ConcreteFlyweight object that creates ConcreteFlyweight\n// Implements CoffeeOrder\nfunction CoffeeFlavor( newFlavor ){\n \n    var flavor = newFlavor;\n \n    // If an interface has been defined for a feature\n    // implement the feature\n    if( typeof this.getFlavor === \"function\" ){\n      this.getFlavor = function() {\n          return flavor;\n      };\n    }\n \n    if( typeof this.serveCoffee === \"function\" ){\n      this.serveCoffee = function( context ) {\n        console.log(\"Serving Coffee flavor \"\n          + flavor\n          + \" to table number \"\n          + context.getTable());\n      };\n    }\n \n}\n \n \n// Implement interface for CoffeeOrder\nCoffeeFlavor.implementsFor( CoffeeOrder );\n \n \n// Handle table numbers for a coffee order\nfunction CoffeeOrderContext( tableNumber ) {\n   return{\n      getTable: function() {\n         return tableNumber;\n     }\n   };\n}\n\nfunction CoffeeFlavorFactory() {\n    var flavors = {},\n    length = 0;\n \n    return {\n        getCoffeeFlavor: function (flavorName) {\n \n            var flavor = flavors[flavorName];\n            if (typeof flavor === \"undefined\") {\n                flavor = new CoffeeFlavor(flavorName);\n                flavors[flavorName] = flavor;\n                length++;\n            }\n            return flavor;\n        },\n \n        getTotalCoffeeFlavorsMade: function () {\n            return length;\n        }\n    };\n}\n \n// Sample usage:\n// testFlyweight()\n \nfunction testFlyweight(){\n \n \n  // The flavors ordered.\n  var flavors = [],\n \n  // The tables for the orders.\n    tables = [],\n \n  // Number of orders made\n    ordersMade = 0,\n \n  // The CoffeeFlavorFactory instance\n    flavorFactory = new CoffeeFlavorFactory();\n \n  function takeOrders( flavorIn, table) {\n     flavors.push( flavorFactory.getCoffeeFlavor( flavorIn ) );\n     tables.push( new CoffeeOrderContext( table ) );\n     ordersMade++;\n  }\n \n   takeOrders(\"Cappuccino\", 2);\n   takeOrders(\"Cappuccino\", 2);\n   takeOrders(\"Frappe\", 1);\n   takeOrders(\"Frappe\", 1);\n   takeOrders(\"Xpresso\", 1);\n   takeOrders(\"Frappe\", 897);\n   takeOrders(\"Cappuccino\", 97);\n   takeOrders(\"Cappuccino\", 97);\n   takeOrders(\"Frappe\", 3);\n   takeOrders(\"Xpresso\", 3);\n   takeOrders(\"Cappuccino\", 3);\n   takeOrders(\"Xpresso\", 96);\n   takeOrders(\"Frappe\", 552);\n   takeOrders(\"Cappuccino\", 121);\n   takeOrders(\"Xpresso\", 121);\n \n   for (var i = 0; i < ordersMade; ++i) {\n       flavors[i].serveCoffee(tables[i]);\n   }\n   console.log(\" \");\n   console.log(\"total CoffeeFlavor objects made: \" + flavorFactory.getTotalCoffeeFlavorsMade());\n}\n```\n\n这个例子中，CoffeeFlavor 接入了 CoffeeOrder 的接口。接口的概念也许对于传统的 JavaScript 开发者有些陌生，我们再来看一个更加具有表现力的例子：在图书管理系统中，每本书都有以下特性：\n\n- ID\n- Title\n- Author\n- Genre\n- Page count\n- Publisher ID\n- ISBN\n\n同时我们需要以下属性来追踪每一本书时，记录它是否可用、归还时间等：\n\n- checkoutDate\n- checkoutMember\n- dueReturnDate\n- availability\n\n那么 Book 这个类看上去就像：\n\n```\nvar Book = function( id, title, author, genre, pageCount,publisherID, ISBN, checkoutDate, checkoutMember, dueReturnDate,availability ){\n \n   this.id = id;\n   this.title = title;\n   this.author = author;\n   this.genre = genre;\n   this.pageCount = pageCount;\n   this.publisherID = publisherID;\n   this.ISBN = ISBN;\n   this.checkoutDate = checkoutDate;\n   this.checkoutMember = checkoutMember;\n   this.dueReturnDate = dueReturnDate;\n   this.availability = availability;\n \n};\n \nBook.prototype = {\n \n  getTitle: function () {\n     return this.title;\n  },\n \n  getAuthor: function () {\n     return this.author;\n  },\n \n  getISBN: function (){\n     return this.ISBN;\n  },\n \n  // For brevity, other getters are not shown\n  updateCheckoutStatus: function( bookID, newStatus, checkoutDate, checkoutMember, newReturnDate ){\n \n     this.id = bookID;\n     this.availability = newStatus;\n     this.checkoutDate = checkoutDate;\n     this.checkoutMember = checkoutMember;\n     this.dueReturnDate = newReturnDate;\n \n  },\n \n  extendCheckoutPeriod: function( bookID, newReturnDate ){\n \n      this.id = bookID;\n      this.dueReturnDate = newReturnDate;\n \n  },\n \n  isPastDue: function(bookID){\n \n     var currentDate = new Date();\n     return currentDate.getTime() > Date.parse( this.dueReturnDate );\n \n   }\n};\n```\n\n这么看上去并没有什么问题，但是当图书增多时，对于系统的压力会逐渐增多。为此我们将书的属性分为两种：本身固有的和外在特性。本身固有的属性包括 title、author 等，外在特性包括 checkoutMember、dueReturnDate 等。这样一来，我们简化书的构造函数为：\n\n```\nvar Book = function ( title, author, genre, pageCount, publisherID, ISBN ) {\n \n    this.title = title;\n    this.author = author;\n    this.genre = genre;\n    this.pageCount = pageCount;\n    this.publisherID = publisherID;\n    this.ISBN = ISBN;\n\n};\n```\n\n我们将外在特性删去，check-outs 等信息将会被移动到一个新的类中，一个新的工厂函数也将出现：\n\n```\n// Book Factory singleton\nvar BookFactory = (function () {\n  var existingBooks = {}, existingBook;\n \n  return {\n    createBook: function ( title, author, genre, pageCount, publisherID, ISBN ) {\n \n      // Find out if a particular book meta-data combination has been created before\n      // !! or (bang bang) forces a boolean to be returned\n      existingBook = existingBooks[ISBN];\n      if ( !!existingBook ) {\n        return existingBook;\n      } else {\n \n        // if not, let&apos;s create a new instance of the book and store it\n        var book = new Book( title, author, genre, pageCount, publisherID, ISBN );\n        existingBooks[ISBN] = book;\n        return book;\n \n      }\n    }\n  };\n \n})();\n```\n\n在这个工厂函数中，我们将会检查当前需要创建的书籍是否已经存在，如果存在直接返回书实例；否则进行调用 Book 构造函数进行创建。这保证了所有的书都是唯一的，而不存在重复。\n\n对于书的外在特性，我们创建 BookRecordManager 来维护每一本书的状态，并通过 bookId 与每一个本书进行关系创建：\n\n```\nvar BookRecordManager = (function () {\n \n  var bookRecordDatabase = {};\n \n  return {\n    // add a new book into the library system\n    addBookRecord: function ( id, title, author, genre, pageCount, publisherID, ISBN, checkoutDate, checkoutMember, dueReturnDate, availability ) {\n \n      var book = BookFactory.createBook( title, author, genre, pageCount, publisherID, ISBN );\n \n      bookRecordDatabase[id] = {\n        checkoutMember: checkoutMember,\n        checkoutDate: checkoutDate,\n        dueReturnDate: dueReturnDate,\n        availability: availability,\n        book: book\n      };\n    },\n    updateCheckoutStatus: function ( bookID, newStatus, checkoutDate, checkoutMember, newReturnDate ) {\n \n      var record = bookRecordDatabase[bookID];\n      record.availability = newStatus;\n      record.checkoutDate = checkoutDate;\n      record.checkoutMember = checkoutMember;\n      record.dueReturnDate = newReturnDate;\n    },\n \n    extendCheckoutPeriod: function ( bookID, newReturnDate ) {\n      bookRecordDatabase[bookID].dueReturnDate = newReturnDate;\n    },\n \n    isPastDue: function ( bookID ) {\n      var currentDate = new Date();\n      return currentDate.getTime() > Date.parse( bookRecordDatabase[bookID].dueReturnDate );\n    }\n  };\n \n})();\n```\n\n其实变动也比较明显，书目所有的外在特性都被从书本身的特性中抽离，现在被移动到 BookManager 的 BookDatabase 当中。对于书借入/借出的操作也移动到了 BookRecordManager 当中，因为这些方法需要直接操作书的外在特性。如此一来，比一本书拥有多项属性的大 object 模式更加高效，也更利于维护。\n\n关于性能可以具体来看：如果有 30 本同样一本书的 copy，现有的模式下只存储了一个实例；同时对于书状态转移的函数，我们维护在 BookManager 当中，而不再出现在对象（原型）上，如果这些函数出现在每一个书实例当中，将会是更大的开销。\n\n享元模式在前端还有更多的应用，比如事件代理就是一个很典型的体现：\n\n```\n<div id=\"container\">\n   <div class=\"toggle\" href=\"#\">More Info (Address)\n       <span class=\"info\">\n           This is more information\n       </span></div>\n   <div class=\"toggle\" href=\"#\">Even More Info (Map)\n       <span class=\"info\">\n          <iframe src=\"http://www.map-generator.net/extmap.php?name=London&amp;address=london%2C%20england&amp;width=500...gt;\"</iframe>\n       </span>\n   </div>\n</div>\n```\n\n我们集中将事件处理放到父容器上：\n\n```\nvar stateManager = {\n \n  fly: function () {\n \n    var self = this;\n \n    $( \"#container\" )\n          .unbind()\n          .on( \"click\", \"div.toggle\", function ( e ) {\n            self.handleClick( e.target );\n          });\n  },\n \n  handleClick: function ( elem ) {\n    $( elem ).find( \"span\" ).toggle( \"slow\" );\n  }\n};\n```\n\n如此类似，前面课程提到过的 React 合成事件的池化机制，都体现了异曲同工之妙。\n\n### 代理模式在前端中的应用\n\n代理模式大家应该都不陌生，ES next 提供的 Proxy 让我们实现代理模式变得更加容易。关于 Proxy 的使用这些基础内容这里不过多赘述，直接来看一些代理模式的应用场景。\n\n我们对函数进行代理，对函数的返回结果进行缓存。在函数执行时，优先使用缓存值，否则返回执行计算值：\n\n```\nconst getCacheProxy = (fn, cache = new Map()) => \n  new Proxy(fn, {\n    apply(target, context, args) {\n      const argsString = args.join(&apos; &apos;)\n      if (cache.has(argsString)) {\n        return cache.get(argsString)\n      }\n      const result = fn(...args)\n      cache.set(argsString, result)\n\n      return result\n    }\n  })\n```\n\n另外一个类似的实现：\n\n```\nconst createThrottleProxy = (fn, timer) => {\n  let last = Date.now() - timer\n  return new Proxy(fn, {\n    apply(target, context, args) {\n      if (Date.now() - last >= rate) {\n        fn(args)\n        last = Date.now()\n      }\n    }\n  })\n};\n```\n\n这些内容在前面的课程都有渗透，相信读者已经不难理解了。我们再来看 jQuery 当中的例子：\n\n```\n$( \"button\" ).on( \"click\", function () {\n  // Within this function, \"this\" refers to the element that was clicked\n  $( this ).addClass( \"active\" );\n});\n```\n\n通过 `$( this )` 可以获取到当前触发事件的元素，但是：\n\n```\n$( \"button\" ).on( \"click\", function () {\n  setTimeout(function () {\n    // \"this\" doesn&apos;t refer to our element!\n    $( this ).addClass( \"active\" );\n  });\n});\n```\n\n但是这里的 `$( this )` 不再是预期之中的结果。为此，jQuery 提供了 .proxy() 方法，这是典型的代理模式体现。\n\n```\n$( \"button\" ).on( \"click\", function () {\n \n    setTimeout( $.proxy( function () {\n        // \"this\" now refers to our element as we wanted\n        $( this ).addClass( \"active\" );\n    }, this), 500);\n \n    // the last \"this\" we&apos;re passing tells $.proxy() that our DOM element\n    // is the value we want \"this\" to refer to.\n});\n```\n\n来看一下 proxy 的实现：\n\n```\n// Bind a function to a context, optionally partially applying any\n// arguments.\nproxy: function( fn, context ) {\n  if ( typeof context === \"string\" ) {\n    var tmp = fn[ context ];\n    context = fn;\n    fn = tmp;\n  }\n \n  // Quick check to determine if target is callable, in the spec\n  // this throws a TypeError, but we will just return undefined.\n  if ( !jQuery.isFunction( fn ) ) {\n    return undefined;\n  }\n \n  // Simulated bind\n  var args = slice.call( arguments, 2 ),\n    proxy = function() {\n      return fn.apply( context, args.concat( slice.call( arguments ) ) );\n    };\n \n  // Set the guid of unique handler to the same of original handler, so it can be removed\n  proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;\n \n  return proxy;\n}\n```\n\n### 装饰者模式在前端中的应用\n\n装饰者模式如同代理模式一样，如今 JavaScript 也已经原生能够很好地进行支持了。简单来说就是在不改变原对象的基础上，对其对象进行包装和拓展，使原对象能够应对更加复杂的需求。这就有一点像高阶函数，因此在前端开发中非常多见：\n\n```\nimport React, { Component } from &apos;react&apos;\nimport {connect} from &apos;react-redux&apos;\nclass App extends Component {\n render() {\n  //...\n }\n}\nexport default connect(mapStateToProps,actionCreators)(App);\n```\n\n或者在 Ant design 中：\n\n```\nclass CustomizedForm extends React.Component {}\n\nCustomizedForm = Form.create({})(CustomizedForm)\n```\n\n当然 TypeScript 函数修饰符 @ 也是类似的。\n\n借助装饰者模式，很容易衍生出 AOP 面向切面编程的概念：\n\n```\nFunction.prototype.before = function(fn) {\n  const self = this\n  return function() {\n    fn.apply(new(self), arguments)\n    return self.apply(new(self), arguments)\n  }\n}\n\nFunction.prototype.after = function(fn) {\n  const self = this\n  return function() {\n    self.apply(new(self), arguments)\n    return fn.apply(new(self), arguments)\n  }\n}\n```\n\n其实面向切面编程和装饰者模式思想是完全一致的。典型场景就是对表单的验证，我们将把表单输入逻辑校验的 validata 函数融入到 before 逻辑当中：\n\n```\nFunction.prototype.before = function( beforefn ) {\n  const self = this\n  return function(){\n    if ( beforefn.apply( this, arguments ) === false ) return \n    return self.apply( this, arguments )\n  }\n}\n\n\nconst validate = function(){\n  // 表单验证逻辑\n}\n\nconst formSubmit = function() {\n  // 表达提交逻辑\n  ajax( &apos;http:// xxx.com/login&apos;, param )\n}\n\nsubmitBtn.onclick = function() {\n  formSubmit.before( validate )\n}\n```\n\n### 职责链模式在前端中的应用\n\n顾名思义，职责链模式就是建立一个流程链条，一个请求从一端进入，并从一个职责根据需求，流转进入另一个对象，直到找到合适的处理程序。\n\n听上去似乎有点“中间件”的意思，我们来看一个简单的应用：账户付款时绑定一个基本帐户类，它连接了多种付款方式：paypal 支付、比特币支付，并根据不同付款方式的金额额度和付款额，选择第一个合适的账户进行支付逻辑：\n\n```\nclass Account {\n    next(account) {\n        this.successor = account\n    }\n    \n    pay(amount) {\n        if (this.canPay(amount)) {\n            console.log(`Paid ${amount} using ${this.name}`)\n        } else if (this.successor) {\n            console.log(`Cannot pay using ${this.name}. Proceeding...`)\n            this.successor.pay(amount)\n        } else {\n            console.log(&apos;None of the accounts have enough balance&apos;)\n        }\n    }\n    \n    canPay(amount) {\n        return this.balance >= amount\n    }\n}\n\nclass Bank extends Account {\n    constructor(balance) {\n        super()\n        this.name = &apos;bank&apos;\n        this.balance = balance\n    }\n}\n\nclass Paypal extends Account {\n    constructor(balance) {\n        super()        \n        this.name = &apos;Paypal&apos;\n        this.balance = balance\n    }\n}\n\nclass Bitcoin extends Account {\n    constructor(balance) {\n        super()        \n        this.name = &apos;bitcoin&apos;\n        this.balance = balance\n    }\n}\n```\n\n在使用时，我们先给三个账户充钱：\n\n```\nconst bank = new Bank(100)          // Bank with balance 100\nconst paypal = new Paypal(200)      // Paypal with balance 200\nconst bitcoin = new Bitcoin(300)    // Bitcoin with balance 300\n```\n\n并按顺序优先调用银行付款、PayPal 付款、比特币付款：\n\n```\nbank.next(paypal)\npaypal.next(bitcoin)\n```\n\n最终付款行为：\n\n```\nbank.pay(250)\n```\n\n输出：\n\n```\nCannot pay using bank. Proceeding...\nCannot pay using Paypal. Proceeding...\nPaid 250 using bitcoin\n```\n\n### 策略模式在前端中的应用\n\n策略模式能够让开发者基于具体场景，来切换不同的算法或者策略。本身这个模式比较简单，但是有一个比较有意思的应用：V8 引擎在实现排序时，根据排序长度的不同，动态合理选用排序策略，达到尽可能的性能优化，例如代码：\n\n```\nconst bubbleSort = target => {\n    console.log(&apos;Sorting with bubble sort&apos;)\n    // ...\n    // ...\n    return target\n}\n\nconst quickSort = target => {\n    console.log(&apos;Sorting with quick sort&apos;)\n    // ...\n    // ...\n    return target\n}\n\nconst sorter = target => {\n    if(target.length > 5){\n        return quickSort(target)\n    } else {\n        return bubbleSort(target)\n    }\n}\n```\n\n在目标数组长度大于 5 时使用快排，否则使用冒泡排序。感兴趣的读者可以自行了解 V8 的实现，看看这个分界策落的阈值（这里的例子中使用了 5）是多少，以及思考为什么选取该阈值。\n\n上述代码的使用：\n\n```\nconst long = [1, 5, 4, 3, 2, 8]\nconst short = [1, 5, 4]\n\nconst result1 = sorter(long)\nconst result2 = sorter(short)\n```\n\n输出：\n\n```\nSorting with quick sort\nSorting with bubble sort\n```\n\n由此看出：第一个部分是策略类，策略类封装了具体的算法，并负责具体的计算过程；第二个部分是环境类，这个环境类接受客户的请求，随后把请求委托给某一个策略类。另一个应用策略模式的例子是表单校验：\n\n```\n\nclass Validator {\n  constructor() {\n    this.cache = []\n  }\n\n  add(dom, rule, errorMsg) {\n    let array = rule.split(&apos;:&apos;)\n\n    this.cache.push(function(){\n      var strategy = array.shift()\n      array.unshift(dom.value)\n      array.push(errorMsg)\n\n      return strategies[strategy].apply(dom, array)\n    })\n  }\n\n  start() {\n    for (let i = 0, validatorFunc; validatorFunc = this.cache[i++]; i < this.cache.length) {\n      const msg = validatorFunc()\n      if (msg) return msg\n    }\n  }\n}\n\nconst strategies = {\n    isNonEmpty: function(value, errorMsg) {\n        if (value=&apos;&apos;) {\n            return errorMsg\n        }\n    },\n    minLength: function(value,length, errorMsg) {\n        if (value.length<length) {\n            return errorMsg\n        }\n    },\n    isMobile: function(value, errorMsg) {\n        if (!/^1[3|5|8][0-9]$/.test(value)) {\n            return errorMsg\n        }\n    }\n}\n\nconst validataFunc = function(){\n    let validator = new Validator()\n    validator.add(registerForm.userName, &apos;isNonEmpty&apos;, &apos;用户名不能为空’)\n    validator.add(registerForm.password, &apos;inLength:6&apos; ,&apos;密码长度不能少于6位&apos;)\n    validator.add(registerForm.phoneNumber, &apos;isMobile&apos;, &apos;手机号码格式不正确’)\n\n    const  errorMsg = validator.start()\n    return errorMsgs\n}\n\nconst registerForm = document.getElementById(\"registerForm\")\nregisterForm.onsubmit = function() {\n    varerrorMsg = validataFunc()\n    if (errorMsg) {\n        alert(errorMsg)\n        return false \n    }\n}\n```\n\n其中，validataFunc 是我们的环境类，而 Validator 和 strategies 构成我们的策略。\n\n### 总结\n\n这节课程讲解了：工厂模式、单例模式、建造者模式、外观模式、适配器模式、享元模式、代理模式、装饰者模式、职责链模式、策略模式等在前端中的实现和应用。同时，包括原型模式、观察者模式、迭代器模式在内，这些模式都非常贴近 JavaScript 原有语法，因此不再过多赘述。\n\n实际上，设计模式很简单，我们应该做到的是需要应用时“胸中有数”，能够想到设计模式实现，而不需要一味死记硬背。","pdfUrl":"","reader":"","duration":"","title":"揭秘前端设计模式（下）","column":"5c91c813968b1d64b1e08fde","isNotification":false,"readingStatistics":0,"htmlContent":"<p>在上一讲中，我们介绍了设计模式的一些基本概念。本讲我们来结合实例，结合前端开发，继续讲解这个话题。</p>\n<p>回顾一下设计模式的内容：</p>\n<img src=\"https://images.gitbook.cn/cb2e6d60-cbfe-11e9-a9bd-857608719494\" width = \"60%\" />\n<h3><a id=\"_6\"></a>工厂模式在前端中的应用</h3>\n<p>创建型的工厂模式一共分为三种：</p>\n<ul>\n<li>简单工厂模式（Simple Factory）</li>\n<li>工厂方法模式（Factory Method）</li>\n<li>抽象工厂模式（Abstract Factory）</li>\n</ul>\n<p>顾名思义，工厂模式就是隐藏了创建一个实例的复杂度，只需要提供一个简单的接口调用，直接完成创建实例的目的。而这三种工厂模式的区别我认为没有太大必要去细分，重点还是在于应用。比如一个非常常见的场景，就是 jQuery 的选择器：</p>\n<pre><code class=\"lang-\">class jQuery {\n    constructor(selector) {\n        super(selector)\n    }\n    //  ....\n}\n\nwindow.$ = function(selector) {\n    return new jQuery(selector)\n}\n</code></pre>\n<p>这样的代码非常明显，我们需要构建一个 jQuery 实例时，只需要：</p>\n<pre><code class=\"lang-\">$(&apos;selector&apos;)\n</code></pre>\n<p>因为 <code>$</code> 已经被挂载在 window 上，而 <code>$</code> 作为一个函数，它直接返回了 new jQuery(selector)，开发者不需要再麻烦地使用 <code>new $(&apos;selector&apos;)</code> 方式。</p>\n<p>除了 jQuery 以外，React 开发者常用的 React.createElement 也是工厂模式的体现：</p>\n<pre><code class=\"lang-\">React.createElement(&apos;span&apos;, null, &apos;Factory Pattern!&apos;),\n</code></pre>\n<p>只要具有组件化思想的类库或者框架，无一例外都会使用工厂模式去创建组件实例，除了提到的 React、jQuery（jQuery UI） 以外，Vue，甚至是更古老的 ExtJS 都不例外。</p>\n<p>我们再来看一个例子，请读者体会：</p>\n<pre><code class=\"lang-\">class Car {\n  constructor(options) {\n    const {doors = 4, state = &apos;new&apos;, color = &apos;black&apos;} = options\n    this.doors = doors\n    this.state = state\n    this.color = color\n  }\n}\n\nclass Truck {\n  constructor(options) {\n    const {wheelSize = &apos;medium&apos;, state = &apos;used&apos;, color = &apos;silver&apos;} = options\n    this.wheelSize = wheelSize\n    this.state = state\n    this.color = color\n  }\n}\n\n\nclass VehicleFactory {\n  createVehicle(options) {\n    switch (options.type) {\n      case &apos;car&apos;:\n        this.vehicleTarget = Car\n        break;\n      case &apos;truck&apos;:\n        this.vehicleTarget = Truck\n        break;\n      default:\n        this.vehicleTarget = Car\n        break;\n    }\n\n    return new this.vehicleTarget(options)\n  }\n}\n\nlet factory = new VehicleFactory()\n\nlet instance1 = factory.createVehicle({\n  type: &apos;car&apos;,\n  color: &apos;yellow&apos;,\n  doors: 4\n})\n\nlet instance2 = factory.createVehicle({\n  type: &apos;truck&apos;,\n  state: &apos;new&apos;,\n  wheelSize: &apos;small&apos;\n})\n\n</code></pre>\n<p>尝试：</p>\n<pre><code class=\"lang-\">instance1 instanceof Car\ninstance2 instanceof Truck\n</code></pre>\n<p>都会返回 true。理解了这个例子，其实你也就明白了建造者模式。“什么？我还不知道建造者模式是什么！”，没错，设计模式就是这样，重要的不是死记硬背每种模式的概念，而是在实际中应用，其实不经意之间，你一直在使用设计模式。</p>\n<h3><a id=\"_110\"></a>单例模式在前端中的应用</h3>\n<p>单例模式非常简单，通俗来说就是某个类只能有一个是实例。那么他的应用场景也就非常直观：引用第三方库，全局唯一的对象或者状态管理，全局唯一的插件等。在之前的课程中，我们通过闭包实现了单例模式，这里再次用 ES6 实现：</p>\n<pre><code class=\"lang-\">class Singleton {\n  constructor() {\n    if (!Singleton.instance) {\n      Singleton.instance = this;\n    }\n\n    return Singleton.instance;\n  }\n}\n</code></pre>\n<h3><a id=\"_126\"></a>建造者模式在前端中的应用</h3>\n<p>前面我们提到了建造者模式，这里再深入地进行了解。建造者的精髓在于“分步骤分情况构建一个复杂的对象”。比如我们想实现一个 pizza 类，用于生成 pizza 实例：</p>\n<pre><code class=\"lang-\">class Pizza {\n    constructor(size, chesse = true, tomato = false, lettuce = false) {\n    }\n}\n</code></pre>\n<p>构建一个 pizza 需要在初始化时传入需要的参数，如果这个 pizza 类变得复杂，比如需要声明是否添加 mushroom、oliver、poulet 等，那么参数就会非常失控：</p>\n<pre><code class=\"lang-\">class Pizza {\n    constructor(size, mushroom = true, oliver= true, poulet = false, chesse = true, tomato = false, lettuce = false) {\n    }\n}\n</code></pre>\n<p>使用建造者模式：</p>\n<pre><code class=\"lang-\">class Pizza {\n    constructor(size) {\n        this.size = size\n    }\n\n    addMushroom() {\n        this.mushroom = true\n        return this\n    }\n\n    addOliver() {\n        this.oliver = true\n        return this\n    }\n\n    addPoulet() {\n        this.poulet = true\n        return this\n    }\n\n    addChesse() {\n        this.chesse = true\n        return this\n    }\n    \n    addTomato() {\n        this.tomato = true\n        return this\n    }\n\n    addLettuce() {\n        this.lettuce = true\n        return this\n    }\n\n    build() {\n        return new Pizza(this)\n    }\n}\n</code></pre>\n<p>这样一来，使用就会更加优雅：</p>\n<pre><code class=\"lang-\">new Pizza(32)\n\t.addOliver()\n\t.addTomato()\n\t.build()\n</code></pre>\n<p>当然，你可以认为参数以对象的形式传入，就能解决参数过多以及参数顺序问题。可是往往构造一个对象并不只是参数的问题。比如构建一个复杂的 DOM 结构，而针对于此 jQuery 利用建造者模式简化了构建 DOM 的过程：</p>\n<p>我们可以通过多种方式构造 DOM ：</p>\n<pre><code class=\"lang-\">$( &quot;&lt;div class= &quot;foo&quot;&gt;bar&lt;/div&gt;&quot; );\n</code></pre>\n<pre><code class=\"lang-\">$( &quot;&lt;p id=&quot;test&quot;&gt;foo &lt;em&gt;bar&lt;/em&gt;&lt;/p&gt;&quot;).appendTo(&quot;body&quot; );\n</code></pre>\n<pre><code class=\"lang-\">var newParagraph = $( &quot;&lt;p /&gt;&quot; ).text( &quot;Hello world&quot; );\n</code></pre>\n<pre><code class=\"lang-\">$( &quot;&lt;input /&gt;&quot; )\n      .attr({ &quot;type&quot;: &quot;text&quot;, &quot;id&quot;:&quot;sample&quot;});\n      .appendTo(&quot;#container&quot;);\n</code></pre>\n<p>对应 jQuery.prototype 源码：</p>\n<pre><code class=\"lang-\">  // HANDLE: $(html) -&gt; $(array)\n    if ( match[1] ) {\n      context = context instanceof jQuery ? context[0] : context;\n      doc = ( context ? context.ownerDocument || context : document );\n      \n      //如果传入的是单个字符串，并且是单个标记\n      //只需执行 createElement 并跳过其余部分\n    \n      ret = rsingleTag.exec( selector );\n\n      if ( ret ) {\n        if ( jQuery.isPlainObject( context ) ) {\n          selector = [ document.createElement( ret[1] ) ];\n          jQuery.fn.attr.call( selector, context, true );\n\n        } else {\n          selector = [ doc.createElement( ret[1] ) ];\n        }\n\n      } else {\n        ret = jQuery.buildFragment( [ match[1] ], [ doc ] );\n        selector = ( ret.cacheable ? jQuery.clone(ret.fragment) \n        : ret.fragment ).childNodes;\n      }\n\n      return jQuery.merge( this, selector );\n</code></pre>\n<h3><a id=\"_252\"></a>外观模式在前端中的应用</h3>\n<p>外观模式的精髓在于对接口进行二次封装，隐藏其内部的复杂度。这种设计在前端开发中也非常常见，比如跨浏览器兼容性的封装，比如事件：</p>\n<pre><code class=\"lang-\">var addMyEvent = function( el,ev,fn ){\n  if( el.addEventListener ){//存在 DOM2 级方法，则使用并传入事件类型、事件处理程序函数和第3个参数 false（表示冒泡阶段）\n        el.addEventListener( ev,fn, false );\n  }else if(el.attachEvent){ // 为兼容 IE8 及更早浏览器，注意事件类型必须加上&quot;on&quot;前缀\n        el.attachEvent( &quot;on&quot; + ev, fn );\n  }else{\n       el[&quot;on&quot; + ev] = fn;//其他方法都无效，默认采用 DOM0 级方法，使用方括号语法将属性名指定为事件处理程序\n    }\n};\n</code></pre>\n<p>再比如 <code>$(document).ready</code> 的用法：</p>\n<pre><code class=\"lang-\">bindReady: function() {\n    ...\n    if ( document.addEventListener ) {\n      // Use the handy event callback\n      document.addEventListener( &quot;DOMContentLoaded&quot;, DOMContentLoaded, false );\n\n      // A fallback to window.onload, that will always work\n      window.addEventListener( &quot;load&quot;, jQuery.ready, false );\n\n    // If IE event model is used\n    } else if ( document.attachEvent ) {\n\n      document.attachEvent( &quot;onreadystatechange&quot;, DOMContentLoaded );\n\n      // A fallback to window.onload, that will always work\n      window.attachEvent( &quot;onload&quot;, jQuery.ready );\n</code></pre>\n<p>再看一个例子，外观模式和模块化的结合：</p>\n<pre><code class=\"lang-\">var module = (function() {\n    var _private = {\n        i: 5,\n        get: function() {\n            console.log( &quot;current value:&quot; + this.i);\n        },\n        set: function( val ) {\n            this.i = val;\n        },\n        run: function() {\n            console.log( &quot;running&quot; );\n        },\n        jump: function(){\n            console.log( &quot;jumping&quot; );\n        }\n    };\n \n    return {\n        facade: function( args ) {\n            _private.set(args.val);\n            _private.get();\n            if ( args.run ) {\n                _private.run();\n            }\n        }\n    };\n}());\n \n \n// Outputs: &quot;current value: 10&quot; and &quot;running&quot;\nmodule.facade( {run: true, val: 10} );\n</code></pre>\n<p>在这个例子中，开发者只需要调用 module.facade( {run: true, val: 10} )，调用后会触发模块当中私有方法，实现对数值的改写，我们并不需要明白 module 内部实现，只需要关心其封装即可。</p>\n<h3><a id=\"_327\"></a>适配器模式在前端中的应用</h3>\n<p>适配器模式在于适配两个及以上类接口不兼容的问题，和外观模式的核心思路类似。在 jQuery 中也广泛应用，我们知道 opacity 属性在不同浏览器中的表现方式不同。</p>\n<p>在 Chrome 4+、FF2+、Saf3.1+、Opera 9+、IE9、iOS 3.2+、Android 2.1+ 中：</p>\n<pre><code class=\"lang-\">opacity: 0.9\n</code></pre>\n<p>是常见用法，但是在 IE6-8，却是：</p>\n<pre><code class=\"lang-\">filter: alpha(opacity=90)\n</code></pre>\n<p>jQuery 利用适配器模式，对这种差异进行了抹平：</p>\n<pre><code class=\"lang-\">// 读\n$( &quot;.container&quot; ).css( { opacity: .5 } );\n\n// 取\nlet opacity = $( &quot;.container&quot; ).css( { opacity: .5 } );\n</code></pre>\n<p>其内部实现为：</p>\n<pre><code class=\"lang-\">get: function( elem, computed ) {\n  // IE uses filters for opacity\n  return ropacity.test( (\n        computed &amp;&amp; elem.currentStyle ?\n            elem.currentStyle.filter : elem.style.filter) || &quot;&quot; ) ?\n    ( parseFloat( RegExp.$1 ) / 100 ) + &quot;&quot; :\n    computed ? &quot;1&quot; : &quot;&quot;;\n},\n \nset: function( elem, value ) {\n  var style = elem.style,\n    currentStyle = elem.currentStyle,\n    opacity = jQuery.isNumeric( value ) ?\n          &quot;alpha(opacity=&quot; + value * 100 + &quot;)&quot; : &quot;&quot;,\n    filter = currentStyle &amp;&amp; currentStyle.filter || style.filter || &quot;&quot;;\n \n  // IE has trouble with opacity if it does not have layout\n  // Force it by setting the zoom level\n  style.zoom = 1;\n \n  // if setting opacity to 1, and no other filters\n  //exist - attempt to remove filter attribute #6652\n  if ( value &gt;= 1 &amp;&amp; jQuery.trim( filter.replace( ralpha, &quot;&quot; ) ) === &quot;&quot; ) {\n \n    // Setting style.filter to null, &quot;&quot; &amp; &quot; &quot; still leave\n    // &quot;filter:&quot; in the cssText if &quot;filter:&quot; is present at all,\n    // clearType is disabled, we want to avoid this style.removeAttribute\n    // is IE Only, but so apparently is this code path...\n    style.removeAttribute( &quot;filter&quot; );\n \n    // if there there is no filter style applied in a css rule, we are done\n    if ( currentStyle &amp;&amp; !currentStyle.filter ) {\n      return;\n    }\n  }\n \n  // otherwise, set new filter values\n  style.filter = ralpha.test( filter ) ?\n    filter.replace( ralpha, opacity ) :\n    filter + &quot; &quot; + opacity;\n}\n};\n</code></pre>\n<h3><a id=\"_400\"></a>享元模式在前端中的应用</h3>\n<p>我个人认为享元模式非常重要，他是用于性能优化的一种常见模式。它依靠：</p>\n<ul>\n<li>主减少创建对象实例的数量</li>\n<li>运用共享技术来有效支持大量细粒度的对象</li>\n</ul>\n<p>这两种方式减少内存占用，以提高性能。在 JavaScript 中，浏览器特别是移动端的浏览器所占有的内存并不算多，因此合理利用享元模式，达到节省内存的目的，就成了一件非常有意义的优化。</p>\n<p>在 Java 中有一个关键字：implements，它用于接入接口 interfaces，这在 JavaScript 语言中并不存在，但是我们仍然可以模拟一个：</p>\n<pre><code class=\"lang-\">Function.prototype.implementsFor = function( parentClassOrObject ){\n    if ( parentClassOrObject.constructor === Function )\n    {\n        // Normal Inheritance\n        this.prototype = new parentClassOrObject();\n        this.prototype.constructor = this;\n        this.prototype.parent = parentClassOrObject.prototype;\n    }\n    else\n    {\n        // Pure Virtual Inheritance\n        this.prototype = parentClassOrObject;\n        this.prototype.constructor = this;\n        this.prototype.parent = parentClassOrObject;\n    }\n    return this;\n};\n</code></pre>\n<p>我们看：implementsFor 作用于一个构造函数，它接受一个父类（function）或者一个 object，并继承该父类构造函数（function）或者指定的 object。上段代码并不难理解，我们看一个应用实例：</p>\n<pre><code class=\"lang-\">// Flyweight object\nvar CoffeeOrder = {\n \n  // Interfaces\n  serveCoffee:function(context){},\n    getFlavor:function(){}\n \n};\n \n \n// ConcreteFlyweight object that creates ConcreteFlyweight\n// Implements CoffeeOrder\nfunction CoffeeFlavor( newFlavor ){\n \n    var flavor = newFlavor;\n \n    // If an interface has been defined for a feature\n    // implement the feature\n    if( typeof this.getFlavor === &quot;function&quot; ){\n      this.getFlavor = function() {\n          return flavor;\n      };\n    }\n \n    if( typeof this.serveCoffee === &quot;function&quot; ){\n      this.serveCoffee = function( context ) {\n        console.log(&quot;Serving Coffee flavor &quot;\n          + flavor\n          + &quot; to table number &quot;\n          + context.getTable());\n      };\n    }\n \n}\n \n \n// Implement interface for CoffeeOrder\nCoffeeFlavor.implementsFor( CoffeeOrder );\n \n \n// Handle table numbers for a coffee order\nfunction CoffeeOrderContext( tableNumber ) {\n   return{\n      getTable: function() {\n         return tableNumber;\n     }\n   };\n}\n\nfunction CoffeeFlavorFactory() {\n    var flavors = {},\n    length = 0;\n \n    return {\n        getCoffeeFlavor: function (flavorName) {\n \n            var flavor = flavors[flavorName];\n            if (typeof flavor === &quot;undefined&quot;) {\n                flavor = new CoffeeFlavor(flavorName);\n                flavors[flavorName] = flavor;\n                length++;\n            }\n            return flavor;\n        },\n \n        getTotalCoffeeFlavorsMade: function () {\n            return length;\n        }\n    };\n}\n \n// Sample usage:\n// testFlyweight()\n \nfunction testFlyweight(){\n \n \n  // The flavors ordered.\n  var flavors = [],\n \n  // The tables for the orders.\n    tables = [],\n \n  // Number of orders made\n    ordersMade = 0,\n \n  // The CoffeeFlavorFactory instance\n    flavorFactory = new CoffeeFlavorFactory();\n \n  function takeOrders( flavorIn, table) {\n     flavors.push( flavorFactory.getCoffeeFlavor( flavorIn ) );\n     tables.push( new CoffeeOrderContext( table ) );\n     ordersMade++;\n  }\n \n   takeOrders(&quot;Cappuccino&quot;, 2);\n   takeOrders(&quot;Cappuccino&quot;, 2);\n   takeOrders(&quot;Frappe&quot;, 1);\n   takeOrders(&quot;Frappe&quot;, 1);\n   takeOrders(&quot;Xpresso&quot;, 1);\n   takeOrders(&quot;Frappe&quot;, 897);\n   takeOrders(&quot;Cappuccino&quot;, 97);\n   takeOrders(&quot;Cappuccino&quot;, 97);\n   takeOrders(&quot;Frappe&quot;, 3);\n   takeOrders(&quot;Xpresso&quot;, 3);\n   takeOrders(&quot;Cappuccino&quot;, 3);\n   takeOrders(&quot;Xpresso&quot;, 96);\n   takeOrders(&quot;Frappe&quot;, 552);\n   takeOrders(&quot;Cappuccino&quot;, 121);\n   takeOrders(&quot;Xpresso&quot;, 121);\n \n   for (var i = 0; i &lt; ordersMade; ++i) {\n       flavors[i].serveCoffee(tables[i]);\n   }\n   console.log(&quot; &quot;);\n   console.log(&quot;total CoffeeFlavor objects made: &quot; + flavorFactory.getTotalCoffeeFlavorsMade());\n}\n</code></pre>\n<p>这个例子中，CoffeeFlavor 接入了 CoffeeOrder 的接口。接口的概念也许对于传统的 JavaScript 开发者有些陌生，我们再来看一个更加具有表现力的例子：在图书管理系统中，每本书都有以下特性：</p>\n<ul>\n<li>ID</li>\n<li>Title</li>\n<li>Author</li>\n<li>Genre</li>\n<li>Page count</li>\n<li>Publisher ID</li>\n<li>ISBN</li>\n</ul>\n<p>同时我们需要以下属性来追踪每一本书时，记录它是否可用、归还时间等：</p>\n<ul>\n<li>checkoutDate</li>\n<li>checkoutMember</li>\n<li>dueReturnDate</li>\n<li>availability</li>\n</ul>\n<p>那么 Book 这个类看上去就像：</p>\n<pre><code class=\"lang-\">var Book = function( id, title, author, genre, pageCount,publisherID, ISBN, checkoutDate, checkoutMember, dueReturnDate,availability ){\n \n   this.id = id;\n   this.title = title;\n   this.author = author;\n   this.genre = genre;\n   this.pageCount = pageCount;\n   this.publisherID = publisherID;\n   this.ISBN = ISBN;\n   this.checkoutDate = checkoutDate;\n   this.checkoutMember = checkoutMember;\n   this.dueReturnDate = dueReturnDate;\n   this.availability = availability;\n \n};\n \nBook.prototype = {\n \n  getTitle: function () {\n     return this.title;\n  },\n \n  getAuthor: function () {\n     return this.author;\n  },\n \n  getISBN: function (){\n     return this.ISBN;\n  },\n \n  // For brevity, other getters are not shown\n  updateCheckoutStatus: function( bookID, newStatus, checkoutDate, checkoutMember, newReturnDate ){\n \n     this.id = bookID;\n     this.availability = newStatus;\n     this.checkoutDate = checkoutDate;\n     this.checkoutMember = checkoutMember;\n     this.dueReturnDate = newReturnDate;\n \n  },\n \n  extendCheckoutPeriod: function( bookID, newReturnDate ){\n \n      this.id = bookID;\n      this.dueReturnDate = newReturnDate;\n \n  },\n \n  isPastDue: function(bookID){\n \n     var currentDate = new Date();\n     return currentDate.getTime() &gt; Date.parse( this.dueReturnDate );\n \n   }\n};\n</code></pre>\n<p>这么看上去并没有什么问题，但是当图书增多时，对于系统的压力会逐渐增多。为此我们将书的属性分为两种：本身固有的和外在特性。本身固有的属性包括 title、author 等，外在特性包括 checkoutMember、dueReturnDate 等。这样一来，我们简化书的构造函数为：</p>\n<pre><code class=\"lang-\">var Book = function ( title, author, genre, pageCount, publisherID, ISBN ) {\n \n    this.title = title;\n    this.author = author;\n    this.genre = genre;\n    this.pageCount = pageCount;\n    this.publisherID = publisherID;\n    this.ISBN = ISBN;\n\n};\n</code></pre>\n<p>我们将外在特性删去，check-outs 等信息将会被移动到一个新的类中，一个新的工厂函数也将出现：</p>\n<pre><code class=\"lang-\">// Book Factory singleton\nvar BookFactory = (function () {\n  var existingBooks = {}, existingBook;\n \n  return {\n    createBook: function ( title, author, genre, pageCount, publisherID, ISBN ) {\n \n      // Find out if a particular book meta-data combination has been created before\n      // !! or (bang bang) forces a boolean to be returned\n      existingBook = existingBooks[ISBN];\n      if ( !!existingBook ) {\n        return existingBook;\n      } else {\n \n        // if not, let&apos;s create a new instance of the book and store it\n        var book = new Book( title, author, genre, pageCount, publisherID, ISBN );\n        existingBooks[ISBN] = book;\n        return book;\n \n      }\n    }\n  };\n \n})();\n</code></pre>\n<p>在这个工厂函数中，我们将会检查当前需要创建的书籍是否已经存在，如果存在直接返回书实例；否则进行调用 Book 构造函数进行创建。这保证了所有的书都是唯一的，而不存在重复。</p>\n<p>对于书的外在特性，我们创建 BookRecordManager 来维护每一本书的状态，并通过 bookId 与每一个本书进行关系创建：</p>\n<pre><code class=\"lang-\">var BookRecordManager = (function () {\n \n  var bookRecordDatabase = {};\n \n  return {\n    // add a new book into the library system\n    addBookRecord: function ( id, title, author, genre, pageCount, publisherID, ISBN, checkoutDate, checkoutMember, dueReturnDate, availability ) {\n \n      var book = BookFactory.createBook( title, author, genre, pageCount, publisherID, ISBN );\n \n      bookRecordDatabase[id] = {\n        checkoutMember: checkoutMember,\n        checkoutDate: checkoutDate,\n        dueReturnDate: dueReturnDate,\n        availability: availability,\n        book: book\n      };\n    },\n    updateCheckoutStatus: function ( bookID, newStatus, checkoutDate, checkoutMember, newReturnDate ) {\n \n      var record = bookRecordDatabase[bookID];\n      record.availability = newStatus;\n      record.checkoutDate = checkoutDate;\n      record.checkoutMember = checkoutMember;\n      record.dueReturnDate = newReturnDate;\n    },\n \n    extendCheckoutPeriod: function ( bookID, newReturnDate ) {\n      bookRecordDatabase[bookID].dueReturnDate = newReturnDate;\n    },\n \n    isPastDue: function ( bookID ) {\n      var currentDate = new Date();\n      return currentDate.getTime() &gt; Date.parse( bookRecordDatabase[bookID].dueReturnDate );\n    }\n  };\n \n})();\n</code></pre>\n<p>其实变动也比较明显，书目所有的外在特性都被从书本身的特性中抽离，现在被移动到 BookManager 的 BookDatabase 当中。对于书借入/借出的操作也移动到了 BookRecordManager 当中，因为这些方法需要直接操作书的外在特性。如此一来，比一本书拥有多项属性的大 object 模式更加高效，也更利于维护。</p>\n<p>关于性能可以具体来看：如果有 30 本同样一本书的 copy，现有的模式下只存储了一个实例；同时对于书状态转移的函数，我们维护在 BookManager 当中，而不再出现在对象（原型）上，如果这些函数出现在每一个书实例当中，将会是更大的开销。</p>\n<p>享元模式在前端还有更多的应用，比如事件代理就是一个很典型的体现：</p>\n<pre><code class=\"lang-\">&lt;div id=&quot;container&quot;&gt;\n   &lt;div class=&quot;toggle&quot; href=&quot;#&quot;&gt;More Info (Address)\n       &lt;span class=&quot;info&quot;&gt;\n           This is more information\n       &lt;/span&gt;&lt;/div&gt;\n   &lt;div class=&quot;toggle&quot; href=&quot;#&quot;&gt;Even More Info (Map)\n       &lt;span class=&quot;info&quot;&gt;\n          &lt;iframe src=&quot;http://www.map-generator.net/extmap.php?name=London&amp;amp;address=london%2C%20england&amp;amp;width=500...gt;&quot;&lt;/iframe&gt;\n       &lt;/span&gt;\n   &lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<p>我们集中将事件处理放到父容器上：</p>\n<pre><code class=\"lang-\">var stateManager = {\n \n  fly: function () {\n \n    var self = this;\n \n    $( &quot;#container&quot; )\n          .unbind()\n          .on( &quot;click&quot;, &quot;div.toggle&quot;, function ( e ) {\n            self.handleClick( e.target );\n          });\n  },\n \n  handleClick: function ( elem ) {\n    $( elem ).find( &quot;span&quot; ).toggle( &quot;slow&quot; );\n  }\n};\n</code></pre>\n<p>如此类似，前面课程提到过的 React 合成事件的池化机制，都体现了异曲同工之妙。</p>\n<h3><a id=\"_763\"></a>代理模式在前端中的应用</h3>\n<p>代理模式大家应该都不陌生，ES next 提供的 Proxy 让我们实现代理模式变得更加容易。关于 Proxy 的使用这些基础内容这里不过多赘述，直接来看一些代理模式的应用场景。</p>\n<p>我们对函数进行代理，对函数的返回结果进行缓存。在函数执行时，优先使用缓存值，否则返回执行计算值：</p>\n<pre><code class=\"lang-\">const getCacheProxy = (fn, cache = new Map()) =&gt; \n  new Proxy(fn, {\n    apply(target, context, args) {\n      const argsString = args.join(&apos; &apos;)\n      if (cache.has(argsString)) {\n        return cache.get(argsString)\n      }\n      const result = fn(...args)\n      cache.set(argsString, result)\n\n      return result\n    }\n  })\n</code></pre>\n<p>另外一个类似的实现：</p>\n<pre><code class=\"lang-\">const createThrottleProxy = (fn, timer) =&gt; {\n  let last = Date.now() - timer\n  return new Proxy(fn, {\n    apply(target, context, args) {\n      if (Date.now() - last &gt;= rate) {\n        fn(args)\n        last = Date.now()\n      }\n    }\n  })\n};\n</code></pre>\n<p>这些内容在前面的课程都有渗透，相信读者已经不难理解了。我们再来看 jQuery 当中的例子：</p>\n<pre><code class=\"lang-\">$( &quot;button&quot; ).on( &quot;click&quot;, function () {\n  // Within this function, &quot;this&quot; refers to the element that was clicked\n  $( this ).addClass( &quot;active&quot; );\n});\n</code></pre>\n<p>通过 <code>$( this )</code> 可以获取到当前触发事件的元素，但是：</p>\n<pre><code class=\"lang-\">$( &quot;button&quot; ).on( &quot;click&quot;, function () {\n  setTimeout(function () {\n    // &quot;this&quot; doesn&apos;t refer to our element!\n    $( this ).addClass( &quot;active&quot; );\n  });\n});\n</code></pre>\n<p>但是这里的 <code>$( this )</code> 不再是预期之中的结果。为此，jQuery 提供了 .proxy() 方法，这是典型的代理模式体现。</p>\n<pre><code class=\"lang-\">$( &quot;button&quot; ).on( &quot;click&quot;, function () {\n \n    setTimeout( $.proxy( function () {\n        // &quot;this&quot; now refers to our element as we wanted\n        $( this ).addClass( &quot;active&quot; );\n    }, this), 500);\n \n    // the last &quot;this&quot; we&apos;re passing tells $.proxy() that our DOM element\n    // is the value we want &quot;this&quot; to refer to.\n});\n</code></pre>\n<p>来看一下 proxy 的实现：</p>\n<pre><code class=\"lang-\">// Bind a function to a context, optionally partially applying any\n// arguments.\nproxy: function( fn, context ) {\n  if ( typeof context === &quot;string&quot; ) {\n    var tmp = fn[ context ];\n    context = fn;\n    fn = tmp;\n  }\n \n  // Quick check to determine if target is callable, in the spec\n  // this throws a TypeError, but we will just return undefined.\n  if ( !jQuery.isFunction( fn ) ) {\n    return undefined;\n  }\n \n  // Simulated bind\n  var args = slice.call( arguments, 2 ),\n    proxy = function() {\n      return fn.apply( context, args.concat( slice.call( arguments ) ) );\n    };\n \n  // Set the guid of unique handler to the same of original handler, so it can be removed\n  proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;\n \n  return proxy;\n}\n</code></pre>\n<h3><a id=\"_867\"></a>装饰者模式在前端中的应用</h3>\n<p>装饰者模式如同代理模式一样，如今 JavaScript 也已经原生能够很好地进行支持了。简单来说就是在不改变原对象的基础上，对其对象进行包装和拓展，使原对象能够应对更加复杂的需求。这就有一点像高阶函数，因此在前端开发中非常多见：</p>\n<pre><code class=\"lang-\">import React, { Component } from &apos;react&apos;\nimport {connect} from &apos;react-redux&apos;\nclass App extends Component {\n render() {\n  //...\n }\n}\nexport default connect(mapStateToProps,actionCreators)(App);\n</code></pre>\n<p>或者在 Ant design 中：</p>\n<pre><code class=\"lang-\">class CustomizedForm extends React.Component {}\n\nCustomizedForm = Form.create({})(CustomizedForm)\n</code></pre>\n<p>当然 TypeScript 函数修饰符 @ 也是类似的。</p>\n<p>借助装饰者模式，很容易衍生出 AOP 面向切面编程的概念：</p>\n<pre><code class=\"lang-\">Function.prototype.before = function(fn) {\n  const self = this\n  return function() {\n    fn.apply(new(self), arguments)\n    return self.apply(new(self), arguments)\n  }\n}\n\nFunction.prototype.after = function(fn) {\n  const self = this\n  return function() {\n    self.apply(new(self), arguments)\n    return fn.apply(new(self), arguments)\n  }\n}\n</code></pre>\n<p>其实面向切面编程和装饰者模式思想是完全一致的。典型场景就是对表单的验证，我们将把表单输入逻辑校验的 validata 函数融入到 before 逻辑当中：</p>\n<pre><code class=\"lang-\">Function.prototype.before = function( beforefn ) {\n  const self = this\n  return function(){\n    if ( beforefn.apply( this, arguments ) === false ) return \n    return self.apply( this, arguments )\n  }\n}\n\n\nconst validate = function(){\n  // 表单验证逻辑\n}\n\nconst formSubmit = function() {\n  // 表达提交逻辑\n  ajax( &apos;http:// xxx.com/login&apos;, param )\n}\n\nsubmitBtn.onclick = function() {\n  formSubmit.before( validate )\n}\n</code></pre>\n<h3><a id=\"_938\"></a>职责链模式在前端中的应用</h3>\n<p>顾名思义，职责链模式就是建立一个流程链条，一个请求从一端进入，并从一个职责根据需求，流转进入另一个对象，直到找到合适的处理程序。</p>\n<p>听上去似乎有点“中间件”的意思，我们来看一个简单的应用：账户付款时绑定一个基本帐户类，它连接了多种付款方式：paypal 支付、比特币支付，并根据不同付款方式的金额额度和付款额，选择第一个合适的账户进行支付逻辑：</p>\n<pre><code class=\"lang-\">class Account {\n    next(account) {\n        this.successor = account\n    }\n    \n    pay(amount) {\n        if (this.canPay(amount)) {\n            console.log(`Paid ${amount} using ${this.name}`)\n        } else if (this.successor) {\n            console.log(`Cannot pay using ${this.name}. Proceeding...`)\n            this.successor.pay(amount)\n        } else {\n            console.log(&apos;None of the accounts have enough balance&apos;)\n        }\n    }\n    \n    canPay(amount) {\n        return this.balance &gt;= amount\n    }\n}\n\nclass Bank extends Account {\n    constructor(balance) {\n        super()\n        this.name = &apos;bank&apos;\n        this.balance = balance\n    }\n}\n\nclass Paypal extends Account {\n    constructor(balance) {\n        super()        \n        this.name = &apos;Paypal&apos;\n        this.balance = balance\n    }\n}\n\nclass Bitcoin extends Account {\n    constructor(balance) {\n        super()        \n        this.name = &apos;bitcoin&apos;\n        this.balance = balance\n    }\n}\n</code></pre>\n<p>在使用时，我们先给三个账户充钱：</p>\n<pre><code class=\"lang-\">const bank = new Bank(100)          // Bank with balance 100\nconst paypal = new Paypal(200)      // Paypal with balance 200\nconst bitcoin = new Bitcoin(300)    // Bitcoin with balance 300\n</code></pre>\n<p>并按顺序优先调用银行付款、PayPal 付款、比特币付款：</p>\n<pre><code class=\"lang-\">bank.next(paypal)\npaypal.next(bitcoin)\n</code></pre>\n<p>最终付款行为：</p>\n<pre><code class=\"lang-\">bank.pay(250)\n</code></pre>\n<p>输出：</p>\n<pre><code class=\"lang-\">Cannot pay using bank. Proceeding...\nCannot pay using Paypal. Proceeding...\nPaid 250 using bitcoin\n</code></pre>\n<h3><a id=\"_1020\"></a>策略模式在前端中的应用</h3>\n<p>策略模式能够让开发者基于具体场景，来切换不同的算法或者策略。本身这个模式比较简单，但是有一个比较有意思的应用：V8 引擎在实现排序时，根据排序长度的不同，动态合理选用排序策略，达到尽可能的性能优化，例如代码：</p>\n<pre><code class=\"lang-\">const bubbleSort = target =&gt; {\n    console.log(&apos;Sorting with bubble sort&apos;)\n    // ...\n    // ...\n    return target\n}\n\nconst quickSort = target =&gt; {\n    console.log(&apos;Sorting with quick sort&apos;)\n    // ...\n    // ...\n    return target\n}\n\nconst sorter = target =&gt; {\n    if(target.length &gt; 5){\n        return quickSort(target)\n    } else {\n        return bubbleSort(target)\n    }\n}\n</code></pre>\n<p>在目标数组长度大于 5 时使用快排，否则使用冒泡排序。感兴趣的读者可以自行了解 V8 的实现，看看这个分界策落的阈值（这里的例子中使用了 5）是多少，以及思考为什么选取该阈值。</p>\n<p>上述代码的使用：</p>\n<pre><code class=\"lang-\">const long = [1, 5, 4, 3, 2, 8]\nconst short = [1, 5, 4]\n\nconst result1 = sorter(long)\nconst result2 = sorter(short)\n</code></pre>\n<p>输出：</p>\n<pre><code class=\"lang-\">Sorting with quick sort\nSorting with bubble sort\n</code></pre>\n<p>由此看出：第一个部分是策略类，策略类封装了具体的算法，并负责具体的计算过程；第二个部分是环境类，这个环境类接受客户的请求，随后把请求委托给某一个策略类。另一个应用策略模式的例子是表单校验：</p>\n<pre><code class=\"lang-\">\nclass Validator {\n  constructor() {\n    this.cache = []\n  }\n\n  add(dom, rule, errorMsg) {\n    let array = rule.split(&apos;:&apos;)\n\n    this.cache.push(function(){\n      var strategy = array.shift()\n      array.unshift(dom.value)\n      array.push(errorMsg)\n\n      return strategies[strategy].apply(dom, array)\n    })\n  }\n\n  start() {\n    for (let i = 0, validatorFunc; validatorFunc = this.cache[i++]; i &lt; this.cache.length) {\n      const msg = validatorFunc()\n      if (msg) return msg\n    }\n  }\n}\n\nconst strategies = {\n    isNonEmpty: function(value, errorMsg) {\n        if (value=&apos;&apos;) {\n            return errorMsg\n        }\n    },\n    minLength: function(value,length, errorMsg) {\n        if (value.length&lt;length) {\n            return errorMsg\n        }\n    },\n    isMobile: function(value, errorMsg) {\n        if (!/^1[3|5|8][0-9]$/.test(value)) {\n            return errorMsg\n        }\n    }\n}\n\nconst validataFunc = function(){\n    let validator = new Validator()\n    validator.add(registerForm.userName, &apos;isNonEmpty&apos;, &apos;用户名不能为空’)\n    validator.add(registerForm.password, &apos;inLength:6&apos; ,&apos;密码长度不能少于6位&apos;)\n    validator.add(registerForm.phoneNumber, &apos;isMobile&apos;, &apos;手机号码格式不正确’)\n\n    const  errorMsg = validator.start()\n    return errorMsgs\n}\n\nconst registerForm = document.getElementById(&quot;registerForm&quot;)\nregisterForm.onsubmit = function() {\n    varerrorMsg = validataFunc()\n    if (errorMsg) {\n        alert(errorMsg)\n        return false \n    }\n}\n</code></pre>\n<p>其中，validataFunc 是我们的环境类，而 Validator 和 strategies 构成我们的策略。</p>\n<h3><a id=\"_1136\"></a>总结</h3>\n<p>这节课程讲解了：工厂模式、单例模式、建造者模式、外观模式、适配器模式、享元模式、代理模式、装饰者模式、职责链模式、策略模式等在前端中的实现和应用。同时，包括原型模式、观察者模式、迭代器模式在内，这些模式都非常贴近 JavaScript 原有语法，因此不再过多赘述。</p>\n<p>实际上，设计模式很简单，我们应该做到的是需要应用时“胸中有数”，能够想到设计模式实现，而不需要一味死记硬背。</p>\n","createdAt":"2019-04-21T04:45:41.642Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":38,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FoThASW9dVEPMEo9nP-zaOfbKyLZ"},{"_id":"5cbbf58ebbbba80861a35c70","communication_start_time":null,"type":1,"audioPath":"","abstract":"","content":"数据结构是计算机中组织和存储数据的特定方式，它的目的是方便且高效地对数据进行访问和修改。数据结构表述了数据之间的关系，以及操作数据的一系列方法。数据又是程序的基本单元，因此无论是哪种语言、哪种领域，都离不开数据结构；另一方面，数据结构是算法的基础，其本身也包含了算法的部分内容。也就是说，想要掌握算法，先有一个巩固的数据结构基础是必要条件。\n\n前端领域也到处体现着数据结构的应用，尤其是随着需求的复杂度上升，前端工程师越来越离不开数据结构。React、Vue 这些设计精巧的框架，在线文档编辑系统、大型管理系统，甚至一个简单的检索需求，都离不开数据结构的支持。是否能够掌握这个难点内容，将是进阶的重要考量。我们应该如何学习数据结构呢？\n\n下图是本讲内容的提纲。\n\n<img src=\"https://images.gitbook.cn/87934440-d04f-11e9-bec2-e1649ddaac83\" width = \"70%\" />\n\n### 数据结构和学习方法概览\n\n我通常将数据结构分为八大类：\n\n- 数组：Array\n- 堆栈：Stack\n- 队列：Queue\n- 链表：Linked Lists\n- 树：Trees\n- 图：Graphs\n- 字典树：Trie\n- 散列表（哈希表）：Hash Tables\n\n这么多的类型，这节课该如何介绍呢？我认为，按部就班地只是实现各种数据结构的意义不大，这些内容读者都可以从算法书籍中找到。更重要地是应用，也只有在应用中，才能真正地记住并掌握特定的数据结构，才能在下次有类似场景时，能够想起来相关的数据结构实现。因此，这节课程我将从前端出发，从前端类库或者典型场景入手，结合数据结构来剖析其实现和应用。这需要读者首先对每种数据结构有一个大概认知，我们可以先来细化感知一下：\n\n- 栈和队列是类似数组的结构，非常多的初级题目要求用数组实现栈和队列，他们在插入和删除的方式上和数组有所差异，但是实现还是非常简单的；\n- 链表、树和图这种数据结构的特点是，其节点需要引用到其他节点，因此在增删时，需要注意对相关前驱和后继节点的影响；\n- 可以从堆栈和队列出发，构建出链表；\n- 树和图最为复杂，因为他们本质上是扩展了链表的概念；\n- 散列表的关键是理解散列函数，明白依赖散列函数实现保存和定位数据的过程；\n- 直观上认为，链表适合记录和存储数据；哈希表和字典树在检索数据以及搜索方面有更大的应用场景。\n\n以上这些“直观感性”的认知并不是“恒等式”， **我们将在下面的学习中去印证这些“认知”，你将会看到熟悉的 React、Vue 框架的部分实现，将会看到典型的算法场景，也请读者做好基础知识的储备。**\n\n### 堆栈和队列\n\n栈和队列是一种操作受限的线性结构，它们非常简单，虽然 JavaScript 并没有原生内置这样的数据结构，但是我们可以轻松地模拟出来。\n\n栈的实现，后进先出 LIFO（Last in、First out）：\n\n```\nclass Stack {\n  constructor(...args) {\n    this.stack = [...args]\n  }\n\n  // Modifiers\n  push(...items) {\n    return this.stack.push(... items)\n  }\n\n  pop() {\n    return this.stack.pop()\n  }\n\n  // Element access\n  peek() {\n    return this.isEmpty() \n        ? undefined\n        : this.stack[this.size() - 1]\n  }\n\n  // Capacity\n  isEmpty() {\n    return this.size() == 0\n  }\n\n  size() {\n    return this.stack.length\n  }\n}\n```\n\n队列的实现，先进先出 FIFO（First in、First out）：\n\n```\nclass Queue {\n  constructor(...args) {\n    this.queue = [...args]\n  }\n\n  // Modifiers\n  enqueue(...items) {\n    return this.queue.push(... items)\n  }\n\n  dequeue() {\n    return this.queue.shift()\n  }\n\n  // Element access\n  front() { \n    return this.isEmpty()\n        ? undefined\n        : this.queue[0]\n  }\n\n  back() {\n    return this.isEmpty()\n        ? undefined\n        : this.queue[this.size() - 1]\n  }\n\n  // Capacity\n  isEmpty() {\n    return this.size() == 0\n  }\n\n  size() {\n    return this.queue.length\n  }\n}\n```\n\n关于栈和队列的实际应用比比皆是：\n\n- 浏览器的历史记录，因为回退总是回退“上一个”最近的页面，它需要遵循栈的原则；\n- 类似浏览器的历史记录，任何 undo/redo 都是一个栈的实现；\n- 在代码中，广泛应用的递归产生的调用栈，同样也是栈思想的体现，想想我们常说的“栈溢出”就是这个道理；\n- 同上，浏览器在抛出异常时，常规都会抛出调用栈信息；\n- 在计算机科学领域应用广泛，如进制转换、括号匹配、栈混洗、表达式求值等；\n- 队列的应用更为直观，我们常说的宏任务 / 微任务都是队列，不管是什么类型的任务，都是先进先执行；\n- 后端也应用广泛，如消息队列、RabbitMQ、ActiveMQ 等，能起到延迟缓冲的功效。\n\n我们看到不管是栈还是队列，都是用数组来模拟的。数组是最基本的数据结构，但是它的价值是惊人的，这里稍微提一下 React hooks 的本质就是数组。给大家推荐文章：[React hooks: not magic, just arrays](https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e )\n\n另外，与性能后话相关，HTTP 1.1 有一个队头阻塞问题，这个原因就在于队列这样的数据结构：我们先看 HTTP 1.0，对于同一个 tcp 连接，HTTP 1.0 是将所有请求都放入队列当中，这么一来，在客户端，“先进先出”，只有前一个请求得到了响应，下一个请求才会发出。在 HTTP 1.1 中，这样的情况得到了改观，每一个链接都默认是长链接，因此对于同一个 tcp 链接，不必等到前一个响应回来。但是这只是解决了客户端的队头阻塞问题，事实上，HTTP 1.1 规定：服务端的响应返回顺序需要遵循其接收到相应的顺序，这样的问题是：如果第一个请求处理需要较长时间，响应较慢，也都会“拖累”其他后续请求的响应，这仍然是一种队头阻塞。\n\nHTTP 2 采用了二进制分帧和多路复用等方法， 同域名下的通信都是在同一个连接上完成，并且这种链接是双向的，在这个链接上可以并行请求和响应而互不干扰。\n\n这里延伸的有点多了，主要是读者需要明白队列和栈这种数据结构的应用，以及利弊。\n\n### 链表（单向链表和双向链表）\n\n堆栈和队列都可以用数组实现，链表同样和数组一样，都实现了**按照一定的顺序**存储元素，不同的地方在于链表不能像数组一样通过下标访问，而是每一个元素指向下一个元素。我们不再过多介绍链表方面的基础知识，对于链表仍不理解的读者可以先自行学习。\n\n直观上我们就可以得出结论：链表不需要一段连续的存储空间，“指向下一个元素”的方式能够更大限度地利用内存。\n\n根据上面结论可以继续总结，链表的优点在于：\n\n- 链表的插入和删除操作的时间复杂度是常数级的，我们只需要改变相关节点的指针指向即可；\n- 链表可以像数组一样顺序访问，查找元素的时间复杂度是线性的。\n\n我们来看看链表的应用场景：\n\n- React 的核心算法 Fiber 的实现就是链表\n\n关于此我们可以稍作展开。React 最早开始使用大名鼎鼎的 Stack reconciler 调度算法，关于此在之前的课程中已经有所涉及。Stack reconciler 调度算法最大的问题在于：**它是像函数调用栈一样，递归地、自顶向下进行 diff 和 render 相关操作的**，在 Stack reconciler 执行的过程当中，该调度算法始终会占据浏览器主线程。也就是说在此期间，用户的交互所触发的布局行为、动画执行任务都不会被立即响应，从而影响用户体验。\n\n因此 React Fiber 将渲染和更新过程进行了拆解，简单来说，就是每次检查虚拟 DOM 的一小部分，在检查间隙会检查“是否还有时间继续执行下一个虚拟 DOM 树上某个分支任务”，同时观察是否有更优先的任务需要响应，如果“没有时间执行下一个虚拟 DOM 树上某个分支任务”，且有更高优先级，React 就会让出主线程，直到主线程“不忙”的时候继续执行任务。\n\nReact Fiber 因此也很简单，它是将 Stack reconciler 过程分成块，一次执行一块，执行完一块需要将结果保存起来，根据是否还有空闲的响应时间（requestIdleCallback）来决定下一步策略。当所有的块都已经执行完，就进入提交阶段，这个阶段需要更新 DOM，它是一口气完成的。\n\n以上是比较主观地介绍，我们来看更具体的实现。\n\n为了达到“随意中断调用栈并手动操作调用栈”，React Fiber 就是专门用于 React 组件堆栈调用的重新实现，也就是说一个 Fiber 就是一个虚拟堆栈帧，一个 Fiber 的结构类似：\n\n```\nfunction FiberNode(\n  tag: WorkTag,\n  pendingProps: mixed,\n  key: null | string,\n  mode: TypeOfMode,\n) {\n  // Instance\n  // ...\n  this.tag = tag;                       \n  \n  // Fiber\n  this.return = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n\n  this.ref = null;\n\n  this.pendingProps = pendingProps;\n  this.memoizedProps = null;\n  this.updateQueue = null;\n  this.memoizedState = null;\n  this.dependencies = null;\n\n  // Effects\n  // ...\n  this.alternate = null; \n}\n```\n\n这么看 Fiber 就是一个对象，通过 parent、children、sibling 维护一个树形关系，同时 parent、children、sibling 也都是一个 Fiber 结构，FiberNode.alternate 这个属性来存储上一次渲染过的结果，事实上整个 Fiber 模式就是一个链表。React 也借此，从依赖于内置堆栈的同步递归模型，变为具有链表和指针的异步模型了。\n\n具体的渲染过程：\n\n```\nfunction renderNode(node) {\n   // 判断是否需要渲染该节点，如果 props 发生变化，则调用 render\n   if (node.memoizedProps !== node.pendingProps) {\n      render(node)\n   }\n\n   // 是否有子节点，进行子节点渲染\n   if (node.child !== null) {\n      return node.child\n   // 是否有兄弟节点，进行兄弟点渲染\n   } else if (node.sibling !== null){\n      return node.sibling\n   // 没有子节点和兄弟节点\n   } else if (node.return !== null){\n      return node.return\n   } else {\n      return null\n   }\n}\n\nfunction workloop(root) {\n   nextNode = root\n   while (nextNode !== null && (no other high priority task)) {\n      nextNode = renderNode(nextNode)\n   }\n}\n```\n\n注意在 workloop 当中，while 条件 nextNode !== null && (no other high priority task)，这是描述 Fiber 工作原理的关键伪代码。\n\n当然这里是为了说明链表的数据结构，伪代码较为简略，也没有深入：\n\n- requestAnimationFrame(callback)\n- requestIdleCallback(callback)\n\n的实现和应用。React Fiber 的介绍我们先到此为止，重点是体会链表数据结构的思想。\n\n### 链表实现\n\n实现链表，我们需要先对链表进行分类，常见的有：\n\n- 单链表：单链表是维护一系列节点的数据结构，其特点是：每个节点包含了数据，同时包含指向链表中下一个节点的指针。\n- 双向链表：不同于单链表，双向链表特点：每个节点分除了包含其数据以外，还包含了分别指向其前驱和后继节点的指针。\n\n由于篇幅有原因，我们挑选更加复杂的双向链表进行实现，实现思路如下。\n\n首先，根据双向链表的特点，我们实现一个节点构造函数（节点类）：\n\n```\nclass Node {\n    constructor(data) {\n        // data 为当前节点所储存的数据\n        this.data = data\n        // next 指向下一个节点\n        this.next = null\n        // prev 指向前一个节点\n        this.prev = null\n    }\n}\n```\n\n有了节点类，我们来初步实现双向链表类：\n\n```\nclass DoublyLinkedList {\n    constructor() {\n    \t// 双向链表开头\n    \tthis.head = null\n    \t// 双向链表结尾\n      this.tail = null\n    }\n\n    // ...\n}\n```\n\n接下来，需要实现双向链表原型上的一些方法，这些方法包括\n\n- add：在链表尾部添加一个新的节点\n- addAt：在链表指定位置添加一个新的节点\n- remove：删除链表指定数据项节点\n- removeAt：删除链表指定位置节点\n- reverse：翻转链表\n- swap：交换两个节点数据\n- isEmpty：查询链表是否为空\n- length：查询链表长度\n- traverse：遍历链表\n- find：查找某个节点的索引\n\nadd 方法：\n\n```\nadd(item) {\n  // 实例化一个节点\n  let node = new Node(item)\n  \n  // 如果当前链表还没有头\n  if(!this.head) {\n    this.head = node\n    this.tail = node\n  } \n  // 如果当前链表已经有了头，只需要在尾部加上该节点\n  else {\n    node.prev = this.tail\n    this.tail.next = node\n    this.tail = node\n  }\n}\n```\n\naddAt 方法：\n\n```\naddAt(index, item) {\n   let current = this.head\n   // 维护查找时当前节点的索引\n   let counter = 1\n   let node = new Node(item)\n   \n   // 如果在头部插入\n   if (index === 0) {\n     this.head.prev = node\n     node.next = this.head\n     this.head = node\n   } \n   // 非头部插入，需要从头开始，找寻插入位置\n   else {\n     while(current) {\n      current = current.next\n      if( counter === index) {\n        node.prev = current.prev\n        current.prev.next = node\n        node.next = current\n        current.prev = node\n      }\n      counter++\n    }\n  }\n}\n```\n\nremove 方法：\n\n```\nremove(item) {\n  let current = this.head\n  \n  while (current) {\n  \t // 找到了目标节点\n    if (current.data === item ) {\n      // 目标链表只有当前目标项，即目标节点即是链表头又是链表尾\n      if (current == this.head && current == this.tail) {\n        this.head = null\n        this.tail = null\n      } \n      // 目标节点为链表头\n      else if (current == this.head ) {\n        this.head = this.head.next\n        this.head.prev = null\n      } \n      // 目标节点为链表尾部\n      else if (current == this.tail ) {\n        this.tail = this.tail.prev;\n        this.tail.next = null;\n      } \n      // 目标节点在链表收尾之间，中部\n      else {\n        current.prev.next = current.next;\n        current.next.prev = current.prev;\n      }\n   }\n   current = current.next\n  }\n}\n```\n\nremoveAt 方法：\n\n```\nremoveAt(index) {\n  // 都是从“头”开始遍历\n  let current = this.head\n  let counter = 1\n  \n  // 删除链表头部\n  if (index === 0 ) {\n   this.head = this.head.next\n   this.head.prev = null\n  } \n  else {\n   while(current) {\n    current = current.next\n    // 如果目标节点在链表尾\n    if (current == this.tail) {\n     this.tail = this.tail.prev\n     this.tail.next = null\n    } \n    else if (counter === index) {\n     current.prev.next = current.next\n     current.next.prev = current.prev\n     break\n    }\n    counter++\n   }\n  }\n}\n```\n\nreverse 方法：\n\n```\nreverse() {\n  let current = this.head\n  let prev = null\n  \n  while (current) {\n   let next = current.next\n   \n   // 前后倒置\n   current.next = prev\n   current.prev = next\n   \n   prev = current\n   current = next\n  }\n  \n  this.tail = this.head\n  this.head = prev\n}\n```\n\nswap 方法，交换两个节点数据值：\n\n```\nswap(index1, index2) {\n  // 使 index1 始终小于 index2，方便后面查找交换\n  if (index1 > index2) {\n    return this.swap(index2, index1)\n  }\n\n  let current = this.head\n  let counter = 0\n  let firstNode\n  \n  while(current !== null) {\n    // 找到第一个节点，先存起来\n    if (counter === index1 ){\n        firstNode = current\n    } \n  \n    // 找到第二个节点，进行数据交换\n    else if (counter === index2) {\n      // ES 提供了更简洁交换数据的方法，这里我们用传统方式实现，更为直观\n      let temp = current.data\n      current.data = firstNode.data\n      firstNode.data = temp\n    }\n    \n    current = current.next\n    counter++\n  }\n  return true\n}\n```\n\nisEmpty 方法：\n\n```\nisEmpty() {\n  return this.length() < 1\n}\n```\n\n这里通过 DoublyLinkedList 类 length 的方法实现。马上看一下 length 方法：\n\n```\nlength() {\n  let current = this.head\n  let counter = 0\n  while(current !== null) {\n    counter++\n    current = current.next\n  }\n  return counter\n}\n```\n\nlength 方法通过遍历链表，返回链表的长度。\n\ntraverse 方法：\n\n```\ntraverse(fn) {\n  let current = this.head\n  while(current !== null) {\n    fn(current)\n    current = current.next\n  }\n  return true\n}\n```\n\n有了上面 length 方法的遍历实现，traverse 也就不难理解了，它接受一个遍历执行函数，在 while 循环中进行调用。\n\n最后一个 search 方法：\n\n```\nsearch(item) {\n  let current = this.head\n  let counter = 0\n  \n  while( current ) {\n    if( current.data == item ) {\n      return counter\n    }\n    current = current.next\n    counter++\n  }\n  return false\n}\n```\n\n到此，我们就实现了所有 DoublyLinkedList 类双向链表的方法。仔细分析整个实现过程，可以发现：双向链表的实现并不复杂，在手写过程当中，需要开发者做到心中有表，考虑到当前节点的 next 和 prev 取值，逻辑上还是很简单的。\n\n掌握了这些内容，在回想一下链表的应用，回想 React Fiber 的设计和实现，也许一切都变的不再神秘。\n\n### 树\n\n前端开发者应该对树这个数据结构丝毫不陌生，不同于之前介绍的所有数据结构，树是非线性的。因为树决定了其存储的数据直接有明确的层级关系，因此对于维护具有层级特性的数据，树是一个天然良好的选择。\n\n在前面总领中，我们看到树有很多种分类，但是他们都具有以下特性：\n\n- 除了根节点以外，所有的节点都有一个父节点\n- 每一个节点都**可以有**若干子节点，如果没有子节点，那么称此节点为叶子节点\n- 一个节点所拥有的叶子节点的个数，称之为该节点的度，因此叶子节点的度为 0\n- 所有节点中，最大的度为整棵树的度\n- 树的最大层次称为树的深度\n\n从应用上来看，我们前端开发离不开的 DOM 就是一个树状结构；同理，不管是 React 还是 Vue 的虚拟 DOM 也都是树。\n\n我们从最基本的二叉树入手，来慢慢深入。\n\n#### 二叉搜索树的实现和遍历\n\n说二叉树最为基本，因为他的结构最简单，每个节点至多包含两个子节点。二叉树又非常有用：因为根据二叉树，我们可以延伸出二叉搜索树（BST）、平衡二叉搜索树（AVL）、红黑树（R/B Tree）等。\n\n二叉搜索树有以下特性：\n\n- 左子树上所有结点的值均小于或等于它的根结点的值\n- 右子树上所有结点的值均大于或等于它的根结点的值\n- 左、右子树也分别为二叉搜索树\n\n根据其特性，我们实现二叉搜索树还是应该先构造一个节点类：\n\n```\nclass Node { \n  constructor(data) { \n    this.left = null\n    this.right = null\n    this.value = data\n  } \n} \n```\n\n接着按照惯例，我们实现二叉搜索树的以下方法：\n\n- insertNode：根据一个父节点，插入一个子节点\n- insert：插入一个新节点\n- removeNode：根据一个父节点，移除一个子节点\n- remove：移除一个节点\n- findMinNode：获取子节点的最小值\n- searchNode：根据一个父节点，查找子节点\n- search：查找节点\n- preOrder：前序遍历\n- InOrder：中序遍历\n- PostOrder：后续遍历\n\n```\ninsertNode(root, newNode) {\n  if (newNode.value < root.value) {\n    (!root.left) ? root.left = newNode : this.insertNode(root.left, newNode)\n  } else {\n    (!root.right) ? root.right = newNode : this.insertNode(root.right, newNode)\n  }\n}\n  \ninsert(value) {\n    let newNode = new Node(value)\n    if (!this.root) {\n      this.root = newNode\n    } else {\n      this.insertNode(this.root, newNode)\n    }\n}\n```\n\n理解这两个方法是理解二叉搜索树的关键，下面的其他方法也就“不在话下”。我们看，insertNode 方法先判断目标父节点和插入节点的值，如果插入节点的值更小，则考虑放到父节点的左边，接着递归调用 his.insertNode(root.left, newNode)；如果插入节点的值更大，以此类推即可。\n\ninsert 方法只是多了一步构造 Node 节点实例，接下来区分有无父节点的情况，调用 this.insertNode 方法即可。\n\n```\n removeNode(root, value) {\n    if (!root) {\n      return null\n    }\n    \n    if (value < root.value) {\n      root.left = this.removeNode(root.left, value)\n      return root\n    } else if (value > root.value) {\n      root.right = tis.removeNode(root.right, value)\n      return root\n    } else {\n      // 找到了需要删除的节点 \n      // 如果当前 root 节点无左右子节点\n      if (!root.left && !root.right) {\n        root = null\n        return root\n      }\n      \n      // 只有左节点\n      if (root.left && !root.right) {\n        root = root.left\n        return root\n      } \n      // 只有右节点\n      else if (root.right) {\n        root = root.right\n        return root\n      }\n      \n      // 有左右两个子节点\n      let minRight = this.findMinNode(root.right)\n      root.value = minRight.value\n      root.right = this.removeNode(root.right, minRight.value)\n      return root\n    }\n  }\n  \nremove(value) {\n    if (this.root) {\n      this.removeNode(this.root, value)\n    }\n}\n```\n\n上述代码不难理解，可能最需要读者思考的就是：\n\n```\n// 有左右两个子节点\nlet minRight = this.findMinNode(root.right)\nroot.value = minRight.value\nroot.right = this.removeNode(root.right, minRight.value)\nreturn root\n```\n\n我来特殊说明一下：当需要删除的节点含有左右两个子节点时，因为我们要把当前节点删除，就需要找到合适的“补位”节点，这个“补位”节点一定在该目标节点的右侧树当中，因为这样才能保证“补位”节点的值一定大于该目标节点的左侧树所有节点，而该目标节点的左侧树不需要调整；同时为了保证“补位”节点的值一定要小于该目标节点的右侧树值，因此要找的“补位”节点其实就是该目标节点的右侧树当中最小的那个节点。\n\n这个过程我们借助 this.findMinNode 方法实现：\n\n```\nfindMinNode(root) {\n    if (!root.left) {\n      return root\n    } else {\n      return this.findMinNode(root.left)\n    }\n}\n```\n\n该方法不断递归，直到找到最左叶子节点即可。\n\n查找方法：\n\n```\nsearchNode(root, value) {\n    if (!root) {\n      return null\n    }\n    \n    if (value < root.value) {\n      return this.searchNode(root.left, value)\n    } else if (value > root.value) {\n      return this.searchNode(root.right, value)\n    }\n    \n    return root\n}\n\nsearch(value) {\n    if (!this.root) {\n      return false\n    }\n    return Boolean(this.searchNode(this.root, value))\n}\n```\n\n这也比较简单，其实就是对递归的运用。最能体现递归简便优势的其实是对于树的遍历：\n\n前序遍历：\n\n```\npreOrder(root) {\n\tif (root) {\n\t  console.log(root.value)\n\t  this.preOrder(root.left)\n\t  this.preOrder(root.right)\n\t}\n}\n```\n\n中序遍历：\n\n```\ninOrder(root) {\n\tif (root) {\n\t  this.inOrder(root.left)\n\t  console.log(root.value)\n\t  this.inOrder(root.right)\n\t}\n}\n```\n\n后序遍历：\n\n```\npostOrder(root) {\n\tif (root) {\n\t  this.postOrder(root.left)\n\t  this.postOrder(root.right)\n\t  console.log(root.value)\n\t}\n}\n```\n\n前后中序遍历其实就在于 console.log(root.value) 方法执行的位置。\n\n#### 字典树\n\n字典树（Trie）是针对特定类型的搜索而优化的树数据结构。典型的例子是 autoComplete，也就是说它适合实现：通过部分值得到完整值的场景。字典树因此也是一种搜索树，我们有时候也叫做前缀树，因为任意一个节点的后代都存在共同的前缀。更多基础概念请读者先做了解。我们总结一下它的特点：\n\n- 字典树能做到高效查询和插入，时间复杂度为 O(k)，k 为字符串长度\n- 但是如果大量字符串没有共同前缀，那就很耗内存，读者可以想象一下最极端的情况，所有单词都没有共同前缀时，这颗字典树是什么样子\n- 字典树的核心就是减少没必要的字符比较，使查询高效率，也就是说用空间换时间，再利用共同前缀来提高查询效率\n\n除了我们刚刚提到的 autoComplete 自动填充的情况，字典树还有很多其他应用场景：\n\n- 搜索\n- 输入法选项\n- 分类\n- IP 地址检索\n- 电话号码检索\n\n#### 字典树的实现和遍历\n\n字典树的实现也不复杂，我们慢慢一步步来，首先实现一个字典树上的节点：\n\n```\nclass PrefixTreeNode {\n  constructor(value) {\n    // 存储子节点\n    this.children = {}\n    this.isEnd = null\n    this.value = value\n  }\n}\n```\n\n一个字典树继承 PrefixTreeNode 类：\n\n```\nclass PrefixTree extends PrefixTreeNode {\n  constructor() {\n    super(null)\n  }\n}\n```\n\n我们实现方法：\n\n- addWord：创建一个字典树节点\n- predictWord：给定一个字符串，返回字典树中以该字符串开头的所有单词\n\naddWord 实现：\n\n```\naddWord(str) {\n    const addWordHelper = (node, str) => {\n    \t  // 当前 node 不含当前 str 开头的目标\n        if (!node.children[str[0]]) {\n            // 以当前 str 开头的第一个字母，创建一个 PrefixTreeNode 实例\n            node.children[str[0]] = new PrefixTreeNode(str[0])\n            if (str.length === 1) {\n                node.children[str[0]].isEnd = true\n            } \n            else if (str.length > 1) {\n                addWordHelper(node.children[str[0]], str.slice(1))\n            }\n        }\n    }\n    addWordHelper(this, str)\n}\n```\n\npredictWord 实现：\n\n```\npredictWord(str) {\n\tlet getRemainingTree = function(str, tree) {\n\t  let node = tree\n\t  while (str) {\n\t    node = node.children[str[0]]\n\t    str = str.substr(1)\n\t  }\n\t  return node\n\t}\n\t\n\t// 该数组维护所有以 str 开头的单词\n\tlet allWords = []\n\t    \n\tlet allWordsHelper = function(stringSoFar, tree) {\n\t  for (let k in tree.children) {\n\t    const child = tree.children[k]\n\t    let newString = stringSoFar + child.value\n\t    if (child.endWord) {\n\t      allWords.push(newString)\n\t    }\n\t    allWordsHelper(newString, child)\n\t  }\n\t}\n\t\n\tlet remainingTree = getRemainingTree(str, this)\n\t\n\tif (remainingTree) {\n\t  allWordsHelper(str, remainingTree)\n\t}\n\t\n\treturn allWords\n}\n```\n\n### 图\n\n图是由具有边的节点集合组成的数据结构，图可以是定向的或不定向的。因此图可以分为好多种类，这里不一一讲解，主要看图的应用场景：\n\n- LBS 地图服务以及 GPS 系统\n- 社交媒体网站的用户关系图\n- 前端工程化中的开发依赖图\n- 搜索算法使用图，保证搜索结果的相关性\n- 寻找降低运输和交付货物和服务成本的最佳途径\n\n图也是应用最广泛的数据结构之一，真实场景中处处有图。更多概念还是需要读者先进行了解，尤其是图的几种基本元素：\n\n- 节点 Node\n- 边 Edge\n- |V| 图中顶点（节点）的总数\n- |E| 图中的连接总数（边）\n\n#### 图的实现和遍历\n\n这里我们主要实现一个有向图，Graph 类：\n\n```\nclass Graph {\n  constructor() {\n    this.AdjList = new Map()\n  }\n}\n```\n\n使用 Map 数据结构表述图中顶点关系。\n\n实现方法：\n\n- 添加顶点：addVertex\n- 添加边：addEdge\n- 打印图：print\n- 广度优先算法遍历\n- 深度优先算法\n\naddVertex 方法：\n\n```\naddVertex(vertex) {\n  if (!this.AdjList.has(vertex)) {\n    this.AdjList.set(vertex, [])\n  } else {\n    throw &apos;vertex already exist!&apos;\n  }\n}\n```\n\n创建顶点：\n\n```\nlet graph = new Graph();\ngraph.addVertex(&apos;A&apos;)\ngraph.addVertex(&apos;B&apos;)\ngraph.addVertex(&apos;C&apos;)\ngraph.addVertex(&apos;D&apos;)\n```\n\n其中 A、B、C、D 顶点都对应一个数组：\n\n```\n  &apos;A&apos; => [],\n  &apos;B&apos; => [],\n  &apos;C&apos; => [],\n  &apos;D&apos; => []\n```\n\n该数组将用来存储边。我们设计图预计得到如下关系：\n\n```\nMap {\n  &apos;A&apos; => [&apos;B&apos;, &apos;C&apos;, &apos;D&apos;],\n  &apos;B&apos; => [],\n  &apos;C&apos; => [&apos;B&apos;],\n  &apos;D&apos; => [&apos;C&apos;]\n}\n```\n\n根据此描述，其实已经可以把图画出来了。addEdge 因此需要两个参数：一个是顶点，一个是连接对象 Node：\n\n```\n addEdge(vertex, node) {\n    if (this.AdjList.has(vertex)) {\n      if (this.AdjList.has(node)){\n        let arr = this.AdjList.get(vertex)\n        if(!arr.includes(node)){\n          arr.push(node)\n        }\n      }else {\n        throw `Can&apos;t add non-existing vertex ->&apos;${node}&apos;`\n      }\n    } else {\n      throw `You should add &apos;${vertex}&apos; first`\n    }\n}\n``` \n\n理清楚数据关系，我们就可以打印图了，其实就是一个很简单的 for...of 循环：\n\n```\nprint() {\n  for (let [key, value] of this.AdjList) {\n    console.log(key, value)\n  }\n}\n```\n\n剩下的内容就是遍历图了。\n\n广度优先算法（BFS），是一种利用队列实现的搜索算法。对于图，其搜索过程和 “湖面丢进一块石头激起层层涟漪” 类似。换成算法语言，就是从起点出发，对于每次出队列的点，都要遍历其四周的点。\n\n因此 BFS 的实现步骤：\n\n- 起始节点作为起始，并初始化一个空对象：visited\n- 初始化一个空数组，该数组将模拟一个队列\n- 将起始节点标记为已访问\n- 将起始节点放入队列中\n- 循环直到队列为空\n\n实现：\n\n```\ncreateVisitedObject() {\n  let map = {}\n  for(let key of this.AdjList.keys()) {\n    arr[key] = false\n  }\n  return map\n}\n\nbfs(initialNode) {\n  // 创建一个已访问节点的 map\n  let visited = this.createVisitedObject()\n  // 模拟一个队列\n  let queue = []\n\n  // 第一个节点已访问\n  visited[initialNode] = true\n  // 第一个节点入队列\n  queue.push(initialNode)\n\n  while(queue.length) {\n    let current = queue.shift()\n    console.log(current)\n\n\t // 获得该节点的其他节点关系\n    let arr = this.AdjList.get(current)\n\n    for (let elem of arr) {\n      // 如果当前节点没有访问过\n      if (!visited[elem]) {\n        visited[elem] = true\n        q.push(elem)\n      }\n    }\n  }\n}\n```\n\n那么对于深度优先搜索算法（DFS），我把它总结为：“不撞南墙不回头”，从起点出发，先把一个方向的点都遍历完才会改变方向。换成程序语言就是：“DFS 是利用递归实现的搜索算法”。\n\n因此 DFS 过程：\n\n- 起始节点作为起始，创建访问对象\n- 调用辅助函数递归起始节点\n\n实现代码：\n\n```\ncreateVisitedObject() {\n  let map = {}\n  for (let key of this.AdjList.keys()) {\n    arr[key] = false\n  }\n  return map\n}\n\n dfs(initialNode) {\n    let visited = this.createVisitedObject()\n    this.dfsHelper(initialNode, visited)\n  }\n\n  dfsHelper(node, visited) {\n    visited[node] = true\n    console.log(node)\n\n    let arr = this.AdjList.get(node)\n\n    for (let elem of arr) {\n      if (!visited[elem]) {\n        this.dfsHelper(elem, visited)\n      }\n    }\n  }\n}\n```\n\nBFS 的重点在于队列，而 DFS 的重点在于递归，这是它们的本质区别。\n\n####  图在前端中的应用\n\n图其实在前端中应用不算特别多，但绝对还是不容忽视的一部分。这里我举一个我现实中应用的例子——循环图。\n\n在前端工程化发展的今天，理清项目中的依赖关系：比如查找项目中的循环依赖，可视化依赖都是图的应用，有助于开发者在宏观上把控工程化项目。在我们的项目中，我借助 [mermaidj](https://mermaidjs.github.io/#/) 画图工具，实现了项目依赖的完全可视化。并借助 npm script 来生成图片结果，相关 script 脚本：\n\n```\nyarn graph\n```\n\n脚本：\n\n```\nimport glob from &apos;glob&apos;\nimport readJSON from &apos;XXX/utils/readJSON&apos;\n\nconst pkgs = glob.sync(&apos;packages/*/package.json&apos;).map(readJSON)\n\nconst deps = {}\n\nfor (const pkg of pkgs) {\n  deps[pkg.name] = Object.keys(pkg.dependencies || []).filter(dep =>\n    // ...\n  )\n}\n\nconst graph = { code: &apos;&apos;, mermaid: { theme: &apos;default&apos; } }\n\ngraph.code += &apos;graph TD;&apos;\nfor (const name in deps) {\n  for (const dep of deps[name]) {\n    graph.code += `${name}-->${dep};`\n  }\n}\n\nconst base64 = Buffer.from(JSON.stringify(graph)).toString(&apos;base64&apos;)\n\n/* eslint-disable-next-line */\nconsole.log(\n  `Open in browser: https://mermaidjs.github.io/mermaid-live-editor/#/edit/${base64}`\n)\n```\n\n上述代码，我首先获取到 packages/*/package.json 中声明的所有依赖，然后对依赖进行必要性过滤之后，维护到 deps 对象当中，按照 mermaid 需求，将 monorepo 项目中的每一个子项目名和依赖按照 → 的间隔维护为 graph.code，最后通过生成 base64 交给 mermaid 进行绘图，绘图过程会根据约定（→ 的标记），成生可视化的依赖图。\n\n最终效果：\n\n![enter image description here](https://images.gitbook.cn/d92587a0-d04f-11e9-82a1-439033eb1f8a)\n\n那么 mermaid 是如何对图进行绘制的呢？了解了课程前面实现图的代码，我们再看 mermaid 绘制图的部分源码实现：\n\n```\nexport const addVertices = function (vert, g, svgId) {\n  const svg = d3.select(`[id=\"${svgId}\"]`)\n  const keys = Object.keys(vert)\n\n  const styleFromStyleArr = function (styleStr, arr) {\n    // Create a compound style definition from the style definitions found for the node in the graph definition\n    for (let i = 0; i < arr.length; i++) {\n      if (typeof arr[i] !== &apos;undefined&apos;) {\n        styleStr = styleStr + arr[i] + &apos;;&apos;\n      }\n    }\n\n    return styleStr\n  }\n\n  // Iterate through each item in the vertex object (containing all the vertices found) in the graph definition\n  keys.forEach(function (id) {\n    const vertex = vert[id]\n\n    /**\n     * Variable for storing the classes for the vertex\n     * @type {string}\n     */\n    let classStr = &apos;&apos;\n    if (vertex.classes.length > 0) {\n      classStr = vertex.classes.join(&apos; &apos;)\n    }\n\n    /**\n     * Variable for storing the extracted style for the vertex\n     * @type {string}\n     */\n    let style = &apos;&apos;\n    // Create a compound style definition from the style definitions found for the node in the graph definition\n    style = styleFromStyleArr(style, vertex.styles)\n\n    // Use vertex id as text in the box if no text is provided by the graph definition\n    let vertexText = vertex.text !== undefined ? vertex.text : vertex.id\n\n    // We create a SVG label, either by delegating to addHtmlLabel or manually\n    let vertexNode\n    if (conf.htmlLabels) {\n      // TODO: addHtmlLabel accepts a labelStyle. Do we possibly have that?\n      const node = { label: vertexText.replace(/fa[lrsb]?:fa-[\\w-]+/g, s => `<i class=&apos;${s.replace(&apos;:&apos;, &apos; &apos;)}&apos;></i>`) }\n      vertexNode = addHtmlLabel(svg, node).node()\n      vertexNode.parentNode.removeChild(vertexNode)\n    } else {\n      const svgLabel = document.createElementNS(&apos;http://www.w3.org/2000/svg&apos;, &apos;text&apos;)\n\n      const rows = vertexText.split(/<br[/]{0,1}>/)\n\n      for (let j = 0; j < rows.length; j++) {\n        const tspan = document.createElementNS(&apos;http://www.w3.org/2000/svg&apos;, &apos;tspan&apos;)\n        tspan.setAttributeNS(&apos;http://www.w3.org/XML/1998/namespace&apos;, &apos;xml:space&apos;, &apos;preserve&apos;)\n        tspan.setAttribute(&apos;dy&apos;, &apos;1em&apos;)\n        tspan.setAttribute(&apos;x&apos;, &apos;1&apos;)\n        tspan.textContent = rows[j]\n        svgLabel.appendChild(tspan)\n      }\n      vertexNode = svgLabel\n    }\n\n    // If the node has a link, we wrap it in a SVG link\n    if (vertex.link) {\n      const link = document.createElementNS(&apos;http://www.w3.org/2000/svg&apos;, &apos;a&apos;)\n      link.setAttributeNS(&apos;http://www.w3.org/2000/svg&apos;, &apos;href&apos;, vertex.link)\n      link.setAttributeNS(&apos;http://www.w3.org/2000/svg&apos;, &apos;rel&apos;, &apos;noopener&apos;)\n      link.appendChild(vertexNode)\n      vertexNode = link\n    }\n\n    let radious = 0\n    let _shape = &apos;&apos;\n    // Set the shape based parameters\n    switch (vertex.type) {\n      case &apos;round&apos;:\n        radious = 5\n        _shape = &apos;rect&apos;\n        break\n      case &apos;square&apos;:\n        _shape = &apos;rect&apos;\n        break\n      case &apos;diamond&apos;:\n        _shape = &apos;question&apos;\n        break\n      case &apos;odd&apos;:\n        _shape = &apos;rect_left_inv_arrow&apos;\n        break\n      case &apos;lean_right&apos;:\n        _shape = &apos;lean_right&apos;\n        break\n      case &apos;lean_left&apos;:\n        _shape = &apos;lean_left&apos;\n        break\n      case &apos;trapezoid&apos;:\n        _shape = &apos;trapezoid&apos;\n        break\n      case &apos;inv_trapezoid&apos;:\n        _shape = &apos;inv_trapezoid&apos;\n        break\n      case &apos;odd_right&apos;:\n        _shape = &apos;rect_left_inv_arrow&apos;\n        break\n      case &apos;circle&apos;:\n        _shape = &apos;circle&apos;\n        break\n      case &apos;ellipse&apos;:\n        _shape = &apos;ellipse&apos;\n        break\n      case &apos;group&apos;:\n        _shape = &apos;rect&apos;\n        break\n      default:\n        _shape = &apos;rect&apos;\n    }\n    // Add the node\n    g.setNode(vertex.id, { labelType: &apos;svg&apos;, shape: _shape, label: vertexNode, rx: radious, ry: radious, &apos;class&apos;: classStr, style: style, id: vertex.id })\n  })\n}\n\n/**\n * Add edges to graph based on parsed graph defninition\n * @param {Object} edges The edges to add to the graph\n * @param {Object} g The graph object\n */\nexport const addEdges = function (edges, g) {\n  let cnt = 0\n\n  let defaultStyle\n  if (typeof edges.defaultStyle !== &apos;undefined&apos;) {\n    defaultStyle = edges.defaultStyle.toString().replace(/,/g, &apos;;&apos;)\n  }\n\n  edges.forEach(function (edge) {\n    cnt++\n    const edgeData = {}\n\n    // Set link type for rendering\n    if (edge.type === &apos;arrow_open&apos;) {\n      edgeData.arrowhead = &apos;none&apos;\n    } else {\n      edgeData.arrowhead = &apos;normal&apos;\n    }\n\n    let style = &apos;&apos;\n    if (typeof edge.style !== &apos;undefined&apos;) {\n      edge.style.forEach(function (s) {\n        style = style + s + &apos;;&apos;\n      })\n    } else {\n      switch (edge.stroke) {\n        case &apos;normal&apos;:\n          style = &apos;fill:none&apos;\n          if (typeof defaultStyle !== &apos;undefined&apos;) {\n            style = defaultStyle\n          }\n          break\n        case &apos;dotted&apos;:\n          style = &apos;stroke: #333; fill:none;stroke-width:2px;stroke-dasharray:3;&apos;\n          break\n        case &apos;thick&apos;:\n          style = &apos;stroke: #333; stroke-width: 3.5px;fill:none&apos;\n          break\n      }\n    }\n    edgeData.style = style\n\n    if (typeof edge.interpolate !== &apos;undefined&apos;) {\n      edgeData.curve = interpolateToCurve(edge.interpolate, d3.curveLinear)\n    } else if (typeof edges.defaultInterpolate !== &apos;undefined&apos;) {\n      edgeData.curve = interpolateToCurve(edges.defaultInterpolate, d3.curveLinear)\n    } else {\n      edgeData.curve = interpolateToCurve(conf.curve, d3.curveLinear)\n    }\n\n    if (typeof edge.text === &apos;undefined&apos;) {\n      if (typeof edge.style !== &apos;undefined&apos;) {\n        edgeData.arrowheadStyle = &apos;fill: #333&apos;\n      }\n    } else {\n      edgeData.arrowheadStyle = &apos;fill: #333&apos;\n      if (typeof edge.style === &apos;undefined&apos;) {\n        edgeData.labelpos = &apos;c&apos;\n        if (conf.htmlLabels) {\n          edgeData.labelType = &apos;html&apos;\n          edgeData.label = &apos;<span class=\"edgeLabel\">&apos; + edge.text + &apos;</span>&apos;\n        } else {\n          edgeData.labelType = &apos;text&apos;\n          edgeData.style = edgeData.style || &apos;stroke: #333; stroke-width: 1.5px;fill:none&apos;\n          edgeData.label = edge.text.replace(/<br>/g, &apos;\\n&apos;)\n        }\n      } else {\n        edgeData.label = edge.text.replace(/<br>/g, &apos;\\n&apos;)\n      }\n    }\n    // Add the edge to the graph\n    g.setEdge(edge.start, edge.end, edgeData, cnt)\n  })\n}\n```\n\n**那么根据我的脚本，用 → 表现的依赖关系，除了可视化以外，还有其他用处吗？** 其实肯定是有的，除了“花架子”，这个依赖图对于项目的部署构建也有非常重要的作用。比如在对 monorepo 项目进行构建时，因为子项目过多，导致构建时间过长。为此，我给出的方案是增量构建，如果这次改动只设计项目 A、项目 B，以及公共依赖 C，那么项目 C，项目 D 等其他项目在构建时只需要读取缓存构建结果即可。思路是很简单，但是一个直接问题是，如果检测说真正需要构建的项目呢？\n\n举个例子，项目 A 依赖公共依赖 C，那么及时通过 git hook 拿到的 diff 表明项目 A 并没有代码变动，但是可能因为 C 变了，我们还需要重新构建项目 A（因为 A 依赖 C）。按照正常的思路，需要遍历整个项目，这样带来的问题是增加了回溯构建的可能：构建时先遍历到 A，读取缓存，再遍历到 C 时，不得不回退到 A，重新构建。解决思路就是使用一个拓扑图，根据拓扑图，按照一定的顺序进行遍历和编译构建即可。\n\n这是我近期一个使用到拓扑图数据结构的经典场景。具体实施过程因为机密性，我不在贴代码了，对于读者来说，更重要地是体会思想，相信自己动手实现也不会困难。\n\n### 散列表（哈希表）\n\n散列表是一种以 key-value 形式存储数据的数据结构，可以把散列表理解为一种高级的数组，这种数组的下标可以是很大的整数，浮点数，字符串甚至结构体。这种数据结构非常有用，js 里的 Map/Set/WeakMap/WeakSet 在 v8 里都是通过散列表来实现的，再比如 LRU Cache、数据库索引等非常多的场景也都能看到散列表的身影。\n\n散列并不仅仅是一种技术，从某种意义上讲，它甚至是一种思想。接下来让我们一起揭开散列表神秘的面纱。\n\n假如，我们要存储 key 为 6、2019、2333333 的三组数据，如果用数组来存，至少需要一个长度为 2333333 的数组来做这件事情，显然这种做法存在大量的空间浪费。\n\n我们也可以像下图一样，准备一个长度为 10 的数组（bucket array），将每一个 key 通过一个散列函数（hash function），映射到桶数组中的一位，将 key 相应的值直接存入即可。可以看到这种方式只需使用一个长度为 10 的数组，同时查找和插入的时间复杂度都是 O(1)。这就是散列表的核心思想。\n\n<img src=\"https://images.gitbook.cn/52397840-c57e-11e9-9d70-f58ea827d9ae\" width = \"70%\" />\n\n散列表中的几个概念：\n\n- 桶（bucket），用来直接存放或间接指向一个数据\n- 桶数组（bucket array）由桶组成的数组\n- 散列函数（hash function）将 key 转换为桶数组下标的函数\n\n上面的例子比较简单，如果我们继续在之前的基础上再存储一个 key 为 9 的数据，通过 9 % 10 计算得出的也是落在下标为 9 的 bucket 上，此时有两个不同的 key 落在了同一个 bucket 上，这一现象被称为散列冲突。\n\n散列冲突理论上是不可避免的，我们能做的优化主要从以下两个方面入手：\n\n- 精心设计桶数组长度及散列函数，尽可能降低冲突的概率\n- 发生冲突时，能对冲突进行排解\n\n假设不用散列表直接用数组来存储需要的数组长度为 R，用散列表存储需要的桶数组长度为 M，需要存储的元素个数为 N，则一定存在以下关系 `N < M << R`，只有这样散列表才能既保持操作的高效同时起到节省空间的效果。\n\n其中，N / M 称为散列表的装载因子，当装载因子超过一定的阈值时，需要对桶数组扩容并 rehash。\n\n理想的散列函数遵循以下的设计原则：\n\n- 确定：同一 key 总是被映射至同一地址\n- 高效：插入/查找/删除 excepted-O(1) 时间复杂度\n- 满射：尽可能充分地覆盖整个桶数组空间\n- 均匀：key 映射到桶数组各位置的概率尽量接近\n\n常用的散列函数如下。\n\n**除余法** \n\n`hash(key) = key % M`，直接对 key 按桶数组的长度取余，这种方法非常简单，但存在以下缺陷。\n\n- 存在不动点：无论桶数组长度 M 取何值，总有 `hash(0) = 0`，这与任何元素都有均等的概率被映射到任何位置的原则相违背。\n- 零阶均匀：`[0, R)` 的关键码，平均分配至 M 个桶；但相邻关键码的散列地址也必相邻。\n\n**MAD 法 multiply-add-divide**\n\n`hash(key) = (a x key + b) % M`，跟除余法相比，引入的变量 b 可以视作偏移量，可有效的消除不动点，另一个变量 a 扮演着步长的角色，也就是说原本相邻的关键码在经过散列后步长为 a，从而不再继续相邻。\n\n**平方取中 mid-square**\n\n取 `key^2` 的中间若干位，构成地址：\n\n- `hash(123) = 512` // 保留 key^2 = 123^2 = 15219 的中间 3 位\n- `hash(1234567) = 556` // 1234567^2 = 1524155677489\n\n我们可以将一个数的平方运算，分解为一系列的左移操作以及若干次加法，从下图中不难看出，每一个数位都是由原关键码中的若干数位经求和得到的，因此两侧的数位由更少的原数位求和而得，越是居中的数位，则是由更多的原数位积累而得，因此截取居中的若干位，可使得原关键码的各数位都能对最终结果产生影响，从而实现更好的均匀性\n\n<img src=\"https://images.gitbook.cn/c06093f0-c71b-11e9-9e56-8d3dec542204\" width = \"70%\" />\n\n**多项式法**\n\n在实际应用中，我们的 key 不一定都是整数形式，因此往往需要一个预处理将其转换为散列码(hashcode)，然后才可以对其进一步处理为桶数组的下标地址。整个过程可以描述为 key → hashcode → bucket addr，多项式法就是一种有效的将字符串 key 转换为 hashcode 的方法\n对于一个长度为 n 的字符串，其计算过程如下：\n\n```\nhash(x0 x1 ... xn-1) = x0 * a^(n-1) + x1 * a^(n-2) ... + xn-2 * a + xn-1 \n// 如果上面的不是很理解，它其实等价于下面这样\n(...((x0 * a + x1) * a + x2) * a + ... xn-2) * a + xn-1)\n```\n\n这个多项式可以在 O(n) 而不是 O(n2) 的时间复杂度内计算出结果，具体证明的过程这里就不详细展开了。\n\n在实际的工程中会采用如下这种近似多项式，但更快捷的做法：\n\n```\nfunction hash(key) {\n    let h = 0\n    for (let n = key.length, i = 0; i != n; i++) {\n        h = (h << 5 | h >> 27)\n        h += key[i].charCodeAt()\n    }\n    return h >>> 0\n}\n```\n\n通过一个循环依次处理字符串的每一个字符，对于每一个字符将它转换为整数后累加，在累加之前对原有的累积值，都按照 h << 5 | h >> 27 这样的规则做一个数位变换\n\n![bit-operations](https://images.gitbook.cn/81040300-c747-11e9-a05e-8fabd2e19d71)\n\n这一不断调整累加的过程，实际上可以是作为是对以上多项式计算的近似，只不过这里消除掉了相对耗时的乘法运算，至于如何理解和解释这种近似的效果，可以作为本文课后的一项作业。\n\n除了上文讲到的方法外，还有非常多的散列函数的方法，如折叠法、位异或法、（伪）随机数法，此类方法林林总总，每种方法都有各自的特点及应用的场景，由于篇幅原因这里就不再展开了，感兴趣的读者可以在读者群中继续研究和探讨。\n\n总之散列函数产生的关键码越是随机，越是没有规律就越好。\n\n**冲突解决方法**\n\n主要的处理散列表冲突的方法有开链法和探测法这两类。\n\n- **开链法（linked-list chaining / seperate chaining）**\n\n每个桶存放一个指针，将冲突的 key 以链表的形式组织起来，这种处理方式最大的优点是能解决任意次数的冲突，但缺点也很明显，最极端的情况所有的 key 数据都落在一个桶上时，散列表将退化为一个链表，查找插入删除的复杂度都将变成 O(n)。\n\n<img src=\"https://images.gitbook.cn/23cf29b0-c749-11e9-9e56-8d3dec542204\" width = \"35%\" />\n\n- **探测法（open addressing / closed hashing）**\n\n探测法所有的冲突都在这块连续的空间中加以排解，而不用像开链法那样申请额外的空间。当存入一个 key 时，所有的桶都按照某种优先级关系排成一个序列，从本该属于该 key 的桶出发，顺次查看每一个桶直到找到可用的桶。每个 key 对应的这样的一个序列，称为试探序列或者查找链，在查找 key 时，沿查找链查找有两种结果，在桶中找到了查询的 key 也就是查找成功，还有的一种可能是找到一个空桶，则说明查找失败，没有这个 key。\n\n最简单的试探序列的生成方法叫做线性试探（Linear probing），具体做法是一旦发生冲突，则试探后一个紧邻的桶单元，直到成功或失败。这种做法的优点是无需附加的（指针、链表等）空间，缺点也很明显，以往的冲突会导致后续的冲突。\n\n```\n[hash(key) + 1] % M\n[hash(key) + 2] % M\n[hash(key) + 3] % M\n...\n```\n\n线性试探的问题根源在于大部分的试探位置都集中在某一个相对较小的局部，因此优化线性试探的方式就是适当的拉开各次探测的间距，平方试探（Quadratic Probing）就是基于这一优化思路的具体实现方式，所谓平方试探顾名思义就是以平方数为距离，确定下一试探桶单元。\n\n```\n[hash(key) + 1^2] % M\n[hash(key) + 2^2] % M\n[hash(key) + 3^2] % M\n...\n```\n\n相对于线性试探，平方探测的确可以在很大程度上缓解数据聚集的现象，查找链上，各桶间距线性递增，一旦冲突，可从没地逃离是非之地。\n\n### 散列表的实现\n\n最后用 JavaScript 来模拟实现一下 hashtable，这里我们采用开链法来解决散列的冲突。\n\n```\n// 单向链表节点\nclass ForwardListNode {\n    constructor(key, value) {\n        this.key = key\n        this.value = value\n        this.next = null\n    }\n}\n\nclass Hashtable {\n  constructor(bucketSize = 97) {\n    this._bucketSize = bucketSize\n    this._size = 0\n    this._buckets = new Array(this._bucketSize)\n  }\n\n  hash(key) {\n    let h = 0\n    for (let n = key.length, i = 0; i != n; i++) {\n      h = (h << 5 | h >> 27)\n      h += key[i].charCodeAt()\n    }\n    return (h >>> 0) % this._bucketSize\n  }\n\n  // Modifiers\n  put(key, value){\n    let index = this.hash(key);\n    let node = new ForwardListNode(key, value)\n\n    if (!this._buckets[index]) {\n      // 如果桶是空的，则直接把新节点放入桶中即可\n      this._buckets[index] = node\n    } else {\n      // 如果桶不为空，则在链表头插入新节点\n      node.next = this._buckets[index]\n      this._buckets[index] = node\n    }\n    this._size++\n    return index\n  }  \n\n  delete(key) {\n    let index = this.hash(key)\n    if (!this._buckets[index]) {\n      return false\n    }\n\n    // 添加一个虚拟头节点，方便后面的删除操作\n    let dummy = new ForwardListNode(null, null)\n    dummy.next = this._buckets[index]\n    let cur = dummy.next, pre = dummy\n    while (cur) {\n      if (cur.key === key) {\n        // 从链表删除该节点\n        pre.next = cur.next\n        cur = pre.next\n        this._size--\n      } else {\n        pre =  cur\n        cur = cur.next\n      }\n    }\n    this._buckets[index] = dummy.next\n    return true\n  }\n\n  // Lookup\n  find(key){\n    let index = this.hash(key);\n    // 如果对应的 bucket 为空，说明不存在此 key\n    if (!this._buckets[index]) {\n      return null\n    }\n    \n    // 遍历对应桶的链表\n    let p = this._buckets[index]\n    while (p) {\n      // 找到 key\n      if (p.key === key) {\n        return p.value\n      }\n      p = p.next\n    }\n    return null\n  } \n\n  // Capacity\n  size() {\n      return this._size\n  }\n\n  isEmpty() {\n      return this._size == 0\n  }\n}\n```\n\n### 总结\n\n这一节课我们介绍了和前端最为贴合的几种数据结构，虽然篇幅较长，但是内容算不上太难。一些基本概念并没有深入讲解， 因为数据结构更重要的是应用，我希望读者能够做到的是：在需要的场景，能够想到最为适合的数据结构处理问题。请读者务必掌握好这些内容，接下来的算法章节需要对数据结构有一个较为熟练地掌握和了解。","pdfUrl":"","reader":"","duration":"","title":"剖析无处不在的数据结构","column":"5c91c813968b1d64b1e08fde","isNotification":false,"readingStatistics":0,"htmlContent":"<p>数据结构是计算机中组织和存储数据的特定方式，它的目的是方便且高效地对数据进行访问和修改。数据结构表述了数据之间的关系，以及操作数据的一系列方法。数据又是程序的基本单元，因此无论是哪种语言、哪种领域，都离不开数据结构；另一方面，数据结构是算法的基础，其本身也包含了算法的部分内容。也就是说，想要掌握算法，先有一个巩固的数据结构基础是必要条件。</p>\n<p>前端领域也到处体现着数据结构的应用，尤其是随着需求的复杂度上升，前端工程师越来越离不开数据结构。React、Vue 这些设计精巧的框架，在线文档编辑系统、大型管理系统，甚至一个简单的检索需求，都离不开数据结构的支持。是否能够掌握这个难点内容，将是进阶的重要考量。我们应该如何学习数据结构呢？</p>\n<p>下图是本讲内容的提纲。</p>\n<img src=\"https://images.gitbook.cn/87934440-d04f-11e9-bec2-e1649ddaac83\" width = \"70%\" />\n<h3><a id=\"_8\"></a>数据结构和学习方法概览</h3>\n<p>我通常将数据结构分为八大类：</p>\n<ul>\n<li>数组：Array</li>\n<li>堆栈：Stack</li>\n<li>队列：Queue</li>\n<li>链表：Linked Lists</li>\n<li>树：Trees</li>\n<li>图：Graphs</li>\n<li>字典树：Trie</li>\n<li>散列表（哈希表）：Hash Tables</li>\n</ul>\n<p>这么多的类型，这节课该如何介绍呢？我认为，按部就班地只是实现各种数据结构的意义不大，这些内容读者都可以从算法书籍中找到。更重要地是应用，也只有在应用中，才能真正地记住并掌握特定的数据结构，才能在下次有类似场景时，能够想起来相关的数据结构实现。因此，这节课程我将从前端出发，从前端类库或者典型场景入手，结合数据结构来剖析其实现和应用。这需要读者首先对每种数据结构有一个大概认知，我们可以先来细化感知一下：</p>\n<ul>\n<li>栈和队列是类似数组的结构，非常多的初级题目要求用数组实现栈和队列，他们在插入和删除的方式上和数组有所差异，但是实现还是非常简单的；</li>\n<li>链表、树和图这种数据结构的特点是，其节点需要引用到其他节点，因此在增删时，需要注意对相关前驱和后继节点的影响；</li>\n<li>可以从堆栈和队列出发，构建出链表；</li>\n<li>树和图最为复杂，因为他们本质上是扩展了链表的概念；</li>\n<li>散列表的关键是理解散列函数，明白依赖散列函数实现保存和定位数据的过程；</li>\n<li>直观上认为，链表适合记录和存储数据；哈希表和字典树在检索数据以及搜索方面有更大的应用场景。</li>\n</ul>\n<p>以上这些“直观感性”的认知并不是“恒等式”， <strong>我们将在下面的学习中去印证这些“认知”，你将会看到熟悉的 React、Vue 框架的部分实现，将会看到典型的算法场景，也请读者做好基础知识的储备。</strong></p>\n<h3><a id=\"_32\"></a>堆栈和队列</h3>\n<p>栈和队列是一种操作受限的线性结构，它们非常简单，虽然 JavaScript 并没有原生内置这样的数据结构，但是我们可以轻松地模拟出来。</p>\n<p>栈的实现，后进先出 LIFO（Last in、First out）：</p>\n<pre><code class=\"lang-\">class Stack {\n  constructor(...args) {\n    this.stack = [...args]\n  }\n\n  // Modifiers\n  push(...items) {\n    return this.stack.push(... items)\n  }\n\n  pop() {\n    return this.stack.pop()\n  }\n\n  // Element access\n  peek() {\n    return this.isEmpty() \n        ? undefined\n        : this.stack[this.size() - 1]\n  }\n\n  // Capacity\n  isEmpty() {\n    return this.size() == 0\n  }\n\n  size() {\n    return this.stack.length\n  }\n}\n</code></pre>\n<p>队列的实现，先进先出 FIFO（First in、First out）：</p>\n<pre><code class=\"lang-\">class Queue {\n  constructor(...args) {\n    this.queue = [...args]\n  }\n\n  // Modifiers\n  enqueue(...items) {\n    return this.queue.push(... items)\n  }\n\n  dequeue() {\n    return this.queue.shift()\n  }\n\n  // Element access\n  front() { \n    return this.isEmpty()\n        ? undefined\n        : this.queue[0]\n  }\n\n  back() {\n    return this.isEmpty()\n        ? undefined\n        : this.queue[this.size() - 1]\n  }\n\n  // Capacity\n  isEmpty() {\n    return this.size() == 0\n  }\n\n  size() {\n    return this.queue.length\n  }\n}\n</code></pre>\n<p>关于栈和队列的实际应用比比皆是：</p>\n<ul>\n<li>浏览器的历史记录，因为回退总是回退“上一个”最近的页面，它需要遵循栈的原则；</li>\n<li>类似浏览器的历史记录，任何 undo/redo 都是一个栈的实现；</li>\n<li>在代码中，广泛应用的递归产生的调用栈，同样也是栈思想的体现，想想我们常说的“栈溢出”就是这个道理；</li>\n<li>同上，浏览器在抛出异常时，常规都会抛出调用栈信息；</li>\n<li>在计算机科学领域应用广泛，如进制转换、括号匹配、栈混洗、表达式求值等；</li>\n<li>队列的应用更为直观，我们常说的宏任务 / 微任务都是队列，不管是什么类型的任务，都是先进先执行；</li>\n<li>后端也应用广泛，如消息队列、RabbitMQ、ActiveMQ 等，能起到延迟缓冲的功效。</li>\n</ul>\n<p>我们看到不管是栈还是队列，都是用数组来模拟的。数组是最基本的数据结构，但是它的价值是惊人的，这里稍微提一下 React hooks 的本质就是数组。给大家推荐文章：<a href=\"https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e\" target=\"_blank\">React hooks: not magic, just arrays</a></p>\n<p>另外，与性能后话相关，HTTP 1.1 有一个队头阻塞问题，这个原因就在于队列这样的数据结构：我们先看 HTTP 1.0，对于同一个 tcp 连接，HTTP 1.0 是将所有请求都放入队列当中，这么一来，在客户端，“先进先出”，只有前一个请求得到了响应，下一个请求才会发出。在 HTTP 1.1 中，这样的情况得到了改观，每一个链接都默认是长链接，因此对于同一个 tcp 链接，不必等到前一个响应回来。但是这只是解决了客户端的队头阻塞问题，事实上，HTTP 1.1 规定：服务端的响应返回顺序需要遵循其接收到相应的顺序，这样的问题是：如果第一个请求处理需要较长时间，响应较慢，也都会“拖累”其他后续请求的响应，这仍然是一种队头阻塞。</p>\n<p>HTTP 2 采用了二进制分帧和多路复用等方法， 同域名下的通信都是在同一个连接上完成，并且这种链接是双向的，在这个链接上可以并行请求和响应而互不干扰。</p>\n<p>这里延伸的有点多了，主要是读者需要明白队列和栈这种数据结构的应用，以及利弊。</p>\n<h3><a id=\"_130\"></a>链表（单向链表和双向链表）</h3>\n<p>堆栈和队列都可以用数组实现，链表同样和数组一样，都实现了<strong>按照一定的顺序</strong>存储元素，不同的地方在于链表不能像数组一样通过下标访问，而是每一个元素指向下一个元素。我们不再过多介绍链表方面的基础知识，对于链表仍不理解的读者可以先自行学习。</p>\n<p>直观上我们就可以得出结论：链表不需要一段连续的存储空间，“指向下一个元素”的方式能够更大限度地利用内存。</p>\n<p>根据上面结论可以继续总结，链表的优点在于：</p>\n<ul>\n<li>链表的插入和删除操作的时间复杂度是常数级的，我们只需要改变相关节点的指针指向即可；</li>\n<li>链表可以像数组一样顺序访问，查找元素的时间复杂度是线性的。</li>\n</ul>\n<p>我们来看看链表的应用场景：</p>\n<ul>\n<li>React 的核心算法 Fiber 的实现就是链表</li>\n</ul>\n<p>关于此我们可以稍作展开。React 最早开始使用大名鼎鼎的 Stack reconciler 调度算法，关于此在之前的课程中已经有所涉及。Stack reconciler 调度算法最大的问题在于：<strong>它是像函数调用栈一样，递归地、自顶向下进行 diff 和 render 相关操作的</strong>，在 Stack reconciler 执行的过程当中，该调度算法始终会占据浏览器主线程。也就是说在此期间，用户的交互所触发的布局行为、动画执行任务都不会被立即响应，从而影响用户体验。</p>\n<p>因此 React Fiber 将渲染和更新过程进行了拆解，简单来说，就是每次检查虚拟 DOM 的一小部分，在检查间隙会检查“是否还有时间继续执行下一个虚拟 DOM 树上某个分支任务”，同时观察是否有更优先的任务需要响应，如果“没有时间执行下一个虚拟 DOM 树上某个分支任务”，且有更高优先级，React 就会让出主线程，直到主线程“不忙”的时候继续执行任务。</p>\n<p>React Fiber 因此也很简单，它是将 Stack reconciler 过程分成块，一次执行一块，执行完一块需要将结果保存起来，根据是否还有空闲的响应时间（requestIdleCallback）来决定下一步策略。当所有的块都已经执行完，就进入提交阶段，这个阶段需要更新 DOM，它是一口气完成的。</p>\n<p>以上是比较主观地介绍，我们来看更具体的实现。</p>\n<p>为了达到“随意中断调用栈并手动操作调用栈”，React Fiber 就是专门用于 React 组件堆栈调用的重新实现，也就是说一个 Fiber 就是一个虚拟堆栈帧，一个 Fiber 的结构类似：</p>\n<pre><code class=\"lang-\">function FiberNode(\n  tag: WorkTag,\n  pendingProps: mixed,\n  key: null | string,\n  mode: TypeOfMode,\n) {\n  // Instance\n  // ...\n  this.tag = tag;                       \n  \n  // Fiber\n  this.return = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n\n  this.ref = null;\n\n  this.pendingProps = pendingProps;\n  this.memoizedProps = null;\n  this.updateQueue = null;\n  this.memoizedState = null;\n  this.dependencies = null;\n\n  // Effects\n  // ...\n  this.alternate = null; \n}\n</code></pre>\n<p>这么看 Fiber 就是一个对象，通过 parent、children、sibling 维护一个树形关系，同时 parent、children、sibling 也都是一个 Fiber 结构，FiberNode.alternate 这个属性来存储上一次渲染过的结果，事实上整个 Fiber 模式就是一个链表。React 也借此，从依赖于内置堆栈的同步递归模型，变为具有链表和指针的异步模型了。</p>\n<p>具体的渲染过程：</p>\n<pre><code class=\"lang-\">function renderNode(node) {\n   // 判断是否需要渲染该节点，如果 props 发生变化，则调用 render\n   if (node.memoizedProps !== node.pendingProps) {\n      render(node)\n   }\n\n   // 是否有子节点，进行子节点渲染\n   if (node.child !== null) {\n      return node.child\n   // 是否有兄弟节点，进行兄弟点渲染\n   } else if (node.sibling !== null){\n      return node.sibling\n   // 没有子节点和兄弟节点\n   } else if (node.return !== null){\n      return node.return\n   } else {\n      return null\n   }\n}\n\nfunction workloop(root) {\n   nextNode = root\n   while (nextNode !== null &amp;&amp; (no other high priority task)) {\n      nextNode = renderNode(nextNode)\n   }\n}\n</code></pre>\n<p>注意在 workloop 当中，while 条件 nextNode !== null &amp;&amp; (no other high priority task)，这是描述 Fiber 工作原理的关键伪代码。</p>\n<p>当然这里是为了说明链表的数据结构，伪代码较为简略，也没有深入：</p>\n<ul>\n<li>requestAnimationFrame(callback)</li>\n<li>requestIdleCallback(callback)</li>\n</ul>\n<p>的实现和应用。React Fiber 的介绍我们先到此为止，重点是体会链表数据结构的思想。</p>\n<h3><a id=\"_228\"></a>链表实现</h3>\n<p>实现链表，我们需要先对链表进行分类，常见的有：</p>\n<ul>\n<li>单链表：单链表是维护一系列节点的数据结构，其特点是：每个节点包含了数据，同时包含指向链表中下一个节点的指针。</li>\n<li>双向链表：不同于单链表，双向链表特点：每个节点分除了包含其数据以外，还包含了分别指向其前驱和后继节点的指针。</li>\n</ul>\n<p>由于篇幅有原因，我们挑选更加复杂的双向链表进行实现，实现思路如下。</p>\n<p>首先，根据双向链表的特点，我们实现一个节点构造函数（节点类）：</p>\n<pre><code class=\"lang-\">class Node {\n    constructor(data) {\n        // data 为当前节点所储存的数据\n        this.data = data\n        // next 指向下一个节点\n        this.next = null\n        // prev 指向前一个节点\n        this.prev = null\n    }\n}\n</code></pre>\n<p>有了节点类，我们来初步实现双向链表类：</p>\n<pre><code class=\"lang-\">class DoublyLinkedList {\n    constructor() {\n    \t// 双向链表开头\n    \tthis.head = null\n    \t// 双向链表结尾\n      this.tail = null\n    }\n\n    // ...\n}\n</code></pre>\n<p>接下来，需要实现双向链表原型上的一些方法，这些方法包括</p>\n<ul>\n<li>add：在链表尾部添加一个新的节点</li>\n<li>addAt：在链表指定位置添加一个新的节点</li>\n<li>remove：删除链表指定数据项节点</li>\n<li>removeAt：删除链表指定位置节点</li>\n<li>reverse：翻转链表</li>\n<li>swap：交换两个节点数据</li>\n<li>isEmpty：查询链表是否为空</li>\n<li>length：查询链表长度</li>\n<li>traverse：遍历链表</li>\n<li>find：查找某个节点的索引</li>\n</ul>\n<p>add 方法：</p>\n<pre><code class=\"lang-\">add(item) {\n  // 实例化一个节点\n  let node = new Node(item)\n  \n  // 如果当前链表还没有头\n  if(!this.head) {\n    this.head = node\n    this.tail = node\n  } \n  // 如果当前链表已经有了头，只需要在尾部加上该节点\n  else {\n    node.prev = this.tail\n    this.tail.next = node\n    this.tail = node\n  }\n}\n</code></pre>\n<p>addAt 方法：</p>\n<pre><code class=\"lang-\">addAt(index, item) {\n   let current = this.head\n   // 维护查找时当前节点的索引\n   let counter = 1\n   let node = new Node(item)\n   \n   // 如果在头部插入\n   if (index === 0) {\n     this.head.prev = node\n     node.next = this.head\n     this.head = node\n   } \n   // 非头部插入，需要从头开始，找寻插入位置\n   else {\n     while(current) {\n      current = current.next\n      if( counter === index) {\n        node.prev = current.prev\n        current.prev.next = node\n        node.next = current\n        current.prev = node\n      }\n      counter++\n    }\n  }\n}\n</code></pre>\n<p>remove 方法：</p>\n<pre><code class=\"lang-\">remove(item) {\n  let current = this.head\n  \n  while (current) {\n  \t // 找到了目标节点\n    if (current.data === item ) {\n      // 目标链表只有当前目标项，即目标节点即是链表头又是链表尾\n      if (current == this.head &amp;&amp; current == this.tail) {\n        this.head = null\n        this.tail = null\n      } \n      // 目标节点为链表头\n      else if (current == this.head ) {\n        this.head = this.head.next\n        this.head.prev = null\n      } \n      // 目标节点为链表尾部\n      else if (current == this.tail ) {\n        this.tail = this.tail.prev;\n        this.tail.next = null;\n      } \n      // 目标节点在链表收尾之间，中部\n      else {\n        current.prev.next = current.next;\n        current.next.prev = current.prev;\n      }\n   }\n   current = current.next\n  }\n}\n</code></pre>\n<p>removeAt 方法：</p>\n<pre><code class=\"lang-\">removeAt(index) {\n  // 都是从“头”开始遍历\n  let current = this.head\n  let counter = 1\n  \n  // 删除链表头部\n  if (index === 0 ) {\n   this.head = this.head.next\n   this.head.prev = null\n  } \n  else {\n   while(current) {\n    current = current.next\n    // 如果目标节点在链表尾\n    if (current == this.tail) {\n     this.tail = this.tail.prev\n     this.tail.next = null\n    } \n    else if (counter === index) {\n     current.prev.next = current.next\n     current.next.prev = current.prev\n     break\n    }\n    counter++\n   }\n  }\n}\n</code></pre>\n<p>reverse 方法：</p>\n<pre><code class=\"lang-\">reverse() {\n  let current = this.head\n  let prev = null\n  \n  while (current) {\n   let next = current.next\n   \n   // 前后倒置\n   current.next = prev\n   current.prev = next\n   \n   prev = current\n   current = next\n  }\n  \n  this.tail = this.head\n  this.head = prev\n}\n</code></pre>\n<p>swap 方法，交换两个节点数据值：</p>\n<pre><code class=\"lang-\">swap(index1, index2) {\n  // 使 index1 始终小于 index2，方便后面查找交换\n  if (index1 &gt; index2) {\n    return this.swap(index2, index1)\n  }\n\n  let current = this.head\n  let counter = 0\n  let firstNode\n  \n  while(current !== null) {\n    // 找到第一个节点，先存起来\n    if (counter === index1 ){\n        firstNode = current\n    } \n  \n    // 找到第二个节点，进行数据交换\n    else if (counter === index2) {\n      // ES 提供了更简洁交换数据的方法，这里我们用传统方式实现，更为直观\n      let temp = current.data\n      current.data = firstNode.data\n      firstNode.data = temp\n    }\n    \n    current = current.next\n    counter++\n  }\n  return true\n}\n</code></pre>\n<p>isEmpty 方法：</p>\n<pre><code class=\"lang-\">isEmpty() {\n  return this.length() &lt; 1\n}\n</code></pre>\n<p>这里通过 DoublyLinkedList 类 length 的方法实现。马上看一下 length 方法：</p>\n<pre><code class=\"lang-\">length() {\n  let current = this.head\n  let counter = 0\n  while(current !== null) {\n    counter++\n    current = current.next\n  }\n  return counter\n}\n</code></pre>\n<p>length 方法通过遍历链表，返回链表的长度。</p>\n<p>traverse 方法：</p>\n<pre><code class=\"lang-\">traverse(fn) {\n  let current = this.head\n  while(current !== null) {\n    fn(current)\n    current = current.next\n  }\n  return true\n}\n</code></pre>\n<p>有了上面 length 方法的遍历实现，traverse 也就不难理解了，它接受一个遍历执行函数，在 while 循环中进行调用。</p>\n<p>最后一个 search 方法：</p>\n<pre><code class=\"lang-\">search(item) {\n  let current = this.head\n  let counter = 0\n  \n  while( current ) {\n    if( current.data == item ) {\n      return counter\n    }\n    current = current.next\n    counter++\n  }\n  return false\n}\n</code></pre>\n<p>到此，我们就实现了所有 DoublyLinkedList 类双向链表的方法。仔细分析整个实现过程，可以发现：双向链表的实现并不复杂，在手写过程当中，需要开发者做到心中有表，考虑到当前节点的 next 和 prev 取值，逻辑上还是很简单的。</p>\n<p>掌握了这些内容，在回想一下链表的应用，回想 React Fiber 的设计和实现，也许一切都变的不再神秘。</p>\n<h3><a id=\"_517\"></a>树</h3>\n<p>前端开发者应该对树这个数据结构丝毫不陌生，不同于之前介绍的所有数据结构，树是非线性的。因为树决定了其存储的数据直接有明确的层级关系，因此对于维护具有层级特性的数据，树是一个天然良好的选择。</p>\n<p>在前面总领中，我们看到树有很多种分类，但是他们都具有以下特性：</p>\n<ul>\n<li>除了根节点以外，所有的节点都有一个父节点</li>\n<li>每一个节点都<strong>可以有</strong>若干子节点，如果没有子节点，那么称此节点为叶子节点</li>\n<li>一个节点所拥有的叶子节点的个数，称之为该节点的度，因此叶子节点的度为 0</li>\n<li>所有节点中，最大的度为整棵树的度</li>\n<li>树的最大层次称为树的深度</li>\n</ul>\n<p>从应用上来看，我们前端开发离不开的 DOM 就是一个树状结构；同理，不管是 React 还是 Vue 的虚拟 DOM 也都是树。</p>\n<p>我们从最基本的二叉树入手，来慢慢深入。</p>\n<h4><a id=\"_533\"></a>二叉搜索树的实现和遍历</h4>\n<p>说二叉树最为基本，因为他的结构最简单，每个节点至多包含两个子节点。二叉树又非常有用：因为根据二叉树，我们可以延伸出二叉搜索树（BST）、平衡二叉搜索树（AVL）、红黑树（R/B Tree）等。</p>\n<p>二叉搜索树有以下特性：</p>\n<ul>\n<li>左子树上所有结点的值均小于或等于它的根结点的值</li>\n<li>右子树上所有结点的值均大于或等于它的根结点的值</li>\n<li>左、右子树也分别为二叉搜索树</li>\n</ul>\n<p>根据其特性，我们实现二叉搜索树还是应该先构造一个节点类：</p>\n<pre><code class=\"lang-\">class Node { \n  constructor(data) { \n    this.left = null\n    this.right = null\n    this.value = data\n  } \n} \n</code></pre>\n<p>接着按照惯例，我们实现二叉搜索树的以下方法：</p>\n<ul>\n<li>insertNode：根据一个父节点，插入一个子节点</li>\n<li>insert：插入一个新节点</li>\n<li>removeNode：根据一个父节点，移除一个子节点</li>\n<li>remove：移除一个节点</li>\n<li>findMinNode：获取子节点的最小值</li>\n<li>searchNode：根据一个父节点，查找子节点</li>\n<li>search：查找节点</li>\n<li>preOrder：前序遍历</li>\n<li>InOrder：中序遍历</li>\n<li>PostOrder：后续遍历</li>\n</ul>\n<pre><code class=\"lang-\">insertNode(root, newNode) {\n  if (newNode.value &lt; root.value) {\n    (!root.left) ? root.left = newNode : this.insertNode(root.left, newNode)\n  } else {\n    (!root.right) ? root.right = newNode : this.insertNode(root.right, newNode)\n  }\n}\n  \ninsert(value) {\n    let newNode = new Node(value)\n    if (!this.root) {\n      this.root = newNode\n    } else {\n      this.insertNode(this.root, newNode)\n    }\n}\n</code></pre>\n<p>理解这两个方法是理解二叉搜索树的关键，下面的其他方法也就“不在话下”。我们看，insertNode 方法先判断目标父节点和插入节点的值，如果插入节点的值更小，则考虑放到父节点的左边，接着递归调用 his.insertNode(root.left, newNode)；如果插入节点的值更大，以此类推即可。</p>\n<p>insert 方法只是多了一步构造 Node 节点实例，接下来区分有无父节点的情况，调用 this.insertNode 方法即可。</p>\n<pre><code class=\"lang-\"> removeNode(root, value) {\n    if (!root) {\n      return null\n    }\n    \n    if (value &lt; root.value) {\n      root.left = this.removeNode(root.left, value)\n      return root\n    } else if (value &gt; root.value) {\n      root.right = tis.removeNode(root.right, value)\n      return root\n    } else {\n      // 找到了需要删除的节点 \n      // 如果当前 root 节点无左右子节点\n      if (!root.left &amp;&amp; !root.right) {\n        root = null\n        return root\n      }\n      \n      // 只有左节点\n      if (root.left &amp;&amp; !root.right) {\n        root = root.left\n        return root\n      } \n      // 只有右节点\n      else if (root.right) {\n        root = root.right\n        return root\n      }\n      \n      // 有左右两个子节点\n      let minRight = this.findMinNode(root.right)\n      root.value = minRight.value\n      root.right = this.removeNode(root.right, minRight.value)\n      return root\n    }\n  }\n  \nremove(value) {\n    if (this.root) {\n      this.removeNode(this.root, value)\n    }\n}\n</code></pre>\n<p>上述代码不难理解，可能最需要读者思考的就是：</p>\n<pre><code class=\"lang-\">// 有左右两个子节点\nlet minRight = this.findMinNode(root.right)\nroot.value = minRight.value\nroot.right = this.removeNode(root.right, minRight.value)\nreturn root\n</code></pre>\n<p>我来特殊说明一下：当需要删除的节点含有左右两个子节点时，因为我们要把当前节点删除，就需要找到合适的“补位”节点，这个“补位”节点一定在该目标节点的右侧树当中，因为这样才能保证“补位”节点的值一定大于该目标节点的左侧树所有节点，而该目标节点的左侧树不需要调整；同时为了保证“补位”节点的值一定要小于该目标节点的右侧树值，因此要找的“补位”节点其实就是该目标节点的右侧树当中最小的那个节点。</p>\n<p>这个过程我们借助 this.findMinNode 方法实现：</p>\n<pre><code class=\"lang-\">findMinNode(root) {\n    if (!root.left) {\n      return root\n    } else {\n      return this.findMinNode(root.left)\n    }\n}\n</code></pre>\n<p>该方法不断递归，直到找到最左叶子节点即可。</p>\n<p>查找方法：</p>\n<pre><code class=\"lang-\">searchNode(root, value) {\n    if (!root) {\n      return null\n    }\n    \n    if (value &lt; root.value) {\n      return this.searchNode(root.left, value)\n    } else if (value &gt; root.value) {\n      return this.searchNode(root.right, value)\n    }\n    \n    return root\n}\n\nsearch(value) {\n    if (!this.root) {\n      return false\n    }\n    return Boolean(this.searchNode(this.root, value))\n}\n</code></pre>\n<p>这也比较简单，其实就是对递归的运用。最能体现递归简便优势的其实是对于树的遍历：</p>\n<p>前序遍历：</p>\n<pre><code class=\"lang-\">preOrder(root) {\n\tif (root) {\n\t  console.log(root.value)\n\t  this.preOrder(root.left)\n\t  this.preOrder(root.right)\n\t}\n}\n</code></pre>\n<p>中序遍历：</p>\n<pre><code class=\"lang-\">inOrder(root) {\n\tif (root) {\n\t  this.inOrder(root.left)\n\t  console.log(root.value)\n\t  this.inOrder(root.right)\n\t}\n}\n</code></pre>\n<p>后序遍历：</p>\n<pre><code class=\"lang-\">postOrder(root) {\n\tif (root) {\n\t  this.postOrder(root.left)\n\t  this.postOrder(root.right)\n\t  console.log(root.value)\n\t}\n}\n</code></pre>\n<p>前后中序遍历其实就在于 console.log(root.value) 方法执行的位置。</p>\n<h4><a id=\"_728\"></a>字典树</h4>\n<p>字典树（Trie）是针对特定类型的搜索而优化的树数据结构。典型的例子是 autoComplete，也就是说它适合实现：通过部分值得到完整值的场景。字典树因此也是一种搜索树，我们有时候也叫做前缀树，因为任意一个节点的后代都存在共同的前缀。更多基础概念请读者先做了解。我们总结一下它的特点：</p>\n<ul>\n<li>字典树能做到高效查询和插入，时间复杂度为 O(k)，k 为字符串长度</li>\n<li>但是如果大量字符串没有共同前缀，那就很耗内存，读者可以想象一下最极端的情况，所有单词都没有共同前缀时，这颗字典树是什么样子</li>\n<li>字典树的核心就是减少没必要的字符比较，使查询高效率，也就是说用空间换时间，再利用共同前缀来提高查询效率</li>\n</ul>\n<p>除了我们刚刚提到的 autoComplete 自动填充的情况，字典树还有很多其他应用场景：</p>\n<ul>\n<li>搜索</li>\n<li>输入法选项</li>\n<li>分类</li>\n<li>IP 地址检索</li>\n<li>电话号码检索</li>\n</ul>\n<h4><a id=\"_744\"></a>字典树的实现和遍历</h4>\n<p>字典树的实现也不复杂，我们慢慢一步步来，首先实现一个字典树上的节点：</p>\n<pre><code class=\"lang-\">class PrefixTreeNode {\n  constructor(value) {\n    // 存储子节点\n    this.children = {}\n    this.isEnd = null\n    this.value = value\n  }\n}\n</code></pre>\n<p>一个字典树继承 PrefixTreeNode 类：</p>\n<pre><code class=\"lang-\">class PrefixTree extends PrefixTreeNode {\n  constructor() {\n    super(null)\n  }\n}\n</code></pre>\n<p>我们实现方法：</p>\n<ul>\n<li>addWord：创建一个字典树节点</li>\n<li>predictWord：给定一个字符串，返回字典树中以该字符串开头的所有单词</li>\n</ul>\n<p>addWord 实现：</p>\n<pre><code class=\"lang-\">addWord(str) {\n    const addWordHelper = (node, str) =&gt; {\n    \t  // 当前 node 不含当前 str 开头的目标\n        if (!node.children[str[0]]) {\n            // 以当前 str 开头的第一个字母，创建一个 PrefixTreeNode 实例\n            node.children[str[0]] = new PrefixTreeNode(str[0])\n            if (str.length === 1) {\n                node.children[str[0]].isEnd = true\n            } \n            else if (str.length &gt; 1) {\n                addWordHelper(node.children[str[0]], str.slice(1))\n            }\n        }\n    }\n    addWordHelper(this, str)\n}\n</code></pre>\n<p>predictWord 实现：</p>\n<pre><code class=\"lang-\">predictWord(str) {\n\tlet getRemainingTree = function(str, tree) {\n\t  let node = tree\n\t  while (str) {\n\t    node = node.children[str[0]]\n\t    str = str.substr(1)\n\t  }\n\t  return node\n\t}\n\t\n\t// 该数组维护所有以 str 开头的单词\n\tlet allWords = []\n\t    \n\tlet allWordsHelper = function(stringSoFar, tree) {\n\t  for (let k in tree.children) {\n\t    const child = tree.children[k]\n\t    let newString = stringSoFar + child.value\n\t    if (child.endWord) {\n\t      allWords.push(newString)\n\t    }\n\t    allWordsHelper(newString, child)\n\t  }\n\t}\n\t\n\tlet remainingTree = getRemainingTree(str, this)\n\t\n\tif (remainingTree) {\n\t  allWordsHelper(str, remainingTree)\n\t}\n\t\n\treturn allWords\n}\n</code></pre>\n<h3><a id=\"_832\"></a>图</h3>\n<p>图是由具有边的节点集合组成的数据结构，图可以是定向的或不定向的。因此图可以分为好多种类，这里不一一讲解，主要看图的应用场景：</p>\n<ul>\n<li>LBS 地图服务以及 GPS 系统</li>\n<li>社交媒体网站的用户关系图</li>\n<li>前端工程化中的开发依赖图</li>\n<li>搜索算法使用图，保证搜索结果的相关性</li>\n<li>寻找降低运输和交付货物和服务成本的最佳途径</li>\n</ul>\n<p>图也是应用最广泛的数据结构之一，真实场景中处处有图。更多概念还是需要读者先进行了解，尤其是图的几种基本元素：</p>\n<ul>\n<li>节点 Node</li>\n<li>边 Edge</li>\n<li>|V| 图中顶点（节点）的总数</li>\n<li>|E| 图中的连接总数（边）</li>\n</ul>\n<h4><a id=\"_849\"></a>图的实现和遍历</h4>\n<p>这里我们主要实现一个有向图，Graph 类：</p>\n<pre><code class=\"lang-\">class Graph {\n  constructor() {\n    this.AdjList = new Map()\n  }\n}\n</code></pre>\n<p>使用 Map 数据结构表述图中顶点关系。</p>\n<p>实现方法：</p>\n<ul>\n<li>添加顶点：addVertex</li>\n<li>添加边：addEdge</li>\n<li>打印图：print</li>\n<li>广度优先算法遍历</li>\n<li>深度优先算法</li>\n</ul>\n<p>addVertex 方法：</p>\n<pre><code class=\"lang-\">addVertex(vertex) {\n  if (!this.AdjList.has(vertex)) {\n    this.AdjList.set(vertex, [])\n  } else {\n    throw &apos;vertex already exist!&apos;\n  }\n}\n</code></pre>\n<p>创建顶点：</p>\n<pre><code class=\"lang-\">let graph = new Graph();\ngraph.addVertex(&apos;A&apos;)\ngraph.addVertex(&apos;B&apos;)\ngraph.addVertex(&apos;C&apos;)\ngraph.addVertex(&apos;D&apos;)\n</code></pre>\n<p>其中 A、B、C、D 顶点都对应一个数组：</p>\n<pre><code class=\"lang-\">  &apos;A&apos; =&gt; [],\n  &apos;B&apos; =&gt; [],\n  &apos;C&apos; =&gt; [],\n  &apos;D&apos; =&gt; []\n</code></pre>\n<p>该数组将用来存储边。我们设计图预计得到如下关系：</p>\n<pre><code class=\"lang-\">Map {\n  &apos;A&apos; =&gt; [&apos;B&apos;, &apos;C&apos;, &apos;D&apos;],\n  &apos;B&apos; =&gt; [],\n  &apos;C&apos; =&gt; [&apos;B&apos;],\n  &apos;D&apos; =&gt; [&apos;C&apos;]\n}\n</code></pre>\n<p>根据此描述，其实已经可以把图画出来了。addEdge 因此需要两个参数：一个是顶点，一个是连接对象 Node：</p>\n<pre><code class=\"lang-\"> addEdge(vertex, node) {\n    if (this.AdjList.has(vertex)) {\n      if (this.AdjList.has(node)){\n        let arr = this.AdjList.get(vertex)\n        if(!arr.includes(node)){\n          arr.push(node)\n        }\n      }else {\n        throw `Can&apos;t add non-existing vertex -&gt;&apos;${node}&apos;`\n      }\n    } else {\n      throw `You should add &apos;${vertex}&apos; first`\n    }\n}\n</code></pre>\n<p>理清楚数据关系，我们就可以打印图了，其实就是一个很简单的 for…of 循环：</p>\n<pre><code class=\"lang-\">print() {\n  for (let [key, value] of this.AdjList) {\n    console.log(key, value)\n  }\n}\n</code></pre>\n<p>剩下的内容就是遍历图了。</p>\n<p>广度优先算法（BFS），是一种利用队列实现的搜索算法。对于图，其搜索过程和 “湖面丢进一块石头激起层层涟漪” 类似。换成算法语言，就是从起点出发，对于每次出队列的点，都要遍历其四周的点。</p>\n<p>因此 BFS 的实现步骤：</p>\n<ul>\n<li>起始节点作为起始，并初始化一个空对象：visited</li>\n<li>初始化一个空数组，该数组将模拟一个队列</li>\n<li>将起始节点标记为已访问</li>\n<li>将起始节点放入队列中</li>\n<li>循环直到队列为空</li>\n</ul>\n<p>实现：</p>\n<pre><code class=\"lang-\">createVisitedObject() {\n  let map = {}\n  for(let key of this.AdjList.keys()) {\n    arr[key] = false\n  }\n  return map\n}\n\nbfs(initialNode) {\n  // 创建一个已访问节点的 map\n  let visited = this.createVisitedObject()\n  // 模拟一个队列\n  let queue = []\n\n  // 第一个节点已访问\n  visited[initialNode] = true\n  // 第一个节点入队列\n  queue.push(initialNode)\n\n  while(queue.length) {\n    let current = queue.shift()\n    console.log(current)\n\n\t // 获得该节点的其他节点关系\n    let arr = this.AdjList.get(current)\n\n    for (let elem of arr) {\n      // 如果当前节点没有访问过\n      if (!visited[elem]) {\n        visited[elem] = true\n        q.push(elem)\n      }\n    }\n  }\n}\n</code></pre>\n<p>那么对于深度优先搜索算法（DFS），我把它总结为：“不撞南墙不回头”，从起点出发，先把一个方向的点都遍历完才会改变方向。换成程序语言就是：“DFS 是利用递归实现的搜索算法”。</p>\n<p>因此 DFS 过程：</p>\n<ul>\n<li>起始节点作为起始，创建访问对象</li>\n<li>调用辅助函数递归起始节点</li>\n</ul>\n<p>实现代码：</p>\n<pre><code class=\"lang-\">createVisitedObject() {\n  let map = {}\n  for (let key of this.AdjList.keys()) {\n    arr[key] = false\n  }\n  return map\n}\n\n dfs(initialNode) {\n    let visited = this.createVisitedObject()\n    this.dfsHelper(initialNode, visited)\n  }\n\n  dfsHelper(node, visited) {\n    visited[node] = true\n    console.log(node)\n\n    let arr = this.AdjList.get(node)\n\n    for (let elem of arr) {\n      if (!visited[elem]) {\n        this.dfsHelper(elem, visited)\n      }\n    }\n  }\n}\n</code></pre>\n<p>BFS 的重点在于队列，而 DFS 的重点在于递归，这是它们的本质区别。</p>\n<h4><a id=\"_1034\"></a>图在前端中的应用</h4>\n<p>图其实在前端中应用不算特别多，但绝对还是不容忽视的一部分。这里我举一个我现实中应用的例子——循环图。</p>\n<p>在前端工程化发展的今天，理清项目中的依赖关系：比如查找项目中的循环依赖，可视化依赖都是图的应用，有助于开发者在宏观上把控工程化项目。在我们的项目中，我借助 <a href=\"https://mermaidjs.github.io/#/\" target=\"_blank\">mermaidj</a> 画图工具，实现了项目依赖的完全可视化。并借助 npm script 来生成图片结果，相关 script 脚本：</p>\n<pre><code class=\"lang-\">yarn graph\n</code></pre>\n<p>脚本：</p>\n<pre><code class=\"lang-\">import glob from &apos;glob&apos;\nimport readJSON from &apos;XXX/utils/readJSON&apos;\n\nconst pkgs = glob.sync(&apos;packages/*/package.json&apos;).map(readJSON)\n\nconst deps = {}\n\nfor (const pkg of pkgs) {\n  deps[pkg.name] = Object.keys(pkg.dependencies || []).filter(dep =&gt;\n    // ...\n  )\n}\n\nconst graph = { code: &apos;&apos;, mermaid: { theme: &apos;default&apos; } }\n\ngraph.code += &apos;graph TD;&apos;\nfor (const name in deps) {\n  for (const dep of deps[name]) {\n    graph.code += `${name}--&gt;${dep};`\n  }\n}\n\nconst base64 = Buffer.from(JSON.stringify(graph)).toString(&apos;base64&apos;)\n\n/* eslint-disable-next-line */\nconsole.log(\n  `Open in browser: https://mermaidjs.github.io/mermaid-live-editor/#/edit/${base64}`\n)\n</code></pre>\n<p>上述代码，我首先获取到 packages/*/package.json 中声明的所有依赖，然后对依赖进行必要性过滤之后，维护到 deps 对象当中，按照 mermaid 需求，将 monorepo 项目中的每一个子项目名和依赖按照 → 的间隔维护为 graph.code，最后通过生成 base64 交给 mermaid 进行绘图，绘图过程会根据约定（→ 的标记），成生可视化的依赖图。</p>\n<p>最终效果：</p>\n<p><img src=\"https://images.gitbook.cn/d92587a0-d04f-11e9-82a1-439033eb1f8a\" alt=\"enter image description here\" /></p>\n<p>那么 mermaid 是如何对图进行绘制的呢？了解了课程前面实现图的代码，我们再看 mermaid 绘制图的部分源码实现：</p>\n<pre><code class=\"lang-\">export const addVertices = function (vert, g, svgId) {\n  const svg = d3.select(`[id=&quot;${svgId}&quot;]`)\n  const keys = Object.keys(vert)\n\n  const styleFromStyleArr = function (styleStr, arr) {\n    // Create a compound style definition from the style definitions found for the node in the graph definition\n    for (let i = 0; i &lt; arr.length; i++) {\n      if (typeof arr[i] !== &apos;undefined&apos;) {\n        styleStr = styleStr + arr[i] + &apos;;&apos;\n      }\n    }\n\n    return styleStr\n  }\n\n  // Iterate through each item in the vertex object (containing all the vertices found) in the graph definition\n  keys.forEach(function (id) {\n    const vertex = vert[id]\n\n    /**\n     * Variable for storing the classes for the vertex\n     * @type {string}\n     */\n    let classStr = &apos;&apos;\n    if (vertex.classes.length &gt; 0) {\n      classStr = vertex.classes.join(&apos; &apos;)\n    }\n\n    /**\n     * Variable for storing the extracted style for the vertex\n     * @type {string}\n     */\n    let style = &apos;&apos;\n    // Create a compound style definition from the style definitions found for the node in the graph definition\n    style = styleFromStyleArr(style, vertex.styles)\n\n    // Use vertex id as text in the box if no text is provided by the graph definition\n    let vertexText = vertex.text !== undefined ? vertex.text : vertex.id\n\n    // We create a SVG label, either by delegating to addHtmlLabel or manually\n    let vertexNode\n    if (conf.htmlLabels) {\n      // TODO: addHtmlLabel accepts a labelStyle. Do we possibly have that?\n      const node = { label: vertexText.replace(/fa[lrsb]?:fa-[\\w-]+/g, s =&gt; `&lt;i class=&apos;${s.replace(&apos;:&apos;, &apos; &apos;)}&apos;&gt;&lt;/i&gt;`) }\n      vertexNode = addHtmlLabel(svg, node).node()\n      vertexNode.parentNode.removeChild(vertexNode)\n    } else {\n      const svgLabel = document.createElementNS(&apos;http://www.w3.org/2000/svg&apos;, &apos;text&apos;)\n\n      const rows = vertexText.split(/&lt;br[/]{0,1}&gt;/)\n\n      for (let j = 0; j &lt; rows.length; j++) {\n        const tspan = document.createElementNS(&apos;http://www.w3.org/2000/svg&apos;, &apos;tspan&apos;)\n        tspan.setAttributeNS(&apos;http://www.w3.org/XML/1998/namespace&apos;, &apos;xml:space&apos;, &apos;preserve&apos;)\n        tspan.setAttribute(&apos;dy&apos;, &apos;1em&apos;)\n        tspan.setAttribute(&apos;x&apos;, &apos;1&apos;)\n        tspan.textContent = rows[j]\n        svgLabel.appendChild(tspan)\n      }\n      vertexNode = svgLabel\n    }\n\n    // If the node has a link, we wrap it in a SVG link\n    if (vertex.link) {\n      const link = document.createElementNS(&apos;http://www.w3.org/2000/svg&apos;, &apos;a&apos;)\n      link.setAttributeNS(&apos;http://www.w3.org/2000/svg&apos;, &apos;href&apos;, vertex.link)\n      link.setAttributeNS(&apos;http://www.w3.org/2000/svg&apos;, &apos;rel&apos;, &apos;noopener&apos;)\n      link.appendChild(vertexNode)\n      vertexNode = link\n    }\n\n    let radious = 0\n    let _shape = &apos;&apos;\n    // Set the shape based parameters\n    switch (vertex.type) {\n      case &apos;round&apos;:\n        radious = 5\n        _shape = &apos;rect&apos;\n        break\n      case &apos;square&apos;:\n        _shape = &apos;rect&apos;\n        break\n      case &apos;diamond&apos;:\n        _shape = &apos;question&apos;\n        break\n      case &apos;odd&apos;:\n        _shape = &apos;rect_left_inv_arrow&apos;\n        break\n      case &apos;lean_right&apos;:\n        _shape = &apos;lean_right&apos;\n        break\n      case &apos;lean_left&apos;:\n        _shape = &apos;lean_left&apos;\n        break\n      case &apos;trapezoid&apos;:\n        _shape = &apos;trapezoid&apos;\n        break\n      case &apos;inv_trapezoid&apos;:\n        _shape = &apos;inv_trapezoid&apos;\n        break\n      case &apos;odd_right&apos;:\n        _shape = &apos;rect_left_inv_arrow&apos;\n        break\n      case &apos;circle&apos;:\n        _shape = &apos;circle&apos;\n        break\n      case &apos;ellipse&apos;:\n        _shape = &apos;ellipse&apos;\n        break\n      case &apos;group&apos;:\n        _shape = &apos;rect&apos;\n        break\n      default:\n        _shape = &apos;rect&apos;\n    }\n    // Add the node\n    g.setNode(vertex.id, { labelType: &apos;svg&apos;, shape: _shape, label: vertexNode, rx: radious, ry: radious, &apos;class&apos;: classStr, style: style, id: vertex.id })\n  })\n}\n\n/**\n * Add edges to graph based on parsed graph defninition\n * @param {Object} edges The edges to add to the graph\n * @param {Object} g The graph object\n */\nexport const addEdges = function (edges, g) {\n  let cnt = 0\n\n  let defaultStyle\n  if (typeof edges.defaultStyle !== &apos;undefined&apos;) {\n    defaultStyle = edges.defaultStyle.toString().replace(/,/g, &apos;;&apos;)\n  }\n\n  edges.forEach(function (edge) {\n    cnt++\n    const edgeData = {}\n\n    // Set link type for rendering\n    if (edge.type === &apos;arrow_open&apos;) {\n      edgeData.arrowhead = &apos;none&apos;\n    } else {\n      edgeData.arrowhead = &apos;normal&apos;\n    }\n\n    let style = &apos;&apos;\n    if (typeof edge.style !== &apos;undefined&apos;) {\n      edge.style.forEach(function (s) {\n        style = style + s + &apos;;&apos;\n      })\n    } else {\n      switch (edge.stroke) {\n        case &apos;normal&apos;:\n          style = &apos;fill:none&apos;\n          if (typeof defaultStyle !== &apos;undefined&apos;) {\n            style = defaultStyle\n          }\n          break\n        case &apos;dotted&apos;:\n          style = &apos;stroke: #333; fill:none;stroke-width:2px;stroke-dasharray:3;&apos;\n          break\n        case &apos;thick&apos;:\n          style = &apos;stroke: #333; stroke-width: 3.5px;fill:none&apos;\n          break\n      }\n    }\n    edgeData.style = style\n\n    if (typeof edge.interpolate !== &apos;undefined&apos;) {\n      edgeData.curve = interpolateToCurve(edge.interpolate, d3.curveLinear)\n    } else if (typeof edges.defaultInterpolate !== &apos;undefined&apos;) {\n      edgeData.curve = interpolateToCurve(edges.defaultInterpolate, d3.curveLinear)\n    } else {\n      edgeData.curve = interpolateToCurve(conf.curve, d3.curveLinear)\n    }\n\n    if (typeof edge.text === &apos;undefined&apos;) {\n      if (typeof edge.style !== &apos;undefined&apos;) {\n        edgeData.arrowheadStyle = &apos;fill: #333&apos;\n      }\n    } else {\n      edgeData.arrowheadStyle = &apos;fill: #333&apos;\n      if (typeof edge.style === &apos;undefined&apos;) {\n        edgeData.labelpos = &apos;c&apos;\n        if (conf.htmlLabels) {\n          edgeData.labelType = &apos;html&apos;\n          edgeData.label = &apos;&lt;span class=&quot;edgeLabel&quot;&gt;&apos; + edge.text + &apos;&lt;/span&gt;&apos;\n        } else {\n          edgeData.labelType = &apos;text&apos;\n          edgeData.style = edgeData.style || &apos;stroke: #333; stroke-width: 1.5px;fill:none&apos;\n          edgeData.label = edge.text.replace(/&lt;br&gt;/g, &apos;\\n&apos;)\n        }\n      } else {\n        edgeData.label = edge.text.replace(/&lt;br&gt;/g, &apos;\\n&apos;)\n      }\n    }\n    // Add the edge to the graph\n    g.setEdge(edge.start, edge.end, edgeData, cnt)\n  })\n}\n</code></pre>\n<p><strong>那么根据我的脚本，用 → 表现的依赖关系，除了可视化以外，还有其他用处吗？</strong> 其实肯定是有的，除了“花架子”，这个依赖图对于项目的部署构建也有非常重要的作用。比如在对 monorepo 项目进行构建时，因为子项目过多，导致构建时间过长。为此，我给出的方案是增量构建，如果这次改动只设计项目 A、项目 B，以及公共依赖 C，那么项目 C，项目 D 等其他项目在构建时只需要读取缓存构建结果即可。思路是很简单，但是一个直接问题是，如果检测说真正需要构建的项目呢？</p>\n<p>举个例子，项目 A 依赖公共依赖 C，那么及时通过 git hook 拿到的 diff 表明项目 A 并没有代码变动，但是可能因为 C 变了，我们还需要重新构建项目 A（因为 A 依赖 C）。按照正常的思路，需要遍历整个项目，这样带来的问题是增加了回溯构建的可能：构建时先遍历到 A，读取缓存，再遍历到 C 时，不得不回退到 A，重新构建。解决思路就是使用一个拓扑图，根据拓扑图，按照一定的顺序进行遍历和编译构建即可。</p>\n<p>这是我近期一个使用到拓扑图数据结构的经典场景。具体实施过程因为机密性，我不在贴代码了，对于读者来说，更重要地是体会思想，相信自己动手实现也不会困难。</p>\n<h3><a id=\"_1293\"></a>散列表（哈希表）</h3>\n<p>散列表是一种以 key-value 形式存储数据的数据结构，可以把散列表理解为一种高级的数组，这种数组的下标可以是很大的整数，浮点数，字符串甚至结构体。这种数据结构非常有用，js 里的 Map/Set/WeakMap/WeakSet 在 v8 里都是通过散列表来实现的，再比如 LRU Cache、数据库索引等非常多的场景也都能看到散列表的身影。</p>\n<p>散列并不仅仅是一种技术，从某种意义上讲，它甚至是一种思想。接下来让我们一起揭开散列表神秘的面纱。</p>\n<p>假如，我们要存储 key 为 6、2019、2333333 的三组数据，如果用数组来存，至少需要一个长度为 2333333 的数组来做这件事情，显然这种做法存在大量的空间浪费。</p>\n<p>我们也可以像下图一样，准备一个长度为 10 的数组（bucket array），将每一个 key 通过一个散列函数（hash function），映射到桶数组中的一位，将 key 相应的值直接存入即可。可以看到这种方式只需使用一个长度为 10 的数组，同时查找和插入的时间复杂度都是 O(1)。这就是散列表的核心思想。</p>\n<img src=\"https://images.gitbook.cn/52397840-c57e-11e9-9d70-f58ea827d9ae\" width = \"70%\" />\n<p>散列表中的几个概念：</p>\n<ul>\n<li>桶（bucket），用来直接存放或间接指向一个数据</li>\n<li>桶数组（bucket array）由桶组成的数组</li>\n<li>散列函数（hash function）将 key 转换为桶数组下标的函数</li>\n</ul>\n<p>上面的例子比较简单，如果我们继续在之前的基础上再存储一个 key 为 9 的数据，通过 9 % 10 计算得出的也是落在下标为 9 的 bucket 上，此时有两个不同的 key 落在了同一个 bucket 上，这一现象被称为散列冲突。</p>\n<p>散列冲突理论上是不可避免的，我们能做的优化主要从以下两个方面入手：</p>\n<ul>\n<li>精心设计桶数组长度及散列函数，尽可能降低冲突的概率</li>\n<li>发生冲突时，能对冲突进行排解</li>\n</ul>\n<p>假设不用散列表直接用数组来存储需要的数组长度为 R，用散列表存储需要的桶数组长度为 M，需要存储的元素个数为 N，则一定存在以下关系 <code>N &lt; M &lt;&lt; R</code>，只有这样散列表才能既保持操作的高效同时起到节省空间的效果。</p>\n<p>其中，N / M 称为散列表的装载因子，当装载因子超过一定的阈值时，需要对桶数组扩容并 rehash。</p>\n<p>理想的散列函数遵循以下的设计原则：</p>\n<ul>\n<li>确定：同一 key 总是被映射至同一地址</li>\n<li>高效：插入/查找/删除 excepted-O(1) 时间复杂度</li>\n<li>满射：尽可能充分地覆盖整个桶数组空间</li>\n<li>均匀：key 映射到桶数组各位置的概率尽量接近</li>\n</ul>\n<p>常用的散列函数如下。</p>\n<p><strong>除余法</strong></p>\n<p><code>hash(key) = key % M</code>，直接对 key 按桶数组的长度取余，这种方法非常简单，但存在以下缺陷。</p>\n<ul>\n<li>存在不动点：无论桶数组长度 M 取何值，总有 <code>hash(0) = 0</code>，这与任何元素都有均等的概率被映射到任何位置的原则相违背。</li>\n<li>零阶均匀：<code>[0, R)</code> 的关键码，平均分配至 M 个桶；但相邻关键码的散列地址也必相邻。</li>\n</ul>\n<p><strong>MAD 法 multiply-add-divide</strong></p>\n<p><code>hash(key) = (a x key + b) % M</code>，跟除余法相比，引入的变量 b 可以视作偏移量，可有效的消除不动点，另一个变量 a 扮演着步长的角色，也就是说原本相邻的关键码在经过散列后步长为 a，从而不再继续相邻。</p>\n<p><strong>平方取中 mid-square</strong></p>\n<p>取 <code>key^2</code> 的中间若干位，构成地址：</p>\n<ul>\n<li><code>hash(123) = 512</code> // 保留 key^2 = 123^2 = 15219 的中间 3 位</li>\n<li><code>hash(1234567) = 556</code> // 1234567^2 = 1524155677489</li>\n</ul>\n<p>我们可以将一个数的平方运算，分解为一系列的左移操作以及若干次加法，从下图中不难看出，每一个数位都是由原关键码中的若干数位经求和得到的，因此两侧的数位由更少的原数位求和而得，越是居中的数位，则是由更多的原数位积累而得，因此截取居中的若干位，可使得原关键码的各数位都能对最终结果产生影响，从而实现更好的均匀性</p>\n<img src=\"https://images.gitbook.cn/c06093f0-c71b-11e9-9e56-8d3dec542204\" width = \"70%\" />\n<p><strong>多项式法</strong></p>\n<p>在实际应用中，我们的 key 不一定都是整数形式，因此往往需要一个预处理将其转换为散列码(hashcode)，然后才可以对其进一步处理为桶数组的下标地址。整个过程可以描述为 key → hashcode → bucket addr，多项式法就是一种有效的将字符串 key 转换为 hashcode 的方法<br />\n对于一个长度为 n 的字符串，其计算过程如下：</p>\n<pre><code class=\"lang-\">hash(x0 x1 ... xn-1) = x0 * a^(n-1) + x1 * a^(n-2) ... + xn-2 * a + xn-1 \n// 如果上面的不是很理解，它其实等价于下面这样\n(...((x0 * a + x1) * a + x2) * a + ... xn-2) * a + xn-1)\n</code></pre>\n<p>这个多项式可以在 O(n) 而不是 O(n2) 的时间复杂度内计算出结果，具体证明的过程这里就不详细展开了。</p>\n<p>在实际的工程中会采用如下这种近似多项式，但更快捷的做法：</p>\n<pre><code class=\"lang-\">function hash(key) {\n    let h = 0\n    for (let n = key.length, i = 0; i != n; i++) {\n        h = (h &lt;&lt; 5 | h &gt;&gt; 27)\n        h += key[i].charCodeAt()\n    }\n    return h &gt;&gt;&gt; 0\n}\n</code></pre>\n<p>通过一个循环依次处理字符串的每一个字符，对于每一个字符将它转换为整数后累加，在累加之前对原有的累积值，都按照 h &lt;&lt; 5 | h &gt;&gt; 27 这样的规则做一个数位变换</p>\n<p><img src=\"https://images.gitbook.cn/81040300-c747-11e9-a05e-8fabd2e19d71\" alt=\"bit-operations\" /></p>\n<p>这一不断调整累加的过程，实际上可以是作为是对以上多项式计算的近似，只不过这里消除掉了相对耗时的乘法运算，至于如何理解和解释这种近似的效果，可以作为本文课后的一项作业。</p>\n<p>除了上文讲到的方法外，还有非常多的散列函数的方法，如折叠法、位异或法、（伪）随机数法，此类方法林林总总，每种方法都有各自的特点及应用的场景，由于篇幅原因这里就不再展开了，感兴趣的读者可以在读者群中继续研究和探讨。</p>\n<p>总之散列函数产生的关键码越是随机，越是没有规律就越好。</p>\n<p><strong>冲突解决方法</strong></p>\n<p>主要的处理散列表冲突的方法有开链法和探测法这两类。</p>\n<ul>\n<li><strong>开链法（linked-list chaining / seperate chaining）</strong></li>\n</ul>\n<p>每个桶存放一个指针，将冲突的 key 以链表的形式组织起来，这种处理方式最大的优点是能解决任意次数的冲突，但缺点也很明显，最极端的情况所有的 key 数据都落在一个桶上时，散列表将退化为一个链表，查找插入删除的复杂度都将变成 O(n)。</p>\n<img src=\"https://images.gitbook.cn/23cf29b0-c749-11e9-9e56-8d3dec542204\" width = \"35%\" />\n<ul>\n<li><strong>探测法（open addressing / closed hashing）</strong></li>\n</ul>\n<p>探测法所有的冲突都在这块连续的空间中加以排解，而不用像开链法那样申请额外的空间。当存入一个 key 时，所有的桶都按照某种优先级关系排成一个序列，从本该属于该 key 的桶出发，顺次查看每一个桶直到找到可用的桶。每个 key 对应的这样的一个序列，称为试探序列或者查找链，在查找 key 时，沿查找链查找有两种结果，在桶中找到了查询的 key 也就是查找成功，还有的一种可能是找到一个空桶，则说明查找失败，没有这个 key。</p>\n<p>最简单的试探序列的生成方法叫做线性试探（Linear probing），具体做法是一旦发生冲突，则试探后一个紧邻的桶单元，直到成功或失败。这种做法的优点是无需附加的（指针、链表等）空间，缺点也很明显，以往的冲突会导致后续的冲突。</p>\n<pre><code class=\"lang-\">[hash(key) + 1] % M\n[hash(key) + 2] % M\n[hash(key) + 3] % M\n...\n</code></pre>\n<p>线性试探的问题根源在于大部分的试探位置都集中在某一个相对较小的局部，因此优化线性试探的方式就是适当的拉开各次探测的间距，平方试探（Quadratic Probing）就是基于这一优化思路的具体实现方式，所谓平方试探顾名思义就是以平方数为距离，确定下一试探桶单元。</p>\n<pre><code class=\"lang-\">[hash(key) + 1^2] % M\n[hash(key) + 2^2] % M\n[hash(key) + 3^2] % M\n...\n</code></pre>\n<p>相对于线性试探，平方探测的确可以在很大程度上缓解数据聚集的现象，查找链上，各桶间距线性递增，一旦冲突，可从没地逃离是非之地。</p>\n<h3><a id=\"_1423\"></a>散列表的实现</h3>\n<p>最后用 JavaScript 来模拟实现一下 hashtable，这里我们采用开链法来解决散列的冲突。</p>\n<pre><code class=\"lang-\">// 单向链表节点\nclass ForwardListNode {\n    constructor(key, value) {\n        this.key = key\n        this.value = value\n        this.next = null\n    }\n}\n\nclass Hashtable {\n  constructor(bucketSize = 97) {\n    this._bucketSize = bucketSize\n    this._size = 0\n    this._buckets = new Array(this._bucketSize)\n  }\n\n  hash(key) {\n    let h = 0\n    for (let n = key.length, i = 0; i != n; i++) {\n      h = (h &lt;&lt; 5 | h &gt;&gt; 27)\n      h += key[i].charCodeAt()\n    }\n    return (h &gt;&gt;&gt; 0) % this._bucketSize\n  }\n\n  // Modifiers\n  put(key, value){\n    let index = this.hash(key);\n    let node = new ForwardListNode(key, value)\n\n    if (!this._buckets[index]) {\n      // 如果桶是空的，则直接把新节点放入桶中即可\n      this._buckets[index] = node\n    } else {\n      // 如果桶不为空，则在链表头插入新节点\n      node.next = this._buckets[index]\n      this._buckets[index] = node\n    }\n    this._size++\n    return index\n  }  \n\n  delete(key) {\n    let index = this.hash(key)\n    if (!this._buckets[index]) {\n      return false\n    }\n\n    // 添加一个虚拟头节点，方便后面的删除操作\n    let dummy = new ForwardListNode(null, null)\n    dummy.next = this._buckets[index]\n    let cur = dummy.next, pre = dummy\n    while (cur) {\n      if (cur.key === key) {\n        // 从链表删除该节点\n        pre.next = cur.next\n        cur = pre.next\n        this._size--\n      } else {\n        pre =  cur\n        cur = cur.next\n      }\n    }\n    this._buckets[index] = dummy.next\n    return true\n  }\n\n  // Lookup\n  find(key){\n    let index = this.hash(key);\n    // 如果对应的 bucket 为空，说明不存在此 key\n    if (!this._buckets[index]) {\n      return null\n    }\n    \n    // 遍历对应桶的链表\n    let p = this._buckets[index]\n    while (p) {\n      // 找到 key\n      if (p.key === key) {\n        return p.value\n      }\n      p = p.next\n    }\n    return null\n  } \n\n  // Capacity\n  size() {\n      return this._size\n  }\n\n  isEmpty() {\n      return this._size == 0\n  }\n}\n</code></pre>\n<h3><a id=\"_1526\"></a>总结</h3>\n<p>这一节课我们介绍了和前端最为贴合的几种数据结构，虽然篇幅较长，但是内容算不上太难。一些基本概念并没有深入讲解， 因为数据结构更重要的是应用，我希望读者能够做到的是：在需要的场景，能够想到最为适合的数据结构处理问题。请读者务必掌握好这些内容，接下来的算法章节需要对数据结构有一个较为熟练地掌握和了解。</p>\n","createdAt":"2019-04-21T04:46:06.598Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":39,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FoThASW9dVEPMEo9nP-zaOfbKyLZ"},{"_id":"5cbbf5a1bbbba80861a35c71","communication_start_time":null,"type":1,"audioPath":"","abstract":"","content":"函数式这个概念我们在以往的课程中其实已经有所涉及了，比如第 1-2、1-3 课介绍的闭包知识；比如 1-4 课《我们不背诵 API，只实现 API》中剖析的 5 种 compose 方法，以及 reduce 实现 pipe、runPromiseInSequence 等都是典型的函数式概念。\n\n函数式其实很早就出现在了编程领域当中，近些年由于 React 的带动，在前端开发中重新“焕发活力”。\n\n很多读者可能一听到函数式就眉头一皱，毕竟相比于面向对象等其他编程概念，它更加晦涩难懂。对于函数式的学习，也一定不是使用或者模仿 compose 那么简单。这一节课，我们就来梳理几个函数式概念。但是我认为单纯的概念介绍并没有意义，因此也准备了大量实战例题以及库的设计方案，与大家一起分享。\n\n![enter image description here](https://images.gitbook.cn/bbd9d5a0-d448-11e9-a4b6-d1d2b628f523)\n\n### 函数式和高质量函数\n\n函数式通常意味着高质量的代码，本小节的主标题之所以是“函数式和高质量函数”，而不是“函数式和高质量代码”，因为在函数式看来，一切都是函数，“函数是第一等公民”。围绕着函数，取代面向过程式的代码，往往能够有以下收益：\n\n- **表达力更加清晰**，因为“一切都是函数”，通过函数的合理命名，函数原子的拆分，我们能够一眼看出来程序在做什么，以及做的过程；\n- **利于复用**，因为“一切都是函数”，函数本身具有天然的复用能力；\n- **利于维护**，纯函数和幂等性保证同样的输入就有同样的输出，在维护或者调试代码时，能够更加专注，减少因为共享带来的潜在问题。\n\n我们下面来通过概念具体展开。\n\n#### 纯函数\n\n之前我们提到过：\n\n> 一个函数如果输入参数确定，输出结果是唯一确定的，那么它就是纯函数。\n\n并且纯函数不能修改外部变量，造成副作用，不能调用 Math.radom() 方法以及发送异步请求等，因为这些操作都不具有确定性。\n\n根据定义我们知道纯函数的特点是：\n\n- 无状态\n- 无副作用\n- 无关时序\n- 幂等（指无论调用多少次，结果相同）\n\n看代码举例：\n\n```\nlet array = [1,2,3,4]\n\n// array 的 slice 方法属于纯函数方法，它不对数组本身进行操作\n// array 的 splice 方法不属于纯函数方法，它对数组本身进行操作 \n\nconst minusCount = () => {\n\twindow.count--\n} \n\n// minusCount 不是纯函数，它依赖并改变外部变量，具有副作用\n\nconst setHtml = (node, html) => {\n\tnode.innerHtml = html\n} \n\n// setHtml 不是纯函数，同上                                                     \n```\n\n这样的纯函数不仅易于维护，逻辑清晰，而且具有更好的组合和测试性。之前的课程中我们多次提到，这里不再单独展开。\n\n#### 高阶函数\n\n高阶函数体现了“函数是第一等公民”，它是指这样的一类函数：该函数接受一个函数作为参数，返回另外一个函数。\n\n没错，和高阶组件的概念类似。为什么会有这么一个“怪异”的高阶函数呢？来看一个例子：filterLowerThan10 这个函数接受一个数组作为参数，它会挑选出数组中数值小于 10 的项目，所有符合条件的值都会构成新数组被返回：\n\n```\nconst filterLowerThan10 = array => {\n\tlet result = []\n\tfor (let i = 0, length = array.length; i < length; i++) {\n\t\tlet currentValue = array[i]\n\t\tif (currentValue < 10) result.push(currentValue)\n\t}\n\treturn result\n}\n```\n\n另外一个需求，挑选出数组中非数值项目，所有符合条件的值都会构成新数组被返回：\n\n```\nconst filterNaN = array => {\n\tlet result = []\n\tfor (let i = 0, length = array.length; i < length; i++) {\n\t\tlet currentValue = array[i]\n\t\tif (isNaN(currentValue)) result.push(currentValue)\n\t}\n\treturn result\n}\n```\n\n这都是很基本的面向过程编程的代码。不够优雅的一点是 filterLowerThan10 和 filterNaN 都有遍历的逻辑，都存在了重复的 for 循环。本质上都是遍历一个列表，并用给定的条件过滤列表。我们能否用函数式的思想，将遍历和筛选解耦呢？\n\n好在 JavaScript 对函数式较为友好，我们使用 filter 函数来完成，并进行一定程度的改造：\n\n```\nconst lowerThan10 = value => value < 10\n\n[12, 3, 4, 89].filter(lowerThan10)\n\n[12, &apos;sd&apos;, null, undefined, {}].filter(isNaN)\n```\n\n这非常简单，我们以此来热身进入状态。\n\n另一个高阶函数的典型应用场景是函数缓存：\n\n```\nconst memorize = fn => {\n    let cacheMap = {}\n    return function(...args) {\n    \tconst cacheKey = args.join(&apos;_&apos;)\n        if (cacheKey in cacheMap) {\n            return cache[cacheKey]\n        } \n        else {\n            return cacheMap[cacheKey] = fn.apply(this || {}, args)\n        }\n    }\n}\n```\n\n高阶函数可以和 decorator 相结合，再来看一个实例，实现有限次数函数调用的装饰器：\n \n```\n class MyClass {\n    @callLimit getSum() {}\n}\n```\n\n实现：\n\n```\nfunction callLimit(limitCallCount = 1, level = &apos;warn&apos;) {\n\t// 记录调用次数\n    let count = 0\n    return function(target, name, descriptor) {\n    \t// 记录原始函数\n        var fn = descriptor.value\n        // 改写新函数\n        descriptor.value = function(...args) {\n            if (count < limitCallCount) {\n                count++\n                return fn.apply(this || {}, args)\n            }\n            if (console[level]) console[level](name, &apos;call limit&apos;)\n            console.warn(name, &apos;call limit&apos;)\n        }\n    }          \n}\n```\n\n严格来说，这也不算是一个高阶函数的使用场景，但是体现了类似的思想。读者可以举一反三。\n\n#### 组合\n\n继续延伸我们的场景，如果输入比较复杂，想先过滤出小于 10 的项目需要先保证数组中每一项都是 Number 类型，那么可以：\n\n```\n[12, &apos;sd&apos;, null, undefined, {}, 23, 45, 3, 6].filter(value=> !isNaN(value) && value !== null).filter(lowerThan10)s\n```\n\n这样的做法得益于 JavaScript filter 对函数式的友好支持，链式调用也在一定程度上实现了组合性。\n\n更加通用的组合做法是使用 compose 方法，收益非常直观：\n\n- 单一功能的小函数更好维护\n- 通过组合，将单一功能的小函数串联起来，完成复杂的功能\n- 复用性更好，硬编码更少\n\n#### point free \n\npoint free 是指一种函数式的编程风格，有时候也可以叫做 tacit programming。point 在这里的意思是指形参，那么 point free，自然就是指没有行参了。这样做的目的是什么呢？没有参数，就意味着我们将注意力放在函数本身上。一般参数存在的意义是传递或者携带某个值，函数根据这个值，来得到另一个值。这样造成的困扰是我们不得不操作数据，同时要给参数命名。如果没有参数，不返回一个数据，那么 point free 的目的就是得到一个函数。\n\n当然业务中不可能永远不存在参数，因此我们允许底层函数非 point free，而 point free 函数更像是一种上层封装，它灵活调度带有参数的的底层函数，通过 point free 和非 point free 的解耦，使得代码更具有声明式特征，更具有美感。\n\npoint free 是我们的追求，而非标准，过度使用某种模式往往让代码“变坏”，这里给大家介绍这种概念，“见多识广”和“矫枉过正”往往只有一线之隔。\n\n### curry 化分析\n\ncurry 化也是一个常见的概念，维基百科对齐解释为：\n\n> 在计算机科学中，柯里化（currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。这个技术由克里斯托弗·斯特雷奇以逻辑学家哈斯凯尔·加里命名的。\n\n简单来说，就是在一个函数中预先填充几个参数，这个函数返回另一个函数，这个返回的新函数将其参数和预先填充的参数进行合并，再执行函数逻辑。\n\n那我们上述代码举例：\n\n```\nconst filterLowerThan10 = array => {\n\tlet result = []\n\tfor (let i = 0, length = array.length; i < length; i++) {\n\t\tlet currentValue = array[i]\n\t\tif (currentValue < 10) result.push(currentValue)\n\t}\n\treturn result\n}\n```\n\nfilterLowerThan10 还是硬编码写死了 10 这个阈值，我们用 curry 化的思想将其改造：\n\n```\nconst filterLowerNumber = number => {\n\treturn array => {\n\t\tlet result = []\n\t\tfor (let i = 0, length = array.length; i < length; i++) {\n\t\t\tlet currentValue = array[i]\n\t\t\tif (currentValue < number) result.push(currentValue)\n\t\t}\n\t\treturn result\n\t}\n}\n\nconst filterLowerThan10 = filterLowerNumber(10)\n\n\nfilterLowerThan10([1, 3, 5, 29, 34])\n```\n\n#### curry 化面试题\n\n再通过一到面试题加深理解。\n\n> 实现 add 方法，要求：\n\n```\nadd(1)(2) == 3 // true\n\nadd(1)(2)(3) == 6 // true\n```\n\n分析这道题：add 函数每次执行后一定需要保证返回一个函数，以供后续继续调用，且返回的这个函数还有返回自身，以支持连续调用。同时，为了满足例题条件，需要改写内部返回的函数 toString：\n\n```\nconst add = arg1 => {\n   const fn = arg2 => {\n\t\treturn fn\n\t}\n\tfn.toString = function () {\n\t\t\n\t}\n\treturn fn\n\t\n}\n```\n\n为了进行“求和”操作，需要在 add 函数内部维护一个闭包变量 args，args 是个数组，记录了每次调用是传进来的参数，toString 方法体中对参数进行求和，fn 方法体中对数组 args 进行添加当前参数的操作：\n\n```\nconst add = arg1 => {\n   let args = [arg1]\n   const fn = arg2 => {\n       args.push(arg2)\n\t\treturn fn\n\t}\n\tfn.toString = function () {\n\t\treturn args.reduce((prev, item) => prev + item, 0)\n\t}\n\treturn fn\n}\n```\n\n注意这里只支持：\n\n```\nadd(1)(2)(3)\n```\n\n单个参数的调用，如果更加通用化，支持：\n\n```\nadd(1)(2, 3)(4)\n```\n\n需要我们改动为：\n\n```\nconst add = (...arg1) => {\n   let args = [...arg1]\n   const fn = (...arg2) => {\n       args = [...args, ...arg2]\n\t\treturn fn\n\t}\n\tfn.toString = function () {\n\t\treturn args.reduce((prev, item) => prev + item, 0)\n\t}\n\treturn fn\n}\n```\n\n实现：\n\n```\nadd(1)(2, 3)(4) == 10\n```\n\n还有一个细节，如果将 == 改为 ===，将会输出 false，这并不奇怪。因为 add 调用后的返回值类型始终为 Function，我们只是改写了其 toString 方法，利用了隐式转换规则而已。\n\n#### 通用 curry 化\n\n我们回到 filterLowerThan10 函数的案例中，从中感受到 curry 化的优势：\n\n- 提高复用性\n- 减少重复传递不必要的参数\n- 动态根据上下文创建函数\n\n其中动态根据上下文创建函数，也是一种惰性求值的体现：\n\n```\nconst addEvent = (function() {\n    if (window.addEventListener) {\n        return function (type, element, handler, capture) {\n            element.addEventListener(type, handler, capture)\n        }\n    }\n    else if (window.attachEvent){\n        return function (type, element, fn) {\n            element.attachEvent(&apos;on&apos; + type, fn)\n        }\n    }\n})()\n```\n\n这是一个典型兼容 IE9 浏览器事件 API 的例子，根据兼容性的嗅探，充分利用 curry 化思想，完成了需求。\n\n那么我们如何编写一个通用化的 curry 函数呢？\n\n```\nconst curry = (fn, length) => {\n\tlength = length || fn.length\n\treturn function (...args) {\n\t\tif (args.length < length) {\n\t\t\treturn curry(fn.bind(this, ...args), length - args.length)\n\t\t}\n\t\telse {\n\t\t\treturn fn.call(this, ...args)\n\t\t}\n\t}\n}\n```\n\n这里我们利用 Function.length 获取函数预期需要的参数个数，并利用了 bind 方法绑定参数。\n\n如果不想使用 bind，另一种常规思路是对每次调用时产生的参数进行存储：\n\n```\nconst curry = fn => {\n\treturn tempFn = (...arg1) => {\n\t\tif (arg1.length >= fn.length) {\n\t\t\treturn fn(...arg1)\n\t\t}\n\t\telse {\n\t\t\treturn (...arg2) => tempFn(...arg1, ...arg2)\n\t\t}\n\t}\n}\n```\n\n简化为：\n\n```\nconst curry = fn =>\n\tjudge = (...arg1) =>\n\t\targ1.length >= fn.length\n\t\t\t? fn(...arg1)\n\t\t\t: (...arg2) => judge(...arg1, ...arg2)\n```\n\n总之，实现原理就是：先用闭包把传入参数保存起来，当传入参数的数量足够执行函数时，就开始执行函数。抽象成步骤：\n\n- 先逐步接受参数，并进行存储，以供后续使用\n- 先不进行函数计算，延后执行\n- 在符合条件时，根据存储的参数，统一传给函数进行计算\n\n#### 反 curry 化\n\n反 curry 化与 curry 正好相反。反 curry 化在于扩大函数的适用性，使本来作为特定对象所拥有的功能函数可以被任意对象所使用。\n\n说到“特定对象所拥有的功能函数可以被任意对象所使用”，有经验的读者可能会想到用于类型判断的 Object.prototype.toString.call(target)：\n\n```\nconst foo = () => ({})\nconst bar = &apos;&apos;\n\nObject.prototype.toString.call(foo) === &apos;[object Function]&apos;\n// true\n\nObject.prototype.toString.call(bar) === &apos;[object String]&apos;\n// true\n```\n\n通过反 curry 化，我们将这个 Object 原型上的属性函数变得更加通用：\n\n```\nconst toString = Object.prototype.toString.unCurry\n```\n\n或者有一个 UI 组件 Toast：\n\n```\nfunction Toast (options) {\n\tthis.message = &apos;&apos;\n}\n\nToast.prototype = {\n\tshowMessage: function () {\n\t\tconsole.log(this.message)\n\t}\n}\n```\n\n这样的代码，使得 Toast 实例均可使用 showMessage 方法：\n\n```\nnew Toast({}).showMessage()\n```\n\n如果有一个变量对象：\n\n```\nconst obj = {\n    message: &apos;uncurry test&apos;\n}\n```\n\n如果想使用 Toast 原型上的 showMessage 方法：\n\n```\nconst unCurryShowMessaage = unCurry(Toast.prototype.showMessage)\n\nunCurryShowMessaage(obj)\n```\n\n就是使用反 curry 化的另一个场景了。\n\n#### 反 curry 化实现\n\n那么上述的 unCurry 方法应该如何实现呢？\n\n我们来分析：unCurry 的参数是一个“希望被其他对象所调用的方法”，暂且称为 fn，unCurry 执行后返回一个新的函数，该函数的第一个参数是预期要执行方法的对象（obj），后面的参数是执行这个方法时需要传递的参数。\n\n```\nfunction unCurry(fn) {\n    return function () {\n        var obj = [].shift.call(arguments)\n        return fn.apply(obj, arguments)\n    }\n}\n```\n\n改成 ES6 的写法：\n\n```\nconst unCurry = fn => (...args) => fn.call(...args)\n```\n\n以上是正常函数实现 uncurry 的实现。我们也可以将 uncurry 挂载在函数原型上：\n\n```\nFunction.prototype.unCurry = !Function.prototype.unCurry || function () {\n    const self = this\n    return function () {\n        return Function.prototype.call.apply(self, arguments)\n    }\n}\n```\n\n这里不太好理解的点在于：Function.prototype.call.apply(self, arguments)，其实这个问题本课程的读者群里也有人问过，我们就一起来讨论下，拆开看就会非常清晰了。\n\n- 第一步：Function.prototype.call.apply(self, arguments) 可以看成 Fn.apply(self, arguments)，Fn 函数执行时，this 指向了 self。而根据代码，self 是调用 unCurry 的函数，执行结果就是 Fn(arguments)，只不过 this 被绑定在 self 上，用 callFn(arguments) 来表示。\n- 第二步：callFn(arguments) 解析，callFn 指的是：Function.prototype.call，call 方法第一个参数是用来指定 this 的，因此 callFn(arguments) 相当于 callFn(arguments[0], arguments[n - 1])。\n\n因此，最终执行就相当于：callFn(arguments[0], arguments[n - 1])，也就是说反 curry 化后得到的函数，第一个参数是用来决定 this 指向的，也就是需要应用的目标对象，剩下的参数是函数执行所需要的参数。\n\n当然，我们可以借助 bind 实现：\n\n```\nFunction.prototype.unCurry = function() {\n  return this.call.bind(this)\n}\n```\n\n借助 bind，call/apply 实现过程相对抽象，读者可以根据示例尝试理解。这里允许我再赘述一下：\n\n> call 中的 this 指的是调用它的函数，call 的内部实现中：第一个参数替换了这个函数中的 this，其余作为形参执行了函数。而我们的代码：Function.prototype.call.apply，使用 apply 之后，apply 的第一个参数更换了 call 中的 this。因此执行时，实际执行计算的的函数为 self。\n\n这里再补充一个例子，供大家理解：\n\n```\nconst push = Array.prototype.push.unCurry()\n\nconst test = { foo: &apos;lucas&apos; }\npush(test, &apos;messi&apos;, &apos;ronaldo&apos;, &apos;neymar&apos;)\nconsole.log(test) \n\n// {0: \"messi\", 1: \"ronaldo\", 2: \"neymar\", foo: \"lucas\", length: 3}\n```\n\n我们借助了数组的 push 方法，应用在对象上，test 对象多了类似数组的属性，键为数组索引。\n\n### 偏函数（partial）\n\n如果了解了 curry 化，那么偏函数（partial application）就很容易理解了。如果说 curry 化是将一个多参数函数转换成多个单参数函数，也就是 curry 化将 n 原函数转换 n 个一元函数，那么偏函数就是固定一个函数的一个或者多个参数，即将一个 n 元函数转换成一个 （n ﹣ k） 元函数：\n\ncurry 化：n = n * 1\n\npartial：n = n/k * k\n\n响应偏函数实现：\n\n```\nconst partial = (fn, ...rest) => (...args) => fn(...rest, ...args)   \n```\n\n使用 bind 版本实现：\n\n```\nconst partial = (fn, ...args) => fn.bind(null, ...args)\n```\n\n#### 函子（functor）\n\n说到函子，大部分没有深入过函数式编程的读者可能有点陌生，而函子确实一个很重要的函数式编程思想。目前社区上介绍的并不算多，我们这里来进行一下了解。\n\n我想先从链式调用说起，看以下代码：\n\n```\nconst addHelloPrefix = str => `Hello : ${str}`\nconst addByeSuffix = str => `${str}, bye!`\n```\n\naddHelloPrefix 和 addByeSuffix 分别给所接收到的字符串添加固定的字符串前缀和后缀，我们可以这样使用：\n\n```\naddByeSuffix(addHelloPrefix(&apos;lucas&apos;))\n```\n\n得到返回结果：\"Hello : lucas, bye!\"\n\n如果我们想链式调用：\n\n```\n&apos;lucas&apos;.addHelloPrefix().addByeSuffix()\n\n// VM176:1 Uncaught TypeError: \"lucas\".addHelloPrefix is not a function\n```\n\n得到报错信息，是因为字符串并不存在 addHelloPrefix 方法，因此调用失败。如果 &apos;lucas&apos; 这样的字符串是一个复杂类型，或者是一个类，也许问题就能解决：\n\n```\nclass Person {\n\tconstructor(value) {\n\t\tthis.value = value\n\t}\n\taddHelloPrefix() {\n\t\treturn `Hello : ${this.value}`\n\t}\n\taddByeSuffix() {\n\t\treturn `${this.value}, bye`\n\t}\n}\n```\n\n这样的 Person 声明并不足以完成链式调用，链式调用的关键是 addHelloPrefix 和 addByeSuffix 方法仍然返回该类实例，而不是字符串。我们改动如下：\n\n```\nclass Person {\n\tconstructor(value) {\n\t\tthis.value = value\n\t}\n\taddHelloPrefix() {\n\t\treturn new Person(`Hello : ${this.value}`)\n\t}\n\taddByeSuffix() {\n\t\treturn new Person(`${this.value}, bye`)\n\t}\n}\n```\n\n执行代码：\n\n```\nnew Person(&apos;lucas&apos;).addHelloPrefix().addByeSuffix()\n```\n\n输出：\n\n```\n{value: \"Hello : lucas, bye\"}\n```\n\n这样一来，似乎举例目标更近了些。我们试图将上述操作变得完全通用，定义一个 Functor 类：\n\n```\nclass Functor {\n\tconstructor(value) {\n\t\tthis.value = value\n\t}\n\tstatic of(value) {\n\t\treturn new Functor(value)\n\t}\n\tapply(fn) {\n\t\treturn Functor.of(fn(this.value))\n\t}\n}\n```\n\nFunctor 可以理解为函子雏形，我们看它做了什么：Functor 的 constructor 按照惯例接收数据；同时定义 Functor 一个静态方法 of，这个方法专门用来返回一个 Functor 实例对象；apply 方法接受一个 fn，使用 fn 对当前实例的 value 进行计算，得到新的 value 之后交给静态 of 方法，最终得到还有新 value 的实例。\n\n这样一来，可以：\n\n```\nFunctor.of(&apos;lucas&apos;).apply(addHelloPrefix).apply(addByeSuffix)\n```\n\n仍然得到结果：\n\n```\n{value: \"Hello : lucas, bye!\"}\n```\n\n我们总结一下：\n\n- Functor 可以理解为一个容器，这个容器中含有值 this.value.；\n- Functor 具有 apply 方法，该方法将容器里面的每一个值，应用到到另一个容器；\n- 上述所说的“应用到另一个容器”，是根据 of 方法，得到新的实例；\n- 所有运算，都是通过函子 Functor 来完成，这样一来，所有运算不直接针对值，而是针对这个值的容器 —— Functor；\n- 这样也保证了值的不可变性；\n- 函数式编程有个约定，函子 Functor 需要拥有一个 of 方法，用来生成新的容器。\n\n#### Maybe 函子\n\n在函字 Functor 的基础上，为了安全性，我们将函子里的空值过滤掉：\n\n```\nclass Maybe {\n\tconstructor(value) {\n\t\tthis.value = value\n\t}\n\tstatic of(value) {\n\t\treturn new Maybe(value)\n\t}\n\tapply(fn) {\n\t\treturn this.value ? Maybe.of(fn(this.value)) : new Maybe(null)\n\t}\n}\n```\n\n注意在 apply 方法中，对当前值 this.value 进行判断，如果非空，返回 Maybe.of(fn(this.value)) 调用，否则直接返回 Maybe(null)。\n\n这就是简单的 Maybe 函子，为此我们总结一下：**不同类型的函子，可以完成不同的功能。他们的共同点是：每个函子并没有直接去操作需要处理的数据（我们没有看到的 this.value 的直接写操作）而是通过 apply 接口应用 fn，并最终返回一个新的函子。**\n\n### 总结\n\n函数式编程博大精深，这一节课只是给大家介绍了 JavaScript 中结合函数式编程常用的概念，已经足够日常开发了。掌握这些概念的 JavaScript 实现是进阶所必需的要求。\n\n此外读者还可以更多考虑函数式编程的性能负担以及框架类库函数式实现的话题，函数式结合 ES Next decorator 也可以玩出很多花样；Ramda.js 是一个典型的函数式类库，感兴趣的读者也可以深入研究。同时给大家推荐一本函数式编程的书《JS 函数式编程指南》，它特有免费的中文版：[mostly-adequate-guide](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/)。\n\n总之，函数式的话题我们就到此结束，你可以研究得更深、更多，但理解本节课内容足够让读者有的放矢，在工程中合理使用。","pdfUrl":"","reader":"","duration":"","title":"古老又新潮的函数式","column":"5c91c813968b1d64b1e08fde","isNotification":false,"readingStatistics":0,"htmlContent":"<p>函数式这个概念我们在以往的课程中其实已经有所涉及了，比如第 1-2、1-3 课介绍的闭包知识；比如 1-4 课《我们不背诵 API，只实现 API》中剖析的 5 种 compose 方法，以及 reduce 实现 pipe、runPromiseInSequence 等都是典型的函数式概念。</p>\n<p>函数式其实很早就出现在了编程领域当中，近些年由于 React 的带动，在前端开发中重新“焕发活力”。</p>\n<p>很多读者可能一听到函数式就眉头一皱，毕竟相比于面向对象等其他编程概念，它更加晦涩难懂。对于函数式的学习，也一定不是使用或者模仿 compose 那么简单。这一节课，我们就来梳理几个函数式概念。但是我认为单纯的概念介绍并没有意义，因此也准备了大量实战例题以及库的设计方案，与大家一起分享。</p>\n<p><img src=\"https://images.gitbook.cn/bbd9d5a0-d448-11e9-a4b6-d1d2b628f523\" alt=\"enter image description here\" /></p>\n<h3><a id=\"_8\"></a>函数式和高质量函数</h3>\n<p>函数式通常意味着高质量的代码，本小节的主标题之所以是“函数式和高质量函数”，而不是“函数式和高质量代码”，因为在函数式看来，一切都是函数，“函数是第一等公民”。围绕着函数，取代面向过程式的代码，往往能够有以下收益：</p>\n<ul>\n<li><strong>表达力更加清晰</strong>，因为“一切都是函数”，通过函数的合理命名，函数原子的拆分，我们能够一眼看出来程序在做什么，以及做的过程；</li>\n<li><strong>利于复用</strong>，因为“一切都是函数”，函数本身具有天然的复用能力；</li>\n<li><strong>利于维护</strong>，纯函数和幂等性保证同样的输入就有同样的输出，在维护或者调试代码时，能够更加专注，减少因为共享带来的潜在问题。</li>\n</ul>\n<p>我们下面来通过概念具体展开。</p>\n<h4><a id=\"_18\"></a>纯函数</h4>\n<p>之前我们提到过：</p>\n<blockquote>\n<p>一个函数如果输入参数确定，输出结果是唯一确定的，那么它就是纯函数。</p>\n</blockquote>\n<p>并且纯函数不能修改外部变量，造成副作用，不能调用 Math.radom() 方法以及发送异步请求等，因为这些操作都不具有确定性。</p>\n<p>根据定义我们知道纯函数的特点是：</p>\n<ul>\n<li>无状态</li>\n<li>无副作用</li>\n<li>无关时序</li>\n<li>幂等（指无论调用多少次，结果相同）</li>\n</ul>\n<p>看代码举例：</p>\n<pre><code class=\"lang-\">let array = [1,2,3,4]\n\n// array 的 slice 方法属于纯函数方法，它不对数组本身进行操作\n// array 的 splice 方法不属于纯函数方法，它对数组本身进行操作 \n\nconst minusCount = () =&gt; {\n\twindow.count--\n} \n\n// minusCount 不是纯函数，它依赖并改变外部变量，具有副作用\n\nconst setHtml = (node, html) =&gt; {\n\tnode.innerHtml = html\n} \n\n// setHtml 不是纯函数，同上                                                     \n</code></pre>\n<p>这样的纯函数不仅易于维护，逻辑清晰，而且具有更好的组合和测试性。之前的课程中我们多次提到，这里不再单独展开。</p>\n<h4><a id=\"_56\"></a>高阶函数</h4>\n<p>高阶函数体现了“函数是第一等公民”，它是指这样的一类函数：该函数接受一个函数作为参数，返回另外一个函数。</p>\n<p>没错，和高阶组件的概念类似。为什么会有这么一个“怪异”的高阶函数呢？来看一个例子：filterLowerThan10 这个函数接受一个数组作为参数，它会挑选出数组中数值小于 10 的项目，所有符合条件的值都会构成新数组被返回：</p>\n<pre><code class=\"lang-\">const filterLowerThan10 = array =&gt; {\n\tlet result = []\n\tfor (let i = 0, length = array.length; i &lt; length; i++) {\n\t\tlet currentValue = array[i]\n\t\tif (currentValue &lt; 10) result.push(currentValue)\n\t}\n\treturn result\n}\n</code></pre>\n<p>另外一个需求，挑选出数组中非数值项目，所有符合条件的值都会构成新数组被返回：</p>\n<pre><code class=\"lang-\">const filterNaN = array =&gt; {\n\tlet result = []\n\tfor (let i = 0, length = array.length; i &lt; length; i++) {\n\t\tlet currentValue = array[i]\n\t\tif (isNaN(currentValue)) result.push(currentValue)\n\t}\n\treturn result\n}\n</code></pre>\n<p>这都是很基本的面向过程编程的代码。不够优雅的一点是 filterLowerThan10 和 filterNaN 都有遍历的逻辑，都存在了重复的 for 循环。本质上都是遍历一个列表，并用给定的条件过滤列表。我们能否用函数式的思想，将遍历和筛选解耦呢？</p>\n<p>好在 JavaScript 对函数式较为友好，我们使用 filter 函数来完成，并进行一定程度的改造：</p>\n<pre><code class=\"lang-\">const lowerThan10 = value =&gt; value &lt; 10\n\n[12, 3, 4, 89].filter(lowerThan10)\n\n[12, &apos;sd&apos;, null, undefined, {}].filter(isNaN)\n</code></pre>\n<p>这非常简单，我们以此来热身进入状态。</p>\n<p>另一个高阶函数的典型应用场景是函数缓存：</p>\n<pre><code class=\"lang-\">const memorize = fn =&gt; {\n    let cacheMap = {}\n    return function(...args) {\n    \tconst cacheKey = args.join(&apos;_&apos;)\n        if (cacheKey in cacheMap) {\n            return cache[cacheKey]\n        } \n        else {\n            return cacheMap[cacheKey] = fn.apply(this || {}, args)\n        }\n    }\n}\n</code></pre>\n<p>高阶函数可以和 decorator 相结合，再来看一个实例，实现有限次数函数调用的装饰器：</p>\n<pre><code class=\"lang-\"> class MyClass {\n    @callLimit getSum() {}\n}\n</code></pre>\n<p>实现：</p>\n<pre><code class=\"lang-\">function callLimit(limitCallCount = 1, level = &apos;warn&apos;) {\n\t// 记录调用次数\n    let count = 0\n    return function(target, name, descriptor) {\n    \t// 记录原始函数\n        var fn = descriptor.value\n        // 改写新函数\n        descriptor.value = function(...args) {\n            if (count &lt; limitCallCount) {\n                count++\n                return fn.apply(this || {}, args)\n            }\n            if (console[level]) console[level](name, &apos;call limit&apos;)\n            console.warn(name, &apos;call limit&apos;)\n        }\n    }          \n}\n</code></pre>\n<p>严格来说，这也不算是一个高阶函数的使用场景，但是体现了类似的思想。读者可以举一反三。</p>\n<h4><a id=\"_149\"></a>组合</h4>\n<p>继续延伸我们的场景，如果输入比较复杂，想先过滤出小于 10 的项目需要先保证数组中每一项都是 Number 类型，那么可以：</p>\n<pre><code class=\"lang-\">[12, &apos;sd&apos;, null, undefined, {}, 23, 45, 3, 6].filter(value=&gt; !isNaN(value) &amp;&amp; value !== null).filter(lowerThan10)s\n</code></pre>\n<p>这样的做法得益于 JavaScript filter 对函数式的友好支持，链式调用也在一定程度上实现了组合性。</p>\n<p>更加通用的组合做法是使用 compose 方法，收益非常直观：</p>\n<ul>\n<li>单一功能的小函数更好维护</li>\n<li>通过组合，将单一功能的小函数串联起来，完成复杂的功能</li>\n<li>复用性更好，硬编码更少</li>\n</ul>\n<h4><a id=\"point_free_165\"></a>point free</h4>\n<p>point free 是指一种函数式的编程风格，有时候也可以叫做 tacit programming。point 在这里的意思是指形参，那么 point free，自然就是指没有行参了。这样做的目的是什么呢？没有参数，就意味着我们将注意力放在函数本身上。一般参数存在的意义是传递或者携带某个值，函数根据这个值，来得到另一个值。这样造成的困扰是我们不得不操作数据，同时要给参数命名。如果没有参数，不返回一个数据，那么 point free 的目的就是得到一个函数。</p>\n<p>当然业务中不可能永远不存在参数，因此我们允许底层函数非 point free，而 point free 函数更像是一种上层封装，它灵活调度带有参数的的底层函数，通过 point free 和非 point free 的解耦，使得代码更具有声明式特征，更具有美感。</p>\n<p>point free 是我们的追求，而非标准，过度使用某种模式往往让代码“变坏”，这里给大家介绍这种概念，“见多识广”和“矫枉过正”往往只有一线之隔。</p>\n<h3><a id=\"curry__173\"></a>curry 化分析</h3>\n<p>curry 化也是一个常见的概念，维基百科对齐解释为：</p>\n<blockquote>\n<p>在计算机科学中，柯里化（currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。这个技术由克里斯托弗·斯特雷奇以逻辑学家哈斯凯尔·加里命名的。</p>\n</blockquote>\n<p>简单来说，就是在一个函数中预先填充几个参数，这个函数返回另一个函数，这个返回的新函数将其参数和预先填充的参数进行合并，再执行函数逻辑。</p>\n<p>那我们上述代码举例：</p>\n<pre><code class=\"lang-\">const filterLowerThan10 = array =&gt; {\n\tlet result = []\n\tfor (let i = 0, length = array.length; i &lt; length; i++) {\n\t\tlet currentValue = array[i]\n\t\tif (currentValue &lt; 10) result.push(currentValue)\n\t}\n\treturn result\n}\n</code></pre>\n<p>filterLowerThan10 还是硬编码写死了 10 这个阈值，我们用 curry 化的思想将其改造：</p>\n<pre><code class=\"lang-\">const filterLowerNumber = number =&gt; {\n\treturn array =&gt; {\n\t\tlet result = []\n\t\tfor (let i = 0, length = array.length; i &lt; length; i++) {\n\t\t\tlet currentValue = array[i]\n\t\t\tif (currentValue &lt; number) result.push(currentValue)\n\t\t}\n\t\treturn result\n\t}\n}\n\nconst filterLowerThan10 = filterLowerNumber(10)\n\n\nfilterLowerThan10([1, 3, 5, 29, 34])\n</code></pre>\n<h4><a id=\"curry__214\"></a>curry 化面试题</h4>\n<p>再通过一到面试题加深理解。</p>\n<blockquote>\n<p>实现 add 方法，要求：</p>\n</blockquote>\n<pre><code class=\"lang-\">add(1)(2) == 3 // true\n\nadd(1)(2)(3) == 6 // true\n</code></pre>\n<p>分析这道题：add 函数每次执行后一定需要保证返回一个函数，以供后续继续调用，且返回的这个函数还有返回自身，以支持连续调用。同时，为了满足例题条件，需要改写内部返回的函数 toString：</p>\n<pre><code class=\"lang-\">const add = arg1 =&gt; {\n   const fn = arg2 =&gt; {\n\t\treturn fn\n\t}\n\tfn.toString = function () {\n\t\t\n\t}\n\treturn fn\n\t\n}\n</code></pre>\n<p>为了进行“求和”操作，需要在 add 函数内部维护一个闭包变量 args，args 是个数组，记录了每次调用是传进来的参数，toString 方法体中对参数进行求和，fn 方法体中对数组 args 进行添加当前参数的操作：</p>\n<pre><code class=\"lang-\">const add = arg1 =&gt; {\n   let args = [arg1]\n   const fn = arg2 =&gt; {\n       args.push(arg2)\n\t\treturn fn\n\t}\n\tfn.toString = function () {\n\t\treturn args.reduce((prev, item) =&gt; prev + item, 0)\n\t}\n\treturn fn\n}\n</code></pre>\n<p>注意这里只支持：</p>\n<pre><code class=\"lang-\">add(1)(2)(3)\n</code></pre>\n<p>单个参数的调用，如果更加通用化，支持：</p>\n<pre><code class=\"lang-\">add(1)(2, 3)(4)\n</code></pre>\n<p>需要我们改动为：</p>\n<pre><code class=\"lang-\">const add = (...arg1) =&gt; {\n   let args = [...arg1]\n   const fn = (...arg2) =&gt; {\n       args = [...args, ...arg2]\n\t\treturn fn\n\t}\n\tfn.toString = function () {\n\t\treturn args.reduce((prev, item) =&gt; prev + item, 0)\n\t}\n\treturn fn\n}\n</code></pre>\n<p>实现：</p>\n<pre><code class=\"lang-\">add(1)(2, 3)(4) == 10\n</code></pre>\n<p>还有一个细节，如果将 == 改为 ===，将会输出 false，这并不奇怪。因为 add 调用后的返回值类型始终为 Function，我们只是改写了其 toString 方法，利用了隐式转换规则而已。</p>\n<h4><a id=\"_curry__293\"></a>通用 curry 化</h4>\n<p>我们回到 filterLowerThan10 函数的案例中，从中感受到 curry 化的优势：</p>\n<ul>\n<li>提高复用性</li>\n<li>减少重复传递不必要的参数</li>\n<li>动态根据上下文创建函数</li>\n</ul>\n<p>其中动态根据上下文创建函数，也是一种惰性求值的体现：</p>\n<pre><code class=\"lang-\">const addEvent = (function() {\n    if (window.addEventListener) {\n        return function (type, element, handler, capture) {\n            element.addEventListener(type, handler, capture)\n        }\n    }\n    else if (window.attachEvent){\n        return function (type, element, fn) {\n            element.attachEvent(&apos;on&apos; + type, fn)\n        }\n    }\n})()\n</code></pre>\n<p>这是一个典型兼容 IE9 浏览器事件 API 的例子，根据兼容性的嗅探，充分利用 curry 化思想，完成了需求。</p>\n<p>那么我们如何编写一个通用化的 curry 函数呢？</p>\n<pre><code class=\"lang-\">const curry = (fn, length) =&gt; {\n\tlength = length || fn.length\n\treturn function (...args) {\n\t\tif (args.length &lt; length) {\n\t\t\treturn curry(fn.bind(this, ...args), length - args.length)\n\t\t}\n\t\telse {\n\t\t\treturn fn.call(this, ...args)\n\t\t}\n\t}\n}\n</code></pre>\n<p>这里我们利用 Function.length 获取函数预期需要的参数个数，并利用了 bind 方法绑定参数。</p>\n<p>如果不想使用 bind，另一种常规思路是对每次调用时产生的参数进行存储：</p>\n<pre><code class=\"lang-\">const curry = fn =&gt; {\n\treturn tempFn = (...arg1) =&gt; {\n\t\tif (arg1.length &gt;= fn.length) {\n\t\t\treturn fn(...arg1)\n\t\t}\n\t\telse {\n\t\t\treturn (...arg2) =&gt; tempFn(...arg1, ...arg2)\n\t\t}\n\t}\n}\n</code></pre>\n<p>简化为：</p>\n<pre><code class=\"lang-\">const curry = fn =&gt;\n\tjudge = (...arg1) =&gt;\n\t\targ1.length &gt;= fn.length\n\t\t\t? fn(...arg1)\n\t\t\t: (...arg2) =&gt; judge(...arg1, ...arg2)\n</code></pre>\n<p>总之，实现原理就是：先用闭包把传入参数保存起来，当传入参数的数量足够执行函数时，就开始执行函数。抽象成步骤：</p>\n<ul>\n<li>先逐步接受参数，并进行存储，以供后续使用</li>\n<li>先不进行函数计算，延后执行</li>\n<li>在符合条件时，根据存储的参数，统一传给函数进行计算</li>\n</ul>\n<h4><a id=\"_curry__369\"></a>反 curry 化</h4>\n<p>反 curry 化与 curry 正好相反。反 curry 化在于扩大函数的适用性，使本来作为特定对象所拥有的功能函数可以被任意对象所使用。</p>\n<p>说到“特定对象所拥有的功能函数可以被任意对象所使用”，有经验的读者可能会想到用于类型判断的 Object.prototype.toString.call(target)：</p>\n<pre><code class=\"lang-\">const foo = () =&gt; ({})\nconst bar = &apos;&apos;\n\nObject.prototype.toString.call(foo) === &apos;[object Function]&apos;\n// true\n\nObject.prototype.toString.call(bar) === &apos;[object String]&apos;\n// true\n</code></pre>\n<p>通过反 curry 化，我们将这个 Object 原型上的属性函数变得更加通用：</p>\n<pre><code class=\"lang-\">const toString = Object.prototype.toString.unCurry\n</code></pre>\n<p>或者有一个 UI 组件 Toast：</p>\n<pre><code class=\"lang-\">function Toast (options) {\n\tthis.message = &apos;&apos;\n}\n\nToast.prototype = {\n\tshowMessage: function () {\n\t\tconsole.log(this.message)\n\t}\n}\n</code></pre>\n<p>这样的代码，使得 Toast 实例均可使用 showMessage 方法：</p>\n<pre><code class=\"lang-\">new Toast({}).showMessage()\n</code></pre>\n<p>如果有一个变量对象：</p>\n<pre><code class=\"lang-\">const obj = {\n    message: &apos;uncurry test&apos;\n}\n</code></pre>\n<p>如果想使用 Toast 原型上的 showMessage 方法：</p>\n<pre><code class=\"lang-\">const unCurryShowMessaage = unCurry(Toast.prototype.showMessage)\n\nunCurryShowMessaage(obj)\n</code></pre>\n<p>就是使用反 curry 化的另一个场景了。</p>\n<h4><a id=\"_curry__430\"></a>反 curry 化实现</h4>\n<p>那么上述的 unCurry 方法应该如何实现呢？</p>\n<p>我们来分析：unCurry 的参数是一个“希望被其他对象所调用的方法”，暂且称为 fn，unCurry 执行后返回一个新的函数，该函数的第一个参数是预期要执行方法的对象（obj），后面的参数是执行这个方法时需要传递的参数。</p>\n<pre><code class=\"lang-\">function unCurry(fn) {\n    return function () {\n        var obj = [].shift.call(arguments)\n        return fn.apply(obj, arguments)\n    }\n}\n</code></pre>\n<p>改成 ES6 的写法：</p>\n<pre><code class=\"lang-\">const unCurry = fn =&gt; (...args) =&gt; fn.call(...args)\n</code></pre>\n<p>以上是正常函数实现 uncurry 的实现。我们也可以将 uncurry 挂载在函数原型上：</p>\n<pre><code class=\"lang-\">Function.prototype.unCurry = !Function.prototype.unCurry || function () {\n    const self = this\n    return function () {\n        return Function.prototype.call.apply(self, arguments)\n    }\n}\n</code></pre>\n<p>这里不太好理解的点在于：Function.prototype.call.apply(self, arguments)，其实这个问题本课程的读者群里也有人问过，我们就一起来讨论下，拆开看就会非常清晰了。</p>\n<ul>\n<li>第一步：Function.prototype.call.apply(self, arguments) 可以看成 Fn.apply(self, arguments)，Fn 函数执行时，this 指向了 self。而根据代码，self 是调用 unCurry 的函数，执行结果就是 Fn(arguments)，只不过 this 被绑定在 self 上，用 callFn(arguments) 来表示。</li>\n<li>第二步：callFn(arguments) 解析，callFn 指的是：Function.prototype.call，call 方法第一个参数是用来指定 this 的，因此 callFn(arguments) 相当于 callFn(arguments[0], arguments[n - 1])。</li>\n</ul>\n<p>因此，最终执行就相当于：callFn(arguments[0], arguments[n - 1])，也就是说反 curry 化后得到的函数，第一个参数是用来决定 this 指向的，也就是需要应用的目标对象，剩下的参数是函数执行所需要的参数。</p>\n<p>当然，我们可以借助 bind 实现：</p>\n<pre><code class=\"lang-\">Function.prototype.unCurry = function() {\n  return this.call.bind(this)\n}\n</code></pre>\n<p>借助 bind，call/apply 实现过程相对抽象，读者可以根据示例尝试理解。这里允许我再赘述一下：</p>\n<blockquote>\n<p>call 中的 this 指的是调用它的函数，call 的内部实现中：第一个参数替换了这个函数中的 this，其余作为形参执行了函数。而我们的代码：Function.prototype.call.apply，使用 apply 之后，apply 的第一个参数更换了 call 中的 this。因此执行时，实际执行计算的的函数为 self。</p>\n</blockquote>\n<p>这里再补充一个例子，供大家理解：</p>\n<pre><code class=\"lang-\">const push = Array.prototype.push.unCurry()\n\nconst test = { foo: &apos;lucas&apos; }\npush(test, &apos;messi&apos;, &apos;ronaldo&apos;, &apos;neymar&apos;)\nconsole.log(test) \n\n// {0: &quot;messi&quot;, 1: &quot;ronaldo&quot;, 2: &quot;neymar&quot;, foo: &quot;lucas&quot;, length: 3}\n</code></pre>\n<p>我们借助了数组的 push 方法，应用在对象上，test 对象多了类似数组的属性，键为数组索引。</p>\n<h3><a id=\"partial_495\"></a>偏函数（partial）</h3>\n<p>如果了解了 curry 化，那么偏函数（partial application）就很容易理解了。如果说 curry 化是将一个多参数函数转换成多个单参数函数，也就是 curry 化将 n 原函数转换 n 个一元函数，那么偏函数就是固定一个函数的一个或者多个参数，即将一个 n 元函数转换成一个 （n ﹣ k） 元函数：</p>\n<p>curry 化：n = n * 1</p>\n<p>partial：n = n/k * k</p>\n<p>响应偏函数实现：</p>\n<pre><code class=\"lang-\">const partial = (fn, ...rest) =&gt; (...args) =&gt; fn(...rest, ...args)   \n</code></pre>\n<p>使用 bind 版本实现：</p>\n<pre><code class=\"lang-\">const partial = (fn, ...args) =&gt; fn.bind(null, ...args)\n</code></pre>\n<h4><a id=\"functor_515\"></a>函子（functor）</h4>\n<p>说到函子，大部分没有深入过函数式编程的读者可能有点陌生，而函子确实一个很重要的函数式编程思想。目前社区上介绍的并不算多，我们这里来进行一下了解。</p>\n<p>我想先从链式调用说起，看以下代码：</p>\n<pre><code class=\"lang-\">const addHelloPrefix = str =&gt; `Hello : ${str}`\nconst addByeSuffix = str =&gt; `${str}, bye!`\n</code></pre>\n<p>addHelloPrefix 和 addByeSuffix 分别给所接收到的字符串添加固定的字符串前缀和后缀，我们可以这样使用：</p>\n<pre><code class=\"lang-\">addByeSuffix(addHelloPrefix(&apos;lucas&apos;))\n</code></pre>\n<p>得到返回结果：“Hello : lucas, bye!”</p>\n<p>如果我们想链式调用：</p>\n<pre><code class=\"lang-\">&apos;lucas&apos;.addHelloPrefix().addByeSuffix()\n\n// VM176:1 Uncaught TypeError: &quot;lucas&quot;.addHelloPrefix is not a function\n</code></pre>\n<p>得到报错信息，是因为字符串并不存在 addHelloPrefix 方法，因此调用失败。如果 ‘lucas’ 这样的字符串是一个复杂类型，或者是一个类，也许问题就能解决：</p>\n<pre><code class=\"lang-\">class Person {\n\tconstructor(value) {\n\t\tthis.value = value\n\t}\n\taddHelloPrefix() {\n\t\treturn `Hello : ${this.value}`\n\t}\n\taddByeSuffix() {\n\t\treturn `${this.value}, bye`\n\t}\n}\n</code></pre>\n<p>这样的 Person 声明并不足以完成链式调用，链式调用的关键是 addHelloPrefix 和 addByeSuffix 方法仍然返回该类实例，而不是字符串。我们改动如下：</p>\n<pre><code class=\"lang-\">class Person {\n\tconstructor(value) {\n\t\tthis.value = value\n\t}\n\taddHelloPrefix() {\n\t\treturn new Person(`Hello : ${this.value}`)\n\t}\n\taddByeSuffix() {\n\t\treturn new Person(`${this.value}, bye`)\n\t}\n}\n</code></pre>\n<p>执行代码：</p>\n<pre><code class=\"lang-\">new Person(&apos;lucas&apos;).addHelloPrefix().addByeSuffix()\n</code></pre>\n<p>输出：</p>\n<pre><code class=\"lang-\">{value: &quot;Hello : lucas, bye&quot;}\n</code></pre>\n<p>这样一来，似乎举例目标更近了些。我们试图将上述操作变得完全通用，定义一个 Functor 类：</p>\n<pre><code class=\"lang-\">class Functor {\n\tconstructor(value) {\n\t\tthis.value = value\n\t}\n\tstatic of(value) {\n\t\treturn new Functor(value)\n\t}\n\tapply(fn) {\n\t\treturn Functor.of(fn(this.value))\n\t}\n}\n</code></pre>\n<p>Functor 可以理解为函子雏形，我们看它做了什么：Functor 的 constructor 按照惯例接收数据；同时定义 Functor 一个静态方法 of，这个方法专门用来返回一个 Functor 实例对象；apply 方法接受一个 fn，使用 fn 对当前实例的 value 进行计算，得到新的 value 之后交给静态 of 方法，最终得到还有新 value 的实例。</p>\n<p>这样一来，可以：</p>\n<pre><code class=\"lang-\">Functor.of(&apos;lucas&apos;).apply(addHelloPrefix).apply(addByeSuffix)\n</code></pre>\n<p>仍然得到结果：</p>\n<pre><code class=\"lang-\">{value: &quot;Hello : lucas, bye!&quot;}\n</code></pre>\n<p>我们总结一下：</p>\n<ul>\n<li>Functor 可以理解为一个容器，这个容器中含有值 this.value.；</li>\n<li>Functor 具有 apply 方法，该方法将容器里面的每一个值，应用到到另一个容器；</li>\n<li>上述所说的“应用到另一个容器”，是根据 of 方法，得到新的实例；</li>\n<li>所有运算，都是通过函子 Functor 来完成，这样一来，所有运算不直接针对值，而是针对这个值的容器 —— Functor；</li>\n<li>这样也保证了值的不可变性；</li>\n<li>函数式编程有个约定，函子 Functor 需要拥有一个 of 方法，用来生成新的容器。</li>\n</ul>\n<h4><a id=\"Maybe__625\"></a>Maybe 函子</h4>\n<p>在函字 Functor 的基础上，为了安全性，我们将函子里的空值过滤掉：</p>\n<pre><code class=\"lang-\">class Maybe {\n\tconstructor(value) {\n\t\tthis.value = value\n\t}\n\tstatic of(value) {\n\t\treturn new Maybe(value)\n\t}\n\tapply(fn) {\n\t\treturn this.value ? Maybe.of(fn(this.value)) : new Maybe(null)\n\t}\n}\n</code></pre>\n<p>注意在 apply 方法中，对当前值 this.value 进行判断，如果非空，返回 Maybe.of(fn(this.value)) 调用，否则直接返回 Maybe(null)。</p>\n<p>这就是简单的 Maybe 函子，为此我们总结一下：<strong>不同类型的函子，可以完成不同的功能。他们的共同点是：每个函子并没有直接去操作需要处理的数据（我们没有看到的 this.value 的直接写操作）而是通过 apply 接口应用 fn，并最终返回一个新的函子。</strong></p>\n<h3><a id=\"_647\"></a>总结</h3>\n<p>函数式编程博大精深，这一节课只是给大家介绍了 JavaScript 中结合函数式编程常用的概念，已经足够日常开发了。掌握这些概念的 JavaScript 实现是进阶所必需的要求。</p>\n<p>此外读者还可以更多考虑函数式编程的性能负担以及框架类库函数式实现的话题，函数式结合 ES Next decorator 也可以玩出很多花样；Ramda.js 是一个典型的函数式类库，感兴趣的读者也可以深入研究。同时给大家推荐一本函数式编程的书《JS 函数式编程指南》，它特有免费的中文版：<a href=\"https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/\" target=\"_blank\">mostly-adequate-guide</a>。</p>\n<p>总之，函数式的话题我们就到此结束，你可以研究得更深、更多，但理解本节课内容足够让读者有的放矢，在工程中合理使用。</p>\n","createdAt":"2019-04-21T04:46:25.588Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":40,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FoThASW9dVEPMEo9nP-zaOfbKyLZ"},{"_id":"5cbbf5d0bbbba80861a35c72","communication_start_time":null,"type":1,"audioPath":"","abstract":"","content":"在上一讲中，我们全面梳理了重要的数据结构，并用 JavaScript 对各种数据结构进行了实现和方法模拟。数据结构常与算法一起出现，两者相互依存密不可分。这一讲，我们来研究一下“那些年常考的前端算法”。\n\n主要内容如下：\n\n![enter image description here](https://images.gitbook.cn/a80ed7e0-d827-11e9-a98d-91914e1a8fb9)\n\n我们将通过三讲的内容来剖析算法问题。本讲先“轻松”一下，主要介绍前端和算法的关系，以及算法中的一些基本概念。\n\n### 前端和算法\n\n前端和算法有什么关系呢？我想先纠正两个常见的错误认知。\n\n#### 关于算法的误解\n\n- 前端没有算法？\n\n“前端没有算法”这种说法往往出自算法岗甚至后端读者，这种认知是错误的。前端不仅有算法，而且算法在前端开发中占据的地位也越来越重要。我们常提到的 Virtual dom diff、webpack 实现、React fiber、React hooks、响应式编程、浏览器引擎工作方式等都有算法的影子。在业务代码中，哪怕写一个抽奖游戏，写一个混淆函数都离不开算法。\n\n- 算法重要不重要？\n\n有读者认为，前端中算法只是提供了一些偏底层的能力和实现支持，我在业务开发中真正使用到算法的场景也很有限。事实上，不仅单纯的前端业务，哪怕对于后端业务来说，真正让你“徒手”实现一段算法的场景也不算多。但是据此得出算法不重要的说法还是太片面了。为什么高阶面试中总会问到算法呢？因为算法很好地反应了候选者编程思维和计算机素养；另一方面，如果我们想进阶，算法也是必须要攻克的一道难关。\n\n#### 前端和算法简单举例\n\n我就先举一个例子作为引子，一起先热热身，看看算法应用在前端开发中的一个小细节。\n\n想必不少读者写过“抽奖”代码，或者“老虎机”转盘。其中可能会涉及到一个问题，就是：\n\n> “如何将一个 JavaScript 数组打乱顺序？”\n\n事实上乱序一个数组不仅仅是前端课题，那么这个问题在前端的背景下，有哪些特点呢？可能有读者首先想到使用数组的 sort API，再结合 Math.random 实现：\n\n```\n[12,4,16,3].sort(function() {\n    return .5 - Math.random();\n})\n```\n\n这样的思路非常自然，但也许你不知道：这不是真正意义上的完全乱序。\n\n为此我们进行验证，对数组\n\n```\nlet letters = [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;,&apos;G&apos;,&apos;H&apos;,&apos;I&apos;,&apos;J&apos;]\n```\n\n使用 array.sort 方法进行了 10000 次乱序处理，并对乱序之后得到的新数组中，每一个字母出现的位置进行统计，并可视化输出：\n\n```\n<body>\n        <table id=\"results\">\n            <tr>\n                <th style=\"background-color:#ccccff\">Results</th>\n                <th>slot 0</th>\n                <th>slot 1</th>\n                <th>slot 2</th>\n                <th>slot 3</th>\n                <th>slot 4</th>\n                <th>slot 5</th>\n                <th>slot 6</th>\n                <th>slot 7</th>\n                <th>slot 8</th>\n                <th>slot 9</th>\n            </tr>\n            <tr>\n                <th>A&apos;s</th><td class=\"strongbias\">0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>\n            </tr>\n            <tr>\n                <th>B&apos;s</th><td>0</td><td class=\"strongbias\">0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>\n            </tr>\n            <tr>\n                <th>C&apos;s</th><td>0</td><td>0</td><td class=\"bias\">0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>\n            </tr>\n            <tr>\n                <th>D&apos;s</th><td>0</td><td>0</td><td>0</td><td class=\"bias\">0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>\n            </tr>\n            <tr>\n                <th>E&apos;s</th><td>0</td><td>0</td><td>0</td><td>0</td><td class=\"bias\">0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>\n            </tr>\n            <tr>\n                <th>F&apos;s</th><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td class=\"bias\">0</td><td>0</td><td>0</td><td>0</td><td>0</td>\n            </tr>\n            <tr>\n                <th>G&apos;s</th><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td class=\"bias\">0</td><td>0</td><td>0</td><td>0</td>\n            </tr>\n            <tr>\n                <th>H&apos;s</th><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td class=\"bias\">0</td><td>0</td><td>0</td>\n            </tr>\n            <tr>\n                <th>I&apos;s</th><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td class=\"strongbias\">0</td><td>0</td>\n            </tr>\n            <tr>\n                <th>J&apos;s</th><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td class=\"strongbias\">0</td>\n            </tr>\n        </table>\n        <div>\n            <input type=\"button\" value=\"recalculate\" onclick=\"recalc()\">\n        </div>\n    </body>\n    <script>\n        const recalc = () => {\n            const countings = [\n                {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0},\n                {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0},\n                {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0},\n                {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0},\n                {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0},\n                {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0},\n                {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0},\n                {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0},\n                {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0},\n                {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0}\n            ]\n            let letters=[&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;,&apos;G&apos;,&apos;H&apos;,&apos;I&apos;,&apos;J&apos;];\n            for (let i = 0; i < 10000; i++) {\n                var r = [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;,&apos;G&apos;,&apos;H&apos;,&apos;I&apos;,&apos;J&apos;].sort(function() {\n                    return .5 - Math.random()\n                })\n                for(var j = 0; j <= 9; j++) {\n                    countings[j][r[j]]++\n                }\n            }\n            for(var i = 0; i <= 9;i++) {\n                for(var j = 0;j <= 9;j++) {\n                    document.getElementById(&apos;results&apos;).rows[i + 1].cells[j + 1].firstChild.data = countings[i][letters[j]]\n                }\n            }\n        }\n        recalc()\n    </script>\n```\n\n得到结果：\n\n![1](https://images.gitbook.cn/75e69d10-d828-11e9-8fae-816b29059b0c)\n\n不管点击按钮几次，你都会发现整体乱序之后的结果绝对不是“完全随机”。\n\n比如，A 元素大概率出现在数组的头部，J 元素大概率出现在数组的尾部，所有元素大概率停留在自己初始位置。\n\n这是为什么呢？\n\n究其原因，在 Chrome v8 引擎源码中，可以清晰看到：\n\n> v8 在处理 sort 方法时，使用了插入排序和快排两种方案。当目标数组长度小于 10（不同版本有差别）时，使用插入排序；反之，使用快排。\n\n其实不管用什么排序方法，大多数排序算法的时间复杂度介于 O(n) 到 O(n2) 之间，元素之间的比较次数通常情况下要远小于 n(n-1)/2，也就意味着有一些元素之间根本就没机会相比较（也就没有了随机交换的可能），这些 sort 随机排序的算法自然也不能真正随机。\n\n通俗地说，其实我们使用 array.sort 进行乱序，理想的方案或者说纯乱序的方案是：数组中每两个元素都要进行比较，这个比较有 50% 的交换位置概率。如此一来，总共比较次数一定为 n(n-1)。\n\n而在 sort 排序算法中，大多数情况都不会满足这样的条件，因此当然不是完全随机的结果了。\n\n那为了满足乱序一个数组的需求，我们应该怎么做呢？\n\nFisher–Yates shuffle 洗牌算法——会是一个更好的选择。这里，我们简单借助图形来理解，非常简单直观。接下来就会明白为什么这是理论上的完全乱序（图片来源于网络）。\n\n首先我们有一个已经排好序的数组：\n\n![2](https://images.gitbook.cn/d8ed90d0-d828-11e9-8797-4924c0d7c082)\n\n**Step1**：\n\n这一步需要做的就是，从数组末尾开始，选取最后一个元素。\n\n![3](https://images.gitbook.cn/fd022b20-d828-11e9-9143-0bdf45914741)\n\n在数组一共 9 个位置中，随机产生一个位置，该位置元素与最后一个元素进行交换。\n\n![4](https://images.gitbook.cn/68a6a040-d829-11e9-a98d-91914e1a8fb9)\n\n![5](https://images.gitbook.cn/80791b30-d829-11e9-a98d-91914e1a8fb9)\n\n![6](https://images.gitbook.cn/9dc03930-d829-11e9-9143-0bdf45914741)\n\n**Step2：**\n\n在上一步中，我们已经把数组末尾元素进行随机置换。\n\n接下来，对数组倒数第二个元素动手。在除去已经排好的最后一个元素位置以外的 8 个位置中，随机产生一个位置，该位置元素与倒数第二个元素进行交换。\n\n![7](https://images.gitbook.cn/f0037d10-d829-11e9-8797-4924c0d7c082)\n\n![8](https://images.gitbook.cn/0aa48150-d82a-11e9-9143-0bdf45914741)\n\n![9](https://images.gitbook.cn/252b1fc0-d82a-11e9-8797-4924c0d7c082)\n\n**Step3：**\n\n理解了前两步，接下来就是依次进行，如此简单。\n\n![10](https://images.gitbook.cn/7cd8cd80-d82a-11e9-8fae-816b29059b0c)\n\n明白了原理，代码实现也很简单：\n\n```\nArray.prototype.shuffle = function() {\n    var array = this;\n    var m = array.length,\n        t, i;\n    while (m) {\n        i = Math.floor(Math.random() * m--);\n        t = array[m];\n        array[m] = array[i];\n        array[i] = t;\n    }\n    return array;\n}\n```\n\n### 算法的基本概念\n\n在具体讲解各种算法前，我们有必要先掌握基本概念。搞定算法，需要读者优先了解数据结构以及各种结构的相关方法，这些内容上一讲中已经进行了梳理。另外一个重要概念就是算法复杂度了，它是评估一个算法优秀程度的重要考证。我们常说的时间复杂度和空间复杂度该如何理解呢？\n\n#### 时间复杂度\n\n我们先看一下时间复杂度的概念：\n\n> 一个算法的时间复杂度反映了程序运行从开始到结束所需要的时间。把算法中基本操作重复执行的次数（频度）作为算法的时间复杂度。\n\n但是时间复杂度的计算既可以“有理可依”，又可以靠“主观感觉”。通常我们认为：\n\n- 没有循环语句，时间复杂度记作 O(1)，我们称为常数阶；\n- 只有一重循环，那么算法的基本操作的执行频度与问题规模 n 呈线性增大关系，记作 O（n），也叫线性阶。\n\n那么如何让时间复杂度的计算“有理可依”呢？来看几个原则：\n\n- 只看循环次数最多的代码\n- 加法法则：总复杂度等于量级最大的那段代码的复杂度\n- 乘法法则：嵌套代码的复杂度等于嵌套内外复杂度的乘积\n\n我们来逐一分析：\n\n```\nconst cal = n => { \n   let sum = 0\n   let i = 1\n   for (; i <= n; ++i) {\n     sum = sum + i\n   }\n   return sum\n }\n```\n\n执行次数最多的是 for 循环及里面的代码，执行了 n 次，应该“只看循环次数最多的代码”原则，因此时间复杂度为 O(n)。\n\n```\nconst cal = n => {\n   let sum1 = 0\n   let p = 1\n   \n   for (; p < 100; ++p) {\n     sum1= sum1 + p\n   }\n\n   let sum2 = 0\n   let q = 1\n   for (; q < n; ++q) {\n     sum2 = sum2 + q\n   }\n \n   let sum3 = 0\n   let i = 1\n   let j = 1\n   for (; i <= n; ++i) {\n     j = 1\n     for (; j <= n; ++j) {\n       sum3 = sum3 +  i * j\n     }\n   }\n \n   return sum1 + sum2 + sum3\n }\n```\n\n上述代码分别对 sum1、sum2、sum3 求和：\n\n- 对于 sum1 求和，循环 100 次，常数执行时间，时间复杂度为 O(1)；\n- 对于 sum2 求和，循环规模为 n，时间复杂度为 O(n)；\n- 对于 sum3 求和，两层循环，时间复杂度为 O(n²)。\n\n因此 O(1) + O(n) + O(n²)，取三段代码的最大量级，上面例子最终的时间复杂度为 O(n²)。\n\n对于代码：\n\n```\nconst cal = n => {\n   let ret = 0\n   let i = 1\n   for (; i < n; ++i) {\n     ret = ret + f(i); // 注意  f(i)\n   } \n } \n \nconst f = n => {\n  let sum = 0\n  let i = 1\n  for (; i < n; ++i) {\n    sum = sum + i\n  } \n  return sum\n }\n```\n\n方法 cal 循环里面调用 f 方法，而 f 方法里面也有循环，这时应用第三个原则——乘法原则，得到时间复杂度 O(n²)。\n\n最后我们再看一个对数阶的概念：\n\n```\nconst aFun = n => {\n  let i = 1;\n  while (i <= n)  {\n     i = i * 2\n  }\n  return i\n}\n\nconst cal = n => { \n   let sum = 0\n   for (let i = 1; i <= n; ++i) {\n     sum = sum + aFun(n)\n   }\n   return sum\n }\n```\n\n这里的不同之处是 aFun 每次循环，i = i * 2，那么自然不再是全遍历。想想高中学过的等比数列：\n\n```\n2^0 * 2^1 * 2^2 * 2^k * 2^x = n\n```\n\n因此，我们只要知道 x 值是多少，就知道这行代码执行的次数了，通过 2x = n 求解 x，数学中求解得 x = log2n 。即上面代码的时间复杂度为 O(log2n)。\n\n但是不知道读者有没有发现：不管是以 2 为底，还是以 K 为底，我们似乎都把所有对数阶的时间复杂度都记为 O(logn)。这又是为什么呢？\n\n事实上，基本的数学概念告诉我们：对数之间是可以互相转换的，log3n = log32 * log2n，因此 O(log3n) = O(C * log2n)，其中 C=log32 是一个常量。所以全部以 2 为底，并没有什么问题。\n\n总之，需要读者准确理解：由于**时间复杂度**描述的是**算法执行时间与数据规模的增长变化趋势**，因而常量、低阶、系数实际上对这种增长趋势不产生决定性影响，所以在做时间复杂度分析时忽略这些项。\n\n#### 最好、最坏时间复杂度，平均时间复杂度，均摊时间复杂度\n\n我们来看一段代码：\n\n```\nconst find = (array, x) => {\n    let pos = -1\n    let n = array.length\n\n    for (let i = 0; i < n; ++i) {\n        if (array[i] === x) {\n            pos = i\n        }\n    }\n\n    return pos\n}\n```\n\n上面的代码有一层循环，循环规模和 n 成线性关系。因此时间复杂度为 O(n)，我们改动代码为：\n\n```\nconst find = (array, x) => {\n     let pos = -1\n     let n = array.length\n\n     for (let i = 0; i < n; ++i) {\n            if (array[i] === x) {\n                 pos = i \n                 break\n            }\n      }\n      return pos\n}\n```\n\n在找到第一个匹配元素后，循环终止，那么时间复杂度就不一定是 O(n) 了，因此就有了最好时间复杂度、最坏时间复杂度的区别。针对上述代码最好时间复杂度就是 O(1)、最坏时间复杂度还是 O(n)。\n\n最好时间复杂度、最坏时间复杂度其实都是极端情况，我们可以从统计学角度给出一个平均时间复杂度。在上述代码中，平均时间复杂度的计算方式应该是：\n\n```\n(1/(n+1)) * 1 + (1/(n+1)) * 2 + ... + (1/(n+1)) * n + (1/(n+1)) * n\n```\n\n得到结果为：n(n+3)/2(n+1)\n\n因为变量 x 出现在数组中的位置分别有 0 —— n－1  种情况，对应需要遍历的次数；除此之外，还有变量 x 不出现在数组中，这种情况仍然后遍历完数组。\n\n上述结果简化之后仍然得到 O(n)。\n\n我们再来看一段代码：\n\n```\nlet array = new Array(n)\nlet count = 0\nfunction insert(val) {\n    let len = array.length\n    if (count === len) {\n        let sum = 0\n        for (let i = 0; i < len; i++) {\n            sum = sum + array[i]\n        }\n        array[0] = sum\n        count = 1\n    }\n    array[count] = val\n    ++count\n}\n```\n\n这段代码逻辑很简单：我们实现了一个往数组中插入数据的功能。但是多了些判断：当数组满了之后，即 count === len 时，采用 for 循环对数组进行求和，求和完毕之后：先清空数组，然后将求和之后的结果放到数组的第一个位置，最后再将新的数据插入。\n\n这是一段非常典型的代码，我们来看它的时间复杂度：\n\n- 最好时间复杂度\n\n数组中有空闲，count !== len，直接执行插入操作，复杂度为 O(1)。\n\n- 最好时间复杂度\n\n数组已满，count === len，需要先遍历一遍再求和，复杂度为 O(n)。\n\n- 平均时间复杂度\n\n假设数组长度为 n，数组空闲时，复杂度为 O(1)；数组已满，复杂度为 O(n)。采用平均加权方式：\n\n```\n(1/(n+1)) * 1 + (1/(n+1)) * 1 + ... + (1/(n+1)) * n\n```\n\n公式求和仍为 O(1)，主观上想：我们的操作是在进行了 n 个 O(1) 的插入操作后，此时数组满了，执行一次 O(n) 的求和和清空操作。这样一来，其实前面的 n 个O (1) 和最后的 1 个 O(n) 其实是可以抵消掉的，这是一种均摊时间复杂度的概念。\n\n这种均摊的概念是有实际应用场景的。例如，C++ 里的 vector 动态数组的自动扩容机制，每次往 vector 里 push 值的时候会判断当前 size 是否等于 capacity，一旦元素超过容器限制，则再申请扩大一倍的内存空间，把原来 vector 里的值复制到新的空间里，触发扩容的这次 push 操作的时间复杂度是 O(n)，但均摊到前面 n 个元素后，可以认为时间复杂度是 O(1) 常数。\n\n最后总结一下，常见时间复杂度：\n\n- O(1)：基本运算 +、-、*、/、%、寻址\n- O(logn)：二分查找，跟分治（Divide & Conquer）相关的基本上都是 logn\n- O(n)：线性查找\n- O(nlogn)：归并排序，快速排序的期望复杂度，基于比较排序的算法下界\n- O(n²)：冒泡排序，插入排序，朴素最近点对\n- O(n³)：Floyd 最短路，普通矩阵乘法\n- O(2ⁿ)：枚举全部子集\n- O(n!)：枚举全排列\n\nO(logn) 近似于是常数的时间复杂度，当 n 为 $2^{32}$ 的规模时 logn 也只是 32 而已；\n对于顺序执行的语句或者算法，总的时间复杂度等于其中最大的时间复杂度。例如，O(n²) + O(n) 可直接记做 O(n²)。\n\n#### 空间复杂度\n\n空间复杂度表示算法的存储空间与数据规模之间的增长关系。常见的空间复杂度：O(1)、O(n)、O(n²)，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。有的题目在空间上要求 in-place（原地），是指使用 O(1) 空间，在输入的空间上进行原地操作，比如字符串反转。但 in-place 又不完全等同于常数的空间复杂度，比如数组的快排认为是 in-place 交换，但其递归产生的堆栈的空间是可以不考虑的，因此 in-place 相对 O(1) 空间的要求会更宽松一点。\n\n对于时间复杂度和空间复杂度，开发者应该有所取舍。在设计算法时，可以考虑“牺牲空间复杂度，换取时间复杂度的优化”，反之依然。空间复杂度我们不再过多介绍。\n\n### 总结\n\n本讲我们介绍了算法的基本概念，重点就是时间复杂度和空间复杂度分析，同时剖出了一个“乱序数组”算法进行热身。算法的大门才刚刚打开，请读者继续保持学习。","pdfUrl":"","reader":"","duration":"","title":"那些年常考的前端算法（上）","column":"5c91c813968b1d64b1e08fde","isNotification":false,"readingStatistics":0,"htmlContent":"<p>在上一讲中，我们全面梳理了重要的数据结构，并用 JavaScript 对各种数据结构进行了实现和方法模拟。数据结构常与算法一起出现，两者相互依存密不可分。这一讲，我们来研究一下“那些年常考的前端算法”。</p>\n<p>主要内容如下：</p>\n<p><img src=\"https://images.gitbook.cn/a80ed7e0-d827-11e9-a98d-91914e1a8fb9\" alt=\"enter image description here\" /></p>\n<p>我们将通过三讲的内容来剖析算法问题。本讲先“轻松”一下，主要介绍前端和算法的关系，以及算法中的一些基本概念。</p>\n<h3><a id=\"_8\"></a>前端和算法</h3>\n<p>前端和算法有什么关系呢？我想先纠正两个常见的错误认知。</p>\n<h4><a id=\"_12\"></a>关于算法的误解</h4>\n<ul>\n<li>前端没有算法？</li>\n</ul>\n<p>“前端没有算法”这种说法往往出自算法岗甚至后端读者，这种认知是错误的。前端不仅有算法，而且算法在前端开发中占据的地位也越来越重要。我们常提到的 Virtual dom diff、webpack 实现、React fiber、React hooks、响应式编程、浏览器引擎工作方式等都有算法的影子。在业务代码中，哪怕写一个抽奖游戏，写一个混淆函数都离不开算法。</p>\n<ul>\n<li>算法重要不重要？</li>\n</ul>\n<p>有读者认为，前端中算法只是提供了一些偏底层的能力和实现支持，我在业务开发中真正使用到算法的场景也很有限。事实上，不仅单纯的前端业务，哪怕对于后端业务来说，真正让你“徒手”实现一段算法的场景也不算多。但是据此得出算法不重要的说法还是太片面了。为什么高阶面试中总会问到算法呢？因为算法很好地反应了候选者编程思维和计算机素养；另一方面，如果我们想进阶，算法也是必须要攻克的一道难关。</p>\n<h4><a id=\"_22\"></a>前端和算法简单举例</h4>\n<p>我就先举一个例子作为引子，一起先热热身，看看算法应用在前端开发中的一个小细节。</p>\n<p>想必不少读者写过“抽奖”代码，或者“老虎机”转盘。其中可能会涉及到一个问题，就是：</p>\n<blockquote>\n<p>“如何将一个 JavaScript 数组打乱顺序？”</p>\n</blockquote>\n<p>事实上乱序一个数组不仅仅是前端课题，那么这个问题在前端的背景下，有哪些特点呢？可能有读者首先想到使用数组的 sort API，再结合 Math.random 实现：</p>\n<pre><code class=\"lang-\">[12,4,16,3].sort(function() {\n    return .5 - Math.random();\n})\n</code></pre>\n<p>这样的思路非常自然，但也许你不知道：这不是真正意义上的完全乱序。</p>\n<p>为此我们进行验证，对数组</p>\n<pre><code class=\"lang-\">let letters = [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;,&apos;G&apos;,&apos;H&apos;,&apos;I&apos;,&apos;J&apos;]\n</code></pre>\n<p>使用 array.sort 方法进行了 10000 次乱序处理，并对乱序之后得到的新数组中，每一个字母出现的位置进行统计，并可视化输出：</p>\n<pre><code class=\"lang-\">&lt;body&gt;\n        &lt;table id=&quot;results&quot;&gt;\n            &lt;tr&gt;\n                &lt;th style=&quot;background-color:#ccccff&quot;&gt;Results&lt;/th&gt;\n                &lt;th&gt;slot 0&lt;/th&gt;\n                &lt;th&gt;slot 1&lt;/th&gt;\n                &lt;th&gt;slot 2&lt;/th&gt;\n                &lt;th&gt;slot 3&lt;/th&gt;\n                &lt;th&gt;slot 4&lt;/th&gt;\n                &lt;th&gt;slot 5&lt;/th&gt;\n                &lt;th&gt;slot 6&lt;/th&gt;\n                &lt;th&gt;slot 7&lt;/th&gt;\n                &lt;th&gt;slot 8&lt;/th&gt;\n                &lt;th&gt;slot 9&lt;/th&gt;\n            &lt;/tr&gt;\n            &lt;tr&gt;\n                &lt;th&gt;A&apos;s&lt;/th&gt;&lt;td class=&quot;strongbias&quot;&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;\n            &lt;/tr&gt;\n            &lt;tr&gt;\n                &lt;th&gt;B&apos;s&lt;/th&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;strongbias&quot;&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;\n            &lt;/tr&gt;\n            &lt;tr&gt;\n                &lt;th&gt;C&apos;s&lt;/th&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;bias&quot;&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;\n            &lt;/tr&gt;\n            &lt;tr&gt;\n                &lt;th&gt;D&apos;s&lt;/th&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;bias&quot;&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;\n            &lt;/tr&gt;\n            &lt;tr&gt;\n                &lt;th&gt;E&apos;s&lt;/th&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;bias&quot;&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;\n            &lt;/tr&gt;\n            &lt;tr&gt;\n                &lt;th&gt;F&apos;s&lt;/th&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;bias&quot;&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;\n            &lt;/tr&gt;\n            &lt;tr&gt;\n                &lt;th&gt;G&apos;s&lt;/th&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;bias&quot;&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;\n            &lt;/tr&gt;\n            &lt;tr&gt;\n                &lt;th&gt;H&apos;s&lt;/th&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;bias&quot;&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;\n            &lt;/tr&gt;\n            &lt;tr&gt;\n                &lt;th&gt;I&apos;s&lt;/th&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;strongbias&quot;&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;\n            &lt;/tr&gt;\n            &lt;tr&gt;\n                &lt;th&gt;J&apos;s&lt;/th&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;strongbias&quot;&gt;0&lt;/td&gt;\n            &lt;/tr&gt;\n        &lt;/table&gt;\n        &lt;div&gt;\n            &lt;input type=&quot;button&quot; value=&quot;recalculate&quot; onclick=&quot;recalc()&quot;&gt;\n        &lt;/div&gt;\n    &lt;/body&gt;\n    &lt;script&gt;\n        const recalc = () =&gt; {\n            const countings = [\n                {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0},\n                {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0},\n                {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0},\n                {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0},\n                {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0},\n                {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0},\n                {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0},\n                {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0},\n                {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0},\n                {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0}\n            ]\n            let letters=[&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;,&apos;G&apos;,&apos;H&apos;,&apos;I&apos;,&apos;J&apos;];\n            for (let i = 0; i &lt; 10000; i++) {\n                var r = [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;,&apos;G&apos;,&apos;H&apos;,&apos;I&apos;,&apos;J&apos;].sort(function() {\n                    return .5 - Math.random()\n                })\n                for(var j = 0; j &lt;= 9; j++) {\n                    countings[j][r[j]]++\n                }\n            }\n            for(var i = 0; i &lt;= 9;i++) {\n                for(var j = 0;j &lt;= 9;j++) {\n                    document.getElementById(&apos;results&apos;).rows[i + 1].cells[j + 1].firstChild.data = countings[i][letters[j]]\n                }\n            }\n        }\n        recalc()\n    &lt;/script&gt;\n</code></pre>\n<p>得到结果：</p>\n<p><img src=\"https://images.gitbook.cn/75e69d10-d828-11e9-8fae-816b29059b0c\" alt=\"1\" /></p>\n<p>不管点击按钮几次，你都会发现整体乱序之后的结果绝对不是“完全随机”。</p>\n<p>比如，A 元素大概率出现在数组的头部，J 元素大概率出现在数组的尾部，所有元素大概率停留在自己初始位置。</p>\n<p>这是为什么呢？</p>\n<p>究其原因，在 Chrome v8 引擎源码中，可以清晰看到：</p>\n<blockquote>\n<p>v8 在处理 sort 方法时，使用了插入排序和快排两种方案。当目标数组长度小于 10（不同版本有差别）时，使用插入排序；反之，使用快排。</p>\n</blockquote>\n<p>其实不管用什么排序方法，大多数排序算法的时间复杂度介于 O(n) 到 O(n2) 之间，元素之间的比较次数通常情况下要远小于 n(n-1)/2，也就意味着有一些元素之间根本就没机会相比较（也就没有了随机交换的可能），这些 sort 随机排序的算法自然也不能真正随机。</p>\n<p>通俗地说，其实我们使用 array.sort 进行乱序，理想的方案或者说纯乱序的方案是：数组中每两个元素都要进行比较，这个比较有 50% 的交换位置概率。如此一来，总共比较次数一定为 n(n-1)。</p>\n<p>而在 sort 排序算法中，大多数情况都不会满足这样的条件，因此当然不是完全随机的结果了。</p>\n<p>那为了满足乱序一个数组的需求，我们应该怎么做呢？</p>\n<p>Fisher–Yates shuffle 洗牌算法——会是一个更好的选择。这里，我们简单借助图形来理解，非常简单直观。接下来就会明白为什么这是理论上的完全乱序（图片来源于网络）。</p>\n<p>首先我们有一个已经排好序的数组：</p>\n<p><img src=\"https://images.gitbook.cn/d8ed90d0-d828-11e9-8797-4924c0d7c082\" alt=\"2\" /></p>\n<p><strong>Step1</strong>：</p>\n<p>这一步需要做的就是，从数组末尾开始，选取最后一个元素。</p>\n<p><img src=\"https://images.gitbook.cn/fd022b20-d828-11e9-9143-0bdf45914741\" alt=\"3\" /></p>\n<p>在数组一共 9 个位置中，随机产生一个位置，该位置元素与最后一个元素进行交换。</p>\n<p><img src=\"https://images.gitbook.cn/68a6a040-d829-11e9-a98d-91914e1a8fb9\" alt=\"4\" /></p>\n<p><img src=\"https://images.gitbook.cn/80791b30-d829-11e9-a98d-91914e1a8fb9\" alt=\"5\" /></p>\n<p><img src=\"https://images.gitbook.cn/9dc03930-d829-11e9-9143-0bdf45914741\" alt=\"6\" /></p>\n<p><strong>Step2：</strong></p>\n<p>在上一步中，我们已经把数组末尾元素进行随机置换。</p>\n<p>接下来，对数组倒数第二个元素动手。在除去已经排好的最后一个元素位置以外的 8 个位置中，随机产生一个位置，该位置元素与倒数第二个元素进行交换。</p>\n<p><img src=\"https://images.gitbook.cn/f0037d10-d829-11e9-8797-4924c0d7c082\" alt=\"7\" /></p>\n<p><img src=\"https://images.gitbook.cn/0aa48150-d82a-11e9-9143-0bdf45914741\" alt=\"8\" /></p>\n<p><img src=\"https://images.gitbook.cn/252b1fc0-d82a-11e9-8797-4924c0d7c082\" alt=\"9\" /></p>\n<p><strong>Step3：</strong></p>\n<p>理解了前两步，接下来就是依次进行，如此简单。</p>\n<p><img src=\"https://images.gitbook.cn/7cd8cd80-d82a-11e9-8fae-816b29059b0c\" alt=\"10\" /></p>\n<p>明白了原理，代码实现也很简单：</p>\n<pre><code class=\"lang-\">Array.prototype.shuffle = function() {\n    var array = this;\n    var m = array.length,\n        t, i;\n    while (m) {\n        i = Math.floor(Math.random() * m--);\n        t = array[m];\n        array[m] = array[i];\n        array[i] = t;\n    }\n    return array;\n}\n</code></pre>\n<h3><a id=\"_209\"></a>算法的基本概念</h3>\n<p>在具体讲解各种算法前，我们有必要先掌握基本概念。搞定算法，需要读者优先了解数据结构以及各种结构的相关方法，这些内容上一讲中已经进行了梳理。另外一个重要概念就是算法复杂度了，它是评估一个算法优秀程度的重要考证。我们常说的时间复杂度和空间复杂度该如何理解呢？</p>\n<h4><a id=\"_213\"></a>时间复杂度</h4>\n<p>我们先看一下时间复杂度的概念：</p>\n<blockquote>\n<p>一个算法的时间复杂度反映了程序运行从开始到结束所需要的时间。把算法中基本操作重复执行的次数（频度）作为算法的时间复杂度。</p>\n</blockquote>\n<p>但是时间复杂度的计算既可以“有理可依”，又可以靠“主观感觉”。通常我们认为：</p>\n<ul>\n<li>没有循环语句，时间复杂度记作 O(1)，我们称为常数阶；</li>\n<li>只有一重循环，那么算法的基本操作的执行频度与问题规模 n 呈线性增大关系，记作 O（n），也叫线性阶。</li>\n</ul>\n<p>那么如何让时间复杂度的计算“有理可依”呢？来看几个原则：</p>\n<ul>\n<li>只看循环次数最多的代码</li>\n<li>加法法则：总复杂度等于量级最大的那段代码的复杂度</li>\n<li>乘法法则：嵌套代码的复杂度等于嵌套内外复杂度的乘积</li>\n</ul>\n<p>我们来逐一分析：</p>\n<pre><code class=\"lang-\">const cal = n =&gt; { \n   let sum = 0\n   let i = 1\n   for (; i &lt;= n; ++i) {\n     sum = sum + i\n   }\n   return sum\n }\n</code></pre>\n<p>执行次数最多的是 for 循环及里面的代码，执行了 n 次，应该“只看循环次数最多的代码”原则，因此时间复杂度为 O(n)。</p>\n<pre><code class=\"lang-\">const cal = n =&gt; {\n   let sum1 = 0\n   let p = 1\n   \n   for (; p &lt; 100; ++p) {\n     sum1= sum1 + p\n   }\n\n   let sum2 = 0\n   let q = 1\n   for (; q &lt; n; ++q) {\n     sum2 = sum2 + q\n   }\n \n   let sum3 = 0\n   let i = 1\n   let j = 1\n   for (; i &lt;= n; ++i) {\n     j = 1\n     for (; j &lt;= n; ++j) {\n       sum3 = sum3 +  i * j\n     }\n   }\n \n   return sum1 + sum2 + sum3\n }\n</code></pre>\n<p>上述代码分别对 sum1、sum2、sum3 求和：</p>\n<ul>\n<li>对于 sum1 求和，循环 100 次，常数执行时间，时间复杂度为 O(1)；</li>\n<li>对于 sum2 求和，循环规模为 n，时间复杂度为 O(n)；</li>\n<li>对于 sum3 求和，两层循环，时间复杂度为 O(n²)。</li>\n</ul>\n<p>因此 O(1) + O(n) + O(n²)，取三段代码的最大量级，上面例子最终的时间复杂度为 O(n²)。</p>\n<p>对于代码：</p>\n<pre><code class=\"lang-\">const cal = n =&gt; {\n   let ret = 0\n   let i = 1\n   for (; i &lt; n; ++i) {\n     ret = ret + f(i); // 注意  f(i)\n   } \n } \n \nconst f = n =&gt; {\n  let sum = 0\n  let i = 1\n  for (; i &lt; n; ++i) {\n    sum = sum + i\n  } \n  return sum\n }\n</code></pre>\n<p>方法 cal 循环里面调用 f 方法，而 f 方法里面也有循环，这时应用第三个原则——乘法原则，得到时间复杂度 O(n²)。</p>\n<p>最后我们再看一个对数阶的概念：</p>\n<pre><code class=\"lang-\">const aFun = n =&gt; {\n  let i = 1;\n  while (i &lt;= n)  {\n     i = i * 2\n  }\n  return i\n}\n\nconst cal = n =&gt; { \n   let sum = 0\n   for (let i = 1; i &lt;= n; ++i) {\n     sum = sum + aFun(n)\n   }\n   return sum\n }\n</code></pre>\n<p>这里的不同之处是 aFun 每次循环，i = i * 2，那么自然不再是全遍历。想想高中学过的等比数列：</p>\n<pre><code class=\"lang-\">2^0 * 2^1 * 2^2 * 2^k * 2^x = n\n</code></pre>\n<p>因此，我们只要知道 x 值是多少，就知道这行代码执行的次数了，通过 2x = n 求解 x，数学中求解得 x = log2n 。即上面代码的时间复杂度为 O(log2n)。</p>\n<p>但是不知道读者有没有发现：不管是以 2 为底，还是以 K 为底，我们似乎都把所有对数阶的时间复杂度都记为 O(logn)。这又是为什么呢？</p>\n<p>事实上，基本的数学概念告诉我们：对数之间是可以互相转换的，log3n = log32 * log2n，因此 O(log3n) = O(C * log2n)，其中 C=log32 是一个常量。所以全部以 2 为底，并没有什么问题。</p>\n<p>总之，需要读者准确理解：由于<strong>时间复杂度</strong>描述的是<strong>算法执行时间与数据规模的增长变化趋势</strong>，因而常量、低阶、系数实际上对这种增长趋势不产生决定性影响，所以在做时间复杂度分析时忽略这些项。</p>\n<h4><a id=\"_339\"></a>最好、最坏时间复杂度，平均时间复杂度，均摊时间复杂度</h4>\n<p>我们来看一段代码：</p>\n<pre><code class=\"lang-\">const find = (array, x) =&gt; {\n    let pos = -1\n    let n = array.length\n\n    for (let i = 0; i &lt; n; ++i) {\n        if (array[i] === x) {\n            pos = i\n        }\n    }\n\n    return pos\n}\n</code></pre>\n<p>上面的代码有一层循环，循环规模和 n 成线性关系。因此时间复杂度为 O(n)，我们改动代码为：</p>\n<pre><code class=\"lang-\">const find = (array, x) =&gt; {\n     let pos = -1\n     let n = array.length\n\n     for (let i = 0; i &lt; n; ++i) {\n            if (array[i] === x) {\n                 pos = i \n                 break\n            }\n      }\n      return pos\n}\n</code></pre>\n<p>在找到第一个匹配元素后，循环终止，那么时间复杂度就不一定是 O(n) 了，因此就有了最好时间复杂度、最坏时间复杂度的区别。针对上述代码最好时间复杂度就是 O(1)、最坏时间复杂度还是 O(n)。</p>\n<p>最好时间复杂度、最坏时间复杂度其实都是极端情况，我们可以从统计学角度给出一个平均时间复杂度。在上述代码中，平均时间复杂度的计算方式应该是：</p>\n<pre><code class=\"lang-\">(1/(n+1)) * 1 + (1/(n+1)) * 2 + ... + (1/(n+1)) * n + (1/(n+1)) * n\n</code></pre>\n<p>得到结果为：n(n+3)/2(n+1)</p>\n<p>因为变量 x 出现在数组中的位置分别有 0 —— n－1  种情况，对应需要遍历的次数；除此之外，还有变量 x 不出现在数组中，这种情况仍然后遍历完数组。</p>\n<p>上述结果简化之后仍然得到 O(n)。</p>\n<p>我们再来看一段代码：</p>\n<pre><code class=\"lang-\">let array = new Array(n)\nlet count = 0\nfunction insert(val) {\n    let len = array.length\n    if (count === len) {\n        let sum = 0\n        for (let i = 0; i &lt; len; i++) {\n            sum = sum + array[i]\n        }\n        array[0] = sum\n        count = 1\n    }\n    array[count] = val\n    ++count\n}\n</code></pre>\n<p>这段代码逻辑很简单：我们实现了一个往数组中插入数据的功能。但是多了些判断：当数组满了之后，即 count === len 时，采用 for 循环对数组进行求和，求和完毕之后：先清空数组，然后将求和之后的结果放到数组的第一个位置，最后再将新的数据插入。</p>\n<p>这是一段非常典型的代码，我们来看它的时间复杂度：</p>\n<ul>\n<li>最好时间复杂度</li>\n</ul>\n<p>数组中有空闲，count !== len，直接执行插入操作，复杂度为 O(1)。</p>\n<ul>\n<li>最好时间复杂度</li>\n</ul>\n<p>数组已满，count === len，需要先遍历一遍再求和，复杂度为 O(n)。</p>\n<ul>\n<li>平均时间复杂度</li>\n</ul>\n<p>假设数组长度为 n，数组空闲时，复杂度为 O(1)；数组已满，复杂度为 O(n)。采用平均加权方式：</p>\n<pre><code class=\"lang-\">(1/(n+1)) * 1 + (1/(n+1)) * 1 + ... + (1/(n+1)) * n\n</code></pre>\n<p>公式求和仍为 O(1)，主观上想：我们的操作是在进行了 n 个 O(1) 的插入操作后，此时数组满了，执行一次 O(n) 的求和和清空操作。这样一来，其实前面的 n 个O (1) 和最后的 1 个 O(n) 其实是可以抵消掉的，这是一种均摊时间复杂度的概念。</p>\n<p>这种均摊的概念是有实际应用场景的。例如，C++ 里的 vector 动态数组的自动扩容机制，每次往 vector 里 push 值的时候会判断当前 size 是否等于 capacity，一旦元素超过容器限制，则再申请扩大一倍的内存空间，把原来 vector 里的值复制到新的空间里，触发扩容的这次 push 操作的时间复杂度是 O(n)，但均摊到前面 n 个元素后，可以认为时间复杂度是 O(1) 常数。</p>\n<p>最后总结一下，常见时间复杂度：</p>\n<ul>\n<li>O(1)：基本运算 +、-、*、/、%、寻址</li>\n<li>O(logn)：二分查找，跟分治（Divide &amp; Conquer）相关的基本上都是 logn</li>\n<li>O(n)：线性查找</li>\n<li>O(nlogn)：归并排序，快速排序的期望复杂度，基于比较排序的算法下界</li>\n<li>O(n²)：冒泡排序，插入排序，朴素最近点对</li>\n<li>O(n³)：Floyd 最短路，普通矩阵乘法</li>\n<li>O(2ⁿ)：枚举全部子集</li>\n<li>O(n!)：枚举全排列</li>\n</ul>\n<p>O(logn) 近似于是常数的时间复杂度，当 n 为 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mn>2</mn><mrow><mn>3</mn><mn>2</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">2^{32}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathrm\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">3</span><span class=\"mord mathrm mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span> 的规模时 logn 也只是 32 而已；<br />\n对于顺序执行的语句或者算法，总的时间复杂度等于其中最大的时间复杂度。例如，O(n²) + O(n) 可直接记做 O(n²)。</p>\n<h4><a id=\"_447\"></a>空间复杂度</h4>\n<p>空间复杂度表示算法的存储空间与数据规模之间的增长关系。常见的空间复杂度：O(1)、O(n)、O(n²)，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。有的题目在空间上要求 in-place（原地），是指使用 O(1) 空间，在输入的空间上进行原地操作，比如字符串反转。但 in-place 又不完全等同于常数的空间复杂度，比如数组的快排认为是 in-place 交换，但其递归产生的堆栈的空间是可以不考虑的，因此 in-place 相对 O(1) 空间的要求会更宽松一点。</p>\n<p>对于时间复杂度和空间复杂度，开发者应该有所取舍。在设计算法时，可以考虑“牺牲空间复杂度，换取时间复杂度的优化”，反之依然。空间复杂度我们不再过多介绍。</p>\n<h3><a id=\"_453\"></a>总结</h3>\n<p>本讲我们介绍了算法的基本概念，重点就是时间复杂度和空间复杂度分析，同时剖出了一个“乱序数组”算法进行热身。算法的大门才刚刚打开，请读者继续保持学习。</p>\n","createdAt":"2019-04-21T04:47:12.671Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":41,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FoThASW9dVEPMEo9nP-zaOfbKyLZ"},{"_id":"5cbbf60bbbbba80861a35c78","communication_start_time":null,"type":1,"audioPath":"","abstract":"","content":"上一讲我们剖析了算法的一些基本概念。这一讲将围绕 v8 引申出的算法进行分析，同时做一些常见、典型考题。主要内容如下：\n\n![enter image description here](https://images.gitbook.cn/a80ed7e0-d827-11e9-a98d-91914e1a8fb9)\n\n### v8 sort 排序的奥秘和演进\n\n前一讲，我带大家分析了“如何将一个 JavaScript 数组打乱顺序？”，其中提到了 sort 这个 API，具体有这样的一段描述：\n\n> v8 在处理 sort 方法时，使用了插入排序和快排两种方案。当目标数组长度小于 10（不同版本有差别）时，使用插入排序；反之，使用快排。\n\n如果细心的读者可能会到 v8 源代码中找寻相关的算法逻辑，那么你一定会大失所望。因为根本找不到 10 这样的常量，更没有插入排序和快排两种方案的切换，甚至连实现的预言都不是 JavaScript 或者 C++，这是为什么呢？\n\n原来，在新的 v8 版本中（具体 V8 6.9）已经使用了一种名叫 Torque 的开发语言重构，并在 7.0 改进了 sort 算法。也就是说，现在社区上几乎所有的 V8 排序源码分析都已经过时了。\n\nTorque 是 v8 团队专门为了开发 v8 引擎而开发的语言，他的后缀名是 tq。作为一种高级语言，Torque 依靠 CodeStubAssembler 编译器来转换为汇编代码。\n\n在新的版本中，v8 也采用了一种名叫 Timsort 的全新算法，这套算法最开始于 2002 被 Tim Peters 在 Python 语言中使用。\n\n从这个演进过程中，我们分为三大块来看。\n\n### 快排和插入排序\n\n排序算法多种多样，社区上的分析也比较多。这里我们挑选 v8 sort 排序中“露脸”的快速排序和插入排序进行讲解。\n\n不知道读者是否有这样的困扰：我们看一遍算法，理解了，可是过两天又完全记不得具体讲了什么。针对于此，我们应该结合算法的特点，加以应用，才能深入记忆。排序算法同样如此，对于每一种算法，我们应该先记住其思想，再记住其实现。不过要知道：“排序没有想象中那么简单”。\n\n#### 快速排序\n\n**快速排序的特点就是分治**。如何体现分治策略呢？我们首先在数组中选取一个基准点，叫做 pivot，根据这个基准点：把比基准点小的数组值放在基准点左边，把比基准点大的数组值放在基准点右边。这样一来，基于基准点，左边分区的值都小于基准点，右边分区的值都大于基准点，然后针对左边分区和右边分区进行同样的操作，直到最后排序完成。\n\n最简单的实现：\n\n```\nconst quickSort = array => {\n  if (array.length < 2) {\n    return array.slice()\n  }\n  \n  // 随机找到 pivot\n  let pivot = array[Math.floor(Math.random() * array.length)]\n  \n  let left = []\n  let middle = []\n  let right = []\n  \n  for (let i = 0; i < array.length; i++) {\n    var value = array[i]\n    if (value < pivot) {\n      left.push(value)\n    }\n    \n    if (value === pivot) {\n      middle.push(value)\n    }\n    \n    if (value > pivot) {\n      right.push(value)\n    }\n  }\n\n  // 递归进行\n  return quickSort(left).concat(middle, quickSort(right))\n}\n```\n\n这种实现方法有不少优化点，其中之一就是我们可以在原数组上进行操作，而不产生一个新的数组：\n\n```\nconst quickSort = (array, start, end) => {\n  start = start === undefined ? 0 : start\n  end = end === undefined ? arr.length - 1 : end;\n  \n  if (start >= end) {\n    return\n  }\n\n  let value = array[start]\n\n  let i = start\n  let j = end\n\n  while (i < j) {\n    // 找出右边第一个小于参照数的下标并记录\n    while (i < j && array[j] >= value) {\n      j--\n    }\n    \n    if (i < j) {\n      arr[i++] = arr[j]\n    }\n    \n    // 找出左边第一个大于参照数的下标，并记录\n    while (i < j && array[i] < value) {\n      i++\n    }\n\n    if (i < j) {\n      arr[j--] = arr[i]\n    }\n  }\n  \n  arr[i] = value\n\n  quickSort(array, start, i - 1)\n  quickSort(array, i + 1, end)\n}\n```\n\n调用方式：\n\n```\nlet arr = [0, 12, 43, 45, 88, 1, 69]\nquickSort(arr, 0, arr.length - 1)\nconsole.log(arr)\n```\n\n我们该如何理解 in place 的快排算法呢？\n\n首先使用双指针，指针开始遍历，当右边发现一个小于参照数（即 array[start]）的时候，就将该值赋值给起始位置。赋值完之后，那么右边这个位置就空闲了。这时在左边发现比参照数大的值时，就赋值给这个刚刚空闲出来的右边位置。以此类推，直到 i 不再小于 j。经过这一轮操作之后，所有比参照数小的都到了数组的左边，所有比参照数大的都到了数组右边，而数组中间被赋值为参照数。\n\n我们再来分析另外一个优化点。之前的课程中提到了尾递归调用优化，那么上面的快排能否使用尾递归进行优化呢？\n\n我们进行观察，上面的实现最后两行：\n\n```\nquickSort(array, start, i - 1)\nquickSort(array, i + 1, end)\n```\n\n如果能形成以下的形式：\n\n```\nreturn quickSort()\n```\n\n那么就实现了尾递归调用优化。为此，我们需要一个 stack 来进行参数信息的传递：\n\n```\n const quickSort = (array, stack) => {\n  let start = stack[0]\n  let end = stack[1]\n\n  let value = array[start]\n\n  let i = start\n  let j = end\n\n  while (i < j) {\n    while (i < j && array[j] >= value) {\n      j--\n    }\n    if (i < j) {\n      array[i++] = array[j]\n    }\n\n    while (i < j && array[i] < value) {\n      i++\n    }\n\n    if (i < j) {\n      array[j--] = array[i]\n    }\n  }\n\n  arr[i] = value\n  \n  // 移除已经使用完的下标\n  stack.shift()\n  stack.shift() \n  \n  // 存入新的下标\n  if (i + 1 < end) {\n    stack.unshift(i + 1, end)\n  }\n  if (start < i - 1) {\n    stack.unshift(start, i - 1)\n  }\n\n  if (stack.length == 0) {\n    return;\n  }\n\n  return quickSort(array, stack)\n}\n```\n\n最后，关于快速排序的优化点还有一个最重要的方向就是对 pivot 元素的选取。通过上面的分析，我们发现快速排序的算法核心在于选择一个 pivot，将经过比较交换的数组按基准分解为两个数区进行后续递归。\n\n那么试想，如果我们对一个已经有序的数组进行排序，恰好每次选择 pivot 时总是选择第一个或者最后一个元素，那么每次都会有一个数区是空的，递归的层数将达到 n，最后导致算法的时间复杂度退化为 O(n²)。因此 pivot 的选择非常重要。\n\n在早期 v8 使用快速排序时，采用了三数取中（median-of-three）的 pivot 优化方案：除了头尾两个元素再额外选择一个元素参与基准元素的竞争。具体 v8 源代码为：\n\n```\nvar GetThirdIndex = function(a, from, to) {\n    var t_array = new InternalArray();\n    // Use both &apos;from&apos; and &apos;to&apos; to determine the pivot candidates.\n    var increment = 200 + ((to - from) & 15);\n    var j = 0;\n    from += 1;\n    to -= 1;\n    for (var i = from; i < to; i += increment) {\n        t_array[j] = [i, a[i]];\n        j++;\n    }\n    t_array.sort(function(a, b) {\n        return comparefn(a[1], b[1]);\n    });\n    var third_index = t_array[t_array.length >> 1][0];\n    return third_index;\n};\n\nvar QuickSort = function QuickSort(a, from, to) {\n    ......\n    while (true) {\n        ......\n        if (to - from > 1000) {\n            third_index = GetThirdIndex(a, from, to);\n        } else {\n            third_index = from + ((to - from) >> 1);\n        }\n    }\n    ......\n};\n\n```\n\n由此看出，这所谓的第三个竞争元素产生方式为：\n\n- 当数组长度小于等于 1000 时，选择折半位置的元素作为目标元素\n- 当数组长度超过 1000 时，每隔 200-215 个（非固定，跟着数组长度而变化）左右的值，去选择一个元素来先确定一批候选元素。接着在这批候选元素中进行一次排序，将所得的中位值作为目标元素\n\n三数取中（median-of-three）当中，最后选取的是三个元素的中位值作为 pivot。\n\n#### 插入排序\n\n插入排序我们还是从特点入手：它先将待排序序列的第一个元素看做一个有序序列，当然了，就一个元素，那么它一定是有序的；而把第二个元素到最后一个元素当成是未排序序列；对于未排序的序列进行遍历，将扫描到的每个元素插入有序序列的适当位置，保证有序序列依然有序，那么直到所有数据都完成，我们也就完成了排序。\n\n如果待插入的元素与有序序列中的某个元素相等，那么我们统一先将待插入元素插入到相等元素的后面。\n\n我们的实现：\n\n```\nconst insertsSort = array => {\n    const length = arr.length\n    let preIndex\n    let current\n    \n    for (let i = 1; i < length; i++) {\n        preIndex = i - 1\n        current = array[i]\n        \n        while (preIndex >= 0 && array[preIndex] > current) {\n            array[preIndex + 1] = array[preIndex]\n            preIndex--\n        }\n        \n        array[preIndex + 1] = current\n    }\n    return array\n}\n```\n\n那么上述实现的插入排序有优化空间吗？\n\n这是一定的，优化空间主要有这么几个方向：\n\n- 在遍历未排序序列时，将当前元素插入到有序序列过程中，可以使用二分法减少查找次数（因为是向有序序列插入）\n- 使用链表，将有序数组转为链表这种数据结构，那么插入操作的时间复杂度为 O(1)，查找复杂度变为 O(n)\n- 使用排序二叉树，将有序数组转为排序二叉树结构，然后中序遍历该二叉树，不过这种方式需要额外空间。\n\n采用二分法的优化实现：\n\n```\nconst insertSort = array => array.reduce(insert, [])\n\nconst insert = (sortedArray, value) => {\n  const length = sortedArray.length\n  \n  if (length === 0) {\n    sortedArray.push(value)\n    return sortedArray\n  }\n\n  let i = 0\n  let j = length\n  let mid\n  \n  // 先判断是否为极端值\n  if (value < sortedArray[i]) {\n    // 直接插入到数组的最头\n    return sortedArray.unshift(value), sortedArray\n  }\n  if (value >= sortedArray[length - 1]) {\n  \t // 直接插入到数组的最尾\n    return sortedArray.push(value), sortedArray\n  }\n\n  // 开始二分查找\n  while (i < j) {\n    mid = ((j + i) / 2) | 0\n\n    if (i == mid) {\n      break\n    }\n    \n    if (value  < sortedArray[mid]) {\n      j = mid\n    }\n    \n    if (value === sortedArray[mid]) {\n      i = mid\n      break\n    }\n    \n    if (value > sortedArray[mid]) {\n      i = mid\n    }\n  }\n  \n  let midArray = [value]\n  let lastArray = sortedArray.slice(i + 1)\n  \n  sortedArray = sortedArray\n    .slice(0, i + 1)\n    .concat(midArray)\n    .concat(lastArray)\n    \n  return sortedArray\n}\n```\n\n到此我们介绍完了两种排序方法。事实上，光排序就是一门很深的学问，也涉及到了算法和数据结构的方方面面，我们将继续通过排序，了解更多算法内容。\n\n### 排序的稳定性\n\n事实上，除了 v8 引擎，其他引擎也有不同的 sort 排序规则。比如 SpiderMoney 早期内部实现了归并排序，Chakra 的数组排序算法实现的也是快速排序。Firefox（Firebird）最初版本实现的数组排序算法是堆排序，这也是一种不稳定的排序算法，Mozilla 开发组内部针对这个问题进行了一系列讨论之后，Firefox3 将归并排序作为了数组排序的新实现。\n\n我们知道，快速排序是一种不稳定的排序算法，而归并排序是一种稳定的排序算法。什么是排序的稳定性呢？\n\n> 简单说，就是能保证排序前 2 个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。形式化一下，如果 array[i] = array[j]，array[i] 原来在位置前，排序后 array[i] 还是要在 array[j] 位置前。\n\n在很多情况下，不稳定的排序也不会造成影响。但是在一些场景中，可能就会“有毒”。比如对于一个数组对象，场景是：\n\n> 某市的机动车牌照拍卖系统，最终中标的规则为：按价格进行倒排序；相同价格则按照竞标顺位（即价格提交时间）进行正排序。\n\n如果采用不稳定排序，那么结果就有可能不符合预期。\n\n那么如果一些浏览器引擎实现的排序采用了不稳定排序算法应该怎么办呢？方案：\n\n> 将待排序数组进行预处理，为每个待排序的对象增加自然序属性，不与对象的其他属性冲突即可。自定义排序比较方法 compareFn，总是将自然序作为前置判断相等时的第二判断维度。\n\n示例代码：\n\n```\nconst HELPER = Symbol(&apos;helper&apos;)\n\nconst getComparer = compare => \n   (left, right) => {\n        let result = compare(left, right)\n\n        return result === 0 ? left[HELPER] - right[HELPER] : result\n    }\n\nconst sort = (array, compare) => {\n    array = array.map(\n        (item, index) => {\n            if (typeof item === &apos;object&apos;) {\n                item[HELPER] = index\n            }\n\n            return item\n        }\n    );\n\n    return array.sort(getComparer(compare))\n}\n```\n\n近些年来，随着浏览器计算能力的进一步提升，项目正在往富客户端应用方向转变，前端在项目中扮演的角色也越来越重要。算法意识是一个不得忽视的话题。\n\n### Timsort 实现\n\n好了，我们再把话题收回来。那么 v8 采用的 Timsort 算法到底是什么呢？Timsort 结合了归并排序和插入排序，效率更高。Pyhton 自从 2.3 版，Java SE7 和 Android以来也一直采用 Timsort 算法排序。\n\n我们看一下 JSE7 中对 Timsort 的描述：\n\n>  A stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when running on partially sorted arrays, while offering performance comparable to a traditional mergesort when run on random arrays.  Like all proper mergesorts, this sort is stable and runs O(n log n) time (worst case).  In the worst case, this sort requires temporary storage space for n/2 object  references; in the best case,  it requires only a small constant amount of space.\n\nTimsort 是稳定且自适应的算法。如果需要排序的数组中存在部分已经排序好的区间，它的时间复杂度会小于 nlogn，它的最坏时间复杂度是 O(nlogn）。在最坏情况下，Timsort 算法需要的临时空间是 n/2，在最好情况下，它只需要一个很小的常量存储空间。\n\nTimsort 算法为了减少对升序部分的回溯和对降序部分的性能倒退，将输入按其升序和降序特点进行了分区。\n\n那么具体的过程：排序输入的单位不是一个个单独的数字，而是一个个分区。其中每一个分区叫一个 run。针对这些 run 序列，每次拿一个 run 出来按规则进行合并。每次合并会将两个 run 合并成一个 run。合并的结果保存到栈中。合并直到消耗掉所有的 run，这时将栈上剩余的 run 合并到只剩一个 run 为止。这时这个仅剩的 run 便是排好序的结果。\n\n这样一来 Timsort 的具体实施规则就是：\n\n- 如果数组长度小于某个值，直接用二分插入排序算法\n- 找到各个 run，并入栈\n- 按规则合并 run\n\n理解 run 将会是关键，请看图：\n\n![1](https://images.gitbook.cn/1eec6920-db4f-11e9-a268-91dece478f6a)\n\n具体实现我参考部分 [timsort](https://github.com/bellbind/stepbystep-timsort) 内容：\n\n```\nArray.prototype.timsort = function(comp) {\n    var global_a = this\n    var MIN_MERGE = 32;\n    var MIN_GALLOP = 7\n    var runBase = [];\n    var runLen = [];\n    var stackSize = 0;\n    var compare = comp;\n    sort(this, 0, this.length, compare);\n\n    function sort(a, lo, hi, compare) {\n        if (typeof compare != \"function\") {\n            throw new Error(\"Compare is not a function.\");\n            return\n        }\n        stackSize = 0;\n        runBase = [];\n        runLen = [];\n        rangeCheck(a.length, lo, hi);\n        var nRemaining = hi - lo;\n        if (nRemaining < 2) return;\n        if (nRemaining < MIN_MERGE) {\n            var initRunLen = countRunAndMakeAscending(a, lo, hi, compare);\n            binarySort(a, lo, hi, lo + initRunLen, compare);\n            return\n        }\n        var ts = [];\n        var minRun = minRunLength(nRemaining);\n        do {\n            var runLenVar = countRunAndMakeAscending(a, lo, hi, compare);\n            if (runLenVar < minRun) {\n                var force = nRemaining <= minRun ? nRemaining : minRun;\n                binarySort(a, lo, lo + force, lo + runLenVar, compare);\n                runLenVar = force\n            }\n            pushRun(lo, runLenVar);\n            mergeCollapse();\n            lo += runLenVar;\n            nRemaining -= runLenVar\n        } while (nRemaining != 0);\n        mergeForceCollapse()\n    }\n\n    function binarySort(a, lo, hi, start, compare) {\n        if (start == lo) start++;\n        for (; start < hi; start++) {\n            var pivot = a[start];\n            var left = lo;\n            var right = start;\n            while (left < right) {\n                var mid = (left + right) >>> 1;\n                if (compare(pivot, a[mid]) < 0) right = mid;\n                else left = mid + 1\n            }\n            var n = start - left;\n            switch (n) {\n                case 2:\n                    a[left + 2] = a[left + 1];\n                case 1:\n                    a[left + 1] = a[left];\n                    break;\n                default:\n                    arraycopy(a, left, a, left + 1, n)\n            }\n            a[left] = pivot\n        }\n    }\n\n    function countRunAndMakeAscending(a, lo, hi, compare) {\n        var runHi = lo + 1;\n        if (compare(a[runHi++], a[lo]) < 0) {\n            while (runHi < hi && compare(a[runHi], a[runHi - 1]) < 0) {\n                runHi++\n            }\n            reverseRange(a, lo, runHi)\n        } else {\n            while (runHi < hi && compare(a[runHi], a[runHi - 1]) >= 0) {\n                runHi++\n            }\n        }\n        return runHi - lo\n    }\n\n    function reverseRange(a, lo, hi) {\n        hi--;\n        while (lo < hi) {\n            var t = a[lo];\n            a[lo++] = a[hi];\n            a[hi--] = t\n        }\n    }\n\n    function minRunLength(n) {\n        var r = 0;\n        return n + 1\n    }\n\n    function pushRun(runBaseArg, runLenArg) {\n        runBase[stackSize] = runBaseArg;\n        runLen[stackSize] = runLenArg;\n        stackSize++\n    }\n\n    function mergeCollapse() {\n        while (stackSize > 1) {\n            var n = stackSize - 2;\n            if (n > 0 && runLen[n - 1] <= runLen[n] + runLen[n + 1]) {\n                if (runLen[n - 1] < runLen[n + 1]) n--;\n                mergeAt(n)\n            } else if (runLen[n] <= runLen[n + 1]) {\n                mergeAt(n)\n            } else {\n                break\n            }\n        }\n    }\n\n    function mergeForceCollapse() {\n        while (stackSize > 1) {\n            var n = stackSize - 2;\n            if (n > 0 && runLen[n - 1] < runLen[n + 1]) n--;\n            mergeAt(n)\n        }\n    }\n\n    function mergeAt(i) {\n        var base1 = runBase[i];\n        var len1 = runLen[i];\n        var base2 = runBase[i + 1];\n        var len2 = runLen[i + 1];\n        runLen[i] = len1 + len2;\n        if (i == stackSize - 3) {\n            runBase[i + 1] = runBase[i + 2];\n            runLen[i + 1] = runLen[i + 2]\n        }\n        stackSize--;\n        var k = gallopRight(global_a[base2], global_a, base1, len1, 0, compare);\n        base1 += k;\n        len1 -= k;\n        if (len1 == 0) return;\n        len2 = gallopLeft(global_a[base1 + len1 - 1], global_a, base2, len2, len2 - 1, compare);\n        if (len2 == 0) return;\n        if (len1 <= len2) mergeLo(base1, len1, base2, len2);\n        else mergeHi(base1, len1, base2, len2)\n    }\n\n    function gallopLeft(key, a, base, len, hint, compare) {\n        var lastOfs = 0;\n        var ofs = 1;\n        if (compare(key, a[base + hint]) > 0) {\n            var maxOfs = len - hint;\n            while (ofs < maxOfs && compare(key, a[base + hint + ofs]) > 0) {\n                lastOfs = ofs;\n                ofs = (ofs << 1) + 1;\n                if (ofs <= 0) ofs = maxOfs\n            }\n            if (ofs > maxOfs) ofs = maxOfs;\n            lastOfs += hint;\n            ofs += hint\n        } else {\n            var maxOfs = hint + 1;\n            while (ofs < maxOfs && compare(key, a[base + hint - ofs]) <= 0) {\n                lastOfs = ofs;\n                ofs = (ofs << 1) + 1;\n                if (ofs <= 0) ofs = maxOfs\n            }\n            if (ofs > maxOfs) ofs = maxOfs;\n            var tmp = lastOfs;\n            lastOfs = hint - ofs;\n            ofs = hint - tmp\n        }\n        lastOfs++;\n        while (lastOfs < ofs) {\n            var m = lastOfs + ((ofs - lastOfs) >>> 1);\n            if (compare(key, a[base + m]) > 0) lastOfs = m + 1;\n            else ofs = m\n        }\n        return ofs\n    }\n\n    function gallopRight(key, a, base, len, hint, compare) {\n        var ofs = 1;\n        var lastOfs = 0;\n        if (compare(key, a[base + hint]) < 0) {\n            var maxOfs = hint + 1;\n            while (ofs < maxOfs && compare(key, a[base + hint - ofs]) < 0) {\n                lastOfs = ofs;\n                ofs = (ofs << 1) + 1;\n                if (ofs <= 0) ofs = maxOfs\n            }\n            if (ofs > maxOfs) ofs = maxOfs;\n            var tmp = lastOfs;\n            lastOfs = hint - ofs;\n            ofs = hint - tmp\n        } else {\n            var maxOfs = len - hint;\n            while (ofs < maxOfs && compare(key, a[base + hint + ofs]) >= 0) {\n                lastOfs = ofs;\n                ofs = (ofs << 1) + 1;\n                if (ofs <= 0) ofs = maxOfs\n            }\n            if (ofs > maxOfs) ofs = maxOfs;\n            lastOfs += hint;\n            ofs += hint\n        }\n        lastOfs++;\n        while (lastOfs < ofs) {\n            var m = lastOfs + ((ofs - lastOfs) >>> 1);\n            if (compare(key, a[base + m]) < 0) ofs = m;\n            else lastOfs = m + 1\n        }\n        return ofs\n    }\n\n    function mergeLo(base1, len1, base2, len2) {\n        var a = global_a;\n        var tmp = a.slice(base1, base1 + len1);\n        var cursor1 = 0;\n        var cursor2 = base2;\n        var dest = base1;\n        a[dest++] = a[cursor2++];\n        if (--len2 == 0) {\n            arraycopy(tmp, cursor1, a, dest, len1);\n            return\n        }\n        if (len1 == 1) {\n            arraycopy(a, cursor2, a, dest, len2);\n            a[dest + len2] = tmp[cursor1];\n            return\n        }\n        var c = compare;\n        var minGallop = MIN_GALLOP;\n        outer: while (true) {\n            var count1 = 0;\n            var count2 = 0;\n            do {\n                if (compare(a[cursor2], tmp[cursor1]) < 0) {\n                    a[dest++] = a[cursor2++];\n                    count2++;\n                    count1 = 0;\n                    if (--len2 == 0) break outer\n                } else {\n                    a[dest++] = tmp[cursor1++];\n                    count1++;\n                    count2 = 0;\n                    if (--len1 == 1) break outer\n                }\n            } while ((count1 | count2) < minGallop);\n            do {\n                count1 = gallopRight(a[cursor2], tmp, cursor1, len1, 0, c);\n                if (count1 != 0) {\n                    arraycopy(tmp, cursor1, a, dest, count1);\n                    dest += count1;\n                    cursor1 += count1;\n                    len1 -= count1;\n                    if (len1 <= 1) break outer\n                }\n                a[dest++] = a[cursor2++];\n                if (--len2 == 0) break outer;\n                count2 = gallopLeft(tmp[cursor1], a, cursor2, len2, 0, c);\n                if (count2 != 0) {\n                    arraycopy(a, cursor2, a, dest, count2);\n                    dest += count2;\n                    cursor2 += count2;\n                    len2 -= count2;\n                    if (len2 == 0) break outer\n                }\n                a[dest++] = tmp[cursor1++];\n                if (--len1 == 1) break outer;\n                minGallop--\n            } while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);\n            if (minGallop < 0) minGallop = 0;\n            minGallop += 2\n        }\n        this.minGallop = minGallop < 1 ? 1 : minGallop;\n        if (len1 == 1) {\n            arraycopy(a, cursor2, a, dest, len2);\n            a[dest + len2] = tmp[cursor1]\n        } else if (len1 == 0) {\n            throw new Error(\"IllegalArgumentException. Comparison method violates its general contract!\");\n        } else {\n            arraycopy(tmp, cursor1, a, dest, len1)\n        }\n    }\n\n    function mergeHi(base1, len1, base2, len2) {\n        var a = global_a;\n        var tmp = a.slice(base2, base2 + len2);\n        var cursor1 = base1 + len1 - 1;\n        var cursor2 = len2 - 1;\n        var dest = base2 + len2 - 1;\n        a[dest--] = a[cursor1--];\n        if (--len1 == 0) {\n            arraycopy(tmp, 0, a, dest - (len2 - 1), len2);\n            return\n        }\n        if (len2 == 1) {\n            dest -= len1;\n            cursor1 -= len1;\n            arraycopy(a, cursor1 + 1, a, dest + 1, len1);\n            a[dest] = tmp[cursor2];\n            return\n        }\n        var c = compare;\n        var minGallop = MIN_GALLOP;\n        outer: while (true) {\n            var count1 = 0;\n            var count2 = 0;\n            do {\n                if (compare(tmp[cursor2], a[cursor1]) < 0) {\n                    a[dest--] = a[cursor1--];\n                    count1++;\n                    count2 = 0;\n                    if (--len1 == 0) break outer\n                } else {\n                    a[dest--] = tmp[cursor2--];\n                    count2++;\n                    count1 = 0;\n                    if (--len2 == 1) break outer\n                }\n            } while ((count1 | count2) < minGallop);\n            do {\n                count1 = len1 - gallopRight(tmp[cursor2], a, base1, len1, len1 - 1, c);\n                if (count1 != 0) {\n                    dest -= count1;\n                    cursor1 -= count1;\n                    len1 -= count1;\n                    arraycopy(a, cursor1 + 1, a, dest + 1, count1);\n                    if (len1 == 0) break outer\n                }\n                a[dest--] = tmp[cursor2--];\n                if (--len2 == 1) break outer;\n                count2 = len2 - gallopLeft(a[cursor1], tmp, 0, len2, len2 - 1, c);\n                if (count2 != 0) {\n                    dest -= count2;\n                    cursor2 -= count2;\n                    len2 -= count2;\n                    arraycopy(tmp, cursor2 + 1, a, dest + 1, count2);\n                    if (len2 <= 1) break outer\n                }\n                a[dest--] = a[cursor1--];\n                if (--len1 == 0) break outer;\n                minGallop--\n            } while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);\n            if (minGallop < 0) minGallop = 0;\n            minGallop += 2\n        }\n        this.minGallop = minGallop < 1 ? 1 : minGallop;\n        if (len2 == 1) {\n            dest -= len1;\n            cursor1 -= len1;\n            arraycopy(a, cursor1 + 1, a, dest + 1, len1);\n            a[dest] = tmp[cursor2]\n        } else if (len2 == 0) {\n            throw new Error(\"IllegalArgumentException. Comparison method violates its general contract!\");\n        } else {\n            arraycopy(tmp, 0, a, dest - (len2 - 1), len2)\n        }\n    }\n\n    function rangeCheck(arrayLen, fromIndex, toIndex) {\n        if (fromIndex > toIndex) throw new Error(\"IllegalArgument fromIndex(\" + fromIndex + \") > toIndex(\" + toIndex + \")\");\n        if (fromIndex < 0) throw new Error(\"ArrayIndexOutOfBounds \" + fromIndex);\n        if (toIndex > arrayLen) throw new Error(\"ArrayIndexOutOfBounds \" + toIndex);\n    }\n}\n```\n\n具体操作较为复杂，这里建议大家更多的了解这个知识点，而具体实现一般不作要求。\n\n我们来看一下 v8 在采用 Timsort 之后，得到的一些 benchmark：\n\n![2](https://images.gitbook.cn/3eb83630-db4f-11e9-b7e8-efbebe7dfdf6)\n\n![3](https://images.gitbook.cn/55bb5330-db4f-11e9-9f9d-c526a5f387ab)\n\n![4](https://images.gitbook.cn/6a0bfa60-db4f-11e9-b7e8-efbebe7dfdf6)\n\n更多内容，可以参考 v8 官方博客：[Getting things sorted in V8](https://v8.dev/blog/array-sort)\n\n### 实战例题\n\n从这里开始，我们来“刷”一些实战例题。\n\n#### 交换星号\n\n题目：一个字符串中只包含 * 和数字，请把 * 号都放开头。\n\n思路：使用两个指针，从后往前扫字符串，遇到数字则赋值给后面的指针，继续往后扫，遇到 * 则不处理。\n\n```\nconst isNumeric = n => !isNaN(parseFloat(n)) && isFinite(n);\n\n/**\n * @param {string}\n * @return {string}\n */\nconst solution = s => {\n    const n = s.length\n    let a = s.split(&apos;&apos;)\n    let j = n - 1\n    \n    for (let i = n - 1; i >= 0; --i)\n        if (isNumeric(a[i])) a[j--] = a[i]\n        \n    for (; j >= 0; --j) a[j] = &apos;*&apos;\n    return a.join(&apos;&apos;)\n}\n```\n\n这样一来，我们逆序操作数组，遇见数字则向后置，遍历完一遍后，所有的数字都已经在后边了，同时把前边的数组项用 * 填充。\n\n#### Longest Substring Without Repeating Characters\n\n题意：给定一个字符串，返回它最长的不包含重复的子串长度。例如，输入 abcabcbb 输出 3（对应 abc）。\n\n思路：\n\n- 暴力枚举起点和终点，并判断重复，时间复杂度是 O(n²)；\n- 通过双指针、滑动窗口，动态维护窗口 [i..j)，使窗口内字符不重复。\n\n我们看第二种思路解法，保证窗口 [i..j) 之间没有重复字符：\n\n- 首先 i, j 两个指针均指向字符串头部，如果没有重复字符，则 j 不断向右滑动，直到出现重复字符；\n- 如果出现了重复的字符，重复字符出现在第 str[j] 处，这时候开始移动指针 i，找到另一个重复的字读出现在 str[i] 处，那么能保证 [0, i] 以及 [i, j] 子字符串是不重复的，更新临时结果为 Math.max(result, j - i)。\n\n**时间复杂度 O(n)**\n\n实现：\n\n```\nconst lengthOfLongestSubstring = str => {\n    let result = 0\n    let len = str.length\n\n    // 记录当前区间内出现的字符\n    let mapping = {}\n\n    for (let i = 0, j = 0; ; ++i) {\n\n        // j 右移的过程\n        while (j < len && !mapping[str[j]])\n            mapping[str[j++]] = true\n        result = Math.max(result, j - i)\n\n        if (j >= len)\n            break;\n\n        // 出现了重复字符，i 开始进行右移的过程，同时将移出的字符在 mapping 中重置\n        while (str[i] != str[j])\n            mapping[str[i++]] = false\n        mapping[str[i]] = false\n\n    }\n    \n    return result\n};\n```\n\n举这个例子的目的是为了展示滑动窗口的思想，通过滑动窗口一般能实现 O(n) 的时间复杂度和 O(1) 的空间复杂度。\n\n### 总结\n\n这一讲我们主要介绍了几种排序算法和最先进的 Timsort，相信凭借这些内容，在前端排序上你可以“鄙视”面试官了。当然算法的坑还是很深的，我们要保持好的心态。最后部分介绍了两个算法题，算是抛砖引玉，下一讲，让我们针对算法面试，刷一刷算法。","pdfUrl":"","reader":"","duration":"","title":"那些年常考的前端算法（中）","column":"5c91c813968b1d64b1e08fde","isNotification":false,"readingStatistics":0,"htmlContent":"<p>上一讲我们剖析了算法的一些基本概念。这一讲将围绕 v8 引申出的算法进行分析，同时做一些常见、典型考题。主要内容如下：</p>\n<p><img src=\"https://images.gitbook.cn/a80ed7e0-d827-11e9-a98d-91914e1a8fb9\" alt=\"enter image description here\" /></p>\n<h3><a id=\"v8_sort__4\"></a>v8 sort 排序的奥秘和演进</h3>\n<p>前一讲，我带大家分析了“如何将一个 JavaScript 数组打乱顺序？”，其中提到了 sort 这个 API，具体有这样的一段描述：</p>\n<blockquote>\n<p>v8 在处理 sort 方法时，使用了插入排序和快排两种方案。当目标数组长度小于 10（不同版本有差别）时，使用插入排序；反之，使用快排。</p>\n</blockquote>\n<p>如果细心的读者可能会到 v8 源代码中找寻相关的算法逻辑，那么你一定会大失所望。因为根本找不到 10 这样的常量，更没有插入排序和快排两种方案的切换，甚至连实现的预言都不是 JavaScript 或者 C++，这是为什么呢？</p>\n<p>原来，在新的 v8 版本中（具体 V8 6.9）已经使用了一种名叫 Torque 的开发语言重构，并在 7.0 改进了 sort 算法。也就是说，现在社区上几乎所有的 V8 排序源码分析都已经过时了。</p>\n<p>Torque 是 v8 团队专门为了开发 v8 引擎而开发的语言，他的后缀名是 tq。作为一种高级语言，Torque 依靠 CodeStubAssembler 编译器来转换为汇编代码。</p>\n<p>在新的版本中，v8 也采用了一种名叫 Timsort 的全新算法，这套算法最开始于 2002 被 Tim Peters 在 Python 语言中使用。</p>\n<p>从这个演进过程中，我们分为三大块来看。</p>\n<h3><a id=\"_20\"></a>快排和插入排序</h3>\n<p>排序算法多种多样，社区上的分析也比较多。这里我们挑选 v8 sort 排序中“露脸”的快速排序和插入排序进行讲解。</p>\n<p>不知道读者是否有这样的困扰：我们看一遍算法，理解了，可是过两天又完全记不得具体讲了什么。针对于此，我们应该结合算法的特点，加以应用，才能深入记忆。排序算法同样如此，对于每一种算法，我们应该先记住其思想，再记住其实现。不过要知道：“排序没有想象中那么简单”。</p>\n<h4><a id=\"_26\"></a>快速排序</h4>\n<p><strong>快速排序的特点就是分治</strong>。如何体现分治策略呢？我们首先在数组中选取一个基准点，叫做 pivot，根据这个基准点：把比基准点小的数组值放在基准点左边，把比基准点大的数组值放在基准点右边。这样一来，基于基准点，左边分区的值都小于基准点，右边分区的值都大于基准点，然后针对左边分区和右边分区进行同样的操作，直到最后排序完成。</p>\n<p>最简单的实现：</p>\n<pre><code class=\"lang-\">const quickSort = array =&gt; {\n  if (array.length &lt; 2) {\n    return array.slice()\n  }\n  \n  // 随机找到 pivot\n  let pivot = array[Math.floor(Math.random() * array.length)]\n  \n  let left = []\n  let middle = []\n  let right = []\n  \n  for (let i = 0; i &lt; array.length; i++) {\n    var value = array[i]\n    if (value &lt; pivot) {\n      left.push(value)\n    }\n    \n    if (value === pivot) {\n      middle.push(value)\n    }\n    \n    if (value &gt; pivot) {\n      right.push(value)\n    }\n  }\n\n  // 递归进行\n  return quickSort(left).concat(middle, quickSort(right))\n}\n</code></pre>\n<p>这种实现方法有不少优化点，其中之一就是我们可以在原数组上进行操作，而不产生一个新的数组：</p>\n<pre><code class=\"lang-\">const quickSort = (array, start, end) =&gt; {\n  start = start === undefined ? 0 : start\n  end = end === undefined ? arr.length - 1 : end;\n  \n  if (start &gt;= end) {\n    return\n  }\n\n  let value = array[start]\n\n  let i = start\n  let j = end\n\n  while (i &lt; j) {\n    // 找出右边第一个小于参照数的下标并记录\n    while (i &lt; j &amp;&amp; array[j] &gt;= value) {\n      j--\n    }\n    \n    if (i &lt; j) {\n      arr[i++] = arr[j]\n    }\n    \n    // 找出左边第一个大于参照数的下标，并记录\n    while (i &lt; j &amp;&amp; array[i] &lt; value) {\n      i++\n    }\n\n    if (i &lt; j) {\n      arr[j--] = arr[i]\n    }\n  }\n  \n  arr[i] = value\n\n  quickSort(array, start, i - 1)\n  quickSort(array, i + 1, end)\n}\n</code></pre>\n<p>调用方式：</p>\n<pre><code class=\"lang-\">let arr = [0, 12, 43, 45, 88, 1, 69]\nquickSort(arr, 0, arr.length - 1)\nconsole.log(arr)\n</code></pre>\n<p>我们该如何理解 in place 的快排算法呢？</p>\n<p>首先使用双指针，指针开始遍历，当右边发现一个小于参照数（即 array[start]）的时候，就将该值赋值给起始位置。赋值完之后，那么右边这个位置就空闲了。这时在左边发现比参照数大的值时，就赋值给这个刚刚空闲出来的右边位置。以此类推，直到 i 不再小于 j。经过这一轮操作之后，所有比参照数小的都到了数组的左边，所有比参照数大的都到了数组右边，而数组中间被赋值为参照数。</p>\n<p>我们再来分析另外一个优化点。之前的课程中提到了尾递归调用优化，那么上面的快排能否使用尾递归进行优化呢？</p>\n<p>我们进行观察，上面的实现最后两行：</p>\n<pre><code class=\"lang-\">quickSort(array, start, i - 1)\nquickSort(array, i + 1, end)\n</code></pre>\n<p>如果能形成以下的形式：</p>\n<pre><code class=\"lang-\">return quickSort()\n</code></pre>\n<p>那么就实现了尾递归调用优化。为此，我们需要一个 stack 来进行参数信息的传递：</p>\n<pre><code class=\"lang-\"> const quickSort = (array, stack) =&gt; {\n  let start = stack[0]\n  let end = stack[1]\n\n  let value = array[start]\n\n  let i = start\n  let j = end\n\n  while (i &lt; j) {\n    while (i &lt; j &amp;&amp; array[j] &gt;= value) {\n      j--\n    }\n    if (i &lt; j) {\n      array[i++] = array[j]\n    }\n\n    while (i &lt; j &amp;&amp; array[i] &lt; value) {\n      i++\n    }\n\n    if (i &lt; j) {\n      array[j--] = array[i]\n    }\n  }\n\n  arr[i] = value\n  \n  // 移除已经使用完的下标\n  stack.shift()\n  stack.shift() \n  \n  // 存入新的下标\n  if (i + 1 &lt; end) {\n    stack.unshift(i + 1, end)\n  }\n  if (start &lt; i - 1) {\n    stack.unshift(start, i - 1)\n  }\n\n  if (stack.length == 0) {\n    return;\n  }\n\n  return quickSort(array, stack)\n}\n</code></pre>\n<p>最后，关于快速排序的优化点还有一个最重要的方向就是对 pivot 元素的选取。通过上面的分析，我们发现快速排序的算法核心在于选择一个 pivot，将经过比较交换的数组按基准分解为两个数区进行后续递归。</p>\n<p>那么试想，如果我们对一个已经有序的数组进行排序，恰好每次选择 pivot 时总是选择第一个或者最后一个元素，那么每次都会有一个数区是空的，递归的层数将达到 n，最后导致算法的时间复杂度退化为 O(n²)。因此 pivot 的选择非常重要。</p>\n<p>在早期 v8 使用快速排序时，采用了三数取中（median-of-three）的 pivot 优化方案：除了头尾两个元素再额外选择一个元素参与基准元素的竞争。具体 v8 源代码为：</p>\n<pre><code class=\"lang-\">var GetThirdIndex = function(a, from, to) {\n    var t_array = new InternalArray();\n    // Use both &apos;from&apos; and &apos;to&apos; to determine the pivot candidates.\n    var increment = 200 + ((to - from) &amp; 15);\n    var j = 0;\n    from += 1;\n    to -= 1;\n    for (var i = from; i &lt; to; i += increment) {\n        t_array[j] = [i, a[i]];\n        j++;\n    }\n    t_array.sort(function(a, b) {\n        return comparefn(a[1], b[1]);\n    });\n    var third_index = t_array[t_array.length &gt;&gt; 1][0];\n    return third_index;\n};\n\nvar QuickSort = function QuickSort(a, from, to) {\n    ......\n    while (true) {\n        ......\n        if (to - from &gt; 1000) {\n            third_index = GetThirdIndex(a, from, to);\n        } else {\n            third_index = from + ((to - from) &gt;&gt; 1);\n        }\n    }\n    ......\n};\n\n</code></pre>\n<p>由此看出，这所谓的第三个竞争元素产生方式为：</p>\n<ul>\n<li>当数组长度小于等于 1000 时，选择折半位置的元素作为目标元素</li>\n<li>当数组长度超过 1000 时，每隔 200-215 个（非固定，跟着数组长度而变化）左右的值，去选择一个元素来先确定一批候选元素。接着在这批候选元素中进行一次排序，将所得的中位值作为目标元素</li>\n</ul>\n<p>三数取中（median-of-three）当中，最后选取的是三个元素的中位值作为 pivot。</p>\n<h4><a id=\"_233\"></a>插入排序</h4>\n<p>插入排序我们还是从特点入手：它先将待排序序列的第一个元素看做一个有序序列，当然了，就一个元素，那么它一定是有序的；而把第二个元素到最后一个元素当成是未排序序列；对于未排序的序列进行遍历，将扫描到的每个元素插入有序序列的适当位置，保证有序序列依然有序，那么直到所有数据都完成，我们也就完成了排序。</p>\n<p>如果待插入的元素与有序序列中的某个元素相等，那么我们统一先将待插入元素插入到相等元素的后面。</p>\n<p>我们的实现：</p>\n<pre><code class=\"lang-\">const insertsSort = array =&gt; {\n    const length = arr.length\n    let preIndex\n    let current\n    \n    for (let i = 1; i &lt; length; i++) {\n        preIndex = i - 1\n        current = array[i]\n        \n        while (preIndex &gt;= 0 &amp;&amp; array[preIndex] &gt; current) {\n            array[preIndex + 1] = array[preIndex]\n            preIndex--\n        }\n        \n        array[preIndex + 1] = current\n    }\n    return array\n}\n</code></pre>\n<p>那么上述实现的插入排序有优化空间吗？</p>\n<p>这是一定的，优化空间主要有这么几个方向：</p>\n<ul>\n<li>在遍历未排序序列时，将当前元素插入到有序序列过程中，可以使用二分法减少查找次数（因为是向有序序列插入）</li>\n<li>使用链表，将有序数组转为链表这种数据结构，那么插入操作的时间复杂度为 O(1)，查找复杂度变为 O(n)</li>\n<li>使用排序二叉树，将有序数组转为排序二叉树结构，然后中序遍历该二叉树，不过这种方式需要额外空间。</li>\n</ul>\n<p>采用二分法的优化实现：</p>\n<pre><code class=\"lang-\">const insertSort = array =&gt; array.reduce(insert, [])\n\nconst insert = (sortedArray, value) =&gt; {\n  const length = sortedArray.length\n  \n  if (length === 0) {\n    sortedArray.push(value)\n    return sortedArray\n  }\n\n  let i = 0\n  let j = length\n  let mid\n  \n  // 先判断是否为极端值\n  if (value &lt; sortedArray[i]) {\n    // 直接插入到数组的最头\n    return sortedArray.unshift(value), sortedArray\n  }\n  if (value &gt;= sortedArray[length - 1]) {\n  \t // 直接插入到数组的最尾\n    return sortedArray.push(value), sortedArray\n  }\n\n  // 开始二分查找\n  while (i &lt; j) {\n    mid = ((j + i) / 2) | 0\n\n    if (i == mid) {\n      break\n    }\n    \n    if (value  &lt; sortedArray[mid]) {\n      j = mid\n    }\n    \n    if (value === sortedArray[mid]) {\n      i = mid\n      break\n    }\n    \n    if (value &gt; sortedArray[mid]) {\n      i = mid\n    }\n  }\n  \n  let midArray = [value]\n  let lastArray = sortedArray.slice(i + 1)\n  \n  sortedArray = sortedArray\n    .slice(0, i + 1)\n    .concat(midArray)\n    .concat(lastArray)\n    \n  return sortedArray\n}\n</code></pre>\n<p>到此我们介绍完了两种排序方法。事实上，光排序就是一门很深的学问，也涉及到了算法和数据结构的方方面面，我们将继续通过排序，了解更多算法内容。</p>\n<h3><a id=\"_333\"></a>排序的稳定性</h3>\n<p>事实上，除了 v8 引擎，其他引擎也有不同的 sort 排序规则。比如 SpiderMoney 早期内部实现了归并排序，Chakra 的数组排序算法实现的也是快速排序。Firefox（Firebird）最初版本实现的数组排序算法是堆排序，这也是一种不稳定的排序算法，Mozilla 开发组内部针对这个问题进行了一系列讨论之后，Firefox3 将归并排序作为了数组排序的新实现。</p>\n<p>我们知道，快速排序是一种不稳定的排序算法，而归并排序是一种稳定的排序算法。什么是排序的稳定性呢？</p>\n<blockquote>\n<p>简单说，就是能保证排序前 2 个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。形式化一下，如果 array[i] = array[j]，array[i] 原来在位置前，排序后 array[i] 还是要在 array[j] 位置前。</p>\n</blockquote>\n<p>在很多情况下，不稳定的排序也不会造成影响。但是在一些场景中，可能就会“有毒”。比如对于一个数组对象，场景是：</p>\n<blockquote>\n<p>某市的机动车牌照拍卖系统，最终中标的规则为：按价格进行倒排序；相同价格则按照竞标顺位（即价格提交时间）进行正排序。</p>\n</blockquote>\n<p>如果采用不稳定排序，那么结果就有可能不符合预期。</p>\n<p>那么如果一些浏览器引擎实现的排序采用了不稳定排序算法应该怎么办呢？方案：</p>\n<blockquote>\n<p>将待排序数组进行预处理，为每个待排序的对象增加自然序属性，不与对象的其他属性冲突即可。自定义排序比较方法 compareFn，总是将自然序作为前置判断相等时的第二判断维度。</p>\n</blockquote>\n<p>示例代码：</p>\n<pre><code class=\"lang-\">const HELPER = Symbol(&apos;helper&apos;)\n\nconst getComparer = compare =&gt; \n   (left, right) =&gt; {\n        let result = compare(left, right)\n\n        return result === 0 ? left[HELPER] - right[HELPER] : result\n    }\n\nconst sort = (array, compare) =&gt; {\n    array = array.map(\n        (item, index) =&gt; {\n            if (typeof item === &apos;object&apos;) {\n                item[HELPER] = index\n            }\n\n            return item\n        }\n    );\n\n    return array.sort(getComparer(compare))\n}\n</code></pre>\n<p>近些年来，随着浏览器计算能力的进一步提升，项目正在往富客户端应用方向转变，前端在项目中扮演的角色也越来越重要。算法意识是一个不得忽视的话题。</p>\n<h3><a id=\"Timsort__380\"></a>Timsort 实现</h3>\n<p>好了，我们再把话题收回来。那么 v8 采用的 Timsort 算法到底是什么呢？Timsort 结合了归并排序和插入排序，效率更高。Pyhton 自从 2.3 版，Java SE7 和 Android以来也一直采用 Timsort 算法排序。</p>\n<p>我们看一下 JSE7 中对 Timsort 的描述：</p>\n<blockquote>\n<p>A stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when running on partially sorted arrays, while offering performance comparable to a traditional mergesort when run on random arrays.  Like all proper mergesorts, this sort is stable and runs O(n log n) time (worst case).  In the worst case, this sort requires temporary storage space for n/2 object  references; in the best case,  it requires only a small constant amount of space.</p>\n</blockquote>\n<p>Timsort 是稳定且自适应的算法。如果需要排序的数组中存在部分已经排序好的区间，它的时间复杂度会小于 nlogn，它的最坏时间复杂度是 O(nlogn）。在最坏情况下，Timsort 算法需要的临时空间是 n/2，在最好情况下，它只需要一个很小的常量存储空间。</p>\n<p>Timsort 算法为了减少对升序部分的回溯和对降序部分的性能倒退，将输入按其升序和降序特点进行了分区。</p>\n<p>那么具体的过程：排序输入的单位不是一个个单独的数字，而是一个个分区。其中每一个分区叫一个 run。针对这些 run 序列，每次拿一个 run 出来按规则进行合并。每次合并会将两个 run 合并成一个 run。合并的结果保存到栈中。合并直到消耗掉所有的 run，这时将栈上剩余的 run 合并到只剩一个 run 为止。这时这个仅剩的 run 便是排好序的结果。</p>\n<p>这样一来 Timsort 的具体实施规则就是：</p>\n<ul>\n<li>如果数组长度小于某个值，直接用二分插入排序算法</li>\n<li>找到各个 run，并入栈</li>\n<li>按规则合并 run</li>\n</ul>\n<p>理解 run 将会是关键，请看图：</p>\n<p><img src=\"https://images.gitbook.cn/1eec6920-db4f-11e9-a268-91dece478f6a\" alt=\"1\" /></p>\n<p>具体实现我参考部分 <a href=\"https://github.com/bellbind/stepbystep-timsort\" target=\"_blank\">timsort</a> 内容：</p>\n<pre><code class=\"lang-\">Array.prototype.timsort = function(comp) {\n    var global_a = this\n    var MIN_MERGE = 32;\n    var MIN_GALLOP = 7\n    var runBase = [];\n    var runLen = [];\n    var stackSize = 0;\n    var compare = comp;\n    sort(this, 0, this.length, compare);\n\n    function sort(a, lo, hi, compare) {\n        if (typeof compare != &quot;function&quot;) {\n            throw new Error(&quot;Compare is not a function.&quot;);\n            return\n        }\n        stackSize = 0;\n        runBase = [];\n        runLen = [];\n        rangeCheck(a.length, lo, hi);\n        var nRemaining = hi - lo;\n        if (nRemaining &lt; 2) return;\n        if (nRemaining &lt; MIN_MERGE) {\n            var initRunLen = countRunAndMakeAscending(a, lo, hi, compare);\n            binarySort(a, lo, hi, lo + initRunLen, compare);\n            return\n        }\n        var ts = [];\n        var minRun = minRunLength(nRemaining);\n        do {\n            var runLenVar = countRunAndMakeAscending(a, lo, hi, compare);\n            if (runLenVar &lt; minRun) {\n                var force = nRemaining &lt;= minRun ? nRemaining : minRun;\n                binarySort(a, lo, lo + force, lo + runLenVar, compare);\n                runLenVar = force\n            }\n            pushRun(lo, runLenVar);\n            mergeCollapse();\n            lo += runLenVar;\n            nRemaining -= runLenVar\n        } while (nRemaining != 0);\n        mergeForceCollapse()\n    }\n\n    function binarySort(a, lo, hi, start, compare) {\n        if (start == lo) start++;\n        for (; start &lt; hi; start++) {\n            var pivot = a[start];\n            var left = lo;\n            var right = start;\n            while (left &lt; right) {\n                var mid = (left + right) &gt;&gt;&gt; 1;\n                if (compare(pivot, a[mid]) &lt; 0) right = mid;\n                else left = mid + 1\n            }\n            var n = start - left;\n            switch (n) {\n                case 2:\n                    a[left + 2] = a[left + 1];\n                case 1:\n                    a[left + 1] = a[left];\n                    break;\n                default:\n                    arraycopy(a, left, a, left + 1, n)\n            }\n            a[left] = pivot\n        }\n    }\n\n    function countRunAndMakeAscending(a, lo, hi, compare) {\n        var runHi = lo + 1;\n        if (compare(a[runHi++], a[lo]) &lt; 0) {\n            while (runHi &lt; hi &amp;&amp; compare(a[runHi], a[runHi - 1]) &lt; 0) {\n                runHi++\n            }\n            reverseRange(a, lo, runHi)\n        } else {\n            while (runHi &lt; hi &amp;&amp; compare(a[runHi], a[runHi - 1]) &gt;= 0) {\n                runHi++\n            }\n        }\n        return runHi - lo\n    }\n\n    function reverseRange(a, lo, hi) {\n        hi--;\n        while (lo &lt; hi) {\n            var t = a[lo];\n            a[lo++] = a[hi];\n            a[hi--] = t\n        }\n    }\n\n    function minRunLength(n) {\n        var r = 0;\n        return n + 1\n    }\n\n    function pushRun(runBaseArg, runLenArg) {\n        runBase[stackSize] = runBaseArg;\n        runLen[stackSize] = runLenArg;\n        stackSize++\n    }\n\n    function mergeCollapse() {\n        while (stackSize &gt; 1) {\n            var n = stackSize - 2;\n            if (n &gt; 0 &amp;&amp; runLen[n - 1] &lt;= runLen[n] + runLen[n + 1]) {\n                if (runLen[n - 1] &lt; runLen[n + 1]) n--;\n                mergeAt(n)\n            } else if (runLen[n] &lt;= runLen[n + 1]) {\n                mergeAt(n)\n            } else {\n                break\n            }\n        }\n    }\n\n    function mergeForceCollapse() {\n        while (stackSize &gt; 1) {\n            var n = stackSize - 2;\n            if (n &gt; 0 &amp;&amp; runLen[n - 1] &lt; runLen[n + 1]) n--;\n            mergeAt(n)\n        }\n    }\n\n    function mergeAt(i) {\n        var base1 = runBase[i];\n        var len1 = runLen[i];\n        var base2 = runBase[i + 1];\n        var len2 = runLen[i + 1];\n        runLen[i] = len1 + len2;\n        if (i == stackSize - 3) {\n            runBase[i + 1] = runBase[i + 2];\n            runLen[i + 1] = runLen[i + 2]\n        }\n        stackSize--;\n        var k = gallopRight(global_a[base2], global_a, base1, len1, 0, compare);\n        base1 += k;\n        len1 -= k;\n        if (len1 == 0) return;\n        len2 = gallopLeft(global_a[base1 + len1 - 1], global_a, base2, len2, len2 - 1, compare);\n        if (len2 == 0) return;\n        if (len1 &lt;= len2) mergeLo(base1, len1, base2, len2);\n        else mergeHi(base1, len1, base2, len2)\n    }\n\n    function gallopLeft(key, a, base, len, hint, compare) {\n        var lastOfs = 0;\n        var ofs = 1;\n        if (compare(key, a[base + hint]) &gt; 0) {\n            var maxOfs = len - hint;\n            while (ofs &lt; maxOfs &amp;&amp; compare(key, a[base + hint + ofs]) &gt; 0) {\n                lastOfs = ofs;\n                ofs = (ofs &lt;&lt; 1) + 1;\n                if (ofs &lt;= 0) ofs = maxOfs\n            }\n            if (ofs &gt; maxOfs) ofs = maxOfs;\n            lastOfs += hint;\n            ofs += hint\n        } else {\n            var maxOfs = hint + 1;\n            while (ofs &lt; maxOfs &amp;&amp; compare(key, a[base + hint - ofs]) &lt;= 0) {\n                lastOfs = ofs;\n                ofs = (ofs &lt;&lt; 1) + 1;\n                if (ofs &lt;= 0) ofs = maxOfs\n            }\n            if (ofs &gt; maxOfs) ofs = maxOfs;\n            var tmp = lastOfs;\n            lastOfs = hint - ofs;\n            ofs = hint - tmp\n        }\n        lastOfs++;\n        while (lastOfs &lt; ofs) {\n            var m = lastOfs + ((ofs - lastOfs) &gt;&gt;&gt; 1);\n            if (compare(key, a[base + m]) &gt; 0) lastOfs = m + 1;\n            else ofs = m\n        }\n        return ofs\n    }\n\n    function gallopRight(key, a, base, len, hint, compare) {\n        var ofs = 1;\n        var lastOfs = 0;\n        if (compare(key, a[base + hint]) &lt; 0) {\n            var maxOfs = hint + 1;\n            while (ofs &lt; maxOfs &amp;&amp; compare(key, a[base + hint - ofs]) &lt; 0) {\n                lastOfs = ofs;\n                ofs = (ofs &lt;&lt; 1) + 1;\n                if (ofs &lt;= 0) ofs = maxOfs\n            }\n            if (ofs &gt; maxOfs) ofs = maxOfs;\n            var tmp = lastOfs;\n            lastOfs = hint - ofs;\n            ofs = hint - tmp\n        } else {\n            var maxOfs = len - hint;\n            while (ofs &lt; maxOfs &amp;&amp; compare(key, a[base + hint + ofs]) &gt;= 0) {\n                lastOfs = ofs;\n                ofs = (ofs &lt;&lt; 1) + 1;\n                if (ofs &lt;= 0) ofs = maxOfs\n            }\n            if (ofs &gt; maxOfs) ofs = maxOfs;\n            lastOfs += hint;\n            ofs += hint\n        }\n        lastOfs++;\n        while (lastOfs &lt; ofs) {\n            var m = lastOfs + ((ofs - lastOfs) &gt;&gt;&gt; 1);\n            if (compare(key, a[base + m]) &lt; 0) ofs = m;\n            else lastOfs = m + 1\n        }\n        return ofs\n    }\n\n    function mergeLo(base1, len1, base2, len2) {\n        var a = global_a;\n        var tmp = a.slice(base1, base1 + len1);\n        var cursor1 = 0;\n        var cursor2 = base2;\n        var dest = base1;\n        a[dest++] = a[cursor2++];\n        if (--len2 == 0) {\n            arraycopy(tmp, cursor1, a, dest, len1);\n            return\n        }\n        if (len1 == 1) {\n            arraycopy(a, cursor2, a, dest, len2);\n            a[dest + len2] = tmp[cursor1];\n            return\n        }\n        var c = compare;\n        var minGallop = MIN_GALLOP;\n        outer: while (true) {\n            var count1 = 0;\n            var count2 = 0;\n            do {\n                if (compare(a[cursor2], tmp[cursor1]) &lt; 0) {\n                    a[dest++] = a[cursor2++];\n                    count2++;\n                    count1 = 0;\n                    if (--len2 == 0) break outer\n                } else {\n                    a[dest++] = tmp[cursor1++];\n                    count1++;\n                    count2 = 0;\n                    if (--len1 == 1) break outer\n                }\n            } while ((count1 | count2) &lt; minGallop);\n            do {\n                count1 = gallopRight(a[cursor2], tmp, cursor1, len1, 0, c);\n                if (count1 != 0) {\n                    arraycopy(tmp, cursor1, a, dest, count1);\n                    dest += count1;\n                    cursor1 += count1;\n                    len1 -= count1;\n                    if (len1 &lt;= 1) break outer\n                }\n                a[dest++] = a[cursor2++];\n                if (--len2 == 0) break outer;\n                count2 = gallopLeft(tmp[cursor1], a, cursor2, len2, 0, c);\n                if (count2 != 0) {\n                    arraycopy(a, cursor2, a, dest, count2);\n                    dest += count2;\n                    cursor2 += count2;\n                    len2 -= count2;\n                    if (len2 == 0) break outer\n                }\n                a[dest++] = tmp[cursor1++];\n                if (--len1 == 1) break outer;\n                minGallop--\n            } while (count1 &gt;= MIN_GALLOP | count2 &gt;= MIN_GALLOP);\n            if (minGallop &lt; 0) minGallop = 0;\n            minGallop += 2\n        }\n        this.minGallop = minGallop &lt; 1 ? 1 : minGallop;\n        if (len1 == 1) {\n            arraycopy(a, cursor2, a, dest, len2);\n            a[dest + len2] = tmp[cursor1]\n        } else if (len1 == 0) {\n            throw new Error(&quot;IllegalArgumentException. Comparison method violates its general contract!&quot;);\n        } else {\n            arraycopy(tmp, cursor1, a, dest, len1)\n        }\n    }\n\n    function mergeHi(base1, len1, base2, len2) {\n        var a = global_a;\n        var tmp = a.slice(base2, base2 + len2);\n        var cursor1 = base1 + len1 - 1;\n        var cursor2 = len2 - 1;\n        var dest = base2 + len2 - 1;\n        a[dest--] = a[cursor1--];\n        if (--len1 == 0) {\n            arraycopy(tmp, 0, a, dest - (len2 - 1), len2);\n            return\n        }\n        if (len2 == 1) {\n            dest -= len1;\n            cursor1 -= len1;\n            arraycopy(a, cursor1 + 1, a, dest + 1, len1);\n            a[dest] = tmp[cursor2];\n            return\n        }\n        var c = compare;\n        var minGallop = MIN_GALLOP;\n        outer: while (true) {\n            var count1 = 0;\n            var count2 = 0;\n            do {\n                if (compare(tmp[cursor2], a[cursor1]) &lt; 0) {\n                    a[dest--] = a[cursor1--];\n                    count1++;\n                    count2 = 0;\n                    if (--len1 == 0) break outer\n                } else {\n                    a[dest--] = tmp[cursor2--];\n                    count2++;\n                    count1 = 0;\n                    if (--len2 == 1) break outer\n                }\n            } while ((count1 | count2) &lt; minGallop);\n            do {\n                count1 = len1 - gallopRight(tmp[cursor2], a, base1, len1, len1 - 1, c);\n                if (count1 != 0) {\n                    dest -= count1;\n                    cursor1 -= count1;\n                    len1 -= count1;\n                    arraycopy(a, cursor1 + 1, a, dest + 1, count1);\n                    if (len1 == 0) break outer\n                }\n                a[dest--] = tmp[cursor2--];\n                if (--len2 == 1) break outer;\n                count2 = len2 - gallopLeft(a[cursor1], tmp, 0, len2, len2 - 1, c);\n                if (count2 != 0) {\n                    dest -= count2;\n                    cursor2 -= count2;\n                    len2 -= count2;\n                    arraycopy(tmp, cursor2 + 1, a, dest + 1, count2);\n                    if (len2 &lt;= 1) break outer\n                }\n                a[dest--] = a[cursor1--];\n                if (--len1 == 0) break outer;\n                minGallop--\n            } while (count1 &gt;= MIN_GALLOP | count2 &gt;= MIN_GALLOP);\n            if (minGallop &lt; 0) minGallop = 0;\n            minGallop += 2\n        }\n        this.minGallop = minGallop &lt; 1 ? 1 : minGallop;\n        if (len2 == 1) {\n            dest -= len1;\n            cursor1 -= len1;\n            arraycopy(a, cursor1 + 1, a, dest + 1, len1);\n            a[dest] = tmp[cursor2]\n        } else if (len2 == 0) {\n            throw new Error(&quot;IllegalArgumentException. Comparison method violates its general contract!&quot;);\n        } else {\n            arraycopy(tmp, 0, a, dest - (len2 - 1), len2)\n        }\n    }\n\n    function rangeCheck(arrayLen, fromIndex, toIndex) {\n        if (fromIndex &gt; toIndex) throw new Error(&quot;IllegalArgument fromIndex(&quot; + fromIndex + &quot;) &gt; toIndex(&quot; + toIndex + &quot;)&quot;);\n        if (fromIndex &lt; 0) throw new Error(&quot;ArrayIndexOutOfBounds &quot; + fromIndex);\n        if (toIndex &gt; arrayLen) throw new Error(&quot;ArrayIndexOutOfBounds &quot; + toIndex);\n    }\n}\n</code></pre>\n<p>具体操作较为复杂，这里建议大家更多的了解这个知识点，而具体实现一般不作要求。</p>\n<p>我们来看一下 v8 在采用 Timsort 之后，得到的一些 benchmark：</p>\n<p><img src=\"https://images.gitbook.cn/3eb83630-db4f-11e9-b7e8-efbebe7dfdf6\" alt=\"2\" /></p>\n<p><img src=\"https://images.gitbook.cn/55bb5330-db4f-11e9-9f9d-c526a5f387ab\" alt=\"3\" /></p>\n<p><img src=\"https://images.gitbook.cn/6a0bfa60-db4f-11e9-b7e8-efbebe7dfdf6\" alt=\"4\" /></p>\n<p>更多内容，可以参考 v8 官方博客：<a href=\"https://v8.dev/blog/array-sort\" target=\"_blank\">Getting things sorted in V8</a></p>\n<h3><a id=\"_787\"></a>实战例题</h3>\n<p>从这里开始，我们来“刷”一些实战例题。</p>\n<h4><a id=\"_791\"></a>交换星号</h4>\n<p>题目：一个字符串中只包含 * 和数字，请把 * 号都放开头。</p>\n<p>思路：使用两个指针，从后往前扫字符串，遇到数字则赋值给后面的指针，继续往后扫，遇到 * 则不处理。</p>\n<pre><code class=\"lang-\">const isNumeric = n =&gt; !isNaN(parseFloat(n)) &amp;&amp; isFinite(n);\n\n/**\n * @param {string}\n * @return {string}\n */\nconst solution = s =&gt; {\n    const n = s.length\n    let a = s.split(&apos;&apos;)\n    let j = n - 1\n    \n    for (let i = n - 1; i &gt;= 0; --i)\n        if (isNumeric(a[i])) a[j--] = a[i]\n        \n    for (; j &gt;= 0; --j) a[j] = &apos;*&apos;\n    return a.join(&apos;&apos;)\n}\n</code></pre>\n<p>这样一来，我们逆序操作数组，遇见数字则向后置，遍历完一遍后，所有的数字都已经在后边了，同时把前边的数组项用 * 填充。</p>\n<h4><a id=\"Longest_Substring_Without_Repeating_Characters_819\"></a>Longest Substring Without Repeating Characters</h4>\n<p>题意：给定一个字符串，返回它最长的不包含重复的子串长度。例如，输入 abcabcbb 输出 3（对应 abc）。</p>\n<p>思路：</p>\n<ul>\n<li>暴力枚举起点和终点，并判断重复，时间复杂度是 O(n²)；</li>\n<li>通过双指针、滑动窗口，动态维护窗口 [i…j)，使窗口内字符不重复。</li>\n</ul>\n<p>我们看第二种思路解法，保证窗口 [i…j) 之间没有重复字符：</p>\n<ul>\n<li>首先 i, j 两个指针均指向字符串头部，如果没有重复字符，则 j 不断向右滑动，直到出现重复字符；</li>\n<li>如果出现了重复的字符，重复字符出现在第 str[j] 处，这时候开始移动指针 i，找到另一个重复的字读出现在 str[i] 处，那么能保证 [0, i] 以及 [i, j] 子字符串是不重复的，更新临时结果为 Math.max(result, j - i)。</li>\n</ul>\n<p><strong>时间复杂度 O(n)</strong></p>\n<p>实现：</p>\n<pre><code class=\"lang-\">const lengthOfLongestSubstring = str =&gt; {\n    let result = 0\n    let len = str.length\n\n    // 记录当前区间内出现的字符\n    let mapping = {}\n\n    for (let i = 0, j = 0; ; ++i) {\n\n        // j 右移的过程\n        while (j &lt; len &amp;&amp; !mapping[str[j]])\n            mapping[str[j++]] = true\n        result = Math.max(result, j - i)\n\n        if (j &gt;= len)\n            break;\n\n        // 出现了重复字符，i 开始进行右移的过程，同时将移出的字符在 mapping 中重置\n        while (str[i] != str[j])\n            mapping[str[i++]] = false\n        mapping[str[i]] = false\n\n    }\n    \n    return result\n};\n</code></pre>\n<p>举这个例子的目的是为了展示滑动窗口的思想，通过滑动窗口一般能实现 O(n) 的时间复杂度和 O(1) 的空间复杂度。</p>\n<h3><a id=\"_868\"></a>总结</h3>\n<p>这一讲我们主要介绍了几种排序算法和最先进的 Timsort，相信凭借这些内容，在前端排序上你可以“鄙视”面试官了。当然算法的坑还是很深的，我们要保持好的心态。最后部分介绍了两个算法题，算是抛砖引玉，下一讲，让我们针对算法面试，刷一刷算法。</p>\n","createdAt":"2019-04-21T04:48:11.215Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":42,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FoThASW9dVEPMEo9nP-zaOfbKyLZ"},{"_id":"5cbbf635bbbba80861a35c79","communication_start_time":null,"type":1,"audioPath":"","abstract":"","content":"前面课程，我们总结了前端和算法的关系，在上一讲中，也已经通过两道题目开启了“刷算法”的热身。算法是面试中必不可少的部分，尤其对于高阶职位来说，算法题目是面试环节的“最难”和“最关键”的环节。\n\n算法说难也不难，我们大可不必“谈虎色变”，有策略地“刷算法题”将会使你更有信心。我认为在课程中一味地“秀算法”，找最高深最偏的算法分析没有任何意义。这里我总结出一些经典的算法题目，我常用来考察候选者以及我作为面试者遇到的一些题目来讲解。\n\n主要内容如下：\n\n![enter image description here](https://images.gitbook.cn/a80ed7e0-d827-11e9-a98d-91914e1a8fb9)\n\n### 爬楼梯\n\n题目：假设我们需要爬一个楼梯，这个楼梯一共有 N 阶，可以一步跨越 1 个或者 2 个台阶，那么爬完楼梯一共有多少种方式？\n\n示例：输入 2（标注 N = 2，一共是 2 级台阶）；\n\n输出：2 （爬完一共两种方法：一次跨两阶 + 分两次走完，一次走一阶）\n\n示例：输入 3；输出 3（1 阶 + 1 阶 + 1 阶；1 阶 + 2 阶；2 阶 + 1 阶）\n\n思路：最直接的想法其实类似 Fibonacci 数列，使用递归比较简单。比如我们爬 N 个台阶，其实就是爬 N － 1 个台阶的方法数 + 爬 N － 2 个台阶的方法数。\n\n解法：\n\n```\nconst climbing = n => {\n    if (n == 1) return 1\n    if (n == 2) return 2\n    return climbing(n - 1) + climbing(n - 2)\n}\n```\n\n我们来分析一下时间复杂度：递归方法的时间复杂度是高度为 n−1 的不完全二叉树节点数，因此近似为 O(2^n)，具体数学公式不再展开。\n\n我们来尝试进行优化。实际上，上述的计算过程肯定都包含了不少重复计算，比如  climbing(N) + climbing(N － 1) 后会计算 climbing(N － 1) + climbing(N － 2)，而实际上 climbing(N － 1) 只需要计算一次就可以了。\n\n优化方案：\n\n```\nconst climbing = n => {\n    let array = []\n    const step = n => {\n        if (n == 1) return 1\n        if (n == 2) return 2\n        if (array[n] > 0) return array[n]\n        \n        array[n] = step(n - 1) + step(n - 2)\n        return array[n]\n    }\n    return step(n)\n}\n```\n\n我们使用了一个数组 array 来储存计算结果，时间复杂度为 O(n)。\n\n另外一个优化方向是：所有递归都可以用循环来代替。\n\n```\nconst climbing = n => {\n    if (n == 1) return 1\n    if (n == 2) return 2\n\n    let array = []\n    array[1] = 1\n    array[2] = 2\n    \n    for (let i = 3; i<= n; i++) {\n        array[i] = array[i - 1] + array[i - 2]\n    }\n    return array[n]\n}\n```\n\n时间复杂度仍然为  O(n)，但是我们优化了内存的开销。\n\n因此这道题看似“困难”，其实就是一个 Fibonacci 数列。很多算法题目都是类似的，也许第一次读题会觉得没有思路，但是隐藏在题目后边的解决方案，其实就是我们常见的知识。\n\n###  Combination Sum\n\n这个算法，让我们来聚焦“回溯”这两个字，题目出处 [Combination Sum](https://juejin.im/post/5d1ca2c5e51d4550bf1ae8cd)。\n\n题目：给定一组不含重复数字的非负数组和一个非负目标数字，在数组中找出所有数加起来等于给定的目标数字的组合。\n\n示例：输入\n\n```\nconst array = [2, 3, 6, 7]\nconst target = 7\n```\n\n输出：\n\n```\n[\n  [7],\n  [2,2,3]\n]\n```\n\n我们直接来看优化后的思想：回溯解决问题的套路就是先用“笨办法”，遍历所有的情况来找出问题的解，在这个遍历过程当中，以深度优先的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索。\n\n回到这个问题，我们先通过图来遍历所有情况：\n\n![5](https://images.gitbook.cn/4a7e0ec0-db51-11e9-a268-91dece478f6a)\n\n对于这个题目，事实上我们思考，数组 [2, 2, 3] 和 [2, 3, 2] 实际是重复的，因此可以删除掉重复的项，优化递归树为：\n\n![6](https://images.gitbook.cn/63ca0a50-db51-11e9-9f9d-c526a5f387ab)\n\n我们该如何用代码描述上述过程呢？这时候需要一个临时数组 tmpArray，进入递归前 push 一个结果，\n\n最终答案：\n\n```\nconst find = (array, target) => {\n\tlet result = []\n\n\tconst dfs = (index, sum, tmpArray)  => {\n        if (sum === target) {\n            result.push(tmpArray.slice())\n        }\n        \n        if (sum > target) {\n    \t    return\n        }\n        \n        for (let i = index; i < array.length; i++) {\n            tmpArray.push(array[i])\n            \n            dfs(i, sum + array[i], tmpArray)\n            \n            tmpArray.pop()\n        }\n    }\n\n    dfs(0, 0, [])\n    \n    return result\t\n}\n```\n\n如果读者存在理解问题，建议打断点调试一下。回溯是一个非常常见的思想，这也是一个典型的回溯常考题目。\n\n另外，该题有另一个变种：\n\n> 从一个数组中找出 N 个数，其和为 M 的所有可能。\n\n这里我们指定数组元素个数的和，需要这个和为指定值。\n\n举例：从数组 [1, 2, 3, 4] 中选取 2 个元素，求和为 5 的所有可能。答案是两组组合: [1, 4] 和 [2, 3]。\n\n这里我们介绍一种借助“二进制”实现的解法，可以用 0 和 1 来表示数组中相应的元素是否被选中。因此，对于一个长度为 4 的数组来说：\n\n- 0000 表示没有选择数组中的任何元素\n- 0100 表示选择了数组中第 1 位元素\n\n以此类推，数组长度为 4，那么上述情况一共有 16 种可能（Math.pow(length, 2)）。\n\n而这道题目中，只需要选择指定数组元素个数的和，还是对于数组长度为 4 的情况：只需要考虑 0011 等 1 的个数累加为 0 case，而不需要考虑类似 0111 这样的 case。\n\n针对符合个数的所有情况，我们进行数组项目的求和，判断是否等于指定值的情况即可：\n\n```\nconst find = (array, target, sum) => {\n  const len = array.length\n  let result = []\n\n  for (let i = 0; i < Math.pow(2, len); i++) {\n    if (getCount(i) == target) {\n      let s = 0 \n      let temp = []\n      for (let j = 0; j < len; j++) {\n        if (i & 1 << (len - 1 -j)) {\n          s += array[j]\n          temp.push(array[j])\n        }\n      }\n      if (s == sum) {\n        result.push(temp)\n      }\n    }\n  }\n  return result\n}\n\nfunction getCount(i) {\n  let count = 0;\n  while (i) {\n   if (i & 1){\n    ++count\n   }\n   i >>= 1\n  }\n  return count\n}\n```\n\n### remove duplicates from sorted array\n\n题目：对一个给定一个排序数组去重，同时返回去重后数组的新长度。\n\n难点：这道题并不困难，但是需要临时加一些条件，即需要原地操作，在使用 O(1) 额外空间的条件下完成。\n\n示例：\n\n输入：\n\n```\nlet array = [0,0,1,1,1,2,2,3,3,4]\n```\n\n输出：\n\n```\nconsole.log(removeDuplicates(array))\n// 5\n\nconsole.log(array)\n// 0, 1, 2, 3, 4\n```\n\n这道题既然规定 in-place 的操作，那么可以考虑算法中的另一个重要思想：双指针。\n\n![7](https://images.gitbook.cn/33808a30-df3a-11e9-87f9-6dac5837a5da)\n\n使用快慢指针：\n\n- 开始时，快指针和慢指针都指向数组中的第一项\n- 如果快指针和慢指针指的数字相同，则快指针向前走一步\n- 如果快指针和慢指针指的数字不同，则两个指针都向前走一步，同时快指针指向的数字赋值给慢指针指向的数字\n- 当快指针走完整个数组后，慢指针当前的坐标加 1 就是数组中不同数字的个数\n\n代码很简单：\n\n```\nconst removeDuplicates = array => {\n\tconst length = array.length\n\n\tlet slowPointer = 0\n\n\tfor (let fastPointer = 0; fastPointer < length; fastPointer ++) {\n\t\tif (array[slowPointer] !== array[fastPointer]) {\n\t\t\tslowPointer++\n\t\t\tarray[slowPointer] = array[fastPointer]\n\t\t}\n\t}\n}\n```\n\n这道题目如果不要求 O(n) 的时间复杂度， O(1) 的空间复杂度，那么会非常简单。如果进行空间复杂度要求，尤其是 in-place 操作，开发者往往可以考虑双指针的思路。\n\n### 求众数\n\n这也是一道简单的题目，关键点在于如何优化。\n\n题目：给定一个大小为 N 的数组，找到其中的众数。众数是指在数组中出现次数大于 N/2 的元素。\n\n可能大家都会想到使用一个额外的空间，记录元素出现的次数，我们往往用一个 map 就可以轻易地实现。那优化点在哪里呢？答案就是投票算法。\n\n```\nconst find = array => {\n\tlet count = 1\n\tlet result = array[0]\n\t\n\tfor (let i = 0; i < array.lenght; i++) {\n\t\tif (count === 0) result = array[i]\n\t\t\n\t\tif (array[i] === result) {\n\t\t\tcount++\n\t\t}\n\t\telse {\n\t\t\tcount--\n\t\t}\n\t}\n\t\n\treturn result\n}\n```\n\n\n### 有效括号\n\n有效括号这个题目和前端息息相关，在之前课程模版解析时，其实都需要类似的算法进行模版的分析，进而实现数据的绑定。我们来看题目：\n\n举例：输入 \"()\"\n\n输出：true\n\n举例：输入 \"()[]{}\"\n\n输出：true\n\n举例：输入 \"{[]}\"\n\n输出：false\n\n举例：输入 \"([)]\"\n\n输出：false\n\n这道题目的解法非常典型，就是借助栈实现，将这些括号自右向左看做栈结构。我们把成对的括号分为左括号和右括号，需要左括号和右括号一一匹配，通过一个 Object 来维护关系：\n\n```\nlet obj = {\n    \"]\": \"[\",\n    \"}\": \"{\",\n    \")\": \"(\",\n}\n```\n\n如果编译器中在解析时，遇见左括号，我们就入栈；如果是右括号，就取出栈顶元素检查是否匹配。如果匹配，就出栈；否则，就返回 false。\n\n```\nconst isValid = str => {\n    let stack = []\n    var obj = {\n        \"]\": \"[\",\n        \"}\": \"{\",\n        \")\": \"(\",\n    }\n\n    for (let i = 0; i < str.length; i++) {\n        if(str[i] === \"[\" || str[i] === \"{\" || str[i] === \"(\") {\n            stack.push(str[i])\n        } \n        else {\n            let key = stack.pop()\n            if(obj[key] !== str[i]) {\n                return false\n            }\n        }\n    }\n\n    if (!stack.length) {\n        return true\n    }\n\n    return false\n};\n```\n\n###  LRU 缓存算法\n\n看了这么多小算法题目，我们来换一个口味，现在看一个算法的实际应用。\n\n> LRU（Least Recently Used）算法是缓存淘汰算法的一种。简单地说，由于内存空间有限，需要根据某种策略淘汰不那么重要的数据，用以释放内存。LRU 的策略是最早操作过的数据放最后，最晚操作过的放开始，按操作时间逆序，如果达到上限，则淘汰末尾的项。\n\n整个 LRU 算法有一定的复杂度，并且需要很多功能扩展。因此在生产环境中建议直接使用成熟的库，比如 npm 搜索 lru-cache。\n\n这里我们尝试实现一个微型体统级别的 LRU 算法：\n\n> 运用你所掌握的数据结构，设计和实现一个  LRU（最近最少使用）缓存机制。它应该支持以下操作：获取数据 get 和 写入数据 put 。\n\n获取数据 get(key) － 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 －1。\n\n写入数据 put(key, value) － 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。\n\n我们先来整体思考：尽量满足 O(1) 的时间复杂度中完成获取和写入的操作，那么可以使用一个 Object 来进行存储，如果 key 不是简单类型，可以使用 Map 实现：\n\n```\nconst LRUCache = function(capacity) {\n  // ...\n  this.map = {};\n  // ...\n};\n```\n\n在这个算法中，最复杂的应该是淘汰策略，淘汰数据的时间复杂度必须是 O(1) 的话，我们一定需要额外的数据结构来完成 O(1) 的淘汰策略。那应该用什么样的数据结构呢？答案是双向链表。\n\n链表在插入与删除操作上，都是 O(1) 时间的复杂度，唯一有问题的查找元素过程比较麻烦，是 O(n)。但是这里我们不需要使用双向链表实现查找逻辑，因为 map 已经很好的弥补了缺陷。\n\n赘述一下：**我们在写入值的时候，判断缓存容量是否已经达到上限，如果缓存容量达到上限时，应该删除最近最少使用的数据值，从而为以后的新的数据值留出空间。**\n\n结合链表的话，我们将刚刚写入的目标值设置为链表的首项，超过限制，就删除链表的尾项。\n\n最终实现：\n\n```\nconst LRUCache = function(capacity) {\n  this.map = {}\n  this.size = 0\n  this.maxSize = capacity\n\n  // 链表初始化，初始化只有一个头和尾\n  this.head = {\n    prev: null,\n    next: null\n  }\n  this.tail = {\n    prev: this.head,\n    next: null\n  }\n\n  this.head.next = this.tail\n};\n\nLRUCache.prototype.get = function(key) {\n  if (this.map[key]) {\n    const node = this.extractNode(this.map[key])\n\n    // 最新访问，将该节点放到链表的头部\n    this.insertNodeToHead(node)\n\n    return this.map[key].val\n  } \n  else {\n    return -1\n  }\n}\n\nLRUCache.prototype.put = function(key, value) {\n  let node\n\n  if (this.map[key]) {\n    // 该项已经存在，更新值\n    node = this.extractNode(this.map[key])\n    node.val = value\n  } \n  else {\n    // 如该项不存在，新创造节点\n    node = {\n      prev: null,\n      next: null,\n      val: value,\n      key,\n    }\n\n    this.map[key] = node\n    this.size++\n  }\n\n  // 最新写入，将该节点放到链表的头部\n  this.insertNodeToHead(node)\n\n  // 判断长度是否已经到达上限\n  if (this.size > this.maxSize) {\n    const nodeToDelete = this.tail.prev\n    const keyToDelete = nodeToDelete.key\n    this.extractNode(nodeToDelete)\n    this.size--\n    delete this.map[keyToDelete]\n  }\n};\n\n// 插入节点到链表首项\nLRUCache.prototype.insertNodeToHead = function(node) {\n  const head = this.head\n  const lastFirstNode = this.head.next\n\n  node.prev = head\n  head.next = node\n  node.next = lastFirstNode\n  lastFirstNode.prev = node\n\n  return node\n}\n\n// 从链表中抽取节点\nLRUCache.prototype.extractNode = function(node) {\n  const beforeNode = node.prev\n  const afterNode = node.next\n\n  beforeNode.next = afterNode\n  afterNode.prev = beforeNode\n\n  node.prev = null\n  node.next = null\n  \n  return node\n}\n```\n\n### 链表相关题目\n\n在之前的课程中，我们介绍了链表这种数据结构。链表应用非常广泛，这里来熟悉两个常见的对链表的操作算法。\n\n#### 反转链表\n\n题目：对一个单链表进行反转\n\n输入：1→2→3→4→5→NULL\n\n输出：5→4→3→2→1→NULL\n\n最直观的解法是使用三个指针，把头节点变成尾节点点，进行遍历：下一个节点\n拼接到当前节点的头部，以此类推。这种方法的实现我们不再手写，而是重点关注一下递归解法。\n\n递归解法就要先判断递归终止条件，当下一个节点为 null，找到尾节点时，将其返回。我们从后往前进行：\n\n```\nconst reverseList = head => {\n   // 到了尾节点，则返回尾节点\n   if (head == null || head.next == null) {\n       return head\n   }\n   else {\n       let newhead = reverseList(head.next)\n       // 将当前节点的一下节点的 next 指向，指向为当前节点\n       head.next.next = head\n       // 暂时情况当前节点的 next 指向\n       head.next = null\n       \n       return newhead\n   }\n}\n```\n\n#### 删除链表的倒数第 N 个节点\n\n题目：给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。\n\n输入：1→2→3→4→5，和 n = 2\n\n输出：1→2→3→5\n\n这道题目的关键是如何优雅地找到倒数第 N 个节点。\n\n我们当然可以使用两次循环，第一次循环得到整个链表的长度 L，那么需要删除的节点就位于 L - N + 1 位置处，第二次遍历到相关位置进行操作即可。\n\n这道题其实是可以用一次遍历来解决的。我们需要使用双指针，快指针 fast 先前进 N，找到需要删除的节点；然后慢指针 slow 从 head 开始，和快指针 fast 一起前进，直到 fast 走到末尾。 此时 slow 的下一个节点就是要删除的节点，也就是倒数第 N 个节点。需要注意的是，如果快指针移动 N 步之后，已经到了尾部，那说明需要删除的就是头节点。\n\n```\nconst removeNthFromEnd = (head, n) => {\n    if (head === null) {\n        return head\n    }\n    \n    if (n === 0) {\n        return head\n    }\n    \n    let fast = head\n    let slow = head\n    \n    // 快指针前进 N 步\n    while (n > 0) {\n        fast = fast.next\n        n--\n    }\n    \n    // 快指针移动 N 步之后，已经到了尾部，那说明需要删除的就是头节点\n    if (fast === null) {\n        return head.next\n    }\n    \n    while (fast.next != null ){\n        fast = fast.next\n        slow = slow.next\n    }\n    \n    slow.next=slow.next.next\n    return head\n}\n```\n\n这两道关于链表的题目都重点考察了对你链表结构的理解，其中是用到了多个指针，这也是解决链表题目的关键。\n\n### 算法学习\n\n本节课内容到这里，我们只是列举了一些算法题目，也算不上“题海战术”，但问题都比较典型。可是面对这些相对零散的内容，我们应该如何入手学习呢？只是一味的刷题，似乎效率低下而无趣。\n\n我认为对于算法的学习，需要做到“分门别类”，按照不同类别的算法思想，遵循循序渐进的进步路线，才会“越来越有感觉”。我把算法的一些基础思想进行了归并：\n\n- 枚举\n- 模拟\n- 递归/分治\n- 贪心\n- 排序\n- 二分\n- 倍增\n- 构造\n- 前缀和/差分\n\n我们来简单总结一下这些算法基础思想。\n\n#### 枚举\n\n枚举是基于已有知识来猜测，印证答案的一种问题求解策略。当拿到一道题目时，枚举这种“暴力解法”最容易想到。这其中重点是：\n\n- 建立简洁的数学模型\n- 想清楚枚举哪些要素\n- 尝试减少枚举空间\n\n举个例子：\n\n> 一个数组中的数互不相同，求其中和为 0 的数对的个数\n\n最笨的方法：\n\n```\n\nfor (int i = 0; i < n; ++i)\n  for (int j = 0; j < n; ++j)\n    if (a[i] + a[j] == 0) ++ans;\n```\n\n我们来看看如何操作进行优化。如果 (a, b) 是答案，那么 (b, a) 也是答案，因此对于这种情况只需统计一种顺序之后的答案，最后再乘 2 就好了。\n\n```\n\nfor (int i = 0; i < n; ++i)\n  for (int j = 0; j < i; ++j)\n    if (a[i] + a[j] == 0) ++ans;\n```\n\n如此一来，就减少了 j 的枚举范围，减少了这段代码的时间开销。然而这还不是最优解。\n\n我们思考：两个数是否都一定要枚举出来呢？其实枚举第一个数之后，题目的条件已经帮我们确定了其他的要素（另一个数），如果能找到一种方法直接判断题目要求的那个数是否存在，就可以省掉枚举后一个数的时间了。代码实现很简单，我们就不动手实现了。\n\n#### 模拟\n\n模拟。顾名思义，就是用计算机来模拟题目中要求的操作，我们只需要按照题面的意思来写就可以了。模拟题目通常具有码量大、操作多、思路繁复的特点。\n\n这种题目往往考察开发者的“逻辑转化为代码”的能力。一道典型题目是：[魔兽世界](http://bailian.openjudge.cn/practice/3750/)。\n\n#### 递归 & 分治\n\n递归的基本思想是某个函数直接或者间接地调用自身，这样就把原问题的求解转换为许多性质相同但是规模更小的子问题。\n\n递归和枚举的区别在于：枚举是横向地把问题划分，然后依次求解子问题，而递归是把问题逐级分解，是纵向的拆分。比如请尝试回答这几个问题：\n\n> 孙悟空身上有多少根毛？答：一根毛加剩下的毛。\n> 你今年几岁？答：去年的岁数加一岁，1999 年我出生。\n\n递归代码最重要的两个特征：结束条件和自我调用。\n\n```\nint func(传入数值) {\n  if (终止条件) return 最小子问题解;\n  return func(缩小规模);\n}\n```\n\n写递归的技巧，“明白一个函数的作用并相信它能完成这个任务，千万不要试图跳进细节”。 千万不要跳进这个函数里面企图探究更多细节，否则就会陷入无穷的细节无法自拔，人脑能压几个栈啊。\n\n先举个最简单的例子：遍历二叉树。\n\n```\nvoid traverse(TreeNode* root) {\n  if (root == nullptr) return;\n  traverse(root->left);\n  traverse(root->right);\n}\n```\n\n这几行代码就足以遍历任何一棵二叉树了。对于递归函数 traverse(root) ，我们只要相信：给它一个根节点 root，它就能遍历这棵树，因为写这个函数不就是为了这个目的吗？\n\n那么遍历一棵 N 叉数呢？\n\n```\nvoid traverse(TreeNode* root) {\n  if (root == nullptr) return;\n  for (child : root->children) traverse(child);\n}\n```\n\n总之，还是那句话：给它一个根节点 root，它就能遍历这棵树，不管你是几个叉。\n\n典型题目：\n\n> 给一棵二叉树，和一个目标值，节点上的值有正有负，返回树中和等于目标值的路径条数\n\n这道题目解法很多，也比较典型。这里我们只谈思想，具体实现就不展开。\n\n分治算法可以分三步走：分解 -> 解决 -> 合并。\n\n- 分解原问题为结构相同的子问题\n- 分解到某个容易求解的边界之后，进行递归求解\n- 将子问题的解合并成原问题的解\n\n归并排序是最典型的分治算法。\n\n```\nvoid mergeSort(一个数组) {\n  if (可以很容易处理) return\n  mergeSort(左半个数组)\n  mergeSort(右半个数组)\n  merge(左半个数组, 右半个数组)\n}\n```\n\n分治算法的套路就是前面说的三步走：分解 -> 解决 -> 合并：先左右分解，再处理合并，回溯就是在退栈，就相当于后序遍历了。至于 merge 函数，相当于两个有序链表的合并。\n\nLeetCode 有[递归专题练习](https://leetcode.com/explore/learn/card/recursion-i/)\nLeetCode 上有[分治算法的专项练习](https://leetcode-cn.com/tag/divide-and-conquer/?utm_source=LCUS&utm_medium=ip_redirect_o_uns&utm_campaign=transfer2china)\n\n#### 贪心\n\n贪心算法顾名思义就是只看眼前，并不考虑以后可能造成的影响。可想而知，并不是所有的时候贪心法都能获得最优解。\n\n最常见的贪心有两种。一种是：「将 XXX 按照某某顺序排序，然后按某种顺序（例如从小到大）处理」。另一种是：「我们每次都取 XXX 中最大/小的东西，并更新 XXX」，有时「XXX 中最大/小的东西」可以优化，比如用优先队列维护。这两种方式分别对应了离线的情况以及在线的情况。\n\n相关题目：\n\n- [工作调度Work Scheduling](https://www.luogu.org/problem/P2949)\n- [修理牛棚 Barn Repair](https://www.luogu.org/problem/P1209)\n- [皇后游戏](https://www.luogu.org/problem/P2123)\n\n#### 二分\n\n以二分搜索为例，它是用来在一个有序数组中查找某一元素的算法。它每次考察数组当前部分的中间元素，如果中间元素刚好是要找的，就结束搜索过程；如果中间元素小于所查找的值，那么左侧的只会更小，不会有所查找的元素，只需要到右侧去找就好了；如果中间元素大于所查找的值，同理，右侧的只会更大而不会有所查找的元素，所以只需要到左侧去找。\n\n在二分搜索过程中，每次都把查询的区间减半，因此对于一个长度为 n 的数组，至多会进行 log(n) 次查找。\n\n一定需要注意的是，这里的有序是广义的有序，如果一个数组中的左侧或者右侧都满足某一种条件，而另一侧都不满足这种条件，也可以看作是一种有序。\n\n二分法把一个寻找极值的问题转化成一个判定的问题（用二分搜索来找这个极值）。类比枚举法，我们当时是枚举答案的可能情况，现在由于单调性，我们不再需要一个个枚举，利用二分的思路，就可以用更优的方法解决「最大值最小」、「最小值最大」。这种解法也成为是「二分答案」，常见于解题报告中。\n\n比如：[砍树问题](https://www.luogu.org/problem/P1873)，我们可以在 1 到 1000000000（10 亿）中枚举答案，但是这种朴素写法肯定拿不到满分，因为从 1 跑到 10 亿太耗时间。我们可以对答案进行 1 到 10 亿的二分，其中，每次都对其进行检查可行性（一般都是使用贪心法）。 \n\n依照此思想，我们还有三分法等展开算法。\n\n\n#### 倍增\n\n倍增法，通过字面意思来看就是翻倍。这个方法在很多算法中均有应用，其中最常用的就是 RMQ 问题和求 LCA。\n\nRMQ 是英文 Range Maximum/Minimum Query 的缩写，表示区间最大（最小）值。解决 RMQ 问题的主要方法有两种，分别是 ST 表和线段树，具体请参见 ST 表和 线段树内容。\n\n#### 构造\n\n构造针对的问题的答案往往具有某种规律性，使得在问题规模迅速增大的时候，仍然有机会比较容易地得到答案。\n\n这种思想我们接触的比较少，主要体现了数学解题方法啊。比较典型的有：\n\n- [Luogu P3599 Koishi Loves Construction](https://www.luogu.org/problemnew/show/P3599)\n- [Vladik and fractions](http://codeforces.com/problemset/problem/743/C)\n- [AtCoder Grand Contest 032 B](https://atcoder.jp/contests/agc032/tasks/agc032_b)\n\n这里我们不再介绍，感兴趣的同学可以进行研究。\n\n#### 前缀和 & 差分\n\n前缀和是一种重要的预处理，能大大降低查询的时间复杂度。我们可以简单理解为“数列的前 n 项的和”。其实前缀和几乎都是基于容斥原理。\n\n比如这道题目：\n\n> 有 N 个的正整数放到数组 A 里，现在要求一个新的数组 B，新数组的第 i 个数 B[i]是原数组 A 第 0 到第 i 个数的和。\n\n对于这道题，我们有两种做法：\n\n- 把对数组 A 的累加依次放入数组 B 中。\n- 递推： B[i] = B[i-1] + A[i]\n\n我们看第二种方法采用前缀和的思想，无疑更加优秀。\n\n其他相关题目：\n\n- [前缀和](https://www.luogu.org/problem/U53525)\n- [前缀和的逆](https://www.luogu.org/problem/U69096)\n- [最大の和](https://www.luogu.org/problem/AT2412)\n- [Subsequences Summing to Sevens](https://www.luogu.org/problem/P3131)\n\n更复杂些，可以延伸出：基于 DP 计算高维前缀和，树上前缀和。\n\n最后，差分是一种和前缀和相对的策略。这种策略是求相邻两数的差。相关题目：\n\n- [树状数组 3 ：区间修改，区间查询](https://loj.ac/problem/132)\n- [地毯](https://www.luogu.org/problem/P3397)\n- [最大流](https://www.luogu.org/problem/P3128)\n\n#### 思想归并\n\n我列举了 9 中算法基本思想，并配上多到典型题目。实际上，读者可以根据自身情况酌情进行了解，在解题外更重要的是体会这些算法思想。比如我留一个小作业：在这三节课中所有讲到的算法中，你能按照这 9 种思想进行归类么？\n\n请动手尝试，我认为我们可以有解不出来的题目，但是对于算法思想的理解至关重要。\n\n### 总结\n\n到此我们关于算法的三节课就结束了。整体来说，算法需要应试。算法就像弹簧一样，只要你有信心，态度正确，不畏难，一定就可以攻克它。\n\n从今天起，下一个决心，制定一个计划，通过不断练习，提升自己解算法题的能力。当然学习数据结构和算法不仅仅对面试有帮助，对于程序的强健性、稳定性、性能来说，算法虽然只是细节，但却是最重要的一部分之一。比如 AVL 或者 B+ 树，可能除了在学校的大作业，一辈子也不会有机会实现一个出来，但你学会了分析和比较类似算法的能力, 有了搜索树的知识，你才能真正理解为什么 InnoDB 索引要用 B+ 树，你才能明白 like \"abc%\" 会不会使用索引，而不是人云亦云、知其然不知其所以然。\n\n这一节课我挑选的典型算法都不算困难，但都能体现算法的思想闪光点，适合类推。但实话说，这节课的内容相对零散，算法的思想却是可以归类的，也留给大家一个作业，将上述算法进行思想归类，并在每个归类下再找一道题目进行扩充。这样的学习方法一定会让你有所收获，在全部课程结束后，我也会和大家针对这个“作业”，进行交流，也分享出我的更多算法心得。","pdfUrl":"","reader":"","duration":"","title":"那些年常考的前端算法（下）","column":"5c91c813968b1d64b1e08fde","isNotification":false,"readingStatistics":0,"htmlContent":"<p>前面课程，我们总结了前端和算法的关系，在上一讲中，也已经通过两道题目开启了“刷算法”的热身。算法是面试中必不可少的部分，尤其对于高阶职位来说，算法题目是面试环节的“最难”和“最关键”的环节。</p>\n<p>算法说难也不难，我们大可不必“谈虎色变”，有策略地“刷算法题”将会使你更有信心。我认为在课程中一味地“秀算法”，找最高深最偏的算法分析没有任何意义。这里我总结出一些经典的算法题目，我常用来考察候选者以及我作为面试者遇到的一些题目来讲解。</p>\n<p>主要内容如下：</p>\n<p><img src=\"https://images.gitbook.cn/a80ed7e0-d827-11e9-a98d-91914e1a8fb9\" alt=\"enter image description here\" /></p>\n<h3><a id=\"_8\"></a>爬楼梯</h3>\n<p>题目：假设我们需要爬一个楼梯，这个楼梯一共有 N 阶，可以一步跨越 1 个或者 2 个台阶，那么爬完楼梯一共有多少种方式？</p>\n<p>示例：输入 2（标注 N = 2，一共是 2 级台阶）；</p>\n<p>输出：2 （爬完一共两种方法：一次跨两阶 + 分两次走完，一次走一阶）</p>\n<p>示例：输入 3；输出 3（1 阶 + 1 阶 + 1 阶；1 阶 + 2 阶；2 阶 + 1 阶）</p>\n<p>思路：最直接的想法其实类似 Fibonacci 数列，使用递归比较简单。比如我们爬 N 个台阶，其实就是爬 N － 1 个台阶的方法数 + 爬 N － 2 个台阶的方法数。</p>\n<p>解法：</p>\n<pre><code class=\"lang-\">const climbing = n =&gt; {\n    if (n == 1) return 1\n    if (n == 2) return 2\n    return climbing(n - 1) + climbing(n - 2)\n}\n</code></pre>\n<p>我们来分析一下时间复杂度：递归方法的时间复杂度是高度为 n−1 的不完全二叉树节点数，因此近似为 O(2^n)，具体数学公式不再展开。</p>\n<p>我们来尝试进行优化。实际上，上述的计算过程肯定都包含了不少重复计算，比如  climbing(N) + climbing(N － 1) 后会计算 climbing(N － 1) + climbing(N － 2)，而实际上 climbing(N － 1) 只需要计算一次就可以了。</p>\n<p>优化方案：</p>\n<pre><code class=\"lang-\">const climbing = n =&gt; {\n    let array = []\n    const step = n =&gt; {\n        if (n == 1) return 1\n        if (n == 2) return 2\n        if (array[n] &gt; 0) return array[n]\n        \n        array[n] = step(n - 1) + step(n - 2)\n        return array[n]\n    }\n    return step(n)\n}\n</code></pre>\n<p>我们使用了一个数组 array 来储存计算结果，时间复杂度为 O(n)。</p>\n<p>另外一个优化方向是：所有递归都可以用循环来代替。</p>\n<pre><code class=\"lang-\">const climbing = n =&gt; {\n    if (n == 1) return 1\n    if (n == 2) return 2\n\n    let array = []\n    array[1] = 1\n    array[2] = 2\n    \n    for (let i = 3; i&lt;= n; i++) {\n        array[i] = array[i - 1] + array[i - 2]\n    }\n    return array[n]\n}\n</code></pre>\n<p>时间复杂度仍然为  O(n)，但是我们优化了内存的开销。</p>\n<p>因此这道题看似“困难”，其实就是一个 Fibonacci 数列。很多算法题目都是类似的，也许第一次读题会觉得没有思路，但是隐藏在题目后边的解决方案，其实就是我们常见的知识。</p>\n<h3><a id=\"Combination_Sum_75\"></a>Combination Sum</h3>\n<p>这个算法，让我们来聚焦“回溯”这两个字，题目出处 <a href=\"https://juejin.im/post/5d1ca2c5e51d4550bf1ae8cd\" target=\"_blank\">Combination Sum</a>。</p>\n<p>题目：给定一组不含重复数字的非负数组和一个非负目标数字，在数组中找出所有数加起来等于给定的目标数字的组合。</p>\n<p>示例：输入</p>\n<pre><code class=\"lang-\">const array = [2, 3, 6, 7]\nconst target = 7\n</code></pre>\n<p>输出：</p>\n<pre><code class=\"lang-\">[\n  [7],\n  [2,2,3]\n]\n</code></pre>\n<p>我们直接来看优化后的思想：回溯解决问题的套路就是先用“笨办法”，遍历所有的情况来找出问题的解，在这个遍历过程当中，以深度优先的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索。</p>\n<p>回到这个问题，我们先通过图来遍历所有情况：</p>\n<p><img src=\"https://images.gitbook.cn/4a7e0ec0-db51-11e9-a268-91dece478f6a\" alt=\"5\" /></p>\n<p>对于这个题目，事实上我们思考，数组 [2, 2, 3] 和 [2, 3, 2] 实际是重复的，因此可以删除掉重复的项，优化递归树为：</p>\n<p><img src=\"https://images.gitbook.cn/63ca0a50-db51-11e9-9f9d-c526a5f387ab\" alt=\"6\" /></p>\n<p>我们该如何用代码描述上述过程呢？这时候需要一个临时数组 tmpArray，进入递归前 push 一个结果，</p>\n<p>最终答案：</p>\n<pre><code class=\"lang-\">const find = (array, target) =&gt; {\n\tlet result = []\n\n\tconst dfs = (index, sum, tmpArray)  =&gt; {\n        if (sum === target) {\n            result.push(tmpArray.slice())\n        }\n        \n        if (sum &gt; target) {\n    \t    return\n        }\n        \n        for (let i = index; i &lt; array.length; i++) {\n            tmpArray.push(array[i])\n            \n            dfs(i, sum + array[i], tmpArray)\n            \n            tmpArray.pop()\n        }\n    }\n\n    dfs(0, 0, [])\n    \n    return result\t\n}\n</code></pre>\n<p>如果读者存在理解问题，建议打断点调试一下。回溯是一个非常常见的思想，这也是一个典型的回溯常考题目。</p>\n<p>另外，该题有另一个变种：</p>\n<blockquote>\n<p>从一个数组中找出 N 个数，其和为 M 的所有可能。</p>\n</blockquote>\n<p>这里我们指定数组元素个数的和，需要这个和为指定值。</p>\n<p>举例：从数组 [1, 2, 3, 4] 中选取 2 个元素，求和为 5 的所有可能。答案是两组组合: [1, 4] 和 [2, 3]。</p>\n<p>这里我们介绍一种借助“二进制”实现的解法，可以用 0 和 1 来表示数组中相应的元素是否被选中。因此，对于一个长度为 4 的数组来说：</p>\n<ul>\n<li>0000 表示没有选择数组中的任何元素</li>\n<li>0100 表示选择了数组中第 1 位元素</li>\n</ul>\n<p>以此类推，数组长度为 4，那么上述情况一共有 16 种可能（Math.pow(length, 2)）。</p>\n<p>而这道题目中，只需要选择指定数组元素个数的和，还是对于数组长度为 4 的情况：只需要考虑 0011 等 1 的个数累加为 0 case，而不需要考虑类似 0111 这样的 case。</p>\n<p>针对符合个数的所有情况，我们进行数组项目的求和，判断是否等于指定值的情况即可：</p>\n<pre><code class=\"lang-\">const find = (array, target, sum) =&gt; {\n  const len = array.length\n  let result = []\n\n  for (let i = 0; i &lt; Math.pow(2, len); i++) {\n    if (getCount(i) == target) {\n      let s = 0 \n      let temp = []\n      for (let j = 0; j &lt; len; j++) {\n        if (i &amp; 1 &lt;&lt; (len - 1 -j)) {\n          s += array[j]\n          temp.push(array[j])\n        }\n      }\n      if (s == sum) {\n        result.push(temp)\n      }\n    }\n  }\n  return result\n}\n\nfunction getCount(i) {\n  let count = 0;\n  while (i) {\n   if (i &amp; 1){\n    ++count\n   }\n   i &gt;&gt;= 1\n  }\n  return count\n}\n</code></pre>\n<h3><a id=\"remove_duplicates_from_sorted_array_195\"></a>remove duplicates from sorted array</h3>\n<p>题目：对一个给定一个排序数组去重，同时返回去重后数组的新长度。</p>\n<p>难点：这道题并不困难，但是需要临时加一些条件，即需要原地操作，在使用 O(1) 额外空间的条件下完成。</p>\n<p>示例：</p>\n<p>输入：</p>\n<pre><code class=\"lang-\">let array = [0,0,1,1,1,2,2,3,3,4]\n</code></pre>\n<p>输出：</p>\n<pre><code class=\"lang-\">console.log(removeDuplicates(array))\n// 5\n\nconsole.log(array)\n// 0, 1, 2, 3, 4\n</code></pre>\n<p>这道题既然规定 in-place 的操作，那么可以考虑算法中的另一个重要思想：双指针。</p>\n<p><img src=\"https://images.gitbook.cn/33808a30-df3a-11e9-87f9-6dac5837a5da\" alt=\"7\" /></p>\n<p>使用快慢指针：</p>\n<ul>\n<li>开始时，快指针和慢指针都指向数组中的第一项</li>\n<li>如果快指针和慢指针指的数字相同，则快指针向前走一步</li>\n<li>如果快指针和慢指针指的数字不同，则两个指针都向前走一步，同时快指针指向的数字赋值给慢指针指向的数字</li>\n<li>当快指针走完整个数组后，慢指针当前的坐标加 1 就是数组中不同数字的个数</li>\n</ul>\n<p>代码很简单：</p>\n<pre><code class=\"lang-\">const removeDuplicates = array =&gt; {\n\tconst length = array.length\n\n\tlet slowPointer = 0\n\n\tfor (let fastPointer = 0; fastPointer &lt; length; fastPointer ++) {\n\t\tif (array[slowPointer] !== array[fastPointer]) {\n\t\t\tslowPointer++\n\t\t\tarray[slowPointer] = array[fastPointer]\n\t\t}\n\t}\n}\n</code></pre>\n<p>这道题目如果不要求 O(n) 的时间复杂度， O(1) 的空间复杂度，那么会非常简单。如果进行空间复杂度要求，尤其是 in-place 操作，开发者往往可以考虑双指针的思路。</p>\n<h3><a id=\"_249\"></a>求众数</h3>\n<p>这也是一道简单的题目，关键点在于如何优化。</p>\n<p>题目：给定一个大小为 N 的数组，找到其中的众数。众数是指在数组中出现次数大于 N/2 的元素。</p>\n<p>可能大家都会想到使用一个额外的空间，记录元素出现的次数，我们往往用一个 map 就可以轻易地实现。那优化点在哪里呢？答案就是投票算法。</p>\n<pre><code class=\"lang-\">const find = array =&gt; {\n\tlet count = 1\n\tlet result = array[0]\n\t\n\tfor (let i = 0; i &lt; array.lenght; i++) {\n\t\tif (count === 0) result = array[i]\n\t\t\n\t\tif (array[i] === result) {\n\t\t\tcount++\n\t\t}\n\t\telse {\n\t\t\tcount--\n\t\t}\n\t}\n\t\n\treturn result\n}\n</code></pre>\n<h3><a id=\"_278\"></a>有效括号</h3>\n<p>有效括号这个题目和前端息息相关，在之前课程模版解析时，其实都需要类似的算法进行模版的分析，进而实现数据的绑定。我们来看题目：</p>\n<p>举例：输入 “()”</p>\n<p>输出：true</p>\n<p>举例：输入 “()[]{}”</p>\n<p>输出：true</p>\n<p>举例：输入 “{[]}”</p>\n<p>输出：false</p>\n<p>举例：输入 “([)]”</p>\n<p>输出：false</p>\n<p>这道题目的解法非常典型，就是借助栈实现，将这些括号自右向左看做栈结构。我们把成对的括号分为左括号和右括号，需要左括号和右括号一一匹配，通过一个 Object 来维护关系：</p>\n<pre><code class=\"lang-\">let obj = {\n    &quot;]&quot;: &quot;[&quot;,\n    &quot;}&quot;: &quot;{&quot;,\n    &quot;)&quot;: &quot;(&quot;,\n}\n</code></pre>\n<p>如果编译器中在解析时，遇见左括号，我们就入栈；如果是右括号，就取出栈顶元素检查是否匹配。如果匹配，就出栈；否则，就返回 false。</p>\n<pre><code class=\"lang-\">const isValid = str =&gt; {\n    let stack = []\n    var obj = {\n        &quot;]&quot;: &quot;[&quot;,\n        &quot;}&quot;: &quot;{&quot;,\n        &quot;)&quot;: &quot;(&quot;,\n    }\n\n    for (let i = 0; i &lt; str.length; i++) {\n        if(str[i] === &quot;[&quot; || str[i] === &quot;{&quot; || str[i] === &quot;(&quot;) {\n            stack.push(str[i])\n        } \n        else {\n            let key = stack.pop()\n            if(obj[key] !== str[i]) {\n                return false\n            }\n        }\n    }\n\n    if (!stack.length) {\n        return true\n    }\n\n    return false\n};\n</code></pre>\n<h3><a id=\"LRU__339\"></a>LRU 缓存算法</h3>\n<p>看了这么多小算法题目，我们来换一个口味，现在看一个算法的实际应用。</p>\n<blockquote>\n<p>LRU（Least Recently Used）算法是缓存淘汰算法的一种。简单地说，由于内存空间有限，需要根据某种策略淘汰不那么重要的数据，用以释放内存。LRU 的策略是最早操作过的数据放最后，最晚操作过的放开始，按操作时间逆序，如果达到上限，则淘汰末尾的项。</p>\n</blockquote>\n<p>整个 LRU 算法有一定的复杂度，并且需要很多功能扩展。因此在生产环境中建议直接使用成熟的库，比如 npm 搜索 lru-cache。</p>\n<p>这里我们尝试实现一个微型体统级别的 LRU 算法：</p>\n<blockquote>\n<p>运用你所掌握的数据结构，设计和实现一个  LRU（最近最少使用）缓存机制。它应该支持以下操作：获取数据 get 和 写入数据 put 。</p>\n</blockquote>\n<p>获取数据 get(key) － 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 －1。</p>\n<p>写入数据 put(key, value) － 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p>\n<p>我们先来整体思考：尽量满足 O(1) 的时间复杂度中完成获取和写入的操作，那么可以使用一个 Object 来进行存储，如果 key 不是简单类型，可以使用 Map 实现：</p>\n<pre><code class=\"lang-\">const LRUCache = function(capacity) {\n  // ...\n  this.map = {};\n  // ...\n};\n</code></pre>\n<p>在这个算法中，最复杂的应该是淘汰策略，淘汰数据的时间复杂度必须是 O(1) 的话，我们一定需要额外的数据结构来完成 O(1) 的淘汰策略。那应该用什么样的数据结构呢？答案是双向链表。</p>\n<p>链表在插入与删除操作上，都是 O(1) 时间的复杂度，唯一有问题的查找元素过程比较麻烦，是 O(n)。但是这里我们不需要使用双向链表实现查找逻辑，因为 map 已经很好的弥补了缺陷。</p>\n<p>赘述一下：<strong>我们在写入值的时候，判断缓存容量是否已经达到上限，如果缓存容量达到上限时，应该删除最近最少使用的数据值，从而为以后的新的数据值留出空间。</strong></p>\n<p>结合链表的话，我们将刚刚写入的目标值设置为链表的首项，超过限制，就删除链表的尾项。</p>\n<p>最终实现：</p>\n<pre><code class=\"lang-\">const LRUCache = function(capacity) {\n  this.map = {}\n  this.size = 0\n  this.maxSize = capacity\n\n  // 链表初始化，初始化只有一个头和尾\n  this.head = {\n    prev: null,\n    next: null\n  }\n  this.tail = {\n    prev: this.head,\n    next: null\n  }\n\n  this.head.next = this.tail\n};\n\nLRUCache.prototype.get = function(key) {\n  if (this.map[key]) {\n    const node = this.extractNode(this.map[key])\n\n    // 最新访问，将该节点放到链表的头部\n    this.insertNodeToHead(node)\n\n    return this.map[key].val\n  } \n  else {\n    return -1\n  }\n}\n\nLRUCache.prototype.put = function(key, value) {\n  let node\n\n  if (this.map[key]) {\n    // 该项已经存在，更新值\n    node = this.extractNode(this.map[key])\n    node.val = value\n  } \n  else {\n    // 如该项不存在，新创造节点\n    node = {\n      prev: null,\n      next: null,\n      val: value,\n      key,\n    }\n\n    this.map[key] = node\n    this.size++\n  }\n\n  // 最新写入，将该节点放到链表的头部\n  this.insertNodeToHead(node)\n\n  // 判断长度是否已经到达上限\n  if (this.size &gt; this.maxSize) {\n    const nodeToDelete = this.tail.prev\n    const keyToDelete = nodeToDelete.key\n    this.extractNode(nodeToDelete)\n    this.size--\n    delete this.map[keyToDelete]\n  }\n};\n\n// 插入节点到链表首项\nLRUCache.prototype.insertNodeToHead = function(node) {\n  const head = this.head\n  const lastFirstNode = this.head.next\n\n  node.prev = head\n  head.next = node\n  node.next = lastFirstNode\n  lastFirstNode.prev = node\n\n  return node\n}\n\n// 从链表中抽取节点\nLRUCache.prototype.extractNode = function(node) {\n  const beforeNode = node.prev\n  const afterNode = node.next\n\n  beforeNode.next = afterNode\n  afterNode.prev = beforeNode\n\n  node.prev = null\n  node.next = null\n  \n  return node\n}\n</code></pre>\n<h3><a id=\"_470\"></a>链表相关题目</h3>\n<p>在之前的课程中，我们介绍了链表这种数据结构。链表应用非常广泛，这里来熟悉两个常见的对链表的操作算法。</p>\n<h4><a id=\"_474\"></a>反转链表</h4>\n<p>题目：对一个单链表进行反转</p>\n<p>输入：1→2→3→4→5→NULL</p>\n<p>输出：5→4→3→2→1→NULL</p>\n<p>最直观的解法是使用三个指针，把头节点变成尾节点点，进行遍历：下一个节点<br />\n拼接到当前节点的头部，以此类推。这种方法的实现我们不再手写，而是重点关注一下递归解法。</p>\n<p>递归解法就要先判断递归终止条件，当下一个节点为 null，找到尾节点时，将其返回。我们从后往前进行：</p>\n<pre><code class=\"lang-\">const reverseList = head =&gt; {\n   // 到了尾节点，则返回尾节点\n   if (head == null || head.next == null) {\n       return head\n   }\n   else {\n       let newhead = reverseList(head.next)\n       // 将当前节点的一下节点的 next 指向，指向为当前节点\n       head.next.next = head\n       // 暂时情况当前节点的 next 指向\n       head.next = null\n       \n       return newhead\n   }\n}\n</code></pre>\n<h4><a id=\"_N__505\"></a>删除链表的倒数第 N 个节点</h4>\n<p>题目：给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>\n<p>输入：1→2→3→4→5，和 n = 2</p>\n<p>输出：1→2→3→5</p>\n<p>这道题目的关键是如何优雅地找到倒数第 N 个节点。</p>\n<p>我们当然可以使用两次循环，第一次循环得到整个链表的长度 L，那么需要删除的节点就位于 L - N + 1 位置处，第二次遍历到相关位置进行操作即可。</p>\n<p>这道题其实是可以用一次遍历来解决的。我们需要使用双指针，快指针 fast 先前进 N，找到需要删除的节点；然后慢指针 slow 从 head 开始，和快指针 fast 一起前进，直到 fast 走到末尾。 此时 slow 的下一个节点就是要删除的节点，也就是倒数第 N 个节点。需要注意的是，如果快指针移动 N 步之后，已经到了尾部，那说明需要删除的就是头节点。</p>\n<pre><code class=\"lang-\">const removeNthFromEnd = (head, n) =&gt; {\n    if (head === null) {\n        return head\n    }\n    \n    if (n === 0) {\n        return head\n    }\n    \n    let fast = head\n    let slow = head\n    \n    // 快指针前进 N 步\n    while (n &gt; 0) {\n        fast = fast.next\n        n--\n    }\n    \n    // 快指针移动 N 步之后，已经到了尾部，那说明需要删除的就是头节点\n    if (fast === null) {\n        return head.next\n    }\n    \n    while (fast.next != null ){\n        fast = fast.next\n        slow = slow.next\n    }\n    \n    slow.next=slow.next.next\n    return head\n}\n</code></pre>\n<p>这两道关于链表的题目都重点考察了对你链表结构的理解，其中是用到了多个指针，这也是解决链表题目的关键。</p>\n<h3><a id=\"_555\"></a>算法学习</h3>\n<p>本节课内容到这里，我们只是列举了一些算法题目，也算不上“题海战术”，但问题都比较典型。可是面对这些相对零散的内容，我们应该如何入手学习呢？只是一味的刷题，似乎效率低下而无趣。</p>\n<p>我认为对于算法的学习，需要做到“分门别类”，按照不同类别的算法思想，遵循循序渐进的进步路线，才会“越来越有感觉”。我把算法的一些基础思想进行了归并：</p>\n<ul>\n<li>枚举</li>\n<li>模拟</li>\n<li>递归/分治</li>\n<li>贪心</li>\n<li>排序</li>\n<li>二分</li>\n<li>倍增</li>\n<li>构造</li>\n<li>前缀和/差分</li>\n</ul>\n<p>我们来简单总结一下这些算法基础思想。</p>\n<h4><a id=\"_573\"></a>枚举</h4>\n<p>枚举是基于已有知识来猜测，印证答案的一种问题求解策略。当拿到一道题目时，枚举这种“暴力解法”最容易想到。这其中重点是：</p>\n<ul>\n<li>建立简洁的数学模型</li>\n<li>想清楚枚举哪些要素</li>\n<li>尝试减少枚举空间</li>\n</ul>\n<p>举个例子：</p>\n<blockquote>\n<p>一个数组中的数互不相同，求其中和为 0 的数对的个数</p>\n</blockquote>\n<p>最笨的方法：</p>\n<pre><code class=\"lang-\">\nfor (int i = 0; i &lt; n; ++i)\n  for (int j = 0; j &lt; n; ++j)\n    if (a[i] + a[j] == 0) ++ans;\n</code></pre>\n<p>我们来看看如何操作进行优化。如果 (a, b) 是答案，那么 (b, a) 也是答案，因此对于这种情况只需统计一种顺序之后的答案，最后再乘 2 就好了。</p>\n<pre><code class=\"lang-\">\nfor (int i = 0; i &lt; n; ++i)\n  for (int j = 0; j &lt; i; ++j)\n    if (a[i] + a[j] == 0) ++ans;\n</code></pre>\n<p>如此一来，就减少了 j 的枚举范围，减少了这段代码的时间开销。然而这还不是最优解。</p>\n<p>我们思考：两个数是否都一定要枚举出来呢？其实枚举第一个数之后，题目的条件已经帮我们确定了其他的要素（另一个数），如果能找到一种方法直接判断题目要求的那个数是否存在，就可以省掉枚举后一个数的时间了。代码实现很简单，我们就不动手实现了。</p>\n<h4><a id=\"_607\"></a>模拟</h4>\n<p>模拟。顾名思义，就是用计算机来模拟题目中要求的操作，我们只需要按照题面的意思来写就可以了。模拟题目通常具有码量大、操作多、思路繁复的特点。</p>\n<p>这种题目往往考察开发者的“逻辑转化为代码”的能力。一道典型题目是：<a href=\"http://bailian.openjudge.cn/practice/3750/\" target=\"_blank\">魔兽世界</a>。</p>\n<h4><a id=\"___613\"></a>递归 &amp; 分治</h4>\n<p>递归的基本思想是某个函数直接或者间接地调用自身，这样就把原问题的求解转换为许多性质相同但是规模更小的子问题。</p>\n<p>递归和枚举的区别在于：枚举是横向地把问题划分，然后依次求解子问题，而递归是把问题逐级分解，是纵向的拆分。比如请尝试回答这几个问题：</p>\n<blockquote>\n<p>孙悟空身上有多少根毛？答：一根毛加剩下的毛。<br />\n你今年几岁？答：去年的岁数加一岁，1999 年我出生。</p>\n</blockquote>\n<p>递归代码最重要的两个特征：结束条件和自我调用。</p>\n<pre><code class=\"lang-\">int func(传入数值) {\n  if (终止条件) return 最小子问题解;\n  return func(缩小规模);\n}\n</code></pre>\n<p>写递归的技巧，“明白一个函数的作用并相信它能完成这个任务，千万不要试图跳进细节”。 千万不要跳进这个函数里面企图探究更多细节，否则就会陷入无穷的细节无法自拔，人脑能压几个栈啊。</p>\n<p>先举个最简单的例子：遍历二叉树。</p>\n<pre><code class=\"lang-\">void traverse(TreeNode* root) {\n  if (root == nullptr) return;\n  traverse(root-&gt;left);\n  traverse(root-&gt;right);\n}\n</code></pre>\n<p>这几行代码就足以遍历任何一棵二叉树了。对于递归函数 traverse(root) ，我们只要相信：给它一个根节点 root，它就能遍历这棵树，因为写这个函数不就是为了这个目的吗？</p>\n<p>那么遍历一棵 N 叉数呢？</p>\n<pre><code class=\"lang-\">void traverse(TreeNode* root) {\n  if (root == nullptr) return;\n  for (child : root-&gt;children) traverse(child);\n}\n</code></pre>\n<p>总之，还是那句话：给它一个根节点 root，它就能遍历这棵树，不管你是几个叉。</p>\n<p>典型题目：</p>\n<blockquote>\n<p>给一棵二叉树，和一个目标值，节点上的值有正有负，返回树中和等于目标值的路径条数</p>\n</blockquote>\n<p>这道题目解法很多，也比较典型。这里我们只谈思想，具体实现就不展开。</p>\n<p>分治算法可以分三步走：分解 -&gt; 解决 -&gt; 合并。</p>\n<ul>\n<li>分解原问题为结构相同的子问题</li>\n<li>分解到某个容易求解的边界之后，进行递归求解</li>\n<li>将子问题的解合并成原问题的解</li>\n</ul>\n<p>归并排序是最典型的分治算法。</p>\n<pre><code class=\"lang-\">void mergeSort(一个数组) {\n  if (可以很容易处理) return\n  mergeSort(左半个数组)\n  mergeSort(右半个数组)\n  merge(左半个数组, 右半个数组)\n}\n</code></pre>\n<p>分治算法的套路就是前面说的三步走：分解 -&gt; 解决 -&gt; 合并：先左右分解，再处理合并，回溯就是在退栈，就相当于后序遍历了。至于 merge 函数，相当于两个有序链表的合并。</p>\n<p>LeetCode 有<a href=\"https://leetcode.com/explore/learn/card/recursion-i/\" target=\"_blank\">递归专题练习</a><br />\nLeetCode 上有<a href=\"https://leetcode-cn.com/tag/divide-and-conquer/?utm_source=LCUS&amp;utm_medium=ip_redirect_o_uns&amp;utm_campaign=transfer2china\" target=\"_blank\">分治算法的专项练习</a></p>\n<h4><a id=\"_684\"></a>贪心</h4>\n<p>贪心算法顾名思义就是只看眼前，并不考虑以后可能造成的影响。可想而知，并不是所有的时候贪心法都能获得最优解。</p>\n<p>最常见的贪心有两种。一种是：「将 XXX 按照某某顺序排序，然后按某种顺序（例如从小到大）处理」。另一种是：「我们每次都取 XXX 中最大/小的东西，并更新 XXX」，有时「XXX 中最大/小的东西」可以优化，比如用优先队列维护。这两种方式分别对应了离线的情况以及在线的情况。</p>\n<p>相关题目：</p>\n<ul>\n<li><a href=\"https://www.luogu.org/problem/P2949\" target=\"_blank\">工作调度Work Scheduling</a></li>\n<li><a href=\"https://www.luogu.org/problem/P1209\" target=\"_blank\">修理牛棚 Barn Repair</a></li>\n<li><a href=\"https://www.luogu.org/problem/P2123\" target=\"_blank\">皇后游戏</a></li>\n</ul>\n<h4><a id=\"_696\"></a>二分</h4>\n<p>以二分搜索为例，它是用来在一个有序数组中查找某一元素的算法。它每次考察数组当前部分的中间元素，如果中间元素刚好是要找的，就结束搜索过程；如果中间元素小于所查找的值，那么左侧的只会更小，不会有所查找的元素，只需要到右侧去找就好了；如果中间元素大于所查找的值，同理，右侧的只会更大而不会有所查找的元素，所以只需要到左侧去找。</p>\n<p>在二分搜索过程中，每次都把查询的区间减半，因此对于一个长度为 n 的数组，至多会进行 log(n) 次查找。</p>\n<p>一定需要注意的是，这里的有序是广义的有序，如果一个数组中的左侧或者右侧都满足某一种条件，而另一侧都不满足这种条件，也可以看作是一种有序。</p>\n<p>二分法把一个寻找极值的问题转化成一个判定的问题（用二分搜索来找这个极值）。类比枚举法，我们当时是枚举答案的可能情况，现在由于单调性，我们不再需要一个个枚举，利用二分的思路，就可以用更优的方法解决「最大值最小」、「最小值最大」。这种解法也成为是「二分答案」，常见于解题报告中。</p>\n<p>比如：<a href=\"https://www.luogu.org/problem/P1873\" target=\"_blank\">砍树问题</a>，我们可以在 1 到 1000000000（10 亿）中枚举答案，但是这种朴素写法肯定拿不到满分，因为从 1 跑到 10 亿太耗时间。我们可以对答案进行 1 到 10 亿的二分，其中，每次都对其进行检查可行性（一般都是使用贪心法）。</p>\n<p>依照此思想，我们还有三分法等展开算法。</p>\n<h4><a id=\"_711\"></a>倍增</h4>\n<p>倍增法，通过字面意思来看就是翻倍。这个方法在很多算法中均有应用，其中最常用的就是 RMQ 问题和求 LCA。</p>\n<p>RMQ 是英文 Range Maximum/Minimum Query 的缩写，表示区间最大（最小）值。解决 RMQ 问题的主要方法有两种，分别是 ST 表和线段树，具体请参见 ST 表和 线段树内容。</p>\n<h4><a id=\"_717\"></a>构造</h4>\n<p>构造针对的问题的答案往往具有某种规律性，使得在问题规模迅速增大的时候，仍然有机会比较容易地得到答案。</p>\n<p>这种思想我们接触的比较少，主要体现了数学解题方法啊。比较典型的有：</p>\n<ul>\n<li><a href=\"https://www.luogu.org/problemnew/show/P3599\" target=\"_blank\">Luogu P3599 Koishi Loves Construction</a></li>\n<li><a href=\"http://codeforces.com/problemset/problem/743/C\" target=\"_blank\">Vladik and fractions</a></li>\n<li><a href=\"https://atcoder.jp/contests/agc032/tasks/agc032_b\" target=\"_blank\">AtCoder Grand Contest 032 B</a></li>\n</ul>\n<p>这里我们不再介绍，感兴趣的同学可以进行研究。</p>\n<h4><a id=\"___729\"></a>前缀和 &amp; 差分</h4>\n<p>前缀和是一种重要的预处理，能大大降低查询的时间复杂度。我们可以简单理解为“数列的前 n 项的和”。其实前缀和几乎都是基于容斥原理。</p>\n<p>比如这道题目：</p>\n<blockquote>\n<p>有 N 个的正整数放到数组 A 里，现在要求一个新的数组 B，新数组的第 i 个数 B[i]是原数组 A 第 0 到第 i 个数的和。</p>\n</blockquote>\n<p>对于这道题，我们有两种做法：</p>\n<ul>\n<li>把对数组 A 的累加依次放入数组 B 中。</li>\n<li>递推： B[i] = B[i-1] + A[i]</li>\n</ul>\n<p>我们看第二种方法采用前缀和的思想，无疑更加优秀。</p>\n<p>其他相关题目：</p>\n<ul>\n<li><a href=\"https://www.luogu.org/problem/U53525\" target=\"_blank\">前缀和</a></li>\n<li><a href=\"https://www.luogu.org/problem/U69096\" target=\"_blank\">前缀和的逆</a></li>\n<li><a href=\"https://www.luogu.org/problem/AT2412\" target=\"_blank\">最大の和</a></li>\n<li><a href=\"https://www.luogu.org/problem/P3131\" target=\"_blank\">Subsequences Summing to Sevens</a></li>\n</ul>\n<p>更复杂些，可以延伸出：基于 DP 计算高维前缀和，树上前缀和。</p>\n<p>最后，差分是一种和前缀和相对的策略。这种策略是求相邻两数的差。相关题目：</p>\n<ul>\n<li><a href=\"https://loj.ac/problem/132\" target=\"_blank\">树状数组 3 ：区间修改，区间查询</a></li>\n<li><a href=\"https://www.luogu.org/problem/P3397\" target=\"_blank\">地毯</a></li>\n<li><a href=\"https://www.luogu.org/problem/P3128\" target=\"_blank\">最大流</a></li>\n</ul>\n<h4><a id=\"_759\"></a>思想归并</h4>\n<p>我列举了 9 中算法基本思想，并配上多到典型题目。实际上，读者可以根据自身情况酌情进行了解，在解题外更重要的是体会这些算法思想。比如我留一个小作业：在这三节课中所有讲到的算法中，你能按照这 9 种思想进行归类么？</p>\n<p>请动手尝试，我认为我们可以有解不出来的题目，但是对于算法思想的理解至关重要。</p>\n<h3><a id=\"_765\"></a>总结</h3>\n<p>到此我们关于算法的三节课就结束了。整体来说，算法需要应试。算法就像弹簧一样，只要你有信心，态度正确，不畏难，一定就可以攻克它。</p>\n<p>从今天起，下一个决心，制定一个计划，通过不断练习，提升自己解算法题的能力。当然学习数据结构和算法不仅仅对面试有帮助，对于程序的强健性、稳定性、性能来说，算法虽然只是细节，但却是最重要的一部分之一。比如 AVL 或者 B+ 树，可能除了在学校的大作业，一辈子也不会有机会实现一个出来，但你学会了分析和比较类似算法的能力, 有了搜索树的知识，你才能真正理解为什么 InnoDB 索引要用 B+ 树，你才能明白 like “abc%” 会不会使用索引，而不是人云亦云、知其然不知其所以然。</p>\n<p>这一节课我挑选的典型算法都不算困难，但都能体现算法的思想闪光点，适合类推。但实话说，这节课的内容相对零散，算法的思想却是可以归类的，也留给大家一个作业，将上述算法进行思想归类，并在每个归类下再找一道题目进行扩充。这样的学习方法一定会让你有所收获，在全部课程结束后，我也会和大家针对这个“作业”，进行交流，也分享出我的更多算法心得。</p>\n","createdAt":"2019-04-21T04:48:53.926Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":43,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FoThASW9dVEPMEo9nP-zaOfbKyLZ"},{"_id":"5cbbf65dbbbba80861a35c7f","communication_start_time":null,"type":1,"audioPath":"","abstract":"","content":"前一段时间，一道疑似“微信”招聘的面试题出现，可能有不少读者已经了解过了。这道题乍一看挺难，但是细细分析却还算简单，我们甚至可以用多种手段解题，用不同思想来给出答案。\n\n网上零零碎碎的有一些解答，但是缺乏全面梳理。我认为通过这道题，有必要将前端多重知识点“融会贯通”，在这里和大家分享。\n\n本讲知识点如下：\n\n![enter image description here](https://images.gitbook.cn/bfedc2e0-de9e-11e9-9f8b-d5f483bb0ebd)\n\n### 题意分析\n\n我们来先看看题目：\n\n> 实现一个 LazyMan，按照以下方式调用时，得到相关输出：\n\n```\nLazyMan(\"Hank\")\n// Hi! This is Hank!\n \nLazyMan(\"Hank\").sleep(10).eat(\"dinner\")\n// Hi! This is Hank!\n// 等待10 秒..\n// Wake up after 10\n// Eat dinner~\n \nLazyMan(\"Hank\").eat(\"dinner\").eat(\"supper\")\n// Hi This is Hank!\n// Eat dinner~\n// Eat supper~\n \nLazyMan(\"Hank\").sleepFirst(5).eat(\"supper\")\n// 等待 5 秒\n// Wake up after 5\n// Hi This is Hank!\n// Eat supper\n```\n \n当面试者拿到这道题目的时候，乍看题干可能会有点慌张。其实很多面试失败是“自己吓唬自己”，在平时放松状态下写代码，也许解题不在话下。\n\n下面我们就从接到题目开始，剖析应该如何进行分析：\n\n- 可以把 LazyMan 理解为一个构造函数，在调用时输出参数内容\n- LazyMan 支持链式调用\n- 链式调用过程提供了以下几个方法：sleepFirst、eat、sleep\n- 其中 eat 方法输出参数相关内容：Eat + 参数\n- sleep 方法比较特殊，链式调用将暂停一定时间后继续执行，看到这里也许应该想到 setTimeout\n- sleepFirst 最为特殊，这个任务或者这个方法的 **优先级最高**；调用 sleepFirst 之后，链式调用将暂停一定时间后继续执行。请再次观察题干，尤其是最后一个 demo，sleepFirst 的输出优先级最高，调用后先等待 5 秒输出 Wake up after 5，再输出 Hi This is Hank!\n\n我们应该如何解这个题目呢，从拿到需求开始进行分析：\n\n- 先从最简单的，我们可以封装一些基础方法，比如 log 输出、封装 setTimeout 等\n- 因为 LazyMan 要实现一系列调用，**且调用并不是顺序执行的，比如如果 sleepFirst 出现在调用链时，优先执行；同时任务并不是全部都同步执行的**，因此**我们应该实现一个任务队列**，这个队列将调度执行各个任务\n- 因此每次调用 LazyMan 或链式执行时，我们应该将相关调用方法加入到（push）任务队列中，储存起来，后续统一被调度\n- 在写入任务队列时，如果当前的方法为 sleepFirst，那么需要将该方法放到队列的最头处，这应该是一个 unshift 方法\n\n这么一分析，这道题就“非常简单”了。\n\n我们来试图解剖一下这道题目的考察点：\n\n- 面向对象思想与设计，包括类的使用等\n- 对象方法链式调用的理解和设计\n- 小部分设计模式的设计\n- 因为存在“重复逻辑”，考察代码的解耦和抽象能力\n- 逻辑的清晰程度以及其他编程思维\n\n### 常规思路解答\n\n基于以上思路，我们给出较为常规的答案，其中代码已经加上了必要的注释：\n\n```\nclass LazyManGenerator {\n  constructor(name) {\n    this.taskArray = []\n\n\t// 初始化时任务\n    const task = () => {\n      console.log(`Hi! This is ${name}`)\n      // 执行完初始化时任务后，继续执行下一个任务\n      this.next()\n    }\n\n\t// 将初始化任务放入任务队列中\n    this.taskArray.push(task)\n\n    setTimeout(() => {\n      this.next()\n    }, 0)\n  }\n\n  next() {\n  \t// 取出下一个任务并执行\n    const task = this.taskArray.shift()\n    task && task()\n  }\n\n  sleep(time) {\n    this.sleepTask(time, false)\n    // return this 保持链式调用\n    return this\n  }\n\n  sleepFirst(time) {\n    this.sleepTask(time, true)\n    return this\n  }\n\n  sleepTask(time, prior) {\n    const task = () => {\n      setTimeout(() => {\n        console.log(`Wake up after ${time}`)\n        this.next()\n      }, time * 1000)\n    }\n\n    if (prior) {\n      this.taskArray.unshift(task)\n    } else {\n      this.taskArray.push(task)\n    }\n  }\n\n  eat(name) {\n    const task = () => {\n      console.log(`Eat ${name}`)\n      this.next()\n    }\n\n    this.taskArray.push(task)\n    return this\n  }\n}\n\nfunction LazyMan(name) {\n  return new LazyManGenerator(name)\n}\n```\n\n简单分析一下：\n\n- LazyMan 方法返回一个 LazyManGenerator 构造函数的实例\n- 在 LazyManGenerator constructor 当中，我们维护了 taskArray 用来存储任务，同时将初始化任务放到 taskArray 当中\n- 还是在 LazyManGenerator constructor 中，将任务的逐个执行即 next 调用放在 setTimeout 中，这样就能够保证在开始执行任务时，taskArray 数组已经填满了任务\n- 我们来看看 next 方法，取出 taskArray 数组中的首项，进行执行\n- eat 方法将 eat task 放到 taskArray 数组中，注意 eat task 方法需要调用 this.next() 显式调用“下一个任务”；同时返回 this，完成链式调用\n- sleep 和 sleepFirst 都调用了 sleepTask，不同在于第二个参数：sleepTask 第二个参数表示是否优先执行，如果 prior 为 true，则使用 unshift 将任务插到 taskArray 开头\n\n这个解法最容易想到，也相对来说容易，主要是面向过程。关键点在于对于 setTimeout 任务队列的准确理解以及 return this 实现链式调用的方式。\n\n事实上，sleepTask 应该作为 LazyManGenerator 类的私有属性出现，因为 ES class 暂时 private 属性没有被广泛实现，这里不再追求实现。\n\n### 设计模式解答\n\n关于这道题目的解答，网上最流行的是一种发布订阅模式的方案。相关代码出处：[lazyMan](https://github.com/wall-wxk/blogDemo/blob/master/2017/01/22/lazyMan.html)。\n\n但是其实仔细看其实现，也是上一环节中常规解法的变种。虽然说是发布订阅模式，但是其实仍然是 next 思想执行下一个任务的思路，该实现 publish 和 subscribe 方法分别是完成执行任务和注册任务逻辑。我认为这样的代码实现有一点“过度设计”之嫌，更像是往发布订阅模式上去靠，整体流程不够自然。\n\n当然读者仍可参考，并有自己的思考，这里我不再更多分析。\n\n### 再谈流程控制和队列、中间件启发\n\n这道题目我们给出解法并不算完，更重要也更有价值的是思考、延伸。微信题目较好地考察了候选者的流程控制能力，而流程控制在前端开发者面前也非常重要。\n\n我们看上述代码中的 next 函数，它负责找出 stack 中的下一个函数并执行：\n\n```\nnext() {\n\t// 取出下一个任务并执行\n\tconst task = this.taskArray.shift()\n\ttask && task()\n}\n```\n\nNodeJS 中 connect 类库，以及其他框架的中间件设计也都离不开类似思想的 next。比如生成器自动执行函数 co、redux、koa 也通过不同的实现，可以让 next 在多个函数之间执行完后面的函数再折回来执行 next，较为巧妙。我们具体来看一下。\n\n#### senchalabs connect 和 express\n\n具体场景：在 Node 环境中，有 parseBody、checkIdInDatabase 等相关中间件，他们组成了 middlewares 数组：\n\n```\nconst middlewares = [\n  function middleware1(req, res, next) {\n    parseBody(req, function(err, body) {\n      if (err) return next(err);\n      req.body = body;\n      next();\n    });\n  },\n  function middleware2(req, res, next) {\n    checkIdInDatabase(req.body.id, function(err, rows) {\n      if (err) return next(err);\n      res.dbResult = rows;\n      next();\n    });\n  },\n  function middleware3(req, res, next) {\n    if (res.dbResult && res.dbResult.length > 0) {\n      res.end(&apos;true&apos;);\n    }\n    else {\n      res.end(&apos;false&apos;);\n    }\n    next();\n  }\n]\n```\n\n当一个请求打开时，我们需要链式调用各个中间件：\n\n```\nconst requestHandler = (req, res) => {\n  let i = 0\n  \n  function next(err) {\n    if (err) {\n      return res.end(&apos;error:&apos;, err.toString())\n    }\n\n    if (i < middlewares.length) {\n      middlewares[i++](req, res, next)\n    } else {\n      return\n    }\n  }\n\n  // 初始执行第一个中间件\n  next()\n}\n```\n\n基本思路和面试题解法一致：\n\n- 将所有中间件（任务处理函数）储存在一个 list 中\n- 循环依次调用中间件（任务处理函数）\n\nsenchalabs/connect 这个库做了很好的封装，是 express 等框架设计实现的原始模型。这里我们简单分析一下 senchalabs/connect 这个库的实现。\n\n用法：\n\n首先使用 createServer 方法创建 app 实例，\n\n```\nconst app = createServer()\n```\n\n对应源码：\n\n```\nfunction createServer() {\n  function app(req, res, next){ app.handle(req, res, next); }\n  merge(app, proto);\n  merge(app, EventEmitter.prototype);\n  app.route = &apos;/&apos;;\n  app.stack = [];\n  return app;\n}\n```\n\n我们看 app 实例“继承”了 EventEmitter 类，实现事件发布订阅，同时 stack 数组来维护各个中间件任务。\n\n接着使用 app.use 来添加中间件：\n\n```\napp.use(&apos;/api&apos;, function(req, res, next) {//...})\n```\n\n源码实现：\n\n```\nproto.use = function use(route, fn) {\n  var handle = fn;\n  var path = route;\n\n  // default route to &apos;/&apos;\n  if (typeof route !== &apos;string&apos;) {\n    handle = route;\n    path = &apos;/&apos;;\n  }\n\n  // wrap sub-apps\n  if (typeof handle.handle === &apos;function&apos;) {\n    var server = handle;\n    server.route = path;\n    handle = function (req, res, next) {\n      server.handle(req, res, next);\n    };\n  }\n\n  // wrap vanilla http.Servers\n  if (handle instanceof http.Server) {\n    handle = handle.listeners(&apos;request&apos;)[0];\n  }\n\n  // strip trailing slash\n  if (path[path.length - 1] === &apos;/&apos;) {\n    path = path.slice(0, -1);\n  }\n\n  // add the middleware\n  debug(&apos;use %s %s&apos;, path || &apos;/&apos;, handle.name || &apos;anonymous&apos;);\n  this.stack.push({ route: path, handle: handle });\n\n  return this;\n};\n```\n\n通过 if...else 逻辑区分出三种不同的 fn 类型：\n\n- fn 是一个普通的 function(req,res[,next]){} 函数\n- fn 是一个普通的 httpServer\n- fn 是一个普通的是另一个 connect 的 app 对象（sub app 特性）\n\n对于这三种类型，分别转换为 function(req, res, next) {} 的形式，具体我们不再分析。最重要的执行过程是：\n\n```\nthis.stack.push({ route: path, handle: handle })\n```\n\n以及返回：\n\n```\nreturn this\n```\n\n以上就完成了中间件即任务的注册，我们有：\n\n```\napp.stack = [function1, function2, function3, ...];\n```\n\n接下来看看任务的调度和执行。使用方法：\n\n```\napp.handle(req, res, out)\n```\n\nhandle 源码实现：\n\n```\nproto.handle = function handle(req, res, out) {\n  var index = 0;\n  var protohost = getProtohost(req.url) || &apos;&apos;;\n  var removed = &apos;&apos;;\n  var slashAdded = false;\n  var stack = this.stack;\n\n  // final function handler\n  var done = out || finalhandler(req, res, {\n    env: env,\n    onerror: logerror\n  });\n\n  // store the original URL\n  req.originalUrl = req.originalUrl || req.url;\n\n  function next(err) {\n    // ...\n  }\n\n  next();\n};\n```\n\n源码导读：out 参数是关于 sub app 的特性，这个特性可以暂时忽略，我们暂时不关心。handle 实现我们并不陌生，它构建 next 函数，并触发第一个 next 执行。\n\nnext 实现：\n\n```\nfunction next(err) {\n\tif (slashAdded) {\n\t  req.url = req.url.substr(1);\n\t  slashAdded = false;\n\t}\n\t\n\tif (removed.length !== 0) {\n\t  req.url = protohost + removed + req.url.substr(protohost.length);\n\t  removed = &apos;&apos;;\n\t}\n\t\n\t// next callback\n\tvar layer = stack[index++];\n\t\n\t// all done\n\tif (!layer) {\n\t  defer(done, err);\n\t  return;\n\t}\n\t\n\t// route data\n\tvar path = parseUrl(req).pathname || &apos;/&apos;;\n\tvar route = layer.route;\n\t\n\t// skip this layer if the route doesn&apos;t match\n\tif (path.toLowerCase().substr(0, route.length) !== route.toLowerCase()) {\n\t  return next(err);\n\t}\n\t\n\t// skip if route match does not border \"/\", \".\", or end\n\tvar c = path.length > route.length && path[route.length];\n\tif (c && c !== &apos;/&apos; && c !== &apos;.&apos;) {\n\t  return next(err);\n\t}\n\t\n\t// trim off the part of the url that matches the route\n\tif (route.length !== 0 && route !== &apos;/&apos;) {\n\t  removed = route;\n\t  req.url = protohost + req.url.substr(protohost.length + removed.length);\n\t\n\t  // ensure leading slash\n\t  if (!protohost && req.url[0] !== &apos;/&apos;) {\n\t    req.url = &apos;/&apos; + req.url;\n\t    slashAdded = true;\n\t  }\n\t}\n\t\n\t// call the layer handle\n\tcall(layer.handle, route, err, req, res, next);\n}\n```\n\n源码导读：\n\n- 取出下一个中间件\n\n```\nvar layer = stack[index++]\n```\n\n- 如果当前请求路由和 handler 不匹配，则跳过：\n\n```\nif (path.toLowerCase().substr(0, route.length) !== route.toLowerCase()) {\n  return next(err);\n}\n```\n\n- 若匹配，则执行 call 函数，call 函数实现：\n\n```\nfunction call(handle, route, err, req, res, next) {\n  var arity = handle.length;\n  var error = err;\n  var hasError = Boolean(err);\n\n  debug(&apos;%s %s : %s&apos;, handle.name || &apos;<anonymous>&apos;, route, req.originalUrl);\n\n  try {\n    if (hasError && arity === 4) {\n      // error-handling middleware\n      handle(err, req, res, next);\n      return;\n    } else if (!hasError && arity < 4) {\n      // request-handling middleware\n      handle(req, res, next);\n      return;\n    }\n  } catch (e) {\n    // replace the error\n    error = e;\n  }\n\n  // continue\n  next(error);\n}\n```\n\n注意：我们使用了 try...catch 包裹逻辑，这是很必要的容错思维，这样第三方中间件的执行如果出错，不至于打挂我们的应用。\n\n较为巧妙的一点是：function(err, req, res, next){} 形式为错误处理函数，function(req, res, next){} 为正常的业务逻辑处理函数。因此通过 Function.length 来判断当前 handler 是否为容错函数，来做到参数的传入。\n\ncall 函数是 next 函数的核心，它是一个执行者，并在最后的逻辑中继续执行 next 函数，完成中间件的顺序调用。\n\nNodeJS 的框架 express，实际就是 senchalabs connect 的升级版，通过对 connect 源码的学习，我们应该更加清楚流程的调度和控制，再去看 express 就轻而易举了。\n\nSenchalabs connect 用流程控制库的回调函数及中间件的思想来解耦回调逻辑；Koa 则是用generator 方法解决回调问题（最新版使用 async/await）。事实上，也可以用事件、Promise 的方式实现，下一环节，我们就分析 Koa 的洋葱模型。\n\n#### Koa 的洋葱模型\n\n对 Koa 中间的洋葱模型的分析文章上不少，著名的洋葱圈图示我也不在自己画了，具体使用不再介绍，不了解的读者请先自行学习。\n\n我想先谈一下面向切面编程（AOP），在 JavaScript 语言为例，一个简单的示例：\n\n```\nFunction.prorotype.before = function (fn) {\n  const self = this\n  return function (...args) {\n    console.log(&apos;&apos;)\n    let res = fn.call(this)\n    if (res) {\n      self.apply(this, args)\n    }\n  }\n}\n\nFunction.prototype.after = function (fn) {\n  const self = this\n  return function (...args) {\n    let res = self.apply(this, args)\n    if (res) {\n      fn.call(this)\n    }\n  }\n}\n```\n\n这样的代码实现，是我们能够在执行某个函数 fn 之前，先执行某段逻辑；在某个函数 fn 之后，再去执行另一段逻辑。其实是一种简单中间件流程控制的体现。不过这样的 AOP 有一个问题：无法实现异步模式。\n\n那么如何实现 Koa 的异步中间件模式呢？即某个中间件执行到一半，交出执行权，之后再回来继续执行。我们直接看源码分析，这段源码实现了 Koa 洋葱模型中间件：\n\n```\nfunction compose(middleware) {\n  return function *(next) {(\n    if (!next) next = noop();\n\n    var i = middleware.length;\n\n    while (i--) {\n      next = middleware[i].call(this, next);\n      console.log(&apos;isGenerator:&apos;, (typeof next.next === &apos;function&apos; && typeof next.throw === &apos;function&apos;)); // true\n    }\n\n    return yield *next;\n  }\n}\n\nfunction *noop(){}\n```\n\n其中，一个中间件的写法类似：\n\n```\napp.use(function *(next){\n  var start = new Date;\n  yield next;\n  var ms = new Date - start;\n  this.set(&apos;X-Response-Time&apos;, ms + &apos;ms&apos;);\n});\n```\n\n这是一个很简单的记录 response time 的中间件，中间件跳转的信号是 yield next。\n\n较新版本的 Koa 已经改用 async/await 实现，思路也是完全一样的，当然看上去更加优雅：\n\n```\nfunction compose (middleware) {\n  if (!Array.isArray(middleware)) throw new TypeError(&apos;Middleware stack must be an array!&apos;)\n  for (const fn of middleware) {\n    if (typeof fn !== &apos;function&apos;) throw new TypeError(&apos;Middleware must be composed of functions!&apos;)\n  }\n\n  return function (context, next) {\n    let index = -1\n    return dispatch(0)\n\n    function dispatch (i) {\n      if (i <= index) return Promise.reject(new Error(&apos;next() called multiple times&apos;))\n      index = i\n      let fn = middleware[i]\n      if (i === middleware.length) {\n        fn = next\n      }\n      if (!fn) return Promise.resolve()\n      try {\n        return Promise.resolve(fn(context, function next () {\n          return dispatch(i + 1)\n        }))\n      } catch (err) {\n        return Promise.reject(err)\n      }\n    }\n  }\n}\n```\n\n我们来重点解读一下这个版本的实现：\n\n- compose 传入的 middleware 参数必须是数组，否则抛出错误\n- middleware 数组的每一个元素必须是函数，否则抛出错误\n- compose 返回一个函数，保存对 middleware 的引用\n- compose 返回函数的第一个参数是 context，所有中间件的第一个参数就是传入的 context\n- compose 返回函数的第二个参数是 next 函数，next 是实现洋葱模型的关键\n- index 记录当前运行到第几个中间件\n- 执行第一个中间件函数：return dispatch(0)\n- dispatch 函数中，参数 i 如果小于等于 index，说明一个中间件中执行了多次 next，我们进行报错，由此可见一个中间件函数内部不允许多次调用 next 函数\n- 取出中间件函数 fn = middleware[i]\n- 如果 i === middleware.length，说明执行到了圆心，将 next 赋值给 fn\n- 因为 async 需要后面是 Promise，我们包一层 Promise\n- next 函数是固定的，它可以执行下一个中间件函数\n\n```\nfunction next () {\n  return dispatch(i + 1)\n}\n```\n\n如果读者不好理解，可以参考应用示例：\n\n```\nasync function middleware1(ctx, next) {\n  console.log(&apos;1&apos;)\n  await next()\n  console.log(&apos;2&apos;)\n};\n\nasync function middleware2(ctx, next) {\n  console.log(&apos;3&apos;)\n  await next()\n  console.log(&apos;4&apos;)\n};\n```\n\n如果读者还是难以理解，我给出一个简版逻辑：\n\n```\nfunction compose (middleware) {\n  return dispatch(0) \n  function dispatch(i) {\n    fn = middleware[i]\n    if(!fn) return\n    return fn(() => dispatch(i + 1))\n  }\n}\n```\n\n#### co 库不再神秘\n\n说到流程控制，也少不了大名鼎鼎的 co 库。co 函数库是 TJ 大神基于 ES6 generator 的异步解决方案，因此这里需要读者熟练掌握 ES6 generator。目前虽然 co 库可能不再“流行”，但是了解其实现，模拟类似场景也是非常有必要的。\n\n我们这里不解读其源码，而是实现一个类似的自动执行 generator 的方案：\n\n```\nconst runGenerator = generatorFunc => {\n  const it = generatorFunc()\n  iterate(it)\n\n  function iterate (it) {\n    step()\n\n    function step(arg, isError) {\n      const {value, done} = isError ? it.throw(arg) : it.next(arg)\n\n      let response\n\n      if (!done) {\n        if (typeof value === &apos;function&apos;) {\n          response = value() \n        } else {\n          response = value  \n        }\n\n        Promise.resolve(response).then(step, err => step(err, true))\n      }\n    }\n  }\n}\n```\n\n代码解读：\n\n- runGenerator 函数接受一个生成器函数 generatorFunc\n- 运行 generatorFunc 得到结果，并通过 iterate 函数，迭代该生成器结果\n- iterate 函数中执行 step 函数，step 函数的第一个参数 arg 是上一个 yield 右表达式的“求出的值”，即下面对应的 response\n- 这里需要考虑 response 的求值过程，它通过 value 计算得来，value 是 yield 右侧的值，它有这么几种情况：\n  - yield new Promise()，value 是一个 promise 实例，那么 response 就是该 Promise 实例 resolve 后的值\n  - yield () => {return value}，value 是一个函数，那么 response 就是执行该函数后的返回值\n  - yield value，value 是一个普通值，那么 response 就是该值\n- 我们最终统一利用 Promise.resolve 的特性，对 response 进行处理，并递归（迭代）调用 step\n- 同时利用 step 函数 arg 参数，赋值给上一个 yield 的左表达式值，并返回下一个 yield 右表达式的值\n\n执行代码：\n\n```\nfunction* gen1() {\n  yield console.log(1)\n  yield console.log(2)\n  yield console.log(3)\n}\n\nrunGenerator(gen1)\n```\n\n或者：\n\n```\nfunction* gen2() {\n  var value1 = yield Promise.resolve(&apos;promise&apos;)\n  console.log(value1)\n\n  var value2 = yield () => Promise.resolve(&apos;thunk&apos;)      \n  console.log(value2)\n\n  var value3 = yield 2\n  console.log(value3)\n}\n\n runGenerator(gen2);\n```\n\n最后还是附上 co 的实现：\n\n```\nfunction co(gen) { // co 接受一个 generator 函数\n    var ctx = this\n    var args = slice.call(arguments, 1)\n    \n    return new Promise(function(resolve, reject) { // co 返回一个 Promise 对象\n        if(typeof gen === &apos;function&apos;) gen = gen.apply(ctx, args) // gen 为 generator 函数，执行该函数\n        if(!gen || typeof gen.next !== &apos;function&apos;) return resolve(gen) // 不是则返回并更新 Promise状态为 resolve\n        \n        onFulfilled() // 将generator 函数的 next 方法包装成 onFulfilled，主要是为了能够捕获抛出的异常\n        \n        /**\n     \t * @param {Mixed} res\n     \t * @return {Promise}\n     \t * @api private\n     \t*/\n        function onFulfilled(res) {\n            var ret;\n            try {\n                ret = gen.next(res)\n            } catch (err) {\n                return reject(err)\n            }\n            next(ret)\n        }\n        \n        /**\n     \t * @param {Error} err\n     \t * @return {Promise}\n     \t * @api private\n     \t*/\n        function onRejected(err) {\n            var ret\n            try {\n                ret = gen.throw(err)\n            } catch (err) {\n                return reject(err)\n            }\n            next(ret)\n        }\n        \n        /**\n     \t * Get the next value in the generator,\n    \t * return a promise.\n    \t *\n    \t * @param {Object} ret\n    \t * @return {Promise}\n    \t * @api private\n     \t*/\n        function next(ret) {\n            if(ret.done) return resolve(ret.value)\n            var value = toPromise.call(ctx, ret.value) // if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj);\n            if(value && isPromise(value)) return value.then(onFulfilled, onRejected)\n            return onRejected(new TypeError(&apos;You may only yield a function, promise, generator, but the following object was passed: &apos; + String(ret.value) + &apos;\"&apos;))\n        }\n    })\n}\n```\n\n如果读者对于以上内容理解有困难，那么我建议还是从 generator 等最基本的概念切入，不必心急，慢慢反复体会。\n\n### 总结\n\n这道“著名”的“微信”面试题，绝不只是网上分析的几行代码答案那么简单，本讲我们从这道题目出发，分析了几种解决方案。更重要的是，在解决方案的基础上，我们重点剖析了 JavaScript 处理任务流程、控制触发逻辑的方方面面。也许在小型传统页面应用中，这样“相对复杂”的处理场景并不多见，但是在大型项目、富交互项目、后端 NodeJS 中非常重要，尤其是中间件思想、洋葱模型是非常典型的编程思路，希望读者能认真体会。\n\n最后我们分析了 generator 以及 Koa 中间件实现原理，也许读者在平时基础业务开发中接触不到这些知识，但是请想一想 redux-saga 的实现、中间件的编写，其实都是这些内容运用体现。进阶即是如此，如果不掌握好这些“难啃”的知识，那么永远无法写出优秀的框架和解决方案。","pdfUrl":"","reader":"","duration":"","title":"分析一道“微信”面试题","column":"5c91c813968b1d64b1e08fde","isNotification":false,"readingStatistics":0,"htmlContent":"<p>前一段时间，一道疑似“微信”招聘的面试题出现，可能有不少读者已经了解过了。这道题乍一看挺难，但是细细分析却还算简单，我们甚至可以用多种手段解题，用不同思想来给出答案。</p>\n<p>网上零零碎碎的有一些解答，但是缺乏全面梳理。我认为通过这道题，有必要将前端多重知识点“融会贯通”，在这里和大家分享。</p>\n<p>本讲知识点如下：</p>\n<p><img src=\"https://images.gitbook.cn/bfedc2e0-de9e-11e9-9f8b-d5f483bb0ebd\" alt=\"enter image description here\" /></p>\n<h3><a id=\"_8\"></a>题意分析</h3>\n<p>我们来先看看题目：</p>\n<blockquote>\n<p>实现一个 LazyMan，按照以下方式调用时，得到相关输出：</p>\n</blockquote>\n<pre><code class=\"lang-\">LazyMan(&quot;Hank&quot;)\n// Hi! This is Hank!\n \nLazyMan(&quot;Hank&quot;).sleep(10).eat(&quot;dinner&quot;)\n// Hi! This is Hank!\n// 等待10 秒..\n// Wake up after 10\n// Eat dinner~\n \nLazyMan(&quot;Hank&quot;).eat(&quot;dinner&quot;).eat(&quot;supper&quot;)\n// Hi This is Hank!\n// Eat dinner~\n// Eat supper~\n \nLazyMan(&quot;Hank&quot;).sleepFirst(5).eat(&quot;supper&quot;)\n// 等待 5 秒\n// Wake up after 5\n// Hi This is Hank!\n// Eat supper\n</code></pre>\n<p>当面试者拿到这道题目的时候，乍看题干可能会有点慌张。其实很多面试失败是“自己吓唬自己”，在平时放松状态下写代码，也许解题不在话下。</p>\n<p>下面我们就从接到题目开始，剖析应该如何进行分析：</p>\n<ul>\n<li>可以把 LazyMan 理解为一个构造函数，在调用时输出参数内容</li>\n<li>LazyMan 支持链式调用</li>\n<li>链式调用过程提供了以下几个方法：sleepFirst、eat、sleep</li>\n<li>其中 eat 方法输出参数相关内容：Eat + 参数</li>\n<li>sleep 方法比较特殊，链式调用将暂停一定时间后继续执行，看到这里也许应该想到 setTimeout</li>\n<li>sleepFirst 最为特殊，这个任务或者这个方法的 <strong>优先级最高</strong>；调用 sleepFirst 之后，链式调用将暂停一定时间后继续执行。请再次观察题干，尤其是最后一个 demo，sleepFirst 的输出优先级最高，调用后先等待 5 秒输出 Wake up after 5，再输出 Hi This is Hank!</li>\n</ul>\n<p>我们应该如何解这个题目呢，从拿到需求开始进行分析：</p>\n<ul>\n<li>先从最简单的，我们可以封装一些基础方法，比如 log 输出、封装 setTimeout 等</li>\n<li>因为 LazyMan 要实现一系列调用，<strong>且调用并不是顺序执行的，比如如果 sleepFirst 出现在调用链时，优先执行；同时任务并不是全部都同步执行的</strong>，因此<strong>我们应该实现一个任务队列</strong>，这个队列将调度执行各个任务</li>\n<li>因此每次调用 LazyMan 或链式执行时，我们应该将相关调用方法加入到（push）任务队列中，储存起来，后续统一被调度</li>\n<li>在写入任务队列时，如果当前的方法为 sleepFirst，那么需要将该方法放到队列的最头处，这应该是一个 unshift 方法</li>\n</ul>\n<p>这么一分析，这道题就“非常简单”了。</p>\n<p>我们来试图解剖一下这道题目的考察点：</p>\n<ul>\n<li>面向对象思想与设计，包括类的使用等</li>\n<li>对象方法链式调用的理解和设计</li>\n<li>小部分设计模式的设计</li>\n<li>因为存在“重复逻辑”，考察代码的解耦和抽象能力</li>\n<li>逻辑的清晰程度以及其他编程思维</li>\n</ul>\n<h3><a id=\"_64\"></a>常规思路解答</h3>\n<p>基于以上思路，我们给出较为常规的答案，其中代码已经加上了必要的注释：</p>\n<pre><code class=\"lang-\">class LazyManGenerator {\n  constructor(name) {\n    this.taskArray = []\n\n\t// 初始化时任务\n    const task = () =&gt; {\n      console.log(`Hi! This is ${name}`)\n      // 执行完初始化时任务后，继续执行下一个任务\n      this.next()\n    }\n\n\t// 将初始化任务放入任务队列中\n    this.taskArray.push(task)\n\n    setTimeout(() =&gt; {\n      this.next()\n    }, 0)\n  }\n\n  next() {\n  \t// 取出下一个任务并执行\n    const task = this.taskArray.shift()\n    task &amp;&amp; task()\n  }\n\n  sleep(time) {\n    this.sleepTask(time, false)\n    // return this 保持链式调用\n    return this\n  }\n\n  sleepFirst(time) {\n    this.sleepTask(time, true)\n    return this\n  }\n\n  sleepTask(time, prior) {\n    const task = () =&gt; {\n      setTimeout(() =&gt; {\n        console.log(`Wake up after ${time}`)\n        this.next()\n      }, time * 1000)\n    }\n\n    if (prior) {\n      this.taskArray.unshift(task)\n    } else {\n      this.taskArray.push(task)\n    }\n  }\n\n  eat(name) {\n    const task = () =&gt; {\n      console.log(`Eat ${name}`)\n      this.next()\n    }\n\n    this.taskArray.push(task)\n    return this\n  }\n}\n\nfunction LazyMan(name) {\n  return new LazyManGenerator(name)\n}\n</code></pre>\n<p>简单分析一下：</p>\n<ul>\n<li>LazyMan 方法返回一个 LazyManGenerator 构造函数的实例</li>\n<li>在 LazyManGenerator constructor 当中，我们维护了 taskArray 用来存储任务，同时将初始化任务放到 taskArray 当中</li>\n<li>还是在 LazyManGenerator constructor 中，将任务的逐个执行即 next 调用放在 setTimeout 中，这样就能够保证在开始执行任务时，taskArray 数组已经填满了任务</li>\n<li>我们来看看 next 方法，取出 taskArray 数组中的首项，进行执行</li>\n<li>eat 方法将 eat task 放到 taskArray 数组中，注意 eat task 方法需要调用 this.next() 显式调用“下一个任务”；同时返回 this，完成链式调用</li>\n<li>sleep 和 sleepFirst 都调用了 sleepTask，不同在于第二个参数：sleepTask 第二个参数表示是否优先执行，如果 prior 为 true，则使用 unshift 将任务插到 taskArray 开头</li>\n</ul>\n<p>这个解法最容易想到，也相对来说容易，主要是面向过程。关键点在于对于 setTimeout 任务队列的准确理解以及 return this 实现链式调用的方式。</p>\n<p>事实上，sleepTask 应该作为 LazyManGenerator 类的私有属性出现，因为 ES class 暂时 private 属性没有被广泛实现，这里不再追求实现。</p>\n<h3><a id=\"_149\"></a>设计模式解答</h3>\n<p>关于这道题目的解答，网上最流行的是一种发布订阅模式的方案。相关代码出处：<a href=\"https://github.com/wall-wxk/blogDemo/blob/master/2017/01/22/lazyMan.html\" target=\"_blank\">lazyMan</a>。</p>\n<p>但是其实仔细看其实现，也是上一环节中常规解法的变种。虽然说是发布订阅模式，但是其实仍然是 next 思想执行下一个任务的思路，该实现 publish 和 subscribe 方法分别是完成执行任务和注册任务逻辑。我认为这样的代码实现有一点“过度设计”之嫌，更像是往发布订阅模式上去靠，整体流程不够自然。</p>\n<p>当然读者仍可参考，并有自己的思考，这里我不再更多分析。</p>\n<h3><a id=\"_157\"></a>再谈流程控制和队列、中间件启发</h3>\n<p>这道题目我们给出解法并不算完，更重要也更有价值的是思考、延伸。微信题目较好地考察了候选者的流程控制能力，而流程控制在前端开发者面前也非常重要。</p>\n<p>我们看上述代码中的 next 函数，它负责找出 stack 中的下一个函数并执行：</p>\n<pre><code class=\"lang-\">next() {\n\t// 取出下一个任务并执行\n\tconst task = this.taskArray.shift()\n\ttask &amp;&amp; task()\n}\n</code></pre>\n<p>NodeJS 中 connect 类库，以及其他框架的中间件设计也都离不开类似思想的 next。比如生成器自动执行函数 co、redux、koa 也通过不同的实现，可以让 next 在多个函数之间执行完后面的函数再折回来执行 next，较为巧妙。我们具体来看一下。</p>\n<h4><a id=\"senchalabs_connect__express_173\"></a>senchalabs connect 和 express</h4>\n<p>具体场景：在 Node 环境中，有 parseBody、checkIdInDatabase 等相关中间件，他们组成了 middlewares 数组：</p>\n<pre><code class=\"lang-\">const middlewares = [\n  function middleware1(req, res, next) {\n    parseBody(req, function(err, body) {\n      if (err) return next(err);\n      req.body = body;\n      next();\n    });\n  },\n  function middleware2(req, res, next) {\n    checkIdInDatabase(req.body.id, function(err, rows) {\n      if (err) return next(err);\n      res.dbResult = rows;\n      next();\n    });\n  },\n  function middleware3(req, res, next) {\n    if (res.dbResult &amp;&amp; res.dbResult.length &gt; 0) {\n      res.end(&apos;true&apos;);\n    }\n    else {\n      res.end(&apos;false&apos;);\n    }\n    next();\n  }\n]\n</code></pre>\n<p>当一个请求打开时，我们需要链式调用各个中间件：</p>\n<pre><code class=\"lang-\">const requestHandler = (req, res) =&gt; {\n  let i = 0\n  \n  function next(err) {\n    if (err) {\n      return res.end(&apos;error:&apos;, err.toString())\n    }\n\n    if (i &lt; middlewares.length) {\n      middlewares[i++](req, res, next)\n    } else {\n      return\n    }\n  }\n\n  // 初始执行第一个中间件\n  next()\n}\n</code></pre>\n<p>基本思路和面试题解法一致：</p>\n<ul>\n<li>将所有中间件（任务处理函数）储存在一个 list 中</li>\n<li>循环依次调用中间件（任务处理函数）</li>\n</ul>\n<p>senchalabs/connect 这个库做了很好的封装，是 express 等框架设计实现的原始模型。这里我们简单分析一下 senchalabs/connect 这个库的实现。</p>\n<p>用法：</p>\n<p>首先使用 createServer 方法创建 app 实例，</p>\n<pre><code class=\"lang-\">const app = createServer()\n</code></pre>\n<p>对应源码：</p>\n<pre><code class=\"lang-\">function createServer() {\n  function app(req, res, next){ app.handle(req, res, next); }\n  merge(app, proto);\n  merge(app, EventEmitter.prototype);\n  app.route = &apos;/&apos;;\n  app.stack = [];\n  return app;\n}\n</code></pre>\n<p>我们看 app 实例“继承”了 EventEmitter 类，实现事件发布订阅，同时 stack 数组来维护各个中间件任务。</p>\n<p>接着使用 app.use 来添加中间件：</p>\n<pre><code class=\"lang-\">app.use(&apos;/api&apos;, function(req, res, next) {//...})\n</code></pre>\n<p>源码实现：</p>\n<pre><code class=\"lang-\">proto.use = function use(route, fn) {\n  var handle = fn;\n  var path = route;\n\n  // default route to &apos;/&apos;\n  if (typeof route !== &apos;string&apos;) {\n    handle = route;\n    path = &apos;/&apos;;\n  }\n\n  // wrap sub-apps\n  if (typeof handle.handle === &apos;function&apos;) {\n    var server = handle;\n    server.route = path;\n    handle = function (req, res, next) {\n      server.handle(req, res, next);\n    };\n  }\n\n  // wrap vanilla http.Servers\n  if (handle instanceof http.Server) {\n    handle = handle.listeners(&apos;request&apos;)[0];\n  }\n\n  // strip trailing slash\n  if (path[path.length - 1] === &apos;/&apos;) {\n    path = path.slice(0, -1);\n  }\n\n  // add the middleware\n  debug(&apos;use %s %s&apos;, path || &apos;/&apos;, handle.name || &apos;anonymous&apos;);\n  this.stack.push({ route: path, handle: handle });\n\n  return this;\n};\n</code></pre>\n<p>通过 if…else 逻辑区分出三种不同的 fn 类型：</p>\n<ul>\n<li>fn 是一个普通的 function(req,res[,next]){} 函数</li>\n<li>fn 是一个普通的 httpServer</li>\n<li>fn 是一个普通的是另一个 connect 的 app 对象（sub app 特性）</li>\n</ul>\n<p>对于这三种类型，分别转换为 function(req, res, next) {} 的形式，具体我们不再分析。最重要的执行过程是：</p>\n<pre><code class=\"lang-\">this.stack.push({ route: path, handle: handle })\n</code></pre>\n<p>以及返回：</p>\n<pre><code class=\"lang-\">return this\n</code></pre>\n<p>以上就完成了中间件即任务的注册，我们有：</p>\n<pre><code class=\"lang-\">app.stack = [function1, function2, function3, ...];\n</code></pre>\n<p>接下来看看任务的调度和执行。使用方法：</p>\n<pre><code class=\"lang-\">app.handle(req, res, out)\n</code></pre>\n<p>handle 源码实现：</p>\n<pre><code class=\"lang-\">proto.handle = function handle(req, res, out) {\n  var index = 0;\n  var protohost = getProtohost(req.url) || &apos;&apos;;\n  var removed = &apos;&apos;;\n  var slashAdded = false;\n  var stack = this.stack;\n\n  // final function handler\n  var done = out || finalhandler(req, res, {\n    env: env,\n    onerror: logerror\n  });\n\n  // store the original URL\n  req.originalUrl = req.originalUrl || req.url;\n\n  function next(err) {\n    // ...\n  }\n\n  next();\n};\n</code></pre>\n<p>源码导读：out 参数是关于 sub app 的特性，这个特性可以暂时忽略，我们暂时不关心。handle 实现我们并不陌生，它构建 next 函数，并触发第一个 next 执行。</p>\n<p>next 实现：</p>\n<pre><code class=\"lang-\">function next(err) {\n\tif (slashAdded) {\n\t  req.url = req.url.substr(1);\n\t  slashAdded = false;\n\t}\n\t\n\tif (removed.length !== 0) {\n\t  req.url = protohost + removed + req.url.substr(protohost.length);\n\t  removed = &apos;&apos;;\n\t}\n\t\n\t// next callback\n\tvar layer = stack[index++];\n\t\n\t// all done\n\tif (!layer) {\n\t  defer(done, err);\n\t  return;\n\t}\n\t\n\t// route data\n\tvar path = parseUrl(req).pathname || &apos;/&apos;;\n\tvar route = layer.route;\n\t\n\t// skip this layer if the route doesn&apos;t match\n\tif (path.toLowerCase().substr(0, route.length) !== route.toLowerCase()) {\n\t  return next(err);\n\t}\n\t\n\t// skip if route match does not border &quot;/&quot;, &quot;.&quot;, or end\n\tvar c = path.length &gt; route.length &amp;&amp; path[route.length];\n\tif (c &amp;&amp; c !== &apos;/&apos; &amp;&amp; c !== &apos;.&apos;) {\n\t  return next(err);\n\t}\n\t\n\t// trim off the part of the url that matches the route\n\tif (route.length !== 0 &amp;&amp; route !== &apos;/&apos;) {\n\t  removed = route;\n\t  req.url = protohost + req.url.substr(protohost.length + removed.length);\n\t\n\t  // ensure leading slash\n\t  if (!protohost &amp;&amp; req.url[0] !== &apos;/&apos;) {\n\t    req.url = &apos;/&apos; + req.url;\n\t    slashAdded = true;\n\t  }\n\t}\n\t\n\t// call the layer handle\n\tcall(layer.handle, route, err, req, res, next);\n}\n</code></pre>\n<p>源码导读：</p>\n<ul>\n<li>取出下一个中间件</li>\n</ul>\n<pre><code class=\"lang-\">var layer = stack[index++]\n</code></pre>\n<ul>\n<li>如果当前请求路由和 handler 不匹配，则跳过：</li>\n</ul>\n<pre><code class=\"lang-\">if (path.toLowerCase().substr(0, route.length) !== route.toLowerCase()) {\n  return next(err);\n}\n</code></pre>\n<ul>\n<li>若匹配，则执行 call 函数，call 函数实现：</li>\n</ul>\n<pre><code class=\"lang-\">function call(handle, route, err, req, res, next) {\n  var arity = handle.length;\n  var error = err;\n  var hasError = Boolean(err);\n\n  debug(&apos;%s %s : %s&apos;, handle.name || &apos;&lt;anonymous&gt;&apos;, route, req.originalUrl);\n\n  try {\n    if (hasError &amp;&amp; arity === 4) {\n      // error-handling middleware\n      handle(err, req, res, next);\n      return;\n    } else if (!hasError &amp;&amp; arity &lt; 4) {\n      // request-handling middleware\n      handle(req, res, next);\n      return;\n    }\n  } catch (e) {\n    // replace the error\n    error = e;\n  }\n\n  // continue\n  next(error);\n}\n</code></pre>\n<p>注意：我们使用了 try…catch 包裹逻辑，这是很必要的容错思维，这样第三方中间件的执行如果出错，不至于打挂我们的应用。</p>\n<p>较为巧妙的一点是：function(err, req, res, next){} 形式为错误处理函数，function(req, res, next){} 为正常的业务逻辑处理函数。因此通过 Function.length 来判断当前 handler 是否为容错函数，来做到参数的传入。</p>\n<p>call 函数是 next 函数的核心，它是一个执行者，并在最后的逻辑中继续执行 next 函数，完成中间件的顺序调用。</p>\n<p>NodeJS 的框架 express，实际就是 senchalabs connect 的升级版，通过对 connect 源码的学习，我们应该更加清楚流程的调度和控制，再去看 express 就轻而易举了。</p>\n<p>Senchalabs connect 用流程控制库的回调函数及中间件的思想来解耦回调逻辑；Koa 则是用generator 方法解决回调问题（最新版使用 async/await）。事实上，也可以用事件、Promise 的方式实现，下一环节，我们就分析 Koa 的洋葱模型。</p>\n<h4><a id=\"Koa__474\"></a>Koa 的洋葱模型</h4>\n<p>对 Koa 中间的洋葱模型的分析文章上不少，著名的洋葱圈图示我也不在自己画了，具体使用不再介绍，不了解的读者请先自行学习。</p>\n<p>我想先谈一下面向切面编程（AOP），在 JavaScript 语言为例，一个简单的示例：</p>\n<pre><code class=\"lang-\">Function.prorotype.before = function (fn) {\n  const self = this\n  return function (...args) {\n    console.log(&apos;&apos;)\n    let res = fn.call(this)\n    if (res) {\n      self.apply(this, args)\n    }\n  }\n}\n\nFunction.prototype.after = function (fn) {\n  const self = this\n  return function (...args) {\n    let res = self.apply(this, args)\n    if (res) {\n      fn.call(this)\n    }\n  }\n}\n</code></pre>\n<p>这样的代码实现，是我们能够在执行某个函数 fn 之前，先执行某段逻辑；在某个函数 fn 之后，再去执行另一段逻辑。其实是一种简单中间件流程控制的体现。不过这样的 AOP 有一个问题：无法实现异步模式。</p>\n<p>那么如何实现 Koa 的异步中间件模式呢？即某个中间件执行到一半，交出执行权，之后再回来继续执行。我们直接看源码分析，这段源码实现了 Koa 洋葱模型中间件：</p>\n<pre><code class=\"lang-\">function compose(middleware) {\n  return function *(next) {(\n    if (!next) next = noop();\n\n    var i = middleware.length;\n\n    while (i--) {\n      next = middleware[i].call(this, next);\n      console.log(&apos;isGenerator:&apos;, (typeof next.next === &apos;function&apos; &amp;&amp; typeof next.throw === &apos;function&apos;)); // true\n    }\n\n    return yield *next;\n  }\n}\n\nfunction *noop(){}\n</code></pre>\n<p>其中，一个中间件的写法类似：</p>\n<pre><code class=\"lang-\">app.use(function *(next){\n  var start = new Date;\n  yield next;\n  var ms = new Date - start;\n  this.set(&apos;X-Response-Time&apos;, ms + &apos;ms&apos;);\n});\n</code></pre>\n<p>这是一个很简单的记录 response time 的中间件，中间件跳转的信号是 yield next。</p>\n<p>较新版本的 Koa 已经改用 async/await 实现，思路也是完全一样的，当然看上去更加优雅：</p>\n<pre><code class=\"lang-\">function compose (middleware) {\n  if (!Array.isArray(middleware)) throw new TypeError(&apos;Middleware stack must be an array!&apos;)\n  for (const fn of middleware) {\n    if (typeof fn !== &apos;function&apos;) throw new TypeError(&apos;Middleware must be composed of functions!&apos;)\n  }\n\n  return function (context, next) {\n    let index = -1\n    return dispatch(0)\n\n    function dispatch (i) {\n      if (i &lt;= index) return Promise.reject(new Error(&apos;next() called multiple times&apos;))\n      index = i\n      let fn = middleware[i]\n      if (i === middleware.length) {\n        fn = next\n      }\n      if (!fn) return Promise.resolve()\n      try {\n        return Promise.resolve(fn(context, function next () {\n          return dispatch(i + 1)\n        }))\n      } catch (err) {\n        return Promise.reject(err)\n      }\n    }\n  }\n}\n</code></pre>\n<p>我们来重点解读一下这个版本的实现：</p>\n<ul>\n<li>compose 传入的 middleware 参数必须是数组，否则抛出错误</li>\n<li>middleware 数组的每一个元素必须是函数，否则抛出错误</li>\n<li>compose 返回一个函数，保存对 middleware 的引用</li>\n<li>compose 返回函数的第一个参数是 context，所有中间件的第一个参数就是传入的 context</li>\n<li>compose 返回函数的第二个参数是 next 函数，next 是实现洋葱模型的关键</li>\n<li>index 记录当前运行到第几个中间件</li>\n<li>执行第一个中间件函数：return dispatch(0)</li>\n<li>dispatch 函数中，参数 i 如果小于等于 index，说明一个中间件中执行了多次 next，我们进行报错，由此可见一个中间件函数内部不允许多次调用 next 函数</li>\n<li>取出中间件函数 fn = middleware[i]</li>\n<li>如果 i === middleware.length，说明执行到了圆心，将 next 赋值给 fn</li>\n<li>因为 async 需要后面是 Promise，我们包一层 Promise</li>\n<li>next 函数是固定的，它可以执行下一个中间件函数</li>\n</ul>\n<pre><code class=\"lang-\">function next () {\n  return dispatch(i + 1)\n}\n</code></pre>\n<p>如果读者不好理解，可以参考应用示例：</p>\n<pre><code class=\"lang-\">async function middleware1(ctx, next) {\n  console.log(&apos;1&apos;)\n  await next()\n  console.log(&apos;2&apos;)\n};\n\nasync function middleware2(ctx, next) {\n  console.log(&apos;3&apos;)\n  await next()\n  console.log(&apos;4&apos;)\n};\n</code></pre>\n<p>如果读者还是难以理解，我给出一个简版逻辑：</p>\n<pre><code class=\"lang-\">function compose (middleware) {\n  return dispatch(0) \n  function dispatch(i) {\n    fn = middleware[i]\n    if(!fn) return\n    return fn(() =&gt; dispatch(i + 1))\n  }\n}\n</code></pre>\n<h4><a id=\"co__622\"></a>co 库不再神秘</h4>\n<p>说到流程控制，也少不了大名鼎鼎的 co 库。co 函数库是 TJ 大神基于 ES6 generator 的异步解决方案，因此这里需要读者熟练掌握 ES6 generator。目前虽然 co 库可能不再“流行”，但是了解其实现，模拟类似场景也是非常有必要的。</p>\n<p>我们这里不解读其源码，而是实现一个类似的自动执行 generator 的方案：</p>\n<pre><code class=\"lang-\">const runGenerator = generatorFunc =&gt; {\n  const it = generatorFunc()\n  iterate(it)\n\n  function iterate (it) {\n    step()\n\n    function step(arg, isError) {\n      const {value, done} = isError ? it.throw(arg) : it.next(arg)\n\n      let response\n\n      if (!done) {\n        if (typeof value === &apos;function&apos;) {\n          response = value() \n        } else {\n          response = value  \n        }\n\n        Promise.resolve(response).then(step, err =&gt; step(err, true))\n      }\n    }\n  }\n}\n</code></pre>\n<p>代码解读：</p>\n<ul>\n<li>runGenerator 函数接受一个生成器函数 generatorFunc</li>\n<li>运行 generatorFunc 得到结果，并通过 iterate 函数，迭代该生成器结果</li>\n<li>iterate 函数中执行 step 函数，step 函数的第一个参数 arg 是上一个 yield 右表达式的“求出的值”，即下面对应的 response</li>\n<li>这里需要考虑 response 的求值过程，它通过 value 计算得来，value 是 yield 右侧的值，它有这么几种情况：\n<ul>\n<li>yield new Promise()，value 是一个 promise 实例，那么 response 就是该 Promise 实例 resolve 后的值</li>\n<li>yield () =&gt; {return value}，value 是一个函数，那么 response 就是执行该函数后的返回值</li>\n<li>yield value，value 是一个普通值，那么 response 就是该值</li>\n</ul>\n</li>\n<li>我们最终统一利用 Promise.resolve 的特性，对 response 进行处理，并递归（迭代）调用 step</li>\n<li>同时利用 step 函数 arg 参数，赋值给上一个 yield 的左表达式值，并返回下一个 yield 右表达式的值</li>\n</ul>\n<p>执行代码：</p>\n<pre><code class=\"lang-\">function* gen1() {\n  yield console.log(1)\n  yield console.log(2)\n  yield console.log(3)\n}\n\nrunGenerator(gen1)\n</code></pre>\n<p>或者：</p>\n<pre><code class=\"lang-\">function* gen2() {\n  var value1 = yield Promise.resolve(&apos;promise&apos;)\n  console.log(value1)\n\n  var value2 = yield () =&gt; Promise.resolve(&apos;thunk&apos;)      \n  console.log(value2)\n\n  var value3 = yield 2\n  console.log(value3)\n}\n\n runGenerator(gen2);\n</code></pre>\n<p>最后还是附上 co 的实现：</p>\n<pre><code class=\"lang-\">function co(gen) { // co 接受一个 generator 函数\n    var ctx = this\n    var args = slice.call(arguments, 1)\n    \n    return new Promise(function(resolve, reject) { // co 返回一个 Promise 对象\n        if(typeof gen === &apos;function&apos;) gen = gen.apply(ctx, args) // gen 为 generator 函数，执行该函数\n        if(!gen || typeof gen.next !== &apos;function&apos;) return resolve(gen) // 不是则返回并更新 Promise状态为 resolve\n        \n        onFulfilled() // 将generator 函数的 next 方法包装成 onFulfilled，主要是为了能够捕获抛出的异常\n        \n        /**\n     \t * @param {Mixed} res\n     \t * @return {Promise}\n     \t * @api private\n     \t*/\n        function onFulfilled(res) {\n            var ret;\n            try {\n                ret = gen.next(res)\n            } catch (err) {\n                return reject(err)\n            }\n            next(ret)\n        }\n        \n        /**\n     \t * @param {Error} err\n     \t * @return {Promise}\n     \t * @api private\n     \t*/\n        function onRejected(err) {\n            var ret\n            try {\n                ret = gen.throw(err)\n            } catch (err) {\n                return reject(err)\n            }\n            next(ret)\n        }\n        \n        /**\n     \t * Get the next value in the generator,\n    \t * return a promise.\n    \t *\n    \t * @param {Object} ret\n    \t * @return {Promise}\n    \t * @api private\n     \t*/\n        function next(ret) {\n            if(ret.done) return resolve(ret.value)\n            var value = toPromise.call(ctx, ret.value) // if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj);\n            if(value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected)\n            return onRejected(new TypeError(&apos;You may only yield a function, promise, generator, but the following object was passed: &apos; + String(ret.value) + &apos;&quot;&apos;))\n        }\n    })\n}\n</code></pre>\n<p>如果读者对于以上内容理解有困难，那么我建议还是从 generator 等最基本的概念切入，不必心急，慢慢反复体会。</p>\n<h3><a id=\"_759\"></a>总结</h3>\n<p>这道“著名”的“微信”面试题，绝不只是网上分析的几行代码答案那么简单，本讲我们从这道题目出发，分析了几种解决方案。更重要的是，在解决方案的基础上，我们重点剖析了 JavaScript 处理任务流程、控制触发逻辑的方方面面。也许在小型传统页面应用中，这样“相对复杂”的处理场景并不多见，但是在大型项目、富交互项目、后端 NodeJS 中非常重要，尤其是中间件思想、洋葱模型是非常典型的编程思路，希望读者能认真体会。</p>\n<p>最后我们分析了 generator 以及 Koa 中间件实现原理，也许读者在平时基础业务开发中接触不到这些知识，但是请想一想 redux-saga 的实现、中间件的编写，其实都是这些内容运用体现。进阶即是如此，如果不掌握好这些“难啃”的知识，那么永远无法写出优秀的框架和解决方案。</p>\n","createdAt":"2019-04-21T04:49:33.514Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":44,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FoThASW9dVEPMEo9nP-zaOfbKyLZ"},{"_id":"5cbbf6cbbbbba80861a35c83","communication_start_time":null,"type":1,"audioPath":"","abstract":"","content":"开启本讲之前，我想先问一句：“网络基础对于前端程序员重不重要”？其实答案是毫无疑问的，如果读者仍然对此有怀疑，那可能你还是刚入行的程序员，相信随着工作经验的增加，你会越来越能意识到网络基础的重要性。事实上，具备必要的网络基础，是对于一个程序员的要求，绝不仅仅是对前端工程师的要求，更何况在 Node.js 发展当下，学好网络知识更是对于前途发展意义重大。\n\n网络基础其实并不难，但绝不仅仅是一讲的内容就能“融会贯通”的，系统性地学习还需要回炉到大学课本。本讲，我从网络基础概念和场景应用两大方面来讲解，主要内容如下：\n\n![1](https://images.gitbook.cn/568aafc0-e263-11e9-a074-f5ff05024c30)\n\n### 网络基础知识\n\n有一个说法——“大厂前端面试对 HTTP 的要求比 CSS 还要高”，确实从面试的频率上，以 HTTP 为核心的网络基础考察绝对是重点。这些考察点其实并不难，都是基础概念，我们先从几个高频考点入手。\n\n更为基础的内容，比如计算机网络体系结构，OSI 七层协议等我们不再提及，必要知识需要读者先行了解。\n\n#### TCP 和 UDP\n\nTCP 和 UDP 是运输层的两种协议，什么是运输层呢？\n\n> 运输层（Transport Layer）就是负责向两台主机进程之间的通信提供通用的数据传输服务，应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。\n\n对于 TCP 和 UDP 这两种协议的理解，我们可以主要从其特点和区别来掌握。\n\n传输控制协议 TCP（Transmisson Control Protocol）是一种**面向连接的、可靠的**数据传输服务。如何理解可靠呢？通过 TCP 协议传送数据可以无差错、不丢失、不重复、并且按序到达；如何理解面向连接呢？就像我们打电话一样，通过拿起电话和挂掉电话来表示连接的建立和中断。此外，TCP 的特点有：\n\n- TCP 提供全双工通信，也就是说双方在连接建立之后，都可以在任何时候进行数据发送\n- TCP 两端连接都设有缓存，在发送和接收时都可以利用缓存临时存放数据\n- TCP 是面向字节流的\n\n用户数据协议 UDP（User Datagram Protocol）是一种**无连接的、不保证数据传输的可靠性**的运输层协议。其特点：\n\n- UDP 无连接\n- UDP 不保证可靠性，因此不需要维持复杂的链接状态\n- UDP 是面向报文的\n- UDP 没有拥塞控制\n- UDP 支持一对一、一对多、多对一和多对多的交互通信\n\n因此根据 TCP 和 UDP 的特点，可以选择不同的协议进行场景应用，比如对于直播、实时视频会议，你认为哪种协议更加适合呢？\n\n因为 UDP 传输速度更快、效率更高，UDP 没有拥塞控制，所以网络出现拥塞不会使源主机的发送速率降低，且直播、实时视频会议丢失一两帧内容对于应用并没有体验性的影响，因此，UDP 对于直播、实时视频会议的场景会更加适合。\n\n**这些内容对应的面试考点：**\n\n- 比较 TCP 和 UDP\n- TCP 和 UDP 的应用场景\n- TCP 如何保证传输的可靠性\n\n前两项考点我们已经有所涉及，现在针对 TCP 如何保证传输的可靠性进行展开。TCP 保证传输的可靠性主要手段有以下几个。\n\n- 数据包校验：如果接收端校验出包有错，则进行丢弃且不进行相应。\n- 对失序数据包重排序：TCP 协议会对失序数据包进行排序，然后再交给应用层。\n- 丢弃重复数据。\n- 应答机制：当接收端接收到数据之后，将发送确认信息。\n- 超时重发：当发送端发出数据后，它启动一个定时器，如果超出计时器的时限，将重发这个报文段。\n- 流量控制：前面提到过，TCP 连接的每一方都有固定大小的缓冲空间，可防止接收端缓冲区溢出，这就是流量控制。TCP 使用可变大小的滑动窗口协议来进行流量控制。\n\n最后再补充一点单工/半双工/双工数据通信的概念区分：\n\n- 单工数据传输是数据只能在一个方向上传输；\n- 半双工数据传输允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信；\n- 全双工数据通信允许数据同时在两个方向上传输，因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力。\n\n#### 三次握手和四次挥手\n\n上面我们说到 TCP 是面向连接的，那么这个连接过程就涉及到著名的三次握手和四次挥手了。也许对于这些名词我们已经“听烂了”，但是你是否有真正的掌握呢？\n\n三次握手，简单来说是指当建立一个 TCP 连接时，整个建立过程需要客户端和服务端一共交互三个包，三次握手的目的是连接服务器的指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号并交换 TCP 窗口大小信息。\n\n![1](https://images.gitbook.cn/f192a820-e267-11e9-bb4c-7169754434c1)\n\n具体来说 **第一次握手**\n\n开始建立连接时，客户端向服务器发出连接请求报文，报文首部中的同部位 SYN = 1，同时选择一个初始序列号 seq = x ，这时客户端进程进入了 SYN-SENT （同步已发送状态）状态，等待服务器确认。\n\n**第二次握手**\n\n服务器收到 syn 包后，如果同意连接，则发出确认报文；确认报文 ACK = 1，SYN = 1，确认号是 ack = x + 1，同时也要为自己初始化一个序列号 seq = y，此时服务器进程进入了 SYN-RCVD（同步收到）状态。\n\n**第三次握手**\n\n客户端收到服务器的 SYN + ACK 包，要向服务器给出确认。确认报文的 ACK = 1，ack = y + 1，自己的序列号 seq = x + 1。此时，TCP 连接建立，客户端进入 ESTABLISHED （已建立连接）状态。\n\n四次挥手是指，TCP 连接的终端需要客户端和服务端总共发送四个包，客户端或者服务器端均可主动发起挥手动作。\n\n![2](https://images.gitbook.cn/08126450-e268-11e9-9514-611dbba450a7)\n\n具体来说，**第一次挥手**\n\n客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部 FIN = 1，其序列号为 seq = u（等于前面已经传送过来的数据最后一个字节的序号加 1）。此时，客户端进入 FIN-WAIT-1（终止等待 1）状态。\n\n**第二次挥手**\n\n服务器收到连接释放报文，发出确认报文，ACK = 1，ack = u + 1，并且带上自己的序列号 seq = v（客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受），此时，服务端就进入了 CLOSE-WAIT（关闭等待）状态。\n\n**第三次挥手**\n\n服务器将最后的数据发送完毕后，就向客户端发送连接中断报文，FIN = 1，ack = u + 1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq = w，此时，服务器就进入了 LAST-ACK（最后确认）状态，等待客户端的确认。\n\n**第四次挥手**\n\n客户端收到服务器的连接释放报文后，必须发出确认，ACK = 1，ack = w + 1，而自己的序列号是 seq = u + 1。此时，客户端就进入了 TIME-WAIT（时间等待）状态。\n\n服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接（注意此时 TCP 连接还没有释放，必须经过 2MSL（最长报文段寿命）的时间后，当客户端撤销相应的 TCB 后，才进入 CLOSED 状态）。服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接。\n\n**这些内容对应的面试考点：**\n\n- 三次握手和四次挥手过程\n- 三次握手和四次挥手的必要性，不做行不行？\n\n#### HTTP 响应常见状态码\n\nHTTP 响应常见状态码这里只做一个速查总结。\n\n- 100-199：表示成功接收请求, 要求客户端继续提交下一次请求才能完成整个处理过程，常见的有 101（客户要求服务器转换 HTTP 协议版本）、100（客户必须继续发出请求）\n- 200-299：表示成功接收请求并已完成整个处理过程\n- 300-399：需要客户进一步细化需求，以进一步完成请求，常用的有 301（永久重定向）、302（临时重定向）、304（缓存相关）\n- 400-499：请求出错，包含语法错误或者无法正确执行逻辑，常用的有 404（无对应资源）、401（权限问题）、403 （服务器拒绝请求）\n- 500-599：服务器端程序处理出现错误，常见的有 502（错误网关）、504（网关超时）、505（HTTP 版本不受支持）\n\n列举更加具体的状态码说明，出自：[HTTP Status Code](https://juejin.im/entry/586b5b7dac502e12d62b4f33)\n\n```\n100     //继续 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分\n101     //切换协议  请求者已要求服务器切换协议，服务器已确认并准备切换\n\n200     //成功  服务器已经成功处理了请求，通常，这表示服务器提供了请求的网页\n201     //已创建  请求成功并且服务器创建了新的资源\n202     //已接受  服务器已接受请求，但尚未处理\n203     //非授权信息  服务器已经成功处理了请求，但返回的信息可能来自另一来源\n204     //无内容  服务器成功处理了请求，但没有返回任何内容\n205     //重置内容  服务器成功处理了请求，但没有返回任何内容\n206     //部分内容  服务器成功处理了部分 GET 请求\n\n300     //多种选择  针对请求，服务器可执行多种操作。服务器可根据请求者（user agent）选择一项操作，或提供操作列表供请求者选择\n301     //永久移动  请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置\n302     //临时移动  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求\n303     //查看其他位置  请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码\n304     //未修改  自动上次请求后，请求的网页未修改过。服务器返回此响应，不会返回网页的内容\n305     //使用代理  请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理\n307     //临时性重定向  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有的位置来进行以后的请求\n\n\n400     //错误请求  服务器不理解请求的语法\n401     //未授权  请求要求身份验证。对于需要登录的网页，服务器可能返回此响应\n403     //禁止  服务器拒绝请求\n404     //未找到  服务器找不到请求的网页\n405     //方法禁用  禁用请求中指定的方法\n406     //不接受  无法使用请求的内容特性响应请求的网页\n407     //需要代理授权  此状态码与401（未授权）类似，但指定请求者应当授权使用代理\n408     //请求超时  服务器等候请求时发生超时\n409     //冲突  服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息\n410     //已删除  如果请求的资源已永久删除，服务器就会返回此响应\n411     //需要有效长度  服务器不接受不含有效内容长度标头字段的请求\n412     //未满足前提条件  服务器未满足请求者在请求者设置的其中一个前提条件\n413     //请求实体过大  服务器无法处理请求，因为请求实体过大，超出了服务器的处理能力\n414     //请求的URI过长  请求的URI（通常为网址）过长，服务器无法处理\n415     //不支持媒体类型  请求的格式不受请求页面的支持\n416     //请求范围不符合要求  如果页面无法提供请求的范围，则服务器会返回此状态码\n417     //未满足期望值  服务器未满足“期望”请求标头字段的要求\n\n500     //服务器内部错误  服务器遇到错误，无法完成请求\n501     //尚未实施  服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码\n502     //错误网关  服务器作为网关或代理，从上游服务器无法收到无效响应\n503     //服务器不可用  服务器目前无法使用（由于超载或者停机维护）。通常，这只是暂时状态\n504     //网关超时  服务器作为网关代理，但是没有及时从上游服务器收到请求\n505     //HTTP 版本不受支持  服务器不支持请求中所用的 HTTP 协议版本\n```\n\n**这些内容对应的面试考点：**\n\n- 状态码的熟悉程度\n- 缓存相关状态码\n- Restful 相关内容\n\n#### HTTP 请求方法\n\n常见的 HTTP 请求方法有以下几个。\n\n- GET 方法：该方法发送请求来取得服务器上的资源，一般来说 GET 方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。\n- POST 方法：该方法向将指定资源的最新数据传送给服务器取代指定的资源的内容，POST 方法是非幂等的方法，因为这个请求可能会创建新的资源或 / 和修改现有资源。\n- PUT 方法：类似 POST 方法，该方法指定了资源在服务器上的位置，进行数据提交或数据更新\n- PARTCH 方法：该方法出现的较晚，它在 2010 年的 RFC 5789 标准中被定义。一般用于资源的部分更新，而 PUT 一般用于资源的整体更新。另外，当资源不存在时，PATCH 会创建一个新的资源，而 PUT 只会对已在资源进行更新。\n- HEAD 方法：该方法只请求页面的首部，也就是说服务端的返回不含内容部分。这个方法，允许我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD 方法常被用于客户端查看服务器的性能。\n- DELETE 方法：该方法删除服务器上的某资源或者数据。\n- OPTIONS 方法：该方法用于获取指定服务能够支持的方法。当请求成功时，客户端会得到相关头部信息，指定了服务能够支持的方法，比如“GET、POST”等。JavaScript 的 XMLHttpRequest 对象进行 CORS 跨域资源共享时，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。\n- TRACE 方法：被用于激发一个远程的，应用层的请求消息回路，该方法主要用于 HTTP 请求的测试或诊断。\n- CONNECT 方法：HTTP/1.1 协议预留的，能够将连接改为管道方式的代理服务器。通常用于 SSL 加密服务器的链接与非加密的 HTTP 代理服务器的通信。\n\n我们再从 HTTP 方法的安全性和幂等性角度来进行总结：\n\n- 安全性是说**多次调用不会产生副作用**，换句话说，**安全的方法不会修改资源状态；**\n- 幂等性，是指该方法**多次调用返回的效果（形式）一致**，客户端可以重复调用并且期望同样的结果。\n\n![3](https://images.gitbook.cn/25525660-e268-11e9-9514-611dbba450a7)\n\n**这些内容对应的面试考点：**\n\n- GET/POST 区别\n- OPTIONS 理解，以及跨域相关内容\n- Restful 相关内容\n\n#### 如何理解 HTTP 协议是无状态的\n\n综合以上内容，我们来分析一个面试常考题目：如何理解 HTTP 协议是无状态的？\n\n我们之所以说 HTTP 协议是无状态的，其实指的是客户端和服务器的通信，每个请求之间是独立的，指的是 HTTP 协议对于独立的请求是没有记忆能力的。\n\n通俗点说，我们的应用发送一个请求，和下一次再打开该应用，发送同一个请求，这些请求之间没有任何联系。**HTTP 是一个无状态的面向连接的协议**，但是无状态不代表 HTTP 不能保持 TCP 连接，更不能代表 TCP 不是面向连接的。\n\n#### 其他概念\n\n这一讲不再做更多 HTTP 内容的介绍，更多 HTTP 的知识会在《HTTP 的深思：我从何而来，去向何处》中继续说明。我们来看一些更多的概念。\n\n#### 域名系统\n\n域名系统（Domain Name System，DNS）是因特网的一项核心服务，它作为可以将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网，而不用去记住能够被机器直接读取的 IP 数串。\n\n比如我们经常访问的网站，其域名就相当于其门牌地址，比如 IBM 公司的域名是 www.ibm.com；Cisco 公司的域名是 www.cisco.com。因此对每一个网站进行访问时，都需要对域名和对应的 IP 地址进行映射，具体过程：\n\n- 先过浏览器搜索自己的 DNS 缓存（可以使用 chrome://net-internals/#dns 来进行查看）\n- 上一步未找到对应缓存的 IP 地址时，搜索操作系统中的 DNS 缓存\n- 上一步未找到对应缓存的 IP 地址时，操作系统将域名发送至 LDNS（本地区域名服务器），LDNS 查询 自己的 DNS 缓存（一般查找成功率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求，为什么说这是迭代的 DNS 解析请求呢？这个过程\n\t- LDNS 向 Root Name Server（根域名服务器，如 com、net、org 等解析顶级域名服务器的地址）发起请求，此处，Root Name Server 返回 com 域的顶级域名服务器地址\n\t- LDNS 向 com 域的顶级域名服务器发起请求，返回 baidu.com 域名服务器地址\n\t- LDNS 向 baidu.com 域名服务器发起请求，得到 www.baidu.com 的 IP 地址\nLDNS 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来\n- 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来\n\nDNS 解析整个过程，分为：递归查询过程和迭代查询过程。\n\n读者可以通过：\n\n```\ncat /etc/resolv.conf \n\n```\n\n获取本机 DNS 配置，我的内容为：\n\n![4](https://images.gitbook.cn/b319a7f0-e268-11e9-b138-7fd562c24e16)\n\n再通过：\n\n```\ndig +trace XXX.com\n```\n\n来查看完整的分级查询过程：\n\n![5](https://images.gitbook.cn/c7d211a0-e268-11e9-bb4c-7169754434c1)\n\n**这些内容对应的面试考点：**\n\n- 域名系统相关工作方式\n- 顶级域名、一级域名、二级域名概念\n\n最后，需要说明的是 DNS 使用无连接的 UDP 协议来进行查询，这样的方式降低了开销，也使得速度更快，保证了高效的通信，但是没有太考虑安全问题。它使用目的端口为 53 的 UDP 明文进行通信，这也带来了诸如 DNS 欺骗、DNS Cache 污染、DNS 放大攻击等问题，一些“黑心”运营商就可以利用这一点达到一些别用用心的目的。\n\n针对于此，DNSSec（Domain Name System Security Extensions，也叫「DNS安全扩展」）机制便诞生了，这个机制会让客户端对域名来源身份进行验证，并且检查来自 DNS 域名服务器应答记录的完整性，以及验证是否在传输过程中被篡改过。总之域名系统的安全性话题已经不可忽视。\n\n#### 跨域\n\n跨域其实是浏览器的行为，狭义上说，它指的是浏览器无法执行其他网站的脚本。为什么无法执行呢？这要由浏览器的同源策略说起，简单来说，跨域是浏览器对 JavaScript 施加的安全限制。\n\n> 同源策略（Same Origin Policy）是一种约定，由 Netscape 公司 1995 年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击。\n\n我们都知道，所谓同源，是指“协议、域名、端口”这三要素都相同，在非同源的情况下，以下行为会收到限制：\n\n- 对 Cookie、LocalStorage 和 IndexDB 的读取\n- 对 DOM 和 JS 对象的读取\n- Ajax 请求的正常执行\n\n关于解决跨越方案的内容市面上的资料讲解较多，我们这里不再赘述。\n\n##### **代理和网关**\n\n在 NodeJS “攻城略地”的背景下，前端开发者越来越多地接触到了代理和网关的概念。代理简单来说，是一种有转发功能的应用程序，它扮演了位于两端之间“中间人”的角色。比如在我的一个项目中，公司内部中台有基于 StatsD（StatsD 就是一个简单的网络守护进程，基于 Node.js 平台，通过 UDP 或者 TCP 方式侦听各种统计信息）的数据收集和统计系统，因为 StatsD 是基于 TCP/UDP 的，因此为了在 C 端统计用户行为，我设计了在 NodeJS 层的一个代理机制，对 C 端上报数据进行简单的接受和分发。\n\n网关是转发其他服务器通信数据的服务器，当接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理，其工作机制和代理类似，但网关能力可能更加强大，它不是提供一个单一服务，而是能给通信链路提供平台化的服务，比如鉴权等内容。\n\n更多应用我们暂不展开，本讲会把更多精力放在网络基础知识的学习上。这里只需要读者明白，前端 BFF 层，或代理层，越来越需要开发者对于网络基础知识的理解和运用。\n\n##### URI VS URL\n\n很多开发者并不理解 URI 和 URL 的区别，从名称上来看：\n\n- URL，统一资源定位符\n- URI，统一资源标识符\n\n通俗来说，URL 像是一个邮政编码，URI 就是收件地址。因此可知，URL 的范围大于 URI。我们以淘宝的例子来说，https://www.taobao.com/ 这个域名就是 URL，而每个商品的地址就是一个 URI。\n\n很多 Ajax 请求库的参数都设计成叫做 url，表示请求地址。但实际上，更准确的表达是 URI。\n\n### 网络相关应用\n\n这部分我们来看一些网络知识的应用，同时剖析一些案例。\n\n#### NodeJS 和 TCP\n\n在 NodeJS 中，我们可以很轻松地实现一个基于 TCP 的数据通信过程，主要依赖 net 模块：\n\n```\nlet net = require(&apos;net&apos;)\n\nlet server = net.createServer(socket => {\n    console.log(&apos;客户端已经链接&apos;)\n    console.log(socket.address())\n})\n\nserver.listen(&apos;8080&apos;, () => {\n    /* 获取地址信息，得到的是一个json { address: &apos;::&apos;, family: &apos;IPv6&apos;, port: 8000 } */\n    const address = server.address()\n    \n    /* TCP 服务器监听的地址 */\n    console.log(`the port of server is ${address.port}`)\n    \n    /* IPv6 还是 IPv4 */\n    console.log(`the family of server is ${address.family}`)\n})\n\nserver.getConnections((err,count) => {\n    console.log(`已经链接 ${count} 个用户`)\n})\n\nserver.maxConnections = 2\n```\n\n这样就使用 NodeJS 创建了一个简单的 TCP 服务器，并设置了最大连接数，监听客户端链接数量，以及对事件的处理等。\n\n也可以利用 socket.write 进行 TCP 服务器的数据发送：\n\n```\nvar net = require(\"net\")\n\n/* 创建 TCP 服务器 */\nlet server = net.createServer(socket => {\n    var address = server.address()\n    var message = `the server address is ${JSON.stringify(address)}`\n\n    socket.write(message, () => {\n        let writeSize = socket.bytesWritten\n        console.log(`${message} has send, the size is ${writeSize}`)\n    })\n\n    socket.on(&apos;data&apos;, (data) => {\n        console.log(data.toString())\n        const readSize = socket.bytesRead\n        console.log(`the size of data is ${readSize}`)\n    })\n})\n\nserver.listen(8000, () => {\n    console.log(\"Creat server on http://127.0.0.1:8000/\")\n})\n```\n\n我们也可以用 NodeJS 来构建一个 TCP 客户端，实现 TCP 客户端和 TCP 服务器的通信，这里就不再展开了。\n\n#### NodeJS 和 UDP\n\n关于 NodeJS 实现 UDP 通信，我们需要依靠 dgram 模块，dgram 模块提供了 UDP 数据包 socket 的实现。先看 UDP server 的创建，创建 server.js 文件：\n\n```\nconst dgram = require(&apos;dgram&apos;)\n\n// 创建 UDP server\nlet udpServer = dgram.createSocket(&apos;udp4&apos;)\n// 绑定端口\nudpServer.bind(5678)\n\n// 监听端口\nudpServer.on(&apos;listening&apos;, () => {\n    console.log(&apos;udp server linstening 5678.&apos;)\n})\n\n//接收消息\nudpServer.on(&apos;message&apos;, (message, rinfo) => {\n    const messageStr = message.toString()\n    udpServer.send(messageStr.toString(), 0, messageStr.length, rinfo.port, rinfo.address)\n    console.log(`udp server received data: ${messageStr} from ${rinfo.address}:${rinfo.port}`)\n})\n\n//错误处理\nudpServer.on(&apos;error&apos;, err => {\n    console.log(&apos;some error on udp server.&apos;)\n    udpServer.close()\n})\n```\n\n创建 UDP Client，创建 client.js：\n\n```\nconst dgram = require(&apos;dgram&apos;)\nlet udpClient = dgram.createSocket(&apos;udp4&apos;)\n\nudpClient.on(&apos;close&apos;, () => {\n    console.log(&apos;udp client closed.&apos;)\n})\n\n// 错误处理\nudpClient.on(&apos;error&apos;, () => {\n    console.log(&apos;some error on udp client.&apos;)\n})\n\n// 接收消息\nudpClient.on(&apos;message&apos;, (message, rinfo) => {\n    console.log(`receive message from ${rinfo.address}: ${rinfo.port}: ${message}`)\n})\n\n// 定时向服务器发送消息\nsetInterval(() => {\n    const sendStr = &apos;hello.&apos;\n    const sendStrLen = sendStr.length\n    udpClient.send(sendStr, 0, sendStrLen, 5678, &apos;172.30.20.10&apos;)\n}, 3000)\n```\n\n在上述代码中，读者可以在 UDP Client 结尾处配置好自己的 IP 地址，并启动：\n\n```\nnode server.js\nnode client.js\n```\n\n观察 NodeJS 应用状况。\n\n#### 短网址功能实现\n\n常用微博或者关注运营需求的读者应该知道短网址功能：\n\n![6](https://images.gitbook.cn/e28fecb0-e268-11e9-8cc6-d3303f1d15c4)\n\n简单来说，短网址工具可以将一长串 URL 地址转换成简短的、可访问的短链接形式。自微博盛行以来，在微博字数有限的特色下，短链接盛行于微博网站，以节省微博字数，给博主发布更多文字的空间。\n\n那么一个短网址生成平台该怎么设计呢？其实原理很简单：\n\n- 用户输入完整网址，服务端接收到完整网址之后，根据算法生成一个短码，维护完整网址和短码的映射关系，并将短码完善成短网址，返回给客户端；\n- 任意客户端访问短网址，服务端根据完整网址和短码的映射关系，重定向到对应的页面。\n\n我们看到了熟悉的三个字：重定向，请读者思考这里的重定向应该对应哪个 HTTP 状态码呢？\n\n我们应该在 302 和 301 中进行选择：从语义上看，短网址对应完整网址的映射关系和跳转关系不会发生变化，应该是 301 永久重定向才对。但是更多的短网址生成平台却采用了 302，这是为什么呢？\n\n引自知乎网友的回答，[原文链接](https://www.zhihu.com/question/20103344/answer/573638467)。\n\n> 如果用了 301，Google、百度等搜索引擎，搜索的时候会直接展示真实地址，那我们就无法统计到短地址被点击的次数了，也无法收集用户的 Cookie、User Agent 等信息，这些信息可以用来做很多有意思的大数据分析，也是短网址服务商的主要盈利来源。\n\n完整的设计我们可以借助 MySQL 和 Redis 实现完整网址和短码之间的映射关系。生成短码的算法主要可以考虑以下几种：\n\n- 自增 id，然后将 id 值转换为 62 进制的字符串，为了解决短码长度不固定的问题，可以指定数字开始递增。同时为了解决短码有序的安全隐患，可以结合 md5 进行混淆。一种实现为：\n\n```\nconst string10to62 = number => {\n    const chars = &apos;0123456789abcdefghigklmnopqrstuvwxyzABCDEFGHIGKLMNOPQRSTUVWXYZ&apos;\n    \n    const charsArr = chars.split(&apos;&apos;)\n    const radix = chars.length\n    let qutient = +number\n    let arr = []\n    \n    do {\n        let mod = qutient % radix\n        qutient = (qutient - mod) / radix\n        arr.unshift(charsArr[mod])\n    }\n    while(qutient)\n    \n    return arr.join(&apos;&apos;)\n}\n```\n\n- 哈希算法，直接输入任意长度的数据，输出固定长度的数据，这种算法比较典型，不再过多介绍\n- 随机数：从 62 个字符串中随机取出固定长度的短码组合，然后去数据库中查询该短码是否已存在。如果已存在，就继续循环该方法重新获取短码，否则就直接返回。这种方法最为简单，但是得到碰撞的概率相对较大，一种实现为：\n\n```\nconst generateShortLink = () => {\n    let str = &apos;&apos;\n    const arr = [\n        &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;,\n        &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;, &apos;m&apos;, &apos;n&apos;, &apos;o&apos;, &apos;p&apos;, &apos;q&apos;, &apos;r&apos;, &apos;s&apos;, &apos;t&apos;, &apos;u&apos;, &apos;v&apos;, &apos;w&apos;, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;,\n        &apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;, &apos;H&apos;, &apos;I&apos;, &apos;J&apos;, &apos;K&apos;, &apos;L&apos;, &apos;M&apos;, &apos;N&apos;, &apos;O&apos;, &apos;P&apos;, &apos;Q&apos;, &apos;R&apos;, &apos;S&apos;, &apos;T&apos;, &apos;U&apos;, &apos;V&apos;, &apos;W&apos;, &apos;X&apos;, &apos;Y&apos;, &apos;Z&apos;,\n    ]\n\n    for (let i = 0; i < 6; i++) {\n        const pos = Math.round(Math.random() * (arr.length - 1))\n        str += arr[pos]\n    }\n    return str\n}\n\nasync getShortLink() {\n    const shortLink = this.generateShortLink()\n\n    const searchResult = await this.searchByLinkInMySQL(shortLink)\n\n    if (searchResult && searchResult.length > 0) {\n        return this.getShortLink();\n    }\n    return shortLink\n}\n```\n\n这一部分应用的分析，参考了社区 [shortLink](https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fliucong1%2FshortLink) 的实现和分析内容。读者可进行进一步研究。\n\n#### 扫码登录实现\n\n另外一个我们要介绍的实现是扫码登录，现在授权第三方的扫码登录越来越流行。比如我们可以通过微信实现在第三方应用的登录、注册账号等，这种共用账号体系的能力究竟是如何实现的呢？\n\n其实原理同样并不复杂：\n\n- 首先打开 PC 端页面，PC 端页面生成一个二维码，这个二维码带有服务端下发的一个唯一 id：uuid\n- 接着，手机在微信账号中进行扫码，发送请求，请求包含了上面提到的 uuid 和当前用户的账号信息\n- 与此同时，PC 端不断轮询服务器（或者通过 websocket，服务端主动 push 信息），获取扫码登录的状态\n- 服务端返回扫码状态\n\n针对手机扫码后服务端的返回情况，我们进行梳理：\n\n- PC 端在轮询时，如果扫码超时（手机没有授权登录或者就没扫码），服务端会阻塞一个时限（比如 30s），30s 内无响应，服务端返回状态码 408，得到返回后，前端继续轮询\n- 大约 5 分钟内仍然没有扫码响应，则二维码失效，这时候服务端返回 400\n- 如果手机端扫码成功，服务端返回 201 同时并返回用户信息，并等待用户点击“确认授权登录”\n- 用户“确认授权登录”之后，服务端返回 200 同时返回一个 token；PC 端在拿到下响应后，重定向到目标页面，同时停止轮询\n\n关键理解点：\n\n- 扫码登录一共涉及到三端：服务端、PC 端和手机扫码端\n- PC 端通过轮询，不断向服务端获取用户扫码登录的状态\n- 服务端阻塞 PC 端请求，这样可以减少 PC 端轮询的次数，优化轮询过程\n- 服务端根据手机扫码状态，返回 408、400、201、200 等状态码\n\n#### 断点续传原理\n\n对于大文件的传输/下载，我们常常采用断点续传原理。想象一下在使用迅雷、网盘上传文件内容时，如果网络条件出现问题，我们仍然可以稍后继续进行上传/下载而不至于丢失之前的上传/下载进度。这种断点续传的能力究竟是如何实现的呢？\n\n实现断点续传，需要依靠 HTTP1.1 协议（RFC2616），该协议版本开始支持获取文件的部分内容，这为并行下载以及断点续传提供了技术支持。\n\n在前端发送请求时，需要在 Header 里加入 Range 参数，同时服务器端响应时返回带有 Content-Range 的 Header，也就是说 Range 和 Content-Range 是一对对应的 Header 头。\n\n比如：\n\n```\nRange: bytes=500-999 \n```\n\n就表示上传第 500-999 字节范围的内容，而浏览器在发出带 Range 的请求后，服务器会在 Content-Range 头部返回当前接受的范围和文件总大小，比如：\n\n```\nContent-Range: bytes 0-499/22400\n```\n\n就指当前发送数据的范围是 0-499，22400 则是文件的总 size。\n\n我们来看一个例子：\n\n- 浏览器下载一个 1024K 的文件，当前已经下载了 512K\n- 这时候不幸网络故障，稍后浏览器请求续传，这时候带有 Range:bytes=512000 的 Header 头，表明本次需要续传的片段\n- 服务端接收到断点续传的请求，从文件的 512K 位置开始传输，并返回 Header 头：\nContent-Range:bytes 512000-/1024000，注意这时候的 HTTP status code 是 206，而非 200，206 表示：206 Partial Content（使用断点续传方式）\n\n请读者思考一个问题，如果在网络故障期间，服务器端文件发生了变化，导致 512K 部分并不能对上之前的内容，这个怎么办呢？\n\n这时候就需要一个标识文件唯一性的标识符。RFC2616 中规定可以使用 Last-Modified 顾名思义，这样就可以标识文件的最后修改时间，浏览器就可判断出续传文件时是否已经发生过改动。这种方式并不惟一，也可以通过名为 Etag 的 Header，直接表文件的唯一标记（类似文件的 MD5 值）。浏览器端请求时申明 If-None-Match 或者 If-Modified-Since 字段，帮助服务端判别文件变化，同时浏览器也可以采用 If-Range Header，该头部包含 ETag 头或者是 Last-Modfied 信息，同样可以帮助服务端进行内容校验。这时候，服务端在校验一致时返回 206 的续传回应校验不通过时，服务端则返回 200 回应，回应的内容为新的文件的全部数据。\n\n### 总结\n\n本讲我们以面试为切入点，总结了网络基础知识的多个方面。其中一些知识比较基础，但根据我观察，很多面试者都会在这些基础内容上“折腰”。网络知识是一个系统性的知识体系，还需要每一个开发者认真学习。也许你有体会：“在大学里学习网络知识时，很多概念很难真正理解”，而工作后有一定实战经验了，但是“很多网络内容又缺少了理论的支持”。因此关于网络的学习，我认为一定要理论结合实践。这些计算机基础内容，是一个开发者真正进阶的基本功。","pdfUrl":"","reader":"","duration":"","title":"离不开的网络基础","column":"5c91c813968b1d64b1e08fde","isNotification":false,"readingStatistics":0,"htmlContent":"<p>开启本讲之前，我想先问一句：“网络基础对于前端程序员重不重要”？其实答案是毫无疑问的，如果读者仍然对此有怀疑，那可能你还是刚入行的程序员，相信随着工作经验的增加，你会越来越能意识到网络基础的重要性。事实上，具备必要的网络基础，是对于一个程序员的要求，绝不仅仅是对前端工程师的要求，更何况在 Node.js 发展当下，学好网络知识更是对于前途发展意义重大。</p>\n<p>网络基础其实并不难，但绝不仅仅是一讲的内容就能“融会贯通”的，系统性地学习还需要回炉到大学课本。本讲，我从网络基础概念和场景应用两大方面来讲解，主要内容如下：</p>\n<p><img src=\"https://images.gitbook.cn/568aafc0-e263-11e9-a074-f5ff05024c30\" alt=\"1\" /></p>\n<h3><a id=\"_6\"></a>网络基础知识</h3>\n<p>有一个说法——“大厂前端面试对 HTTP 的要求比 CSS 还要高”，确实从面试的频率上，以 HTTP 为核心的网络基础考察绝对是重点。这些考察点其实并不难，都是基础概念，我们先从几个高频考点入手。</p>\n<p>更为基础的内容，比如计算机网络体系结构，OSI 七层协议等我们不再提及，必要知识需要读者先行了解。</p>\n<h4><a id=\"TCP__UDP_12\"></a>TCP 和 UDP</h4>\n<p>TCP 和 UDP 是运输层的两种协议，什么是运输层呢？</p>\n<blockquote>\n<p>运输层（Transport Layer）就是负责向两台主机进程之间的通信提供通用的数据传输服务，应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。</p>\n</blockquote>\n<p>对于 TCP 和 UDP 这两种协议的理解，我们可以主要从其特点和区别来掌握。</p>\n<p>传输控制协议 TCP（Transmisson Control Protocol）是一种<strong>面向连接的、可靠的</strong>数据传输服务。如何理解可靠呢？通过 TCP 协议传送数据可以无差错、不丢失、不重复、并且按序到达；如何理解面向连接呢？就像我们打电话一样，通过拿起电话和挂掉电话来表示连接的建立和中断。此外，TCP 的特点有：</p>\n<ul>\n<li>TCP 提供全双工通信，也就是说双方在连接建立之后，都可以在任何时候进行数据发送</li>\n<li>TCP 两端连接都设有缓存，在发送和接收时都可以利用缓存临时存放数据</li>\n<li>TCP 是面向字节流的</li>\n</ul>\n<p>用户数据协议 UDP（User Datagram Protocol）是一种<strong>无连接的、不保证数据传输的可靠性</strong>的运输层协议。其特点：</p>\n<ul>\n<li>UDP 无连接</li>\n<li>UDP 不保证可靠性，因此不需要维持复杂的链接状态</li>\n<li>UDP 是面向报文的</li>\n<li>UDP 没有拥塞控制</li>\n<li>UDP 支持一对一、一对多、多对一和多对多的交互通信</li>\n</ul>\n<p>因此根据 TCP 和 UDP 的特点，可以选择不同的协议进行场景应用，比如对于直播、实时视频会议，你认为哪种协议更加适合呢？</p>\n<p>因为 UDP 传输速度更快、效率更高，UDP 没有拥塞控制，所以网络出现拥塞不会使源主机的发送速率降低，且直播、实时视频会议丢失一两帧内容对于应用并没有体验性的影响，因此，UDP 对于直播、实时视频会议的场景会更加适合。</p>\n<p><strong>这些内容对应的面试考点：</strong></p>\n<ul>\n<li>比较 TCP 和 UDP</li>\n<li>TCP 和 UDP 的应用场景</li>\n<li>TCP 如何保证传输的可靠性</li>\n</ul>\n<p>前两项考点我们已经有所涉及，现在针对 TCP 如何保证传输的可靠性进行展开。TCP 保证传输的可靠性主要手段有以下几个。</p>\n<ul>\n<li>数据包校验：如果接收端校验出包有错，则进行丢弃且不进行相应。</li>\n<li>对失序数据包重排序：TCP 协议会对失序数据包进行排序，然后再交给应用层。</li>\n<li>丢弃重复数据。</li>\n<li>应答机制：当接收端接收到数据之后，将发送确认信息。</li>\n<li>超时重发：当发送端发出数据后，它启动一个定时器，如果超出计时器的时限，将重发这个报文段。</li>\n<li>流量控制：前面提到过，TCP 连接的每一方都有固定大小的缓冲空间，可防止接收端缓冲区溢出，这就是流量控制。TCP 使用可变大小的滑动窗口协议来进行流量控制。</li>\n</ul>\n<p>最后再补充一点单工/半双工/双工数据通信的概念区分：</p>\n<ul>\n<li>单工数据传输是数据只能在一个方向上传输；</li>\n<li>半双工数据传输允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信；</li>\n<li>全双工数据通信允许数据同时在两个方向上传输，因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力。</li>\n</ul>\n<h4><a id=\"_59\"></a>三次握手和四次挥手</h4>\n<p>上面我们说到 TCP 是面向连接的，那么这个连接过程就涉及到著名的三次握手和四次挥手了。也许对于这些名词我们已经“听烂了”，但是你是否有真正的掌握呢？</p>\n<p>三次握手，简单来说是指当建立一个 TCP 连接时，整个建立过程需要客户端和服务端一共交互三个包，三次握手的目的是连接服务器的指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号并交换 TCP 窗口大小信息。</p>\n<p><img src=\"https://images.gitbook.cn/f192a820-e267-11e9-bb4c-7169754434c1\" alt=\"1\" /></p>\n<p>具体来说 <strong>第一次握手</strong></p>\n<p>开始建立连接时，客户端向服务器发出连接请求报文，报文首部中的同部位 SYN = 1，同时选择一个初始序列号 seq = x ，这时客户端进程进入了 SYN-SENT （同步已发送状态）状态，等待服务器确认。</p>\n<p><strong>第二次握手</strong></p>\n<p>服务器收到 syn 包后，如果同意连接，则发出确认报文；确认报文 ACK = 1，SYN = 1，确认号是 ack = x + 1，同时也要为自己初始化一个序列号 seq = y，此时服务器进程进入了 SYN-RCVD（同步收到）状态。</p>\n<p><strong>第三次握手</strong></p>\n<p>客户端收到服务器的 SYN + ACK 包，要向服务器给出确认。确认报文的 ACK = 1，ack = y + 1，自己的序列号 seq = x + 1。此时，TCP 连接建立，客户端进入 ESTABLISHED （已建立连接）状态。</p>\n<p>四次挥手是指，TCP 连接的终端需要客户端和服务端总共发送四个包，客户端或者服务器端均可主动发起挥手动作。</p>\n<p><img src=\"https://images.gitbook.cn/08126450-e268-11e9-9514-611dbba450a7\" alt=\"2\" /></p>\n<p>具体来说，<strong>第一次挥手</strong></p>\n<p>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部 FIN = 1，其序列号为 seq = u（等于前面已经传送过来的数据最后一个字节的序号加 1）。此时，客户端进入 FIN-WAIT-1（终止等待 1）状态。</p>\n<p><strong>第二次挥手</strong></p>\n<p>服务器收到连接释放报文，发出确认报文，ACK = 1，ack = u + 1，并且带上自己的序列号 seq = v（客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受），此时，服务端就进入了 CLOSE-WAIT（关闭等待）状态。</p>\n<p><strong>第三次挥手</strong></p>\n<p>服务器将最后的数据发送完毕后，就向客户端发送连接中断报文，FIN = 1，ack = u + 1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq = w，此时，服务器就进入了 LAST-ACK（最后确认）状态，等待客户端的确认。</p>\n<p><strong>第四次挥手</strong></p>\n<p>客户端收到服务器的连接释放报文后，必须发出确认，ACK = 1，ack = w + 1，而自己的序列号是 seq = u + 1。此时，客户端就进入了 TIME-WAIT（时间等待）状态。</p>\n<p>服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接（注意此时 TCP 连接还没有释放，必须经过 2MSL（最长报文段寿命）的时间后，当客户端撤销相应的 TCB 后，才进入 CLOSED 状态）。服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接。</p>\n<p><strong>这些内容对应的面试考点：</strong></p>\n<ul>\n<li>三次握手和四次挥手过程</li>\n<li>三次握手和四次挥手的必要性，不做行不行？</li>\n</ul>\n<h4><a id=\"HTTP__106\"></a>HTTP 响应常见状态码</h4>\n<p>HTTP 响应常见状态码这里只做一个速查总结。</p>\n<ul>\n<li>100-199：表示成功接收请求, 要求客户端继续提交下一次请求才能完成整个处理过程，常见的有 101（客户要求服务器转换 HTTP 协议版本）、100（客户必须继续发出请求）</li>\n<li>200-299：表示成功接收请求并已完成整个处理过程</li>\n<li>300-399：需要客户进一步细化需求，以进一步完成请求，常用的有 301（永久重定向）、302（临时重定向）、304（缓存相关）</li>\n<li>400-499：请求出错，包含语法错误或者无法正确执行逻辑，常用的有 404（无对应资源）、401（权限问题）、403 （服务器拒绝请求）</li>\n<li>500-599：服务器端程序处理出现错误，常见的有 502（错误网关）、504（网关超时）、505（HTTP 版本不受支持）</li>\n</ul>\n<p>列举更加具体的状态码说明，出自：<a href=\"https://juejin.im/entry/586b5b7dac502e12d62b4f33\" target=\"_blank\">HTTP Status Code</a></p>\n<pre><code class=\"lang-\">100     //继续 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分\n101     //切换协议  请求者已要求服务器切换协议，服务器已确认并准备切换\n\n200     //成功  服务器已经成功处理了请求，通常，这表示服务器提供了请求的网页\n201     //已创建  请求成功并且服务器创建了新的资源\n202     //已接受  服务器已接受请求，但尚未处理\n203     //非授权信息  服务器已经成功处理了请求，但返回的信息可能来自另一来源\n204     //无内容  服务器成功处理了请求，但没有返回任何内容\n205     //重置内容  服务器成功处理了请求，但没有返回任何内容\n206     //部分内容  服务器成功处理了部分 GET 请求\n\n300     //多种选择  针对请求，服务器可执行多种操作。服务器可根据请求者（user agent）选择一项操作，或提供操作列表供请求者选择\n301     //永久移动  请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置\n302     //临时移动  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求\n303     //查看其他位置  请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码\n304     //未修改  自动上次请求后，请求的网页未修改过。服务器返回此响应，不会返回网页的内容\n305     //使用代理  请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理\n307     //临时性重定向  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有的位置来进行以后的请求\n\n\n400     //错误请求  服务器不理解请求的语法\n401     //未授权  请求要求身份验证。对于需要登录的网页，服务器可能返回此响应\n403     //禁止  服务器拒绝请求\n404     //未找到  服务器找不到请求的网页\n405     //方法禁用  禁用请求中指定的方法\n406     //不接受  无法使用请求的内容特性响应请求的网页\n407     //需要代理授权  此状态码与401（未授权）类似，但指定请求者应当授权使用代理\n408     //请求超时  服务器等候请求时发生超时\n409     //冲突  服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息\n410     //已删除  如果请求的资源已永久删除，服务器就会返回此响应\n411     //需要有效长度  服务器不接受不含有效内容长度标头字段的请求\n412     //未满足前提条件  服务器未满足请求者在请求者设置的其中一个前提条件\n413     //请求实体过大  服务器无法处理请求，因为请求实体过大，超出了服务器的处理能力\n414     //请求的URI过长  请求的URI（通常为网址）过长，服务器无法处理\n415     //不支持媒体类型  请求的格式不受请求页面的支持\n416     //请求范围不符合要求  如果页面无法提供请求的范围，则服务器会返回此状态码\n417     //未满足期望值  服务器未满足“期望”请求标头字段的要求\n\n500     //服务器内部错误  服务器遇到错误，无法完成请求\n501     //尚未实施  服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码\n502     //错误网关  服务器作为网关或代理，从上游服务器无法收到无效响应\n503     //服务器不可用  服务器目前无法使用（由于超载或者停机维护）。通常，这只是暂时状态\n504     //网关超时  服务器作为网关代理，但是没有及时从上游服务器收到请求\n505     //HTTP 版本不受支持  服务器不支持请求中所用的 HTTP 协议版本\n</code></pre>\n<p><strong>这些内容对应的面试考点：</strong></p>\n<ul>\n<li>状态码的熟悉程度</li>\n<li>缓存相关状态码</li>\n<li>Restful 相关内容</li>\n</ul>\n<h4><a id=\"HTTP__171\"></a>HTTP 请求方法</h4>\n<p>常见的 HTTP 请求方法有以下几个。</p>\n<ul>\n<li>GET 方法：该方法发送请求来取得服务器上的资源，一般来说 GET 方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。</li>\n<li>POST 方法：该方法向将指定资源的最新数据传送给服务器取代指定的资源的内容，POST 方法是非幂等的方法，因为这个请求可能会创建新的资源或 / 和修改现有资源。</li>\n<li>PUT 方法：类似 POST 方法，该方法指定了资源在服务器上的位置，进行数据提交或数据更新</li>\n<li>PARTCH 方法：该方法出现的较晚，它在 2010 年的 RFC 5789 标准中被定义。一般用于资源的部分更新，而 PUT 一般用于资源的整体更新。另外，当资源不存在时，PATCH 会创建一个新的资源，而 PUT 只会对已在资源进行更新。</li>\n<li>HEAD 方法：该方法只请求页面的首部，也就是说服务端的返回不含内容部分。这个方法，允许我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD 方法常被用于客户端查看服务器的性能。</li>\n<li>DELETE 方法：该方法删除服务器上的某资源或者数据。</li>\n<li>OPTIONS 方法：该方法用于获取指定服务能够支持的方法。当请求成功时，客户端会得到相关头部信息，指定了服务能够支持的方法，比如“GET、POST”等。JavaScript 的 XMLHttpRequest 对象进行 CORS 跨域资源共享时，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。</li>\n<li>TRACE 方法：被用于激发一个远程的，应用层的请求消息回路，该方法主要用于 HTTP 请求的测试或诊断。</li>\n<li>CONNECT 方法：HTTP/1.1 协议预留的，能够将连接改为管道方式的代理服务器。通常用于 SSL 加密服务器的链接与非加密的 HTTP 代理服务器的通信。</li>\n</ul>\n<p>我们再从 HTTP 方法的安全性和幂等性角度来进行总结：</p>\n<ul>\n<li>安全性是说<strong>多次调用不会产生副作用</strong>，换句话说，<strong>安全的方法不会修改资源状态；</strong></li>\n<li>幂等性，是指该方法<strong>多次调用返回的效果（形式）一致</strong>，客户端可以重复调用并且期望同样的结果。</li>\n</ul>\n<p><img src=\"https://images.gitbook.cn/25525660-e268-11e9-9514-611dbba450a7\" alt=\"3\" /></p>\n<p><strong>这些内容对应的面试考点：</strong></p>\n<ul>\n<li>GET/POST 区别</li>\n<li>OPTIONS 理解，以及跨域相关内容</li>\n<li>Restful 相关内容</li>\n</ul>\n<h4><a id=\"_HTTP__198\"></a>如何理解 HTTP 协议是无状态的</h4>\n<p>综合以上内容，我们来分析一个面试常考题目：如何理解 HTTP 协议是无状态的？</p>\n<p>我们之所以说 HTTP 协议是无状态的，其实指的是客户端和服务器的通信，每个请求之间是独立的，指的是 HTTP 协议对于独立的请求是没有记忆能力的。</p>\n<p>通俗点说，我们的应用发送一个请求，和下一次再打开该应用，发送同一个请求，这些请求之间没有任何联系。<strong>HTTP 是一个无状态的面向连接的协议</strong>，但是无状态不代表 HTTP 不能保持 TCP 连接，更不能代表 TCP 不是面向连接的。</p>\n<h4><a id=\"_206\"></a>其他概念</h4>\n<p>这一讲不再做更多 HTTP 内容的介绍，更多 HTTP 的知识会在《HTTP 的深思：我从何而来，去向何处》中继续说明。我们来看一些更多的概念。</p>\n<h4><a id=\"_210\"></a>域名系统</h4>\n<p>域名系统（Domain Name System，DNS）是因特网的一项核心服务，它作为可以将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网，而不用去记住能够被机器直接读取的 IP 数串。</p>\n<p>比如我们经常访问的网站，其域名就相当于其门牌地址，比如 IBM 公司的域名是 www.ibm.com；Cisco 公司的域名是 www.cisco.com。因此对每一个网站进行访问时，都需要对域名和对应的 IP 地址进行映射，具体过程：</p>\n<ul>\n<li>先过浏览器搜索自己的 DNS 缓存（可以使用 chrome://net-internals/#dns 来进行查看）</li>\n<li>上一步未找到对应缓存的 IP 地址时，搜索操作系统中的 DNS 缓存</li>\n<li>上一步未找到对应缓存的 IP 地址时，操作系统将域名发送至 LDNS（本地区域名服务器），LDNS 查询 自己的 DNS 缓存（一般查找成功率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求，为什么说这是迭代的 DNS 解析请求呢？这个过程\n<ul>\n<li>LDNS 向 Root Name Server（根域名服务器，如 com、net、org 等解析顶级域名服务器的地址）发起请求，此处，Root Name Server 返回 com 域的顶级域名服务器地址</li>\n<li>LDNS 向 com 域的顶级域名服务器发起请求，返回 baidu.com 域名服务器地址</li>\n<li>LDNS 向 baidu.com 域名服务器发起请求，得到 www.baidu.com 的 IP 地址<br />\nLDNS 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来</li>\n</ul>\n</li>\n<li>操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来</li>\n</ul>\n<p>DNS 解析整个过程，分为：递归查询过程和迭代查询过程。</p>\n<p>读者可以通过：</p>\n<pre><code class=\"lang-\">cat /etc/resolv.conf \n\n</code></pre>\n<p>获取本机 DNS 配置，我的内容为：</p>\n<p><img src=\"https://images.gitbook.cn/b319a7f0-e268-11e9-b138-7fd562c24e16\" alt=\"4\" /></p>\n<p>再通过：</p>\n<pre><code class=\"lang-\">dig +trace XXX.com\n</code></pre>\n<p>来查看完整的分级查询过程：</p>\n<p><img src=\"https://images.gitbook.cn/c7d211a0-e268-11e9-bb4c-7169754434c1\" alt=\"5\" /></p>\n<p><strong>这些内容对应的面试考点：</strong></p>\n<ul>\n<li>域名系统相关工作方式</li>\n<li>顶级域名、一级域名、二级域名概念</li>\n</ul>\n<p>最后，需要说明的是 DNS 使用无连接的 UDP 协议来进行查询，这样的方式降低了开销，也使得速度更快，保证了高效的通信，但是没有太考虑安全问题。它使用目的端口为 53 的 UDP 明文进行通信，这也带来了诸如 DNS 欺骗、DNS Cache 污染、DNS 放大攻击等问题，一些“黑心”运营商就可以利用这一点达到一些别用用心的目的。</p>\n<p>针对于此，DNSSec（Domain Name System Security Extensions，也叫「DNS安全扩展」）机制便诞生了，这个机制会让客户端对域名来源身份进行验证，并且检查来自 DNS 域名服务器应答记录的完整性，以及验证是否在传输过程中被篡改过。总之域名系统的安全性话题已经不可忽视。</p>\n<h4><a id=\"_257\"></a>跨域</h4>\n<p>跨域其实是浏览器的行为，狭义上说，它指的是浏览器无法执行其他网站的脚本。为什么无法执行呢？这要由浏览器的同源策略说起，简单来说，跨域是浏览器对 JavaScript 施加的安全限制。</p>\n<blockquote>\n<p>同源策略（Same Origin Policy）是一种约定，由 Netscape 公司 1995 年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击。</p>\n</blockquote>\n<p>我们都知道，所谓同源，是指“协议、域名、端口”这三要素都相同，在非同源的情况下，以下行为会收到限制：</p>\n<ul>\n<li>对 Cookie、LocalStorage 和 IndexDB 的读取</li>\n<li>对 DOM 和 JS 对象的读取</li>\n<li>Ajax 请求的正常执行</li>\n</ul>\n<p>关于解决跨越方案的内容市面上的资料讲解较多，我们这里不再赘述。</p>\n<h5><a id=\"_271\"></a><strong>代理和网关</strong></h5>\n<p>在 NodeJS “攻城略地”的背景下，前端开发者越来越多地接触到了代理和网关的概念。代理简单来说，是一种有转发功能的应用程序，它扮演了位于两端之间“中间人”的角色。比如在我的一个项目中，公司内部中台有基于 StatsD（StatsD 就是一个简单的网络守护进程，基于 Node.js 平台，通过 UDP 或者 TCP 方式侦听各种统计信息）的数据收集和统计系统，因为 StatsD 是基于 TCP/UDP 的，因此为了在 C 端统计用户行为，我设计了在 NodeJS 层的一个代理机制，对 C 端上报数据进行简单的接受和分发。</p>\n<p>网关是转发其他服务器通信数据的服务器，当接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理，其工作机制和代理类似，但网关能力可能更加强大，它不是提供一个单一服务，而是能给通信链路提供平台化的服务，比如鉴权等内容。</p>\n<p>更多应用我们暂不展开，本讲会把更多精力放在网络基础知识的学习上。这里只需要读者明白，前端 BFF 层，或代理层，越来越需要开发者对于网络基础知识的理解和运用。</p>\n<h5><a id=\"URI_VS_URL_279\"></a>URI VS URL</h5>\n<p>很多开发者并不理解 URI 和 URL 的区别，从名称上来看：</p>\n<ul>\n<li>URL，统一资源定位符</li>\n<li>URI，统一资源标识符</li>\n</ul>\n<p>通俗来说，URL 像是一个邮政编码，URI 就是收件地址。因此可知，URL 的范围大于 URI。我们以淘宝的例子来说，https://www.taobao.com/ 这个域名就是 URL，而每个商品的地址就是一个 URI。</p>\n<p>很多 Ajax 请求库的参数都设计成叫做 url，表示请求地址。但实际上，更准确的表达是 URI。</p>\n<h3><a id=\"_290\"></a>网络相关应用</h3>\n<p>这部分我们来看一些网络知识的应用，同时剖析一些案例。</p>\n<h4><a id=\"NodeJS__TCP_294\"></a>NodeJS 和 TCP</h4>\n<p>在 NodeJS 中，我们可以很轻松地实现一个基于 TCP 的数据通信过程，主要依赖 net 模块：</p>\n<pre><code class=\"lang-\">let net = require(&apos;net&apos;)\n\nlet server = net.createServer(socket =&gt; {\n    console.log(&apos;客户端已经链接&apos;)\n    console.log(socket.address())\n})\n\nserver.listen(&apos;8080&apos;, () =&gt; {\n    /* 获取地址信息，得到的是一个json { address: &apos;::&apos;, family: &apos;IPv6&apos;, port: 8000 } */\n    const address = server.address()\n    \n    /* TCP 服务器监听的地址 */\n    console.log(`the port of server is ${address.port}`)\n    \n    /* IPv6 还是 IPv4 */\n    console.log(`the family of server is ${address.family}`)\n})\n\nserver.getConnections((err,count) =&gt; {\n    console.log(`已经链接 ${count} 个用户`)\n})\n\nserver.maxConnections = 2\n</code></pre>\n<p>这样就使用 NodeJS 创建了一个简单的 TCP 服务器，并设置了最大连接数，监听客户端链接数量，以及对事件的处理等。</p>\n<p>也可以利用 socket.write 进行 TCP 服务器的数据发送：</p>\n<pre><code class=\"lang-\">var net = require(&quot;net&quot;)\n\n/* 创建 TCP 服务器 */\nlet server = net.createServer(socket =&gt; {\n    var address = server.address()\n    var message = `the server address is ${JSON.stringify(address)}`\n\n    socket.write(message, () =&gt; {\n        let writeSize = socket.bytesWritten\n        console.log(`${message} has send, the size is ${writeSize}`)\n    })\n\n    socket.on(&apos;data&apos;, (data) =&gt; {\n        console.log(data.toString())\n        const readSize = socket.bytesRead\n        console.log(`the size of data is ${readSize}`)\n    })\n})\n\nserver.listen(8000, () =&gt; {\n    console.log(&quot;Creat server on http://127.0.0.1:8000/&quot;)\n})\n</code></pre>\n<p>我们也可以用 NodeJS 来构建一个 TCP 客户端，实现 TCP 客户端和 TCP 服务器的通信，这里就不再展开了。</p>\n<h4><a id=\"NodeJS__UDP_355\"></a>NodeJS 和 UDP</h4>\n<p>关于 NodeJS 实现 UDP 通信，我们需要依靠 dgram 模块，dgram 模块提供了 UDP 数据包 socket 的实现。先看 UDP server 的创建，创建 server.js 文件：</p>\n<pre><code class=\"lang-\">const dgram = require(&apos;dgram&apos;)\n\n// 创建 UDP server\nlet udpServer = dgram.createSocket(&apos;udp4&apos;)\n// 绑定端口\nudpServer.bind(5678)\n\n// 监听端口\nudpServer.on(&apos;listening&apos;, () =&gt; {\n    console.log(&apos;udp server linstening 5678.&apos;)\n})\n\n//接收消息\nudpServer.on(&apos;message&apos;, (message, rinfo) =&gt; {\n    const messageStr = message.toString()\n    udpServer.send(messageStr.toString(), 0, messageStr.length, rinfo.port, rinfo.address)\n    console.log(`udp server received data: ${messageStr} from ${rinfo.address}:${rinfo.port}`)\n})\n\n//错误处理\nudpServer.on(&apos;error&apos;, err =&gt; {\n    console.log(&apos;some error on udp server.&apos;)\n    udpServer.close()\n})\n</code></pre>\n<p>创建 UDP Client，创建 client.js：</p>\n<pre><code class=\"lang-\">const dgram = require(&apos;dgram&apos;)\nlet udpClient = dgram.createSocket(&apos;udp4&apos;)\n\nudpClient.on(&apos;close&apos;, () =&gt; {\n    console.log(&apos;udp client closed.&apos;)\n})\n\n// 错误处理\nudpClient.on(&apos;error&apos;, () =&gt; {\n    console.log(&apos;some error on udp client.&apos;)\n})\n\n// 接收消息\nudpClient.on(&apos;message&apos;, (message, rinfo) =&gt; {\n    console.log(`receive message from ${rinfo.address}: ${rinfo.port}: ${message}`)\n})\n\n// 定时向服务器发送消息\nsetInterval(() =&gt; {\n    const sendStr = &apos;hello.&apos;\n    const sendStrLen = sendStr.length\n    udpClient.send(sendStr, 0, sendStrLen, 5678, &apos;172.30.20.10&apos;)\n}, 3000)\n</code></pre>\n<p>在上述代码中，读者可以在 UDP Client 结尾处配置好自己的 IP 地址，并启动：</p>\n<pre><code class=\"lang-\">node server.js\nnode client.js\n</code></pre>\n<p>观察 NodeJS 应用状况。</p>\n<h4><a id=\"_423\"></a>短网址功能实现</h4>\n<p>常用微博或者关注运营需求的读者应该知道短网址功能：</p>\n<p><img src=\"https://images.gitbook.cn/e28fecb0-e268-11e9-8cc6-d3303f1d15c4\" alt=\"6\" /></p>\n<p>简单来说，短网址工具可以将一长串 URL 地址转换成简短的、可访问的短链接形式。自微博盛行以来，在微博字数有限的特色下，短链接盛行于微博网站，以节省微博字数，给博主发布更多文字的空间。</p>\n<p>那么一个短网址生成平台该怎么设计呢？其实原理很简单：</p>\n<ul>\n<li>用户输入完整网址，服务端接收到完整网址之后，根据算法生成一个短码，维护完整网址和短码的映射关系，并将短码完善成短网址，返回给客户端；</li>\n<li>任意客户端访问短网址，服务端根据完整网址和短码的映射关系，重定向到对应的页面。</li>\n</ul>\n<p>我们看到了熟悉的三个字：重定向，请读者思考这里的重定向应该对应哪个 HTTP 状态码呢？</p>\n<p>我们应该在 302 和 301 中进行选择：从语义上看，短网址对应完整网址的映射关系和跳转关系不会发生变化，应该是 301 永久重定向才对。但是更多的短网址生成平台却采用了 302，这是为什么呢？</p>\n<p>引自知乎网友的回答，<a href=\"https://www.zhihu.com/question/20103344/answer/573638467\" target=\"_blank\">原文链接</a>。</p>\n<blockquote>\n<p>如果用了 301，Google、百度等搜索引擎，搜索的时候会直接展示真实地址，那我们就无法统计到短地址被点击的次数了，也无法收集用户的 Cookie、User Agent 等信息，这些信息可以用来做很多有意思的大数据分析，也是短网址服务商的主要盈利来源。</p>\n</blockquote>\n<p>完整的设计我们可以借助 MySQL 和 Redis 实现完整网址和短码之间的映射关系。生成短码的算法主要可以考虑以下几种：</p>\n<ul>\n<li>自增 id，然后将 id 值转换为 62 进制的字符串，为了解决短码长度不固定的问题，可以指定数字开始递增。同时为了解决短码有序的安全隐患，可以结合 md5 进行混淆。一种实现为：</li>\n</ul>\n<pre><code class=\"lang-\">const string10to62 = number =&gt; {\n    const chars = &apos;0123456789abcdefghigklmnopqrstuvwxyzABCDEFGHIGKLMNOPQRSTUVWXYZ&apos;\n    \n    const charsArr = chars.split(&apos;&apos;)\n    const radix = chars.length\n    let qutient = +number\n    let arr = []\n    \n    do {\n        let mod = qutient % radix\n        qutient = (qutient - mod) / radix\n        arr.unshift(charsArr[mod])\n    }\n    while(qutient)\n    \n    return arr.join(&apos;&apos;)\n}\n</code></pre>\n<ul>\n<li>哈希算法，直接输入任意长度的数据，输出固定长度的数据，这种算法比较典型，不再过多介绍</li>\n<li>随机数：从 62 个字符串中随机取出固定长度的短码组合，然后去数据库中查询该短码是否已存在。如果已存在，就继续循环该方法重新获取短码，否则就直接返回。这种方法最为简单，但是得到碰撞的概率相对较大，一种实现为：</li>\n</ul>\n<pre><code class=\"lang-\">const generateShortLink = () =&gt; {\n    let str = &apos;&apos;\n    const arr = [\n        &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;,\n        &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;, &apos;m&apos;, &apos;n&apos;, &apos;o&apos;, &apos;p&apos;, &apos;q&apos;, &apos;r&apos;, &apos;s&apos;, &apos;t&apos;, &apos;u&apos;, &apos;v&apos;, &apos;w&apos;, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;,\n        &apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;, &apos;H&apos;, &apos;I&apos;, &apos;J&apos;, &apos;K&apos;, &apos;L&apos;, &apos;M&apos;, &apos;N&apos;, &apos;O&apos;, &apos;P&apos;, &apos;Q&apos;, &apos;R&apos;, &apos;S&apos;, &apos;T&apos;, &apos;U&apos;, &apos;V&apos;, &apos;W&apos;, &apos;X&apos;, &apos;Y&apos;, &apos;Z&apos;,\n    ]\n\n    for (let i = 0; i &lt; 6; i++) {\n        const pos = Math.round(Math.random() * (arr.length - 1))\n        str += arr[pos]\n    }\n    return str\n}\n\nasync getShortLink() {\n    const shortLink = this.generateShortLink()\n\n    const searchResult = await this.searchByLinkInMySQL(shortLink)\n\n    if (searchResult &amp;&amp; searchResult.length &gt; 0) {\n        return this.getShortLink();\n    }\n    return shortLink\n}\n</code></pre>\n<p>这一部分应用的分析，参考了社区 <a href=\"https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fliucong1%2FshortLink\" target=\"_blank\">shortLink</a> 的实现和分析内容。读者可进行进一步研究。</p>\n<h4><a id=\"_501\"></a>扫码登录实现</h4>\n<p>另外一个我们要介绍的实现是扫码登录，现在授权第三方的扫码登录越来越流行。比如我们可以通过微信实现在第三方应用的登录、注册账号等，这种共用账号体系的能力究竟是如何实现的呢？</p>\n<p>其实原理同样并不复杂：</p>\n<ul>\n<li>首先打开 PC 端页面，PC 端页面生成一个二维码，这个二维码带有服务端下发的一个唯一 id：uuid</li>\n<li>接着，手机在微信账号中进行扫码，发送请求，请求包含了上面提到的 uuid 和当前用户的账号信息</li>\n<li>与此同时，PC 端不断轮询服务器（或者通过 websocket，服务端主动 push 信息），获取扫码登录的状态</li>\n<li>服务端返回扫码状态</li>\n</ul>\n<p>针对手机扫码后服务端的返回情况，我们进行梳理：</p>\n<ul>\n<li>PC 端在轮询时，如果扫码超时（手机没有授权登录或者就没扫码），服务端会阻塞一个时限（比如 30s），30s 内无响应，服务端返回状态码 408，得到返回后，前端继续轮询</li>\n<li>大约 5 分钟内仍然没有扫码响应，则二维码失效，这时候服务端返回 400</li>\n<li>如果手机端扫码成功，服务端返回 201 同时并返回用户信息，并等待用户点击“确认授权登录”</li>\n<li>用户“确认授权登录”之后，服务端返回 200 同时返回一个 token；PC 端在拿到下响应后，重定向到目标页面，同时停止轮询</li>\n</ul>\n<p>关键理解点：</p>\n<ul>\n<li>扫码登录一共涉及到三端：服务端、PC 端和手机扫码端</li>\n<li>PC 端通过轮询，不断向服务端获取用户扫码登录的状态</li>\n<li>服务端阻塞 PC 端请求，这样可以减少 PC 端轮询的次数，优化轮询过程</li>\n<li>服务端根据手机扫码状态，返回 408、400、201、200 等状态码</li>\n</ul>\n<h4><a id=\"_526\"></a>断点续传原理</h4>\n<p>对于大文件的传输/下载，我们常常采用断点续传原理。想象一下在使用迅雷、网盘上传文件内容时，如果网络条件出现问题，我们仍然可以稍后继续进行上传/下载而不至于丢失之前的上传/下载进度。这种断点续传的能力究竟是如何实现的呢？</p>\n<p>实现断点续传，需要依靠 HTTP1.1 协议（RFC2616），该协议版本开始支持获取文件的部分内容，这为并行下载以及断点续传提供了技术支持。</p>\n<p>在前端发送请求时，需要在 Header 里加入 Range 参数，同时服务器端响应时返回带有 Content-Range 的 Header，也就是说 Range 和 Content-Range 是一对对应的 Header 头。</p>\n<p>比如：</p>\n<pre><code class=\"lang-\">Range: bytes=500-999 \n</code></pre>\n<p>就表示上传第 500-999 字节范围的内容，而浏览器在发出带 Range 的请求后，服务器会在 Content-Range 头部返回当前接受的范围和文件总大小，比如：</p>\n<pre><code class=\"lang-\">Content-Range: bytes 0-499/22400\n</code></pre>\n<p>就指当前发送数据的范围是 0-499，22400 则是文件的总 size。</p>\n<p>我们来看一个例子：</p>\n<ul>\n<li>浏览器下载一个 1024K 的文件，当前已经下载了 512K</li>\n<li>这时候不幸网络故障，稍后浏览器请求续传，这时候带有 Range:bytes=512000 的 Header 头，表明本次需要续传的片段</li>\n<li>服务端接收到断点续传的请求，从文件的 512K 位置开始传输，并返回 Header 头：<br />\nContent-Range:bytes 512000-/1024000，注意这时候的 HTTP status code 是 206，而非 200，206 表示：206 Partial Content（使用断点续传方式）</li>\n</ul>\n<p>请读者思考一个问题，如果在网络故障期间，服务器端文件发生了变化，导致 512K 部分并不能对上之前的内容，这个怎么办呢？</p>\n<p>这时候就需要一个标识文件唯一性的标识符。RFC2616 中规定可以使用 Last-Modified 顾名思义，这样就可以标识文件的最后修改时间，浏览器就可判断出续传文件时是否已经发生过改动。这种方式并不惟一，也可以通过名为 Etag 的 Header，直接表文件的唯一标记（类似文件的 MD5 值）。浏览器端请求时申明 If-None-Match 或者 If-Modified-Since 字段，帮助服务端判别文件变化，同时浏览器也可以采用 If-Range Header，该头部包含 ETag 头或者是 Last-Modfied 信息，同样可以帮助服务端进行内容校验。这时候，服务端在校验一致时返回 206 的续传回应校验不通过时，服务端则返回 200 回应，回应的内容为新的文件的全部数据。</p>\n<h3><a id=\"_559\"></a>总结</h3>\n<p>本讲我们以面试为切入点，总结了网络基础知识的多个方面。其中一些知识比较基础，但根据我观察，很多面试者都会在这些基础内容上“折腰”。网络知识是一个系统性的知识体系，还需要每一个开发者认真学习。也许你有体会：“在大学里学习网络知识时，很多概念很难真正理解”，而工作后有一定实战经验了，但是“很多网络内容又缺少了理论的支持”。因此关于网络的学习，我认为一定要理论结合实践。这些计算机基础内容，是一个开发者真正进阶的基本功。</p>\n","createdAt":"2019-04-21T04:51:23.973Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":45,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FoThASW9dVEPMEo9nP-zaOfbKyLZ"},{"_id":"5cbbf70abbbba80861a35c85","communication_start_time":null,"type":1,"audioPath":"","abstract":"","content":"缓存是网络世界中非常重要的一环，也是解决性能问题最常用的手段之一。说起缓存这个概念，貌似谁都可以说上两句，但又不能完全面面俱到；你可能听说过 etag 或者 if-modified-since 这样的头部，可是并不能梳理好所有这些头部的关系；你可能观察过某个网站或者请求的缓存策略，但是并没有亲自设计并应用个缓存机制；你可能在面试中被问起，在实际开发中踩过坑。\n\n我们将用两节课，彻底梳理缓存知识的方方面面，亲自动手配置尝试，打消那些似懂非懂。主要内容如下：\n\n![0](https://images.gitbook.cn/14a4f400-e270-11e9-bb4c-7169754434c1)\n\n### 缓存概念与分类\n\n其实缓存是一个很“大”的概念，尤其 Web 缓存分为很多种。比如：\n\n- 数据库缓存\n- （代理）服务器缓存\n- CDN 缓存\n- 浏览器缓存\n\n甚至一个函数的执行结果都可以进行缓存。而我们要分析的就是 HTTP 缓存，或者浏览器缓存\n\nHTTP 缓存的官方概念：\n\n> HTTP 缓存（或 Web 缓存）是用于临时存储（缓存）Web文档（如 HTML 页面和图像），以减少服务器延迟的一种信息技术。HTTP 缓存系统会保存下通过这套系统的文档的副本；如果满足某些条件，则可以由缓存满足后续请求。HTTP 缓存系统既可以指设备，也可以指计算机程序。\n\n《HTTP 权威指南》一书中，这样介绍到缓存：\n\n> 在前端开发中，性能一直都是被大家所重视的一点，然而判断一个网站的性能最直观的就是看网页打开的速度。其中提高网页反应速度的一个方式就是使用缓存。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。那么下面我们就来看看服务器端缓存的原理。\n\n目前网络应用中很少有不接入缓存的案例。缓存之所以这么重要，是因为它能带来非常多的好处：\n\n- 使得网页加载和呈现速度更快\n- 减少了不必要的的数据传输，因而节省网络流量和带宽\n- 在上一步的基础上，服务器的负担因此减少\n\n事实上，前两点非常好理解，合理地使用缓存，能够最大限度地读取和利用本地已有的静态资源，减少了数据传输，加快了网页应用的呈现。对于第三点，可能一两个用户的访问对于减小服务器的负担没有明显效果。但请设想高并发的场景，使用缓存对于减小服务器压力非常有帮助。\n\n对于浏览器缓存的分类，分类方式有很多，按缓存位置分类，我们有：\n \n- memory cache\n- disk cache\n- Service Worker 等\n\n浏览器的资源缓存分为 from disk cache 和 from memory cache 两类。当首次访问网页时，资源文件被缓存在内存中，同时也会在本地磁盘中保留一份副本。当用户刷新页面，如果缓存的资源没有过期，那么直接从内存中读取并加载。当用户关闭页面后，当前页面缓存在内存中的资源被清空。当用户再一次访问页面时，如果资源文件的缓存没有过期，那么将从本地磁盘进行加载并再次缓存到内存之中。\n\n关于 from disk cache 和 from memory cache 的区别：\n\n> When you visit a URL in Chrome, the HTML and the other assets(like images) on the page are stored locally in a memory and a disk cache. Chrome will use the memory cache first because it is much faster, but it will also store the page in a disk cache in case you quit your browser or it crashes, because the disk cache is persistent.\n\n翻译：\n\n> 当您访问chrome中的URL时，页面上的HTML和其他资产（如图像）将本地存储在内存和磁盘缓存中。Chrome将首先使用内存缓存，因为它的速度快得多，但它也会将页面存储在磁盘缓存中，以防您退出浏览器或它崩溃，因为磁盘缓存是持久的。\n\n\n如果按失效策略分类，我们有：\n\n- 强缓存\n- 协商缓存\n\n![1](https://images.gitbook.cn/0f95a6a0-e269-11e9-bb4c-7169754434c1)\n\n缓存策略是理解缓存的最重要一环，我们这节课重点了解一下强缓存和协商缓存。说到底缓存最重要的核心就是解决**什么时候使用缓存，什么时候更新缓存**的问题。\n\n#### 强缓存\n\n强缓存是指客户端在第一次请求后，有效时间内不会再去请求服务器，而是直接使用缓存数据。\n\n那么这个过程，就涉及到一个缓存有效时间的判断。在有效时间判断上，HTTP 1.0 和 HTTP 1.1 是有所不同的。\n\nHTTP 1.0 版本规定响应头字段 Expires，它对应一个未来的时间戳。客户端第一次请求之后，服务端下发 Expires 响应头字段，当客户端再次需要请求时，先会对比当前时间和 Expires 头中设置的时间。如果当前时间早于 Expires 时间，那么直接使用缓存数据；反之，需要再次发送请求，更新数据。\n\n响应头如：\n\n```\nExpires:Tue, 13 May 2020 09:33:34 GMT\n```\n\n上述 Expires 信息告诉浏览器：在 2020.05.13 号之前,可以直接使用该文本的缓存副本。\n\nExpires 为负数，那么就等同于 no-cache，正数或零同 max-age 的表意是相同的。\n\n但是使用 Expires 响应头存在一些小的瑕疵，比如：\n\n- 可能会因为服务器和客户端的 GMT 时间不同，出现偏差\n- 如果修改了本地时间，那么客户端端日期可能不准确\n- 写法太复杂，字符串多个空格，少个字母，都会导致非法属性从而设置失效\n\n在 HTTP 1.1 版本中，服务端使用 Cache-control 这个响应头，这个头部更加强大，它具有多个不同值：\n\n- private：表示私有缓存，不能被共有缓存代理服务器缓存，不能在用户间共享，可被用户的浏览器缓存。\n- public：表示共有缓存，可被代理服务器缓存，比如 CDN，允许多用户间共享\n- max-age：值以秒为单位，表示缓存的内容会在该值后过期\n- no-cache：需要使用协商缓存，协商缓存的内容我们后面介绍。注意这个字段并不表示不使用缓存\n- no-store：所有内容都不会被缓存\n- must-revalidate：告诉浏览器，你这必须再次验证检查信息是否过期, 返回的代号就不是 200 而是 304 了\n\n关于 Cache-control 的取值，还有其他情况比如 s-maxage，proxy-revalidate 等，以及 HTTP 1.0 的 Pragma，由于比较少用或已经过气，我们不再过多介绍。\n\n我们看这样的 Cache-control 设置：\n\n```\n//Response Headers\nCache-Control:private, max-age=0, must-revalidate\n```\n\n它表示：该资源只能被浏览器缓存，而不能被代理缓存。max-age 标识为 0，说明该缓存资源立即过期，must-revalidate 告诉浏览器，需要验证文件是否过期，接下来可能会使用协商缓存进行判断。\n\n**HTTP 规定，如果 Cache-control  的 max-age 和 Expires 同时出现，那么 max-age 的优先级更高，他会默认覆盖掉 expires。**\n\n关于 Cache-control 取值总结，我们可以参考 Google developer 的一个图示：\n\n![2](https://images.gitbook.cn/71206530-e26a-11e9-bb4c-7169754434c1)\n\n对于上图的翻译图：\n\n![3](https://images.gitbook.cn/f0915d60-e26a-11e9-bb4c-7169754434c1)\n\n#### 协商缓存\n\n我们进一步思考，强缓存判断的实质上是缓存资源是否超出某个时间或者某个时间段。很多情况是超出了这个时间或时间段，但是资源并没有更新。从优化的角度来说，我们真正应该关心的是服务器端文件是否已经发生了变化。此时我们需要用到协商缓存策略。\n\n那如何做到知晓「服务器端文件是否已经发生了变化」了呢？回到强缓存上，强缓存关于是否使用缓存的决断完全是由浏览器作出的，单一的浏览器是不可能知道「服务器端文件是否已经发生了变化」的。那么协商缓存需要将是否使用缓存的决定权交给服务端，因此协商缓存还是需要一次网络请求的。\n\n协商缓存过程：在浏览器端，当对某个资源的请求没有命中强缓存时，浏览器就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的 HTTP 状态为 304。\n\n现在问题就到服务端如何判断资源有没有过期上了。服务端掌握着最新的资源，那么为了做对比，它需要知道客户端的资源信息。根据 HTTP 协议，这个决断是根据【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对 header 来作出的。\n\n我们先来看【Last-Modified，If-Modified-Since】 这一对 header 主导的协商缓存过程：\n\n- 浏览器第一次请求资源，服务端在返回资源的响应头中加入 Last-Modified 字段，这个字段表示这个资源在服务器上的最近修改时间\n\n```\nLast-Modified: Tue, 12 Jan 2019 09:08:53 GMT\n```\n\n- 浏览器收到响应，并记录 Last-Modified 这个响应头的值为 T\n- 当浏览器再次向服务端请求该资源时，请求头加上 If-Modified-Since 的 header，这个 If-Modified-Since 的值正是上一次请求该资源时，后端返回的 Last-Modified 响应头值 T\n- 服务端再次收到请求，根据请求头 If-Modified-Since 的值 T，判断相关资源是否在 T 时间后有变化；如果没有变化则返回 304 Not Modified，且并不返回资源内容，浏览器使用资源缓存值；如果有变化，则正常返回资源内容，且更新 Last-Modified 响应头内容\n\n我们思考这种基于时间的判断方式和 HTTP 1.0 的 Expires 的问题类似，如果客户端的时间不准确，就会导致判断不可靠；同时 Last-Modified 标注的最后修改只能精确到秒级，如果某些文件在 1 秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间；也要考虑到，一些文件也许会周期性的更改，但是他的内容并不改变，仅仅改变的修改时间，这时候使用  Last-Modified 就不是很合适了。为了弥补这种小缺陷，就有了 【ETag、If-None-Match】这一对 header 头来进行协商缓存的判断。\n\n我们来看 【ETag、If-None-Match】这一对 header 主导的协商缓存过程：\n\n- 浏览器第一次请求资源，服务端在返回资源的响应头中加入 Etag，Etag 能够弥补 Last-Modified 的问题，因为 Etag 的生成过程类似文件 hash 值，Etag 是一个字符串，不同文件内容对应不同的 Etag 值\n\n```\n//response Headers\nETag:\"751F63A30AB5F98F855D1D90D217B356\"\n```\n\n- 浏览器收到响应，记录 Etag 这个响应头的值为 E \n- 浏览器再次跟服务器请求这个资源时，在请求头上加上 If-None-Match，值为 Etag 这个响应头的值 E \n- 服务端再次收到请求，根据请求头 If-None-Match 的值 E，根据资源生成一个新的 ETag，对比 E 和新的 Etag：如果两值相同，则说明资源没有变化，返回 304 Not Modified，同时携带着新的 ETag 响应头；如果两值不同，就正常返回资源内容，这时也更新 ETag 响应头\n- 浏览器收到 304 的响应后，就会从缓存中加载资源\n\n这里需要重点说明一下的是 Etag 的生成策略，实际上规范并没有强制说明，这就取决于各大厂商或平台的自主实现方式了：Apache 中，ETag 的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行混淆后得到的；MDN 使用 wiki 内容的十六进制数字的哈希值。\n\n另外一个需要注意的细节是：Etag 优先级比 Last-Modified 高，如果他们组合出现在请求头当中，我们会优先采用 Etag 策略。同时 Etag 也有自己的问题：相同的资源，在两台服务器产生的 Etag 是不是相同的，所以对于使用服务器集群来处理请求的网站来说， Etag 的匹配概率会大幅降低。所在在这种情况下，使用 Etag 来处理缓存，反而会有更大的开销。\n\n### 流程图\n\n由上述内容我们开出：为了使缓存策略更加可靠，灵活，HTTP 1.0 版本 和 HTTP 1.1 版本的缓存策略一直是在渐进增强的。这也意味着 HTTP 1.0 版本 和 HTTP 1.1 版本关于缓存的特性可以同时使用，强制缓存和协商缓存也会同时使用。当然他们在混合使用时有优先级的限制，我们通过下面这个流程图来做一个总结：\n\n![4](https://images.gitbook.cn/138a0060-e26b-11e9-b138-7fd562c24e16)\n\n根据这个流程，我们该如何合理应用缓存呢？一般来说：\n\n优先级上：Cache-Control > Expires > ETag > Last-Modified\n\n强制缓存优先级最高，并且资源的改动在缓存有效期内浏览器都不会发送请求，因此强制缓存的使用适用于大型且不易修改的的资源文件，例如第三方 CSS、JS 文件或图片资源。如果更加灵活的话，我们也可以为文件名加上 hash 进行版本的区分。\n\n协商缓存灵活性高，适用于数据的缓存，根据上述知识的介绍，采用 Etag 标识进行对比灵活度最高，也最为可靠。对于数据的缓存，我们可以重点考虑存入内存中，因为内存加载速最快，并且数据体积小。\n\n### 总结\n\n这一讲我们梳理了缓存知识体系，实际上缓存并不难理解，只要搞清楚什么时候使用缓存这个关键问题，并以此问题为核心，结合 HTTP 协议关于缓存的发展变革，就很容易掌握理论知识。\n\n下一讲，我们将集中总结常见的缓存面试考察点，并结合实战来巩固知识。","pdfUrl":"","reader":"","duration":"","title":"缓存谁都懂，一问都哑巴（上）","column":"5c91c813968b1d64b1e08fde","isNotification":false,"readingStatistics":0,"htmlContent":"<p>缓存是网络世界中非常重要的一环，也是解决性能问题最常用的手段之一。说起缓存这个概念，貌似谁都可以说上两句，但又不能完全面面俱到；你可能听说过 etag 或者 if-modified-since 这样的头部，可是并不能梳理好所有这些头部的关系；你可能观察过某个网站或者请求的缓存策略，但是并没有亲自设计并应用个缓存机制；你可能在面试中被问起，在实际开发中踩过坑。</p>\n<p>我们将用两节课，彻底梳理缓存知识的方方面面，亲自动手配置尝试，打消那些似懂非懂。主要内容如下：</p>\n<p><img src=\"https://images.gitbook.cn/14a4f400-e270-11e9-bb4c-7169754434c1\" alt=\"0\" /></p>\n<h3><a id=\"_6\"></a>缓存概念与分类</h3>\n<p>其实缓存是一个很“大”的概念，尤其 Web 缓存分为很多种。比如：</p>\n<ul>\n<li>数据库缓存</li>\n<li>（代理）服务器缓存</li>\n<li>CDN 缓存</li>\n<li>浏览器缓存</li>\n</ul>\n<p>甚至一个函数的执行结果都可以进行缓存。而我们要分析的就是 HTTP 缓存，或者浏览器缓存</p>\n<p>HTTP 缓存的官方概念：</p>\n<blockquote>\n<p>HTTP 缓存（或 Web 缓存）是用于临时存储（缓存）Web文档（如 HTML 页面和图像），以减少服务器延迟的一种信息技术。HTTP 缓存系统会保存下通过这套系统的文档的副本；如果满足某些条件，则可以由缓存满足后续请求。HTTP 缓存系统既可以指设备，也可以指计算机程序。</p>\n</blockquote>\n<p>《HTTP 权威指南》一书中，这样介绍到缓存：</p>\n<blockquote>\n<p>在前端开发中，性能一直都是被大家所重视的一点，然而判断一个网站的性能最直观的就是看网页打开的速度。其中提高网页反应速度的一个方式就是使用缓存。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。那么下面我们就来看看服务器端缓存的原理。</p>\n</blockquote>\n<p>目前网络应用中很少有不接入缓存的案例。缓存之所以这么重要，是因为它能带来非常多的好处：</p>\n<ul>\n<li>使得网页加载和呈现速度更快</li>\n<li>减少了不必要的的数据传输，因而节省网络流量和带宽</li>\n<li>在上一步的基础上，服务器的负担因此减少</li>\n</ul>\n<p>事实上，前两点非常好理解，合理地使用缓存，能够最大限度地读取和利用本地已有的静态资源，减少了数据传输，加快了网页应用的呈现。对于第三点，可能一两个用户的访问对于减小服务器的负担没有明显效果。但请设想高并发的场景，使用缓存对于减小服务器压力非常有帮助。</p>\n<p>对于浏览器缓存的分类，分类方式有很多，按缓存位置分类，我们有：</p>\n<ul>\n<li>memory cache</li>\n<li>disk cache</li>\n<li>Service Worker 等</li>\n</ul>\n<p>浏览器的资源缓存分为 from disk cache 和 from memory cache 两类。当首次访问网页时，资源文件被缓存在内存中，同时也会在本地磁盘中保留一份副本。当用户刷新页面，如果缓存的资源没有过期，那么直接从内存中读取并加载。当用户关闭页面后，当前页面缓存在内存中的资源被清空。当用户再一次访问页面时，如果资源文件的缓存没有过期，那么将从本地磁盘进行加载并再次缓存到内存之中。</p>\n<p>关于 from disk cache 和 from memory cache 的区别：</p>\n<blockquote>\n<p>When you visit a URL in Chrome, the HTML and the other assets(like images) on the page are stored locally in a memory and a disk cache. Chrome will use the memory cache first because it is much faster, but it will also store the page in a disk cache in case you quit your browser or it crashes, because the disk cache is persistent.</p>\n</blockquote>\n<p>翻译：</p>\n<blockquote>\n<p>当您访问chrome中的URL时，页面上的HTML和其他资产（如图像）将本地存储在内存和磁盘缓存中。Chrome将首先使用内存缓存，因为它的速度快得多，但它也会将页面存储在磁盘缓存中，以防您退出浏览器或它崩溃，因为磁盘缓存是持久的。</p>\n</blockquote>\n<p>如果按失效策略分类，我们有：</p>\n<ul>\n<li>强缓存</li>\n<li>协商缓存</li>\n</ul>\n<p><img src=\"https://images.gitbook.cn/0f95a6a0-e269-11e9-bb4c-7169754434c1\" alt=\"1\" /></p>\n<p>缓存策略是理解缓存的最重要一环，我们这节课重点了解一下强缓存和协商缓存。说到底缓存最重要的核心就是解决<strong>什么时候使用缓存，什么时候更新缓存</strong>的问题。</p>\n<h4><a id=\"_59\"></a>强缓存</h4>\n<p>强缓存是指客户端在第一次请求后，有效时间内不会再去请求服务器，而是直接使用缓存数据。</p>\n<p>那么这个过程，就涉及到一个缓存有效时间的判断。在有效时间判断上，HTTP 1.0 和 HTTP 1.1 是有所不同的。</p>\n<p>HTTP 1.0 版本规定响应头字段 Expires，它对应一个未来的时间戳。客户端第一次请求之后，服务端下发 Expires 响应头字段，当客户端再次需要请求时，先会对比当前时间和 Expires 头中设置的时间。如果当前时间早于 Expires 时间，那么直接使用缓存数据；反之，需要再次发送请求，更新数据。</p>\n<p>响应头如：</p>\n<pre><code class=\"lang-\">Expires:Tue, 13 May 2020 09:33:34 GMT\n</code></pre>\n<p>上述 Expires 信息告诉浏览器：在 2020.05.13 号之前,可以直接使用该文本的缓存副本。</p>\n<p>Expires 为负数，那么就等同于 no-cache，正数或零同 max-age 的表意是相同的。</p>\n<p>但是使用 Expires 响应头存在一些小的瑕疵，比如：</p>\n<ul>\n<li>可能会因为服务器和客户端的 GMT 时间不同，出现偏差</li>\n<li>如果修改了本地时间，那么客户端端日期可能不准确</li>\n<li>写法太复杂，字符串多个空格，少个字母，都会导致非法属性从而设置失效</li>\n</ul>\n<p>在 HTTP 1.1 版本中，服务端使用 Cache-control 这个响应头，这个头部更加强大，它具有多个不同值：</p>\n<ul>\n<li>private：表示私有缓存，不能被共有缓存代理服务器缓存，不能在用户间共享，可被用户的浏览器缓存。</li>\n<li>public：表示共有缓存，可被代理服务器缓存，比如 CDN，允许多用户间共享</li>\n<li>max-age：值以秒为单位，表示缓存的内容会在该值后过期</li>\n<li>no-cache：需要使用协商缓存，协商缓存的内容我们后面介绍。注意这个字段并不表示不使用缓存</li>\n<li>no-store：所有内容都不会被缓存</li>\n<li>must-revalidate：告诉浏览器，你这必须再次验证检查信息是否过期, 返回的代号就不是 200 而是 304 了</li>\n</ul>\n<p>关于 Cache-control 的取值，还有其他情况比如 s-maxage，proxy-revalidate 等，以及 HTTP 1.0 的 Pragma，由于比较少用或已经过气，我们不再过多介绍。</p>\n<p>我们看这样的 Cache-control 设置：</p>\n<pre><code class=\"lang-\">//Response Headers\nCache-Control:private, max-age=0, must-revalidate\n</code></pre>\n<p>它表示：该资源只能被浏览器缓存，而不能被代理缓存。max-age 标识为 0，说明该缓存资源立即过期，must-revalidate 告诉浏览器，需要验证文件是否过期，接下来可能会使用协商缓存进行判断。</p>\n<p><strong>HTTP 规定，如果 Cache-control  的 max-age 和 Expires 同时出现，那么 max-age 的优先级更高，他会默认覆盖掉 expires。</strong></p>\n<p>关于 Cache-control 取值总结，我们可以参考 Google developer 的一个图示：</p>\n<p><img src=\"https://images.gitbook.cn/71206530-e26a-11e9-bb4c-7169754434c1\" alt=\"2\" /></p>\n<p>对于上图的翻译图：</p>\n<p><img src=\"https://images.gitbook.cn/f0915d60-e26a-11e9-bb4c-7169754434c1\" alt=\"3\" /></p>\n<h4><a id=\"_113\"></a>协商缓存</h4>\n<p>我们进一步思考，强缓存判断的实质上是缓存资源是否超出某个时间或者某个时间段。很多情况是超出了这个时间或时间段，但是资源并没有更新。从优化的角度来说，我们真正应该关心的是服务器端文件是否已经发生了变化。此时我们需要用到协商缓存策略。</p>\n<p>那如何做到知晓「服务器端文件是否已经发生了变化」了呢？回到强缓存上，强缓存关于是否使用缓存的决断完全是由浏览器作出的，单一的浏览器是不可能知道「服务器端文件是否已经发生了变化」的。那么协商缓存需要将是否使用缓存的决定权交给服务端，因此协商缓存还是需要一次网络请求的。</p>\n<p>协商缓存过程：在浏览器端，当对某个资源的请求没有命中强缓存时，浏览器就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的 HTTP 状态为 304。</p>\n<p>现在问题就到服务端如何判断资源有没有过期上了。服务端掌握着最新的资源，那么为了做对比，它需要知道客户端的资源信息。根据 HTTP 协议，这个决断是根据【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对 header 来作出的。</p>\n<p>我们先来看【Last-Modified，If-Modified-Since】 这一对 header 主导的协商缓存过程：</p>\n<ul>\n<li>浏览器第一次请求资源，服务端在返回资源的响应头中加入 Last-Modified 字段，这个字段表示这个资源在服务器上的最近修改时间</li>\n</ul>\n<pre><code class=\"lang-\">Last-Modified: Tue, 12 Jan 2019 09:08:53 GMT\n</code></pre>\n<ul>\n<li>浏览器收到响应，并记录 Last-Modified 这个响应头的值为 T</li>\n<li>当浏览器再次向服务端请求该资源时，请求头加上 If-Modified-Since 的 header，这个 If-Modified-Since 的值正是上一次请求该资源时，后端返回的 Last-Modified 响应头值 T</li>\n<li>服务端再次收到请求，根据请求头 If-Modified-Since 的值 T，判断相关资源是否在 T 时间后有变化；如果没有变化则返回 304 Not Modified，且并不返回资源内容，浏览器使用资源缓存值；如果有变化，则正常返回资源内容，且更新 Last-Modified 响应头内容</li>\n</ul>\n<p>我们思考这种基于时间的判断方式和 HTTP 1.0 的 Expires 的问题类似，如果客户端的时间不准确，就会导致判断不可靠；同时 Last-Modified 标注的最后修改只能精确到秒级，如果某些文件在 1 秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间；也要考虑到，一些文件也许会周期性的更改，但是他的内容并不改变，仅仅改变的修改时间，这时候使用  Last-Modified 就不是很合适了。为了弥补这种小缺陷，就有了 【ETag、If-None-Match】这一对 header 头来进行协商缓存的判断。</p>\n<p>我们来看 【ETag、If-None-Match】这一对 header 主导的协商缓存过程：</p>\n<ul>\n<li>浏览器第一次请求资源，服务端在返回资源的响应头中加入 Etag，Etag 能够弥补 Last-Modified 的问题，因为 Etag 的生成过程类似文件 hash 值，Etag 是一个字符串，不同文件内容对应不同的 Etag 值</li>\n</ul>\n<pre><code class=\"lang-\">//response Headers\nETag:&quot;751F63A30AB5F98F855D1D90D217B356&quot;\n</code></pre>\n<ul>\n<li>浏览器收到响应，记录 Etag 这个响应头的值为 E</li>\n<li>浏览器再次跟服务器请求这个资源时，在请求头上加上 If-None-Match，值为 Etag 这个响应头的值 E</li>\n<li>服务端再次收到请求，根据请求头 If-None-Match 的值 E，根据资源生成一个新的 ETag，对比 E 和新的 Etag：如果两值相同，则说明资源没有变化，返回 304 Not Modified，同时携带着新的 ETag 响应头；如果两值不同，就正常返回资源内容，这时也更新 ETag 响应头</li>\n<li>浏览器收到 304 的响应后，就会从缓存中加载资源</li>\n</ul>\n<p>这里需要重点说明一下的是 Etag 的生成策略，实际上规范并没有强制说明，这就取决于各大厂商或平台的自主实现方式了：Apache 中，ETag 的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行混淆后得到的；MDN 使用 wiki 内容的十六进制数字的哈希值。</p>\n<p>另外一个需要注意的细节是：Etag 优先级比 Last-Modified 高，如果他们组合出现在请求头当中，我们会优先采用 Etag 策略。同时 Etag 也有自己的问题：相同的资源，在两台服务器产生的 Etag 是不是相同的，所以对于使用服务器集群来处理请求的网站来说， Etag 的匹配概率会大幅降低。所在在这种情况下，使用 Etag 来处理缓存，反而会有更大的开销。</p>\n<h3><a id=\"_155\"></a>流程图</h3>\n<p>由上述内容我们开出：为了使缓存策略更加可靠，灵活，HTTP 1.0 版本 和 HTTP 1.1 版本的缓存策略一直是在渐进增强的。这也意味着 HTTP 1.0 版本 和 HTTP 1.1 版本关于缓存的特性可以同时使用，强制缓存和协商缓存也会同时使用。当然他们在混合使用时有优先级的限制，我们通过下面这个流程图来做一个总结：</p>\n<p><img src=\"https://images.gitbook.cn/138a0060-e26b-11e9-b138-7fd562c24e16\" alt=\"4\" /></p>\n<p>根据这个流程，我们该如何合理应用缓存呢？一般来说：</p>\n<p>优先级上：Cache-Control &gt; Expires &gt; ETag &gt; Last-Modified</p>\n<p>强制缓存优先级最高，并且资源的改动在缓存有效期内浏览器都不会发送请求，因此强制缓存的使用适用于大型且不易修改的的资源文件，例如第三方 CSS、JS 文件或图片资源。如果更加灵活的话，我们也可以为文件名加上 hash 进行版本的区分。</p>\n<p>协商缓存灵活性高，适用于数据的缓存，根据上述知识的介绍，采用 Etag 标识进行对比灵活度最高，也最为可靠。对于数据的缓存，我们可以重点考虑存入内存中，因为内存加载速最快，并且数据体积小。</p>\n<h3><a id=\"_169\"></a>总结</h3>\n<p>这一讲我们梳理了缓存知识体系，实际上缓存并不难理解，只要搞清楚什么时候使用缓存这个关键问题，并以此问题为核心，结合 HTTP 协议关于缓存的发展变革，就很容易掌握理论知识。</p>\n<p>下一讲，我们将集中总结常见的缓存面试考察点，并结合实战来巩固知识。</p>\n","createdAt":"2019-04-21T04:52:26.413Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":46,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FoThASW9dVEPMEo9nP-zaOfbKyLZ"},{"_id":"5cbbf750bbbba80861a35c86","communication_start_time":null,"type":1,"audioPath":"","abstract":"","content":"上一讲，我们了解了缓存的几种方式和基本概念；这一讲，让我们从应用和面试的角度出发，巩固理论基础，加深操作印象。\n\n![0](https://images.gitbook.cn/14a4f400-e270-11e9-bb4c-7169754434c1)\n\n### 缓存和浏览器操作\n\n缓存的重要一环是浏览器，常见浏览器行为对应的缓存行为有哪些呢？我们来做一个总结（注意，不同浏览器引擎、不同版本可能会有差别，读者可以根据不同情况酌情参考）：\n\n- 当用户 Ctrl + F5 强制刷新网页时，浏览器直接从服务器加载，跳过强缓存和协商缓存\n- 当用户仅仅敲击 F5 刷新网页时，跳过强缓存，但是仍然会进行协商缓存过程\n\n这里我借用 [Alloy Team](https://link.juejin.im/?target=http%3A%2F%2Fwww.alloyteam.com%2F2012%2F03%2Fweb-cache-2-browser-cache%2F) 的图进行一个总结：\n\n![1](https://images.gitbook.cn/cc134b80-e26d-11e9-bb4c-7169754434c1)\n\n### 缓存相关面试题目\n\n知识点我们已经梳理完毕，是时候刷一下经典题目来巩固了。以下题目都可以在上述知识中找到答案，我们也当做一个总结和考察。\n\n- 题目一：如何禁止浏览器不缓存静态资源\n\n在实际工作中，很多场景都需要禁用浏览器缓存。比如可以使用 Chrome 隐私模式，在代码层面可以设置相关请求头：\n\n```\nCache-Control: no-cache, no-store, must-revalidate\n```\n\n此外，也可以给请求的资源增加一个版本号：\n\n```\n<link rel=\"stylesheet\" type=\"text/css\" href=\"./asset.css?version=1.8.9\"/>\n```\n\n我们也可以使用 Meta 标签来声明缓存规则：\n\n```\n<meta http-equiv=\"Cache-Control\" content=\"no-cache, no-store, must-revalidate\"/>\n```\n\n- 题目二：设置以下 request/response header 会有什么效果？\n\n```\ncache-control: max-age=0\n```\n\n上述响应头属于强缓存，因为 max-age 设置为 0，所以浏览器必须发请求重新验证资源。这时候会走协商缓存机制，可能返回 200 或者 304。\n\n- 题目三：设置以下 request/response header 会有什么效果？\n\n```\ncache-control: no-cache\n```\n\n上述响应头属于强缓存，因为设置 no-cache，所以浏览器必须发请求重新验证资源。这时候会走协商缓存机制。\n\n- 题目四：除了上述方式，还有哪种方式可以设置浏览器必须发请求重新验证资源，走协商缓存机制？\n\n设置 request/response header：\n\n```\ncache-control: must-revalidate\n```\n\n- 题目五：设置以下 request/response header 会有什么效果？\n\n```\nCache-Control: max-age=60, must-revalidate\n```\n\n如果资源在 60s 内再次访问，走强缓存，可以直接返回缓存资源内容；如果超过 60s，则必须发送网络请求到服务端，去验证资源的有效性。\n\n- 题目五：据你的经验，为什么大厂都不怎么用 Etag？\n\n大厂多使用负载分担的方式来调度 HTTP 请求。因此，同一个客户端对同一个页面的多次请求，很可能被分配到不同的服务器来相应，而根据 ETag 的计算原理，不同的服务器，有可能在资源内容没有变化的情况下，计算出不一样的 Etag，而使得缓存失效。\n\n- 题目六：Yahoo 的 YSlow 页面分析工具为什么推荐关闭 ETag?\n\n因为 Etag 计算较为复杂，所以可能会使得服务端响应变慢。\n\n### 缓存实战\n\n我们来通过几个简单的真实项目案例实操一下缓存。\n\n#### 启动项目\n\n首先创建项目：\n\n```\nmkdir cache\nnpm init\n```\n\n之后，得到 package.json，同时声明我们的相关依赖：\n\n```\n{\n  \"name\": \"cache\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Cache demo\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"start\": \"nodemon ./index.js\"\n  },\n  \"keywords\": [\n    \"cache\",\n    \"node\"\n  ],\n  \"devDependencies\": {\n    \"@babel/core\": \"latest\",\n    \"@babel/preset-env\": \"latest\",\n    \"@babel/register\": \"latest\",\n    \"koa\": \"latest\",\n    \"koa-conditional-get\": \"^2.0.0\",\n    \"koa-etag\": \"^3.0.0\",\n    \"koa-static\": \"latest\"\n  },\n  \"dependencies\": {\n    \"nodemon\": \"latest\"\n  },\n  \"license\": \"ISC\"\n}\n```\n\n使用 nodemon 来启动并 watch Node 脚本，同时配置  .babelrc 如下：\n\n```\n{\n \"presets\": [\n   [\n     \"@babel/preset-env\",\n     {\n       \"targets\": {\n         \"node\": \"current\"\n       }\n     }\n   ]\n ]\n}\n```\n\n在 cache/static 目录下，创建 index.html 和一张测试图片 web.png：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" />\n    <title>前端开发核心知识进阶</title>\n    <style>\n      .cache img {\n        display: block;\n        width: 100%;\n      }\n    </style>\n  </head>\n  <body>\n    <div class=\"cache\">\n      <img src=\"./web.png\" />\n    </div>\n  </body>\n</html>\n``` \n\n看一下我们的核心脚本 index.js，其实就是一个简单的 NodeJS 服务：\n\nindex.js：\n\n```\nrequire(&apos;@babel/register&apos;);\nrequire(&apos;./cache.js&apos;);\n```\n\ncache.js：\n\n```\nimport Koa from &apos;koa&apos;\nimport path from &apos;path&apos;\nimport resource from &apos;koa-static&apos;\n\nconst app = new Koa()\nconst host = &apos;localhost&apos;\nconst port = 6666\n\napp.use(resource(path.join(__dirname, &apos;./static&apos;)))\n\napp.listen(port, () => {\n  console.log(`server is listen in ${host}:${port}`)\n})\n```\n\n我们启动：\n\n```\nnpm run start\n```\n\n得到页面：\n\n![2](https://images.gitbook.cn/e5aca3c0-e26d-11e9-bb4c-7169754434c1)\n\n#### 应用缓存\n\n我们来尝试加入一些缓存，首先应用强缓存，只需要在响应头上加入相关字段即可：\n\n```\nimport Koa from &apos;koa&apos;\nimport path from &apos;path&apos;\nimport resource from &apos;koa-static&apos;\n\nconst app = new Koa()\nconst host = &apos;localhost&apos;\nconst port = 5999\n\napp.use(async (ctx, next) => {\n  ctx.set({\n    &apos;Cache-Control&apos;: &apos;max-age=5000&apos;  \n  })\n  await next()\n})\n\napp.use(resource(path.join(__dirname, &apos;./static&apos;)))\n\napp.listen(port, () => {\n  console.log(`server is listen in ${host}:${port}`);\n})\n```\n\n我们加入了 Cache-Control 头，设置 max-age 值为 5000。页面得到了响应：\n\n![3](https://images.gitbook.cn/f94f7ec0-e26d-11e9-b138-7fd562c24e16)\n\n再次刷新，得到了 200 OK（from memory cache）的标记：\n\n![4](https://images.gitbook.cn/1765ac90-e26e-11e9-9514-611dbba450a7)\n\n当我们关掉浏览器，再次打开页面，得到了 200 OK（from disk cache）的标记。请体会与 from memory cache 的不同，memory cache 已经随着我们关闭浏览器而清除，这里是从 disk cache 取到的缓存。\n\n![5](https://images.gitbook.cn/3d0bbc50-e26e-11e9-bb4c-7169754434c1)\n\n我们尝试将 max-age 改为 5 秒，5 秒后再次刷新页面，发现缓存已经失效。这里读者可以自行试验，不再截图了。\n\n下面来试验一下协商缓存，在初始 package.json 中，已经引入了 koa-etag 和 koa-conditional-get 这两个包依赖。\n\n修改 cache.js 为：\n\n```\nimport Koa from &apos;koa&apos;\nimport path from &apos;path&apos;\nimport resource from &apos;koa-static&apos;\nimport conditional from &apos;koa-conditional-get&apos;\nimport etag from &apos;koa-etag&apos;\n\nconst app = new Koa()\nconst host = &apos;localhost&apos;\nconst port = 5999\n\napp.use(conditional())\napp.use(etag())\napp.use(resource(path.join(__dirname, &apos;./static&apos;)))\n\napp.listen(port, () => {\n console.log(`server is listen in ${host}:${port}`)\n})\n```\n \n一切都很简单：\n\n![6](https://images.gitbook.cn/552d68b0-e26e-11e9-bb4c-7169754434c1)\n\n我们再次刷新浏览器，这次找到请求头，得到了 If-None-Match 字段，且内容与上一次的响应头相同。\n\n![7](https://images.gitbook.cn/6b1e0440-e26e-11e9-b138-7fd562c24e16)\n\n因为我们的图片并没有发生变化，所以得到了 304 响应头。\n\n![8](https://images.gitbook.cn/84e85790-e26e-11e9-8cc6-d3303f1d15c4)\n\n读者可以自行尝试替换图片来验证内容。\n\n这里我们主要使用了 Koa 库，如果对于原生 NodeJS，这里截取一个代码片段，供大家参考，该代码主要实现了 【if-modified-since/last-modified】头：\n\n```\nhttp.createServer((req, res) => {\n    let { pathname } = url.parse(req.url, true)\n    \n    let absolutePath = path.join(__dirname, pathname)\n    \n    fs.stat(path.join(__dirname, pathname), (err, stat) => {\n        // 路径不存在\n        if(err) {\n            res.statusCode = 404\n            res.end(&apos;Not Fount&apos;)\n            return\n        }\n        \n        if(stat.isFile()) {\n            res.setHeader(&apos;Last-Modified&apos;, stat.ctime.toGMTString())\n            \n            if(req.headers[&apos;if-modified-since&apos;] === stat.ctime.toGMTString()) {\n                res.statusCode = 304\n                res.end()\n                return\n            }\n            \n            fs.createReadStream(absolutePath).pipe(res)\n        }\n    })\n})\n```\n\n该项目源码，读者可以在[这里找到](https://github.com/HOUCe/lucas-gitchat-courses/tree/master/%E7%BC%93%E5%AD%98%E8%B0%81%E9%83%BD%E6%87%82%EF%BC%8C%E4%B8%80%E9%97%AE%E9%83%BD%E5%93%91%E5%8F%A3/cache)。\n\n#### 源码探究\n\n在上面应用 Etag 试验当中，使用了 koa-etag 这个包，这里我们就来了解一下这个包的实现。\n\n源码如下：\n\n```\nvar calculate = require(&apos;etag&apos;);\nvar Stream = require(&apos;stream&apos;);\nvar fs = require(&apos;mz/fs&apos;);\n\nmodule.exports = etag;\n\nfunction etag(options) {\n  return function etag(ctx, next) {\n    return next()\n      .then(() => getResponseEntity(ctx))\n      .then(entity => setEtag(ctx, entity, options));\n  };\n}\n\nfunction getResponseEntity(ctx, options) {\n  // no body\n  var body = ctx.body;\n  if (!body || ctx.response.get(&apos;ETag&apos;)) return;\n\n  // type\n  var status = ctx.status / 100 | 0;\n\n  // 2xx\n  if (2 != status) return;\n\n  if (body instanceof Stream) {\n    if (!body.path) return;\n    return fs.stat(body.path).catch(noop);\n  } else if ((&apos;string&apos; == typeof body) || Buffer.isBuffer(body)) {\n    return body;\n  } else {\n    return JSON.stringify(body);\n  }\n}\n\nfunction setEtag(ctx, entity, options) {\n  if (!entity) return;\n\n  ctx.response.etag = calculate(entity, options);\n}\n\nfunction noop() {}\n```\n\n我们看整个 etag 库就是一个中间件，它首先调用 getResponseEntity 方法获取响应体，根据 body 最终调用了 setEtag 方法，根据响应内容生产 etag。最终生成 etag 的计算过程又利用了 etag 这个包，再来看一下 etag 库：\n\n```\n&apos;use strict&apos;\n\nmodule.exports = etag\n\nvar crypto = require(&apos;crypto&apos;)\nvar Stats = require(&apos;fs&apos;).Stats\n\nvar toString = Object.prototype.toString\n\nfunction entitytag (entity) {\n  if (entity.length === 0) {\n    // fast-path empty\n    return &apos;\"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk\"&apos;\n  }\n\n  // compute hash of entity\n  var hash = crypto\n    .createHash(&apos;sha1&apos;)\n    .update(entity, &apos;utf8&apos;)\n    .digest(&apos;base64&apos;)\n    .substring(0, 27)\n\n  // compute length of entity\n  var len = typeof entity === &apos;string&apos;\n    ? Buffer.byteLength(entity, &apos;utf8&apos;)\n    : entity.length\n\n  return &apos;\"&apos; + len.toString(16) + &apos;-&apos; + hash + &apos;\"&apos;\n}\n\nfunction etag (entity, options) {\n  if (entity == null) {\n    throw new TypeError(&apos;argument entity is required&apos;)\n  }\n\n  // support fs.Stats object\n  var isStats = isstats(entity)\n  var weak = options && typeof options.weak === &apos;boolean&apos;\n    ? options.weak\n    : isStats\n\n  // validate argument\n  if (!isStats && typeof entity !== &apos;string&apos; && !Buffer.isBuffer(entity)) {\n    throw new TypeError(&apos;argument entity must be string, Buffer, or fs.Stats&apos;)\n  }\n\n  // generate entity tag\n  var tag = isStats\n    ? stattag(entity)\n    : entitytag(entity)\n\n  return weak\n    ? &apos;W/&apos; + tag\n    : tag\n}\n\nfunction isstats (obj) {\n  // genuine fs.Stats\n  if (typeof Stats === &apos;function&apos; && obj instanceof Stats) {\n    return true\n  }\n\n  // quack quack\n  return obj && typeof obj === &apos;object&apos; &&\n    &apos;ctime&apos; in obj && toString.call(obj.ctime) === &apos;[object Date]&apos; &&\n    &apos;mtime&apos; in obj && toString.call(obj.mtime) === &apos;[object Date]&apos; &&\n    &apos;ino&apos; in obj && typeof obj.ino === &apos;number&apos; &&\n    &apos;size&apos; in obj && typeof obj.size === &apos;number&apos;\n}\n\nfunction stattag (stat) {\n  var mtime = stat.mtime.getTime().toString(16)\n  var size = stat.size.toString(16)\n\n  return &apos;\"&apos; + size + &apos;-&apos; + mtime + &apos;\"&apos;\n}\n```\n\netag 方法接受一个 entity 最为入参一，entity 可以是 string、Buffer 或者 Stats 类型。如果是 Stats 类型，那么 etag 的生成方法会有不同：\n\n```\nvar mtime = stat.mtime.getTime().toString(16)\nvar size = stat.size.toString(16)\n\nreturn &apos;\"&apos; + size + &apos;-&apos; + mtime + &apos;\"&apos;\n```\n\n主要是根据 Stats 类型的 entity 的 mtime 和 size 特征，拼成一个 etag 即可。\n\n如果是正常 String 或者 Buffer 类型，etag 的生成方法依赖了内置 crypto 包，主要是根据 entity 生成 hash，hash 生成主要依赖了 sha1 加密方法：\n\n```\nvar hash = crypto\n    .createHash(&apos;sha1&apos;)\n    .update(entity, &apos;utf8&apos;)\n    .digest(&apos;base64&apos;)\n```\n\n了解了这些，如果面试官再问“Etag 的生成方法”，我想读者已经能够有一定底气了。\n\n### 实现一个验证缓存的轮子\n\n分析完关于 etag 的这个库，我们来尝试自救造一个轮子，也当作留给大家的一个作业。这个轮子的需要完成验证缓存是否可用的功能，它接受请求头和响应头，并根据这两个头部，返回一个布尔值，表示缓存是否可用。\n\n应用举例：\n\n```\nvar reqHeaders = { &apos;if-none-match&apos;: &apos;\"foo\"&apos; }\nvar resHeaders = { &apos;etag&apos;: &apos;\"bar\"&apos; }\nisFresh(reqHeaders, resHeaders)\n// => false\n\nvar reqHeaders = { &apos;if-none-match&apos;: &apos;\"foo\"&apos; }\nvar resHeaders = { &apos;etag&apos;: &apos;\"foo\"&apos; }\nisFresh(reqHeaders, resHeaders)\n// => true\n```\n\n在业务端使用时，可以直接：\n\n```\nvar isFresh = require(&apos;is-fresh&apos;)\nvar http = require(&apos;http&apos;)\n\nvar server = http.createServer(function (req, res) {\n\n  if (isFresh(req.headers, {\n    &apos;etag&apos;: res.getHeader(&apos;ETag&apos;),\n    &apos;last-modified&apos;: res.getHeader(&apos;Last-Modified&apos;)\n  })) {\n    res.statusCode = 304\n    res.end()\n    return\n  }\n  \n  res.statusCode = 200\n  res.end(&apos;hello, world!&apos;)\n})\n\nserver.listen(3000)\n```\n\n实现这道题目的前提就是先要了解缓存的基本知识，知晓缓存优先级。我们应该先验证 cache-control，之后验证 If-None-Match，之后是 If-Modified-Since。了解了这些，我们按部就班不难实现：\n\n```\nvar CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\\s*?no-cache\\s*?(?:,|$)/\n\nfunction fresh (reqHeaders, resHeaders) {\n  // fields\n  var modifiedSince = reqHeaders[&apos;if-modified-since&apos;]\n  var noneMatch = reqHeaders[&apos;if-none-match&apos;]\n\n  if (!modifiedSince && !noneMatch) {\n    return false\n  }\n\n  var cacheControl = reqHeaders[&apos;cache-control&apos;]\n  if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {\n    return false\n  }\n\n  // if-none-match\n  if (noneMatch && noneMatch !== &apos;*&apos;) {\n    var etag = resHeaders[&apos;etag&apos;]\n\n    if (!etag) {\n      return false\n    }\n\n    var etagStale = true\n    var matches = parseTokenList(noneMatch)\n    for (var i = 0; i < matches.length; i++) {\n      var match = matches[i]\n      if (match === etag || match === &apos;W/&apos; + etag || &apos;W/&apos; + match === etag) {\n        etagStale = false\n        break\n      }\n    }\n\n    if (etagStale) {\n      return false\n    }\n  }\n\n  // if-modified-since\n  if (modifiedSince) {\n    var lastModified = resHeaders[&apos;last-modified&apos;]\n    var modifiedStale = !lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince))\n\n    if (modifiedStale) {\n      return false\n    }\n  }\n\n  return true\n}\n\nfunction parseHttpDate (date) {\n  var timestamp = date && Date.parse(date)\n\n  return typeof timestamp === &apos;number&apos;\n    ? timestamp\n    : NaN\n}\n\nfunction parseTokenList (str) {\n  var end = 0\n  var list = []\n  var start = 0\n\n  for (var i = 0, len = str.length; i < len; i++) {\n    switch (str.charCodeAt(i)) {\n      case 0x20: /*   */\n        if (start === end) {\n          start = end = i + 1\n        }\n        break\n      case 0x2c: /* , */\n        list.push(str.substring(start, end))\n        start = end = i + 1\n        break\n      default:\n        end = i + 1\n        break\n    }\n  }\n\n  list.push(str.substring(start, end))\n\n  return list\n}\n```\n\n这个实现比较简单，读者可以尝试解读该源码，如果这两讲的内容你已经融会贯通，上述实现并不困难。\n\n当然，缓存的轮子却也没有“想象的那么简单”，“上述的代码强健性是否足够”？“API 设计是否优雅”？等这些话题值得思考。也希望在整个内容完结后，针对实战代码的优化和调试，应用的踩坑和解决能够大家继续交流。我们也会针对上述代码，展开更多内容。\n\n### 总结\n\n我们通过两讲的学习，介绍了缓存这一热门话题。缓存体现了理论规范和实战结合的美妙，是网络应用经验的结晶。建议读者可以多观察大型门户网站、页面应用，并结合工程化知识来看待并学习缓存。","pdfUrl":"","reader":"","duration":"","title":"缓存谁都懂，一问都哑巴（下）","column":"5c91c813968b1d64b1e08fde","isNotification":false,"readingStatistics":0,"htmlContent":"<p>上一讲，我们了解了缓存的几种方式和基本概念；这一讲，让我们从应用和面试的角度出发，巩固理论基础，加深操作印象。</p>\n<p><img src=\"https://images.gitbook.cn/14a4f400-e270-11e9-bb4c-7169754434c1\" alt=\"0\" /></p>\n<h3><a id=\"_4\"></a>缓存和浏览器操作</h3>\n<p>缓存的重要一环是浏览器，常见浏览器行为对应的缓存行为有哪些呢？我们来做一个总结（注意，不同浏览器引擎、不同版本可能会有差别，读者可以根据不同情况酌情参考）：</p>\n<ul>\n<li>当用户 Ctrl + F5 强制刷新网页时，浏览器直接从服务器加载，跳过强缓存和协商缓存</li>\n<li>当用户仅仅敲击 F5 刷新网页时，跳过强缓存，但是仍然会进行协商缓存过程</li>\n</ul>\n<p>这里我借用 <a href=\"https://link.juejin.im/?target=http%3A%2F%2Fwww.alloyteam.com%2F2012%2F03%2Fweb-cache-2-browser-cache%2F\" target=\"_blank\">Alloy Team</a> 的图进行一个总结：</p>\n<p><img src=\"https://images.gitbook.cn/cc134b80-e26d-11e9-bb4c-7169754434c1\" alt=\"1\" /></p>\n<h3><a id=\"_15\"></a>缓存相关面试题目</h3>\n<p>知识点我们已经梳理完毕，是时候刷一下经典题目来巩固了。以下题目都可以在上述知识中找到答案，我们也当做一个总结和考察。</p>\n<ul>\n<li>题目一：如何禁止浏览器不缓存静态资源</li>\n</ul>\n<p>在实际工作中，很多场景都需要禁用浏览器缓存。比如可以使用 Chrome 隐私模式，在代码层面可以设置相关请求头：</p>\n<pre><code class=\"lang-\">Cache-Control: no-cache, no-store, must-revalidate\n</code></pre>\n<p>此外，也可以给请求的资源增加一个版本号：</p>\n<pre><code class=\"lang-\">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./asset.css?version=1.8.9&quot;/&gt;\n</code></pre>\n<p>我们也可以使用 Meta 标签来声明缓存规则：</p>\n<pre><code class=\"lang-\">&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache, no-store, must-revalidate&quot;/&gt;\n</code></pre>\n<ul>\n<li>题目二：设置以下 request/response header 会有什么效果？</li>\n</ul>\n<pre><code class=\"lang-\">cache-control: max-age=0\n</code></pre>\n<p>上述响应头属于强缓存，因为 max-age 设置为 0，所以浏览器必须发请求重新验证资源。这时候会走协商缓存机制，可能返回 200 或者 304。</p>\n<ul>\n<li>题目三：设置以下 request/response header 会有什么效果？</li>\n</ul>\n<pre><code class=\"lang-\">cache-control: no-cache\n</code></pre>\n<p>上述响应头属于强缓存，因为设置 no-cache，所以浏览器必须发请求重新验证资源。这时候会走协商缓存机制。</p>\n<ul>\n<li>题目四：除了上述方式，还有哪种方式可以设置浏览器必须发请求重新验证资源，走协商缓存机制？</li>\n</ul>\n<p>设置 request/response header：</p>\n<pre><code class=\"lang-\">cache-control: must-revalidate\n</code></pre>\n<ul>\n<li>题目五：设置以下 request/response header 会有什么效果？</li>\n</ul>\n<pre><code class=\"lang-\">Cache-Control: max-age=60, must-revalidate\n</code></pre>\n<p>如果资源在 60s 内再次访问，走强缓存，可以直接返回缓存资源内容；如果超过 60s，则必须发送网络请求到服务端，去验证资源的有效性。</p>\n<ul>\n<li>题目五：据你的经验，为什么大厂都不怎么用 Etag？</li>\n</ul>\n<p>大厂多使用负载分担的方式来调度 HTTP 请求。因此，同一个客户端对同一个页面的多次请求，很可能被分配到不同的服务器来相应，而根据 ETag 的计算原理，不同的服务器，有可能在资源内容没有变化的情况下，计算出不一样的 Etag，而使得缓存失效。</p>\n<ul>\n<li>题目六：Yahoo 的 YSlow 页面分析工具为什么推荐关闭 ETag?</li>\n</ul>\n<p>因为 Etag 计算较为复杂，所以可能会使得服务端响应变慢。</p>\n<h3><a id=\"_79\"></a>缓存实战</h3>\n<p>我们来通过几个简单的真实项目案例实操一下缓存。</p>\n<h4><a id=\"_83\"></a>启动项目</h4>\n<p>首先创建项目：</p>\n<pre><code class=\"lang-\">mkdir cache\nnpm init\n</code></pre>\n<p>之后，得到 package.json，同时声明我们的相关依赖：</p>\n<pre><code class=\"lang-\">{\n  &quot;name&quot;: &quot;cache&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;Cache demo&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: {\n    &quot;start&quot;: &quot;nodemon ./index.js&quot;\n  },\n  &quot;keywords&quot;: [\n    &quot;cache&quot;,\n    &quot;node&quot;\n  ],\n  &quot;devDependencies&quot;: {\n    &quot;@babel/core&quot;: &quot;latest&quot;,\n    &quot;@babel/preset-env&quot;: &quot;latest&quot;,\n    &quot;@babel/register&quot;: &quot;latest&quot;,\n    &quot;koa&quot;: &quot;latest&quot;,\n    &quot;koa-conditional-get&quot;: &quot;^2.0.0&quot;,\n    &quot;koa-etag&quot;: &quot;^3.0.0&quot;,\n    &quot;koa-static&quot;: &quot;latest&quot;\n  },\n  &quot;dependencies&quot;: {\n    &quot;nodemon&quot;: &quot;latest&quot;\n  },\n  &quot;license&quot;: &quot;ISC&quot;\n}\n</code></pre>\n<p>使用 nodemon 来启动并 watch Node 脚本，同时配置  .babelrc 如下：</p>\n<pre><code class=\"lang-\">{\n &quot;presets&quot;: [\n   [\n     &quot;@babel/preset-env&quot;,\n     {\n       &quot;targets&quot;: {\n         &quot;node&quot;: &quot;current&quot;\n       }\n     }\n   ]\n ]\n}\n</code></pre>\n<p>在 cache/static 目录下，创建 index.html 和一张测试图片 web.png：</p>\n<pre><code class=\"lang-\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;\n    &lt;title&gt;前端开发核心知识进阶&lt;/title&gt;\n    &lt;style&gt;\n      .cache img {\n        display: block;\n        width: 100%;\n      }\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div class=&quot;cache&quot;&gt;\n      &lt;img src=&quot;./web.png&quot; /&gt;\n    &lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>看一下我们的核心脚本 index.js，其实就是一个简单的 NodeJS 服务：</p>\n<p>index.js：</p>\n<pre><code class=\"lang-\">require(&apos;@babel/register&apos;);\nrequire(&apos;./cache.js&apos;);\n</code></pre>\n<p>cache.js：</p>\n<pre><code class=\"lang-\">import Koa from &apos;koa&apos;\nimport path from &apos;path&apos;\nimport resource from &apos;koa-static&apos;\n\nconst app = new Koa()\nconst host = &apos;localhost&apos;\nconst port = 6666\n\napp.use(resource(path.join(__dirname, &apos;./static&apos;)))\n\napp.listen(port, () =&gt; {\n  console.log(`server is listen in ${host}:${port}`)\n})\n</code></pre>\n<p>我们启动：</p>\n<pre><code class=\"lang-\">npm run start\n</code></pre>\n<p>得到页面：</p>\n<p><img src=\"https://images.gitbook.cn/e5aca3c0-e26d-11e9-bb4c-7169754434c1\" alt=\"2\" /></p>\n<h4><a id=\"_202\"></a>应用缓存</h4>\n<p>我们来尝试加入一些缓存，首先应用强缓存，只需要在响应头上加入相关字段即可：</p>\n<pre><code class=\"lang-\">import Koa from &apos;koa&apos;\nimport path from &apos;path&apos;\nimport resource from &apos;koa-static&apos;\n\nconst app = new Koa()\nconst host = &apos;localhost&apos;\nconst port = 5999\n\napp.use(async (ctx, next) =&gt; {\n  ctx.set({\n    &apos;Cache-Control&apos;: &apos;max-age=5000&apos;  \n  })\n  await next()\n})\n\napp.use(resource(path.join(__dirname, &apos;./static&apos;)))\n\napp.listen(port, () =&gt; {\n  console.log(`server is listen in ${host}:${port}`);\n})\n</code></pre>\n<p>我们加入了 Cache-Control 头，设置 max-age 值为 5000。页面得到了响应：</p>\n<p><img src=\"https://images.gitbook.cn/f94f7ec0-e26d-11e9-b138-7fd562c24e16\" alt=\"3\" /></p>\n<p>再次刷新，得到了 200 OK（from memory cache）的标记：</p>\n<p><img src=\"https://images.gitbook.cn/1765ac90-e26e-11e9-9514-611dbba450a7\" alt=\"4\" /></p>\n<p>当我们关掉浏览器，再次打开页面，得到了 200 OK（from disk cache）的标记。请体会与 from memory cache 的不同，memory cache 已经随着我们关闭浏览器而清除，这里是从 disk cache 取到的缓存。</p>\n<p><img src=\"https://images.gitbook.cn/3d0bbc50-e26e-11e9-bb4c-7169754434c1\" alt=\"5\" /></p>\n<p>我们尝试将 max-age 改为 5 秒，5 秒后再次刷新页面，发现缓存已经失效。这里读者可以自行试验，不再截图了。</p>\n<p>下面来试验一下协商缓存，在初始 package.json 中，已经引入了 koa-etag 和 koa-conditional-get 这两个包依赖。</p>\n<p>修改 cache.js 为：</p>\n<pre><code class=\"lang-\">import Koa from &apos;koa&apos;\nimport path from &apos;path&apos;\nimport resource from &apos;koa-static&apos;\nimport conditional from &apos;koa-conditional-get&apos;\nimport etag from &apos;koa-etag&apos;\n\nconst app = new Koa()\nconst host = &apos;localhost&apos;\nconst port = 5999\n\napp.use(conditional())\napp.use(etag())\napp.use(resource(path.join(__dirname, &apos;./static&apos;)))\n\napp.listen(port, () =&gt; {\n console.log(`server is listen in ${host}:${port}`)\n})\n</code></pre>\n<p>一切都很简单：</p>\n<p><img src=\"https://images.gitbook.cn/552d68b0-e26e-11e9-bb4c-7169754434c1\" alt=\"6\" /></p>\n<p>我们再次刷新浏览器，这次找到请求头，得到了 If-None-Match 字段，且内容与上一次的响应头相同。</p>\n<p><img src=\"https://images.gitbook.cn/6b1e0440-e26e-11e9-b138-7fd562c24e16\" alt=\"7\" /></p>\n<p>因为我们的图片并没有发生变化，所以得到了 304 响应头。</p>\n<p><img src=\"https://images.gitbook.cn/84e85790-e26e-11e9-8cc6-d3303f1d15c4\" alt=\"8\" /></p>\n<p>读者可以自行尝试替换图片来验证内容。</p>\n<p>这里我们主要使用了 Koa 库，如果对于原生 NodeJS，这里截取一个代码片段，供大家参考，该代码主要实现了 【if-modified-since/last-modified】头：</p>\n<pre><code class=\"lang-\">http.createServer((req, res) =&gt; {\n    let { pathname } = url.parse(req.url, true)\n    \n    let absolutePath = path.join(__dirname, pathname)\n    \n    fs.stat(path.join(__dirname, pathname), (err, stat) =&gt; {\n        // 路径不存在\n        if(err) {\n            res.statusCode = 404\n            res.end(&apos;Not Fount&apos;)\n            return\n        }\n        \n        if(stat.isFile()) {\n            res.setHeader(&apos;Last-Modified&apos;, stat.ctime.toGMTString())\n            \n            if(req.headers[&apos;if-modified-since&apos;] === stat.ctime.toGMTString()) {\n                res.statusCode = 304\n                res.end()\n                return\n            }\n            \n            fs.createReadStream(absolutePath).pipe(res)\n        }\n    })\n})\n</code></pre>\n<p>该项目源码，读者可以在<a href=\"https://github.com/HOUCe/lucas-gitchat-courses/tree/master/%E7%BC%93%E5%AD%98%E8%B0%81%E9%83%BD%E6%87%82%EF%BC%8C%E4%B8%80%E9%97%AE%E9%83%BD%E5%93%91%E5%8F%A3/cache\" target=\"_blank\">这里找到</a>。</p>\n<h4><a id=\"_314\"></a>源码探究</h4>\n<p>在上面应用 Etag 试验当中，使用了 koa-etag 这个包，这里我们就来了解一下这个包的实现。</p>\n<p>源码如下：</p>\n<pre><code class=\"lang-\">var calculate = require(&apos;etag&apos;);\nvar Stream = require(&apos;stream&apos;);\nvar fs = require(&apos;mz/fs&apos;);\n\nmodule.exports = etag;\n\nfunction etag(options) {\n  return function etag(ctx, next) {\n    return next()\n      .then(() =&gt; getResponseEntity(ctx))\n      .then(entity =&gt; setEtag(ctx, entity, options));\n  };\n}\n\nfunction getResponseEntity(ctx, options) {\n  // no body\n  var body = ctx.body;\n  if (!body || ctx.response.get(&apos;ETag&apos;)) return;\n\n  // type\n  var status = ctx.status / 100 | 0;\n\n  // 2xx\n  if (2 != status) return;\n\n  if (body instanceof Stream) {\n    if (!body.path) return;\n    return fs.stat(body.path).catch(noop);\n  } else if ((&apos;string&apos; == typeof body) || Buffer.isBuffer(body)) {\n    return body;\n  } else {\n    return JSON.stringify(body);\n  }\n}\n\nfunction setEtag(ctx, entity, options) {\n  if (!entity) return;\n\n  ctx.response.etag = calculate(entity, options);\n}\n\nfunction noop() {}\n</code></pre>\n<p>我们看整个 etag 库就是一个中间件，它首先调用 getResponseEntity 方法获取响应体，根据 body 最终调用了 setEtag 方法，根据响应内容生产 etag。最终生成 etag 的计算过程又利用了 etag 这个包，再来看一下 etag 库：</p>\n<pre><code class=\"lang-\">&apos;use strict&apos;\n\nmodule.exports = etag\n\nvar crypto = require(&apos;crypto&apos;)\nvar Stats = require(&apos;fs&apos;).Stats\n\nvar toString = Object.prototype.toString\n\nfunction entitytag (entity) {\n  if (entity.length === 0) {\n    // fast-path empty\n    return &apos;&quot;0-2jmj7l5rSw0yVb/vlWAYkK/YBwk&quot;&apos;\n  }\n\n  // compute hash of entity\n  var hash = crypto\n    .createHash(&apos;sha1&apos;)\n    .update(entity, &apos;utf8&apos;)\n    .digest(&apos;base64&apos;)\n    .substring(0, 27)\n\n  // compute length of entity\n  var len = typeof entity === &apos;string&apos;\n    ? Buffer.byteLength(entity, &apos;utf8&apos;)\n    : entity.length\n\n  return &apos;&quot;&apos; + len.toString(16) + &apos;-&apos; + hash + &apos;&quot;&apos;\n}\n\nfunction etag (entity, options) {\n  if (entity == null) {\n    throw new TypeError(&apos;argument entity is required&apos;)\n  }\n\n  // support fs.Stats object\n  var isStats = isstats(entity)\n  var weak = options &amp;&amp; typeof options.weak === &apos;boolean&apos;\n    ? options.weak\n    : isStats\n\n  // validate argument\n  if (!isStats &amp;&amp; typeof entity !== &apos;string&apos; &amp;&amp; !Buffer.isBuffer(entity)) {\n    throw new TypeError(&apos;argument entity must be string, Buffer, or fs.Stats&apos;)\n  }\n\n  // generate entity tag\n  var tag = isStats\n    ? stattag(entity)\n    : entitytag(entity)\n\n  return weak\n    ? &apos;W/&apos; + tag\n    : tag\n}\n\nfunction isstats (obj) {\n  // genuine fs.Stats\n  if (typeof Stats === &apos;function&apos; &amp;&amp; obj instanceof Stats) {\n    return true\n  }\n\n  // quack quack\n  return obj &amp;&amp; typeof obj === &apos;object&apos; &amp;&amp;\n    &apos;ctime&apos; in obj &amp;&amp; toString.call(obj.ctime) === &apos;[object Date]&apos; &amp;&amp;\n    &apos;mtime&apos; in obj &amp;&amp; toString.call(obj.mtime) === &apos;[object Date]&apos; &amp;&amp;\n    &apos;ino&apos; in obj &amp;&amp; typeof obj.ino === &apos;number&apos; &amp;&amp;\n    &apos;size&apos; in obj &amp;&amp; typeof obj.size === &apos;number&apos;\n}\n\nfunction stattag (stat) {\n  var mtime = stat.mtime.getTime().toString(16)\n  var size = stat.size.toString(16)\n\n  return &apos;&quot;&apos; + size + &apos;-&apos; + mtime + &apos;&quot;&apos;\n}\n</code></pre>\n<p>etag 方法接受一个 entity 最为入参一，entity 可以是 string、Buffer 或者 Stats 类型。如果是 Stats 类型，那么 etag 的生成方法会有不同：</p>\n<pre><code class=\"lang-\">var mtime = stat.mtime.getTime().toString(16)\nvar size = stat.size.toString(16)\n\nreturn &apos;&quot;&apos; + size + &apos;-&apos; + mtime + &apos;&quot;&apos;\n</code></pre>\n<p>主要是根据 Stats 类型的 entity 的 mtime 和 size 特征，拼成一个 etag 即可。</p>\n<p>如果是正常 String 或者 Buffer 类型，etag 的生成方法依赖了内置 crypto 包，主要是根据 entity 生成 hash，hash 生成主要依赖了 sha1 加密方法：</p>\n<pre><code class=\"lang-\">var hash = crypto\n    .createHash(&apos;sha1&apos;)\n    .update(entity, &apos;utf8&apos;)\n    .digest(&apos;base64&apos;)\n</code></pre>\n<p>了解了这些，如果面试官再问“Etag 的生成方法”，我想读者已经能够有一定底气了。</p>\n<h3><a id=\"_468\"></a>实现一个验证缓存的轮子</h3>\n<p>分析完关于 etag 的这个库，我们来尝试自救造一个轮子，也当作留给大家的一个作业。这个轮子的需要完成验证缓存是否可用的功能，它接受请求头和响应头，并根据这两个头部，返回一个布尔值，表示缓存是否可用。</p>\n<p>应用举例：</p>\n<pre><code class=\"lang-\">var reqHeaders = { &apos;if-none-match&apos;: &apos;&quot;foo&quot;&apos; }\nvar resHeaders = { &apos;etag&apos;: &apos;&quot;bar&quot;&apos; }\nisFresh(reqHeaders, resHeaders)\n// =&gt; false\n\nvar reqHeaders = { &apos;if-none-match&apos;: &apos;&quot;foo&quot;&apos; }\nvar resHeaders = { &apos;etag&apos;: &apos;&quot;foo&quot;&apos; }\nisFresh(reqHeaders, resHeaders)\n// =&gt; true\n</code></pre>\n<p>在业务端使用时，可以直接：</p>\n<pre><code class=\"lang-\">var isFresh = require(&apos;is-fresh&apos;)\nvar http = require(&apos;http&apos;)\n\nvar server = http.createServer(function (req, res) {\n\n  if (isFresh(req.headers, {\n    &apos;etag&apos;: res.getHeader(&apos;ETag&apos;),\n    &apos;last-modified&apos;: res.getHeader(&apos;Last-Modified&apos;)\n  })) {\n    res.statusCode = 304\n    res.end()\n    return\n  }\n  \n  res.statusCode = 200\n  res.end(&apos;hello, world!&apos;)\n})\n\nserver.listen(3000)\n</code></pre>\n<p>实现这道题目的前提就是先要了解缓存的基本知识，知晓缓存优先级。我们应该先验证 cache-control，之后验证 If-None-Match，之后是 If-Modified-Since。了解了这些，我们按部就班不难实现：</p>\n<pre><code class=\"lang-\">var CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\\s*?no-cache\\s*?(?:,|$)/\n\nfunction fresh (reqHeaders, resHeaders) {\n  // fields\n  var modifiedSince = reqHeaders[&apos;if-modified-since&apos;]\n  var noneMatch = reqHeaders[&apos;if-none-match&apos;]\n\n  if (!modifiedSince &amp;&amp; !noneMatch) {\n    return false\n  }\n\n  var cacheControl = reqHeaders[&apos;cache-control&apos;]\n  if (cacheControl &amp;&amp; CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {\n    return false\n  }\n\n  // if-none-match\n  if (noneMatch &amp;&amp; noneMatch !== &apos;*&apos;) {\n    var etag = resHeaders[&apos;etag&apos;]\n\n    if (!etag) {\n      return false\n    }\n\n    var etagStale = true\n    var matches = parseTokenList(noneMatch)\n    for (var i = 0; i &lt; matches.length; i++) {\n      var match = matches[i]\n      if (match === etag || match === &apos;W/&apos; + etag || &apos;W/&apos; + match === etag) {\n        etagStale = false\n        break\n      }\n    }\n\n    if (etagStale) {\n      return false\n    }\n  }\n\n  // if-modified-since\n  if (modifiedSince) {\n    var lastModified = resHeaders[&apos;last-modified&apos;]\n    var modifiedStale = !lastModified || !(parseHttpDate(lastModified) &lt;= parseHttpDate(modifiedSince))\n\n    if (modifiedStale) {\n      return false\n    }\n  }\n\n  return true\n}\n\nfunction parseHttpDate (date) {\n  var timestamp = date &amp;&amp; Date.parse(date)\n\n  return typeof timestamp === &apos;number&apos;\n    ? timestamp\n    : NaN\n}\n\nfunction parseTokenList (str) {\n  var end = 0\n  var list = []\n  var start = 0\n\n  for (var i = 0, len = str.length; i &lt; len; i++) {\n    switch (str.charCodeAt(i)) {\n      case 0x20: /*   */\n        if (start === end) {\n          start = end = i + 1\n        }\n        break\n      case 0x2c: /* , */\n        list.push(str.substring(start, end))\n        start = end = i + 1\n        break\n      default:\n        end = i + 1\n        break\n    }\n  }\n\n  list.push(str.substring(start, end))\n\n  return list\n}\n</code></pre>\n<p>这个实现比较简单，读者可以尝试解读该源码，如果这两讲的内容你已经融会贯通，上述实现并不困难。</p>\n<p>当然，缓存的轮子却也没有“想象的那么简单”，“上述的代码强健性是否足够”？“API 设计是否优雅”？等这些话题值得思考。也希望在整个内容完结后，针对实战代码的优化和调试，应用的踩坑和解决能够大家继续交流。我们也会针对上述代码，展开更多内容。</p>\n<h3><a id=\"_605\"></a>总结</h3>\n<p>我们通过两讲的学习，介绍了缓存这一热门话题。缓存体现了理论规范和实战结合的美妙，是网络应用经验的结晶。建议读者可以多观察大型门户网站、页面应用，并结合工程化知识来看待并学习缓存。</p>\n","createdAt":"2019-04-21T04:53:36.951Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":47,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FoThASW9dVEPMEo9nP-zaOfbKyLZ"},{"_id":"5cbbf76abbbba80861a35c87","communication_start_time":null,"type":1,"audioPath":"","abstract":"","content":"在前面三讲中，分别了解了网络的基本内容、HTTP 的特性，尤其是缓存特性。这一讲让我们从历史的角度来审视 HTTP，探究 HTTP 的演进是为了更好的应用，更理解网络这个宏大概念中的一环。\n\n主要内容如下：\n\n![主要内容](https://images.gitbook.cn/36e4b700-e9b2-11e9-bf8f-1183a185e45f)\n\n### HTTP 的诞生\n\nHTTP 从何处来？\n\nHTTP 协议诞生自 1989 年（可能比很多开发者年纪要大），第一版本是 HTTP 0.9，但 HTTP 0.9 并不是一个正式标准；直到 1996 年，根据 RFC 1945，HTTP 1.0 成为 IEFT 标准，1999 年，在 RFC 2616 中发布了 HTTP 1.1。\n\n版本路线如下：\n\n- HTTP/0.9\n- HTTP/1.0\n- HTTP/1.1\n- HTTP/2\n\n但是需要注意的是，HTTP 和 JavaScript 一样，说到底还是需要浏览器的支持和实现。到那时每个浏览器或服务器对于该协议的每个方面并不能完全一致实现，因此还是有着细微用户体验与标准规范不一致的情况。\n\n这些“陈年旧事”我们不再过多回顾，下面来看一下 HTTP 的现状和发展痛点。\n\n### HTTP 的现状和痛点\n\nHTTP 2.0 于 2015 年发布，考虑到发布后的落地情况，以及现在各大厂商的应用情况，我们认可 HTTP 1.1 作为现状分析。\n\nHTTP 1.1 是划时代的，它解决了 HTTP 1.0 时代最重要的两个大问题：\n\n- **TCP 连接无法复用**，每次请求都需要重新建立 TCP 通道，也就要重复三次握手和四次挥手的情况；就是说*每个 TCP 连接只能发送一个请求*。\n- **队头阻塞**，每个请求都要过“独木桥”，桥宽为一个请求的宽度；也就是说，即使多个请求并行发出，也只能一个接一个地进行请求排队。\n\nHTTP 1.1 的改进点“对症下药”，它引入了：\n\n- 长连接：HTTP 1.1 支持长连接（Persistent Connection），且默认就开启了 Connection：keep-alive，这样在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。业界的成熟方案，如 Google 的 protobuf。\n- 管线化：在长连接的基础上，管线化（HTTP Pipelining）使得多个请求使用同一个 tcp 连接使请求并按照并行方式成为可能：多个请求同时发起，无需等待上一个请求的回包。但是需要注意，管线化只是让请求并行，但并没有从根本上解决队头阻塞问题，因为响应仍然要遵循先进先出的原则，第一个请求的回包发出之后，才会响应第二个请求。同时，浏览器供应商很难实现管道，而且大多数浏览器默认禁用该特性，有的甚至完全删除了它。\n\n除此以外，HTTP 1.1 还有一些创造性的改进，比如：\n\n- 缓存处理\n- 带宽优化及网络连接的使用，比如，range 头，支持断点续传功能，这个内容我们已经在前面的内容中进行了介绍\n- 错误通知的增强，响应码的增强\n- Host 头处理，请求消息中如果没有 Host 头域会报告一个错误\n\n基于 HTTP 1.1 的变革，一些成熟的方案也应运而出，比如：\n\n- http long-polling\n- http streaming\n- websocket\n\n这些内容我们会在本专栏「从实时通信系统看 HTTP 发展」部分进行介绍。\n\n这么看来，HTTP 1.1 简直不要太完美！当然他还是有一些缺陷和痛点的。比如：\n\n- 队头堵塞问题没有真正解决\n- 明文传输，安全性有隐患\n- header 携带内容过多，增加了传输成本\n- 默认开启 keep-alive 可能会给服务端造成更大的性能压力，比如对于一次性的请求（图片 CDN 服务），在文件被请求之后还保持了不必要的连接很长时间\n\n### HTTP 2.0 未来已来\n\n说起 HTTP 2.0，不得不提一下 SPDY 协议。2009 年，谷歌针对 HTTP 1.1 的一些问题，发布了 SPDY 协议。这个协议在 Chrome 浏览器上进行应用，并证明可行后，就成为了 HTTP 2.0 的基础，主要特性都在 HTTP 2.0 之中得到继承。但作为推动时代发展的产出，SPDY 说到底不会主宰时代而流行，我们暂不介绍更多，而把主要精力放在 HTTP 2.0 上。\n\nHTTP 2.0 目标是显著改善性能，同时做到迁移透明。我们先来理解几个 HTTP 2.0 的相关前置基础概念：\n\n- 帧：HTTP 2.0 中，客户端与服务器通过交换帧来通信，帧是基于这个新协议通信的最小单位。\n- 消息：是指逻辑上的 HTTP 消息，比如请求、响应等，由一或多个帧组成。\n- 流：流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的标识符\n\n最主要的特性如下。\n\n- 二进制分帧\n\nHTTP 2.0 的协议解析决定采用二进制格式，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效，这可以说是性能增强的焦点。新协议称为二进制分帧层（Binary Framing Layer），每一个请求都有这些公共字段：\n\n- Type：帧的类型，标识帧的用途\n- Length：整个帧的开始到结束大小\n- Flags：指定帧的状态信息\n- Steam Identifier：用于流控制，可以跟踪逻辑流的帧成员关系\n- Frame payload：r 请求正文\n\n这些内容相对底层和细致，这里只需要大家明白：二进制协议将通信分解为帧的方式，这些帧交织在客户端与服务器之间的双向逻辑流中，这样就使得所有通信都在单个 TCP 连接上执行，而且该连接在整个对话期间一直处于打开状态。\n\n- 请求/响应复用\n\n上面提到，为每帧分配一个流标识符，这就可以在一个 TCP 连接上独立发送它们。此技术实现了完全双向的请求和响应消息复用，解决了队头阻塞的问题。换句话说：一个请求对应一个 stream 并分配一个 id，这样一个连接上可以有多个 stream，每个 stream 的 frame 可以混杂在一起，接收方可以根据 stream id 将 frame 再归属到各自不同的请求里面。\n\n总结一下：所有的相同域名请求都通过同一个 TCP 连接并发完成。同一 TCP 中可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。这是真正意义上的多路复用。\n\n- 报头压缩\n\n报头压缩的实现方式是，要求客户端和服务器都维护之前看见的标头字段的列表。在第一个请求后，它仅需发送与前一个标头的不同之处，其他相同之处，服务器可以从标头的列表中恢复。\n\n- 流优先化\n\n消息帧通过流进行发送。我们提到每个流都分配了一个 id，同时也可以分配优先级。这样一来，服务端可以根据优先级确定它的处理顺序。\n\n- 服务器推送\n\n当一个客户端主动请求资源 K，如果这时候服务器知道它很可能也需要资源 M，那么服务器可以主动将资源 M 推送给客户端。当客户端真的请求 M 时，便可以从缓存中读取。\n\n这里有一个问题是：如何管理让服务器推送资源而不会让客户端过载？\n\n事实上，针对服务度希望发送的每个资源，服务端会发送一个 PUSH\\_PROMISE 帧，但客户端可通过发送 RST\\_STREAM 帧作为响应来拒绝推送。\n\n- 流控制\n\n流控制允许接收者主动示意停止或减少发送的数据量。比如一个视频应用，在观看一个视频流时，服务器会同时向客户端发送数据。如果视频暂停，客户端会通知服务器停止发送视频数据，以避免耗尽它的缓存。\n\n### 从实时通信系统看 HTTP 发展\n\n从上面的知识我们看出，传统的浏览器和 HTTP 协议，早期只能通过客户端主动发送请求，服务端应答回复请求来实现数据交互。但是在一些监控、Web 在线通讯、即时报价系、在线游戏等场景中，都需要将后台发生的变化主动地、实时地传送到浏览器端，而不需要用户手动地刷新页面。为了达到这个目的，一些 hack 方法或“官方”方法便应用而生。\n\n- Ajax polling\n\n轮询是最简单无脑的方案：客户端通过定期发送 ajax 请求，服务端受理请求立刻返回数据。这种方式保证了数据的相对实时性，具有很好的浏览器兼容性和简单性。但是缺点也明显：数据延迟取决于轮询频率，如果频率过高，就会产生大部分无效请求；反转频率过低，数据的实时性较差。同时，服务端的压力较大，也浪费了带宽流量。\n\n- Ajax long polling\n\n在短轮询的基础上，长轮询的实现思路是：客户端通过 ajax 发起请求，服务器在接到请求后不马上返回，而是保持住这个连接，等待数据的更新。当有数据要推送给客户端时，才发送目标数据给客户端，请求返回。客户端收到响应之后，马上再发起一个新的请求给服务器，周而复始。\n\n这样的长轮询能够有效减少轮询次数，而且延迟大大降低，但服务端需要保持大量连接，也是一种消耗。\n\n- Comet streaming\n\nComet streaming 技术又被称为 Forever iframe，这种技术听上去更加 hack：需要我们动态载入一个隐藏的 iframe 标签，iframe 的 src 指向请求的服务器地址。同时客户端准备好一个处理数据的函数，在服务端通过 iframe 和客户端通信时，服务端返回类似 script 标签的文本，客户端解析为 JavaScript 脚本，并调用用预先准备好的函数，将数据传递给 parent window，类似 Jsonp 的实现原理一样：\n\n```\n<script>parent.getData(\"data from server\")</script>\n```\n\n这样的实现也不算复杂，但说到底也是一种奇怪的 hack。\n\n- Ajax multipart streaming\n\n这种方式就用到了 HTTP 1.1 的 multipart 特性：客户端发送请求，服务端保持住这个连接，利用  HTTP 1.1 的 chunked encoding 机制（分块传输编码），将数据传递给客户端，直到 timeout 或者客户端手动断开。\n\n这种方法至少属于官方规范，但是就像前面知识所介绍的那样，HTTP 1.1 的 multipart 特性并没有被更广泛的浏览器接受并实现，它需要浏览器支持 multipart 特性。\n\n- Websocket\n\nWebSocket 是 HTML5 开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。依靠这种技术可以实现客户端和服务器端的长连接，双向实时通信。\n\n我们该如何理解 Websocket 和 HTTP 协议呢？\n\n> HTTP 和 WebSocket 都是应用层协议，都是基于 TCP 协议来传输数据的。WebSocket 依赖一种升级的 HTTP 协议进行一次握手，握手成功后，数据就直接从 TCP 通道传输。\n\n这样一来，连接的发起端还是客户端，但是一旦 Websocket 连接建立，客户端和服务端任何一方都可以向对方发送数据。\n\nWebscoket 无疑是强大的，但是它也错过了浏览器为HTTP提供的一些服务，需要开发中在使用时自己实现。因此 WebSocket 并不能取代 HTTP。\n\n由此看出，HTTP 的发展不是封闭的，而是吸取了“民间方案”和各种应用技术所长。尤其是 HTTP 2.0 更是一个极大的补充和优化。在下一部分，我们对 HTTP 和 Tcp. 以及相关内容以面试题的方式在进行巩固。\n\n### 相关深度面试题目\n\n- 题目一：「HTTP 连接分为长连接和短连接，而我们现在常用的都是 HTTP 1.1，因此我们用的都是长连接。」这种说法正确吗？\n\n其实这句话只对了后半句：我们现在大多应用 HTTP 1.1，因此用的都是长连接，这种说法勉强算对，因为 HTTP 1.1 默认 Connection 为 keep-alive。但是 HTTP 协议并没有长连接、短连接之分，所谓的长短连接都是在说 TCP 连接，TCP 连接是一个双向的通道，它是可以保持一段时间不关闭的，因此 TCP 连接才有真正的长连接和短连接这一说。\n\n这个可以回到网络分层的话题上，HTTP 协议说到底是应用层的协议，而 TCP 才是真正的传输层协议，只有负责传输的这一层才需要建立连接。\n\n-  题目二：长连接是一种永久连接吗？\n\n事实上，长连接并不是永久连接的，在长连接建立以后，如果一段时间内没有 HTTP 请求发出，这个长连接就会断掉。这个超时的时间可以在 header 中进行设置。\n\n- 题目三：现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？\n\n在 HTTP 1.0 中，一个服务器在发送完一个 HTTP 响应后，会断开 TCP 链接。但 HTTP 1.1 中，默认开启 Connection：keep-alive，浏览器和服务器之间是会维持一段时间的 TCP 连接，不会一个请求结束就断掉。除非显式声明：Connection: close。\n\n- 题目四：一个 TCP 连接可以对应几个 HTTP 请求，这些 HTTP 请求发送是否可以一起发送？\n\n不管是 HTTP 1.0 还是 HTTP 1.1，单个 TCP 连接在同一时刻只能处理一个请求，意思是说：两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠。也就是上面说的“队头阻塞”。\n\n虽然 HTTP 1.1 规范中规定了 Pipelining 来试图解决这个问题，但是这个功能在浏览器中默认是关闭的。\n\n因此，在 HTTP 1.1 中，一个支持持久连接的客户端可以在一个连接中发送多个请求（不需要等待任意请求的响应），收到请求的服务器必须按照请求收到的顺序发送响应。HTTP 2.0 中，由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行。\n\n### 总结\n\n这一讲中，我们从 HTTP 的发展角度，解析了当前 HTTP 协议的现状和痛点，并详细介绍了 HTTP 2.0 相关内容。\n\n后面部分，从实时通信系统网络协议层面的解析，又一次巩固了相关知识。\n\n到此，我们在理论层面已经有了必要的知识储备。**在整个课程完结时，感兴趣的同学可以跟我亲自动手，实践一下 HTTP 2.0，让我们从实战角度，探究一下「HTTP 2.0」的众多特性到底能不能优化应用。**","pdfUrl":"","reader":"","duration":"","title":"HTTP 的深思：我从何而来，去向何处","column":"5c91c813968b1d64b1e08fde","isNotification":false,"readingStatistics":0,"htmlContent":"<p>在前面三讲中，分别了解了网络的基本内容、HTTP 的特性，尤其是缓存特性。这一讲让我们从历史的角度来审视 HTTP，探究 HTTP 的演进是为了更好的应用，更理解网络这个宏大概念中的一环。</p>\n<p>主要内容如下：</p>\n<p><img src=\"https://images.gitbook.cn/36e4b700-e9b2-11e9-bf8f-1183a185e45f\" alt=\"主要内容\" /></p>\n<h3><a id=\"HTTP__6\"></a>HTTP 的诞生</h3>\n<p>HTTP 从何处来？</p>\n<p>HTTP 协议诞生自 1989 年（可能比很多开发者年纪要大），第一版本是 HTTP 0.9，但 HTTP 0.9 并不是一个正式标准；直到 1996 年，根据 RFC 1945，HTTP 1.0 成为 IEFT 标准，1999 年，在 RFC 2616 中发布了 HTTP 1.1。</p>\n<p>版本路线如下：</p>\n<ul>\n<li>HTTP/0.9</li>\n<li>HTTP/1.0</li>\n<li>HTTP/1.1</li>\n<li>HTTP/2</li>\n</ul>\n<p>但是需要注意的是，HTTP 和 JavaScript 一样，说到底还是需要浏览器的支持和实现。到那时每个浏览器或服务器对于该协议的每个方面并不能完全一致实现，因此还是有着细微用户体验与标准规范不一致的情况。</p>\n<p>这些“陈年旧事”我们不再过多回顾，下面来看一下 HTTP 的现状和发展痛点。</p>\n<h3><a id=\"HTTP__23\"></a>HTTP 的现状和痛点</h3>\n<p>HTTP 2.0 于 2015 年发布，考虑到发布后的落地情况，以及现在各大厂商的应用情况，我们认可 HTTP 1.1 作为现状分析。</p>\n<p>HTTP 1.1 是划时代的，它解决了 HTTP 1.0 时代最重要的两个大问题：</p>\n<ul>\n<li><strong>TCP 连接无法复用</strong>，每次请求都需要重新建立 TCP 通道，也就要重复三次握手和四次挥手的情况；就是说<em>每个 TCP 连接只能发送一个请求</em>。</li>\n<li><strong>队头阻塞</strong>，每个请求都要过“独木桥”，桥宽为一个请求的宽度；也就是说，即使多个请求并行发出，也只能一个接一个地进行请求排队。</li>\n</ul>\n<p>HTTP 1.1 的改进点“对症下药”，它引入了：</p>\n<ul>\n<li>长连接：HTTP 1.1 支持长连接（Persistent Connection），且默认就开启了 Connection：keep-alive，这样在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。业界的成熟方案，如 Google 的 protobuf。</li>\n<li>管线化：在长连接的基础上，管线化（HTTP Pipelining）使得多个请求使用同一个 tcp 连接使请求并按照并行方式成为可能：多个请求同时发起，无需等待上一个请求的回包。但是需要注意，管线化只是让请求并行，但并没有从根本上解决队头阻塞问题，因为响应仍然要遵循先进先出的原则，第一个请求的回包发出之后，才会响应第二个请求。同时，浏览器供应商很难实现管道，而且大多数浏览器默认禁用该特性，有的甚至完全删除了它。</li>\n</ul>\n<p>除此以外，HTTP 1.1 还有一些创造性的改进，比如：</p>\n<ul>\n<li>缓存处理</li>\n<li>带宽优化及网络连接的使用，比如，range 头，支持断点续传功能，这个内容我们已经在前面的内容中进行了介绍</li>\n<li>错误通知的增强，响应码的增强</li>\n<li>Host 头处理，请求消息中如果没有 Host 头域会报告一个错误</li>\n</ul>\n<p>基于 HTTP 1.1 的变革，一些成熟的方案也应运而出，比如：</p>\n<ul>\n<li>http long-polling</li>\n<li>http streaming</li>\n<li>websocket</li>\n</ul>\n<p>这些内容我们会在本专栏「从实时通信系统看 HTTP 发展」部分进行介绍。</p>\n<p>这么看来，HTTP 1.1 简直不要太完美！当然他还是有一些缺陷和痛点的。比如：</p>\n<ul>\n<li>队头堵塞问题没有真正解决</li>\n<li>明文传输，安全性有隐患</li>\n<li>header 携带内容过多，增加了传输成本</li>\n<li>默认开启 keep-alive 可能会给服务端造成更大的性能压力，比如对于一次性的请求（图片 CDN 服务），在文件被请求之后还保持了不必要的连接很长时间</li>\n</ul>\n<h3><a id=\"HTTP_20__59\"></a>HTTP 2.0 未来已来</h3>\n<p>说起 HTTP 2.0，不得不提一下 SPDY 协议。2009 年，谷歌针对 HTTP 1.1 的一些问题，发布了 SPDY 协议。这个协议在 Chrome 浏览器上进行应用，并证明可行后，就成为了 HTTP 2.0 的基础，主要特性都在 HTTP 2.0 之中得到继承。但作为推动时代发展的产出，SPDY 说到底不会主宰时代而流行，我们暂不介绍更多，而把主要精力放在 HTTP 2.0 上。</p>\n<p>HTTP 2.0 目标是显著改善性能，同时做到迁移透明。我们先来理解几个 HTTP 2.0 的相关前置基础概念：</p>\n<ul>\n<li>帧：HTTP 2.0 中，客户端与服务器通过交换帧来通信，帧是基于这个新协议通信的最小单位。</li>\n<li>消息：是指逻辑上的 HTTP 消息，比如请求、响应等，由一或多个帧组成。</li>\n<li>流：流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的标识符</li>\n</ul>\n<p>最主要的特性如下。</p>\n<ul>\n<li>二进制分帧</li>\n</ul>\n<p>HTTP 2.0 的协议解析决定采用二进制格式，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效，这可以说是性能增强的焦点。新协议称为二进制分帧层（Binary Framing Layer），每一个请求都有这些公共字段：</p>\n<ul>\n<li>Type：帧的类型，标识帧的用途</li>\n<li>Length：整个帧的开始到结束大小</li>\n<li>Flags：指定帧的状态信息</li>\n<li>Steam Identifier：用于流控制，可以跟踪逻辑流的帧成员关系</li>\n<li>Frame payload：r 请求正文</li>\n</ul>\n<p>这些内容相对底层和细致，这里只需要大家明白：二进制协议将通信分解为帧的方式，这些帧交织在客户端与服务器之间的双向逻辑流中，这样就使得所有通信都在单个 TCP 连接上执行，而且该连接在整个对话期间一直处于打开状态。</p>\n<ul>\n<li>请求/响应复用</li>\n</ul>\n<p>上面提到，为每帧分配一个流标识符，这就可以在一个 TCP 连接上独立发送它们。此技术实现了完全双向的请求和响应消息复用，解决了队头阻塞的问题。换句话说：一个请求对应一个 stream 并分配一个 id，这样一个连接上可以有多个 stream，每个 stream 的 frame 可以混杂在一起，接收方可以根据 stream id 将 frame 再归属到各自不同的请求里面。</p>\n<p>总结一下：所有的相同域名请求都通过同一个 TCP 连接并发完成。同一 TCP 中可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。这是真正意义上的多路复用。</p>\n<ul>\n<li>报头压缩</li>\n</ul>\n<p>报头压缩的实现方式是，要求客户端和服务器都维护之前看见的标头字段的列表。在第一个请求后，它仅需发送与前一个标头的不同之处，其他相同之处，服务器可以从标头的列表中恢复。</p>\n<ul>\n<li>流优先化</li>\n</ul>\n<p>消息帧通过流进行发送。我们提到每个流都分配了一个 id，同时也可以分配优先级。这样一来，服务端可以根据优先级确定它的处理顺序。</p>\n<ul>\n<li>服务器推送</li>\n</ul>\n<p>当一个客户端主动请求资源 K，如果这时候服务器知道它很可能也需要资源 M，那么服务器可以主动将资源 M 推送给客户端。当客户端真的请求 M 时，便可以从缓存中读取。</p>\n<p>这里有一个问题是：如何管理让服务器推送资源而不会让客户端过载？</p>\n<p>事实上，针对服务度希望发送的每个资源，服务端会发送一个 PUSH_PROMISE 帧，但客户端可通过发送 RST_STREAM 帧作为响应来拒绝推送。</p>\n<ul>\n<li>流控制</li>\n</ul>\n<p>流控制允许接收者主动示意停止或减少发送的数据量。比如一个视频应用，在观看一个视频流时，服务器会同时向客户端发送数据。如果视频暂停，客户端会通知服务器停止发送视频数据，以避免耗尽它的缓存。</p>\n<h3><a id=\"_HTTP__109\"></a>从实时通信系统看 HTTP 发展</h3>\n<p>从上面的知识我们看出，传统的浏览器和 HTTP 协议，早期只能通过客户端主动发送请求，服务端应答回复请求来实现数据交互。但是在一些监控、Web 在线通讯、即时报价系、在线游戏等场景中，都需要将后台发生的变化主动地、实时地传送到浏览器端，而不需要用户手动地刷新页面。为了达到这个目的，一些 hack 方法或“官方”方法便应用而生。</p>\n<ul>\n<li>Ajax polling</li>\n</ul>\n<p>轮询是最简单无脑的方案：客户端通过定期发送 ajax 请求，服务端受理请求立刻返回数据。这种方式保证了数据的相对实时性，具有很好的浏览器兼容性和简单性。但是缺点也明显：数据延迟取决于轮询频率，如果频率过高，就会产生大部分无效请求；反转频率过低，数据的实时性较差。同时，服务端的压力较大，也浪费了带宽流量。</p>\n<ul>\n<li>Ajax long polling</li>\n</ul>\n<p>在短轮询的基础上，长轮询的实现思路是：客户端通过 ajax 发起请求，服务器在接到请求后不马上返回，而是保持住这个连接，等待数据的更新。当有数据要推送给客户端时，才发送目标数据给客户端，请求返回。客户端收到响应之后，马上再发起一个新的请求给服务器，周而复始。</p>\n<p>这样的长轮询能够有效减少轮询次数，而且延迟大大降低，但服务端需要保持大量连接，也是一种消耗。</p>\n<ul>\n<li>Comet streaming</li>\n</ul>\n<p>Comet streaming 技术又被称为 Forever iframe，这种技术听上去更加 hack：需要我们动态载入一个隐藏的 iframe 标签，iframe 的 src 指向请求的服务器地址。同时客户端准备好一个处理数据的函数，在服务端通过 iframe 和客户端通信时，服务端返回类似 script 标签的文本，客户端解析为 JavaScript 脚本，并调用用预先准备好的函数，将数据传递给 parent window，类似 Jsonp 的实现原理一样：</p>\n<pre><code class=\"lang-\">&lt;script&gt;parent.getData(&quot;data from server&quot;)&lt;/script&gt;\n</code></pre>\n<p>这样的实现也不算复杂，但说到底也是一种奇怪的 hack。</p>\n<ul>\n<li>Ajax multipart streaming</li>\n</ul>\n<p>这种方式就用到了 HTTP 1.1 的 multipart 特性：客户端发送请求，服务端保持住这个连接，利用  HTTP 1.1 的 chunked encoding 机制（分块传输编码），将数据传递给客户端，直到 timeout 或者客户端手动断开。</p>\n<p>这种方法至少属于官方规范，但是就像前面知识所介绍的那样，HTTP 1.1 的 multipart 特性并没有被更广泛的浏览器接受并实现，它需要浏览器支持 multipart 特性。</p>\n<ul>\n<li>Websocket</li>\n</ul>\n<p>WebSocket 是 HTML5 开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。依靠这种技术可以实现客户端和服务器端的长连接，双向实时通信。</p>\n<p>我们该如何理解 Websocket 和 HTTP 协议呢？</p>\n<blockquote>\n<p>HTTP 和 WebSocket 都是应用层协议，都是基于 TCP 协议来传输数据的。WebSocket 依赖一种升级的 HTTP 协议进行一次握手，握手成功后，数据就直接从 TCP 通道传输。</p>\n</blockquote>\n<p>这样一来，连接的发起端还是客户端，但是一旦 Websocket 连接建立，客户端和服务端任何一方都可以向对方发送数据。</p>\n<p>Webscoket 无疑是强大的，但是它也错过了浏览器为HTTP提供的一些服务，需要开发中在使用时自己实现。因此 WebSocket 并不能取代 HTTP。</p>\n<p>由此看出，HTTP 的发展不是封闭的，而是吸取了“民间方案”和各种应用技术所长。尤其是 HTTP 2.0 更是一个极大的补充和优化。在下一部分，我们对 HTTP 和 Tcp. 以及相关内容以面试题的方式在进行巩固。</p>\n<h3><a id=\"_153\"></a>相关深度面试题目</h3>\n<ul>\n<li>题目一：「HTTP 连接分为长连接和短连接，而我们现在常用的都是 HTTP 1.1，因此我们用的都是长连接。」这种说法正确吗？</li>\n</ul>\n<p>其实这句话只对了后半句：我们现在大多应用 HTTP 1.1，因此用的都是长连接，这种说法勉强算对，因为 HTTP 1.1 默认 Connection 为 keep-alive。但是 HTTP 协议并没有长连接、短连接之分，所谓的长短连接都是在说 TCP 连接，TCP 连接是一个双向的通道，它是可以保持一段时间不关闭的，因此 TCP 连接才有真正的长连接和短连接这一说。</p>\n<p>这个可以回到网络分层的话题上，HTTP 协议说到底是应用层的协议，而 TCP 才是真正的传输层协议，只有负责传输的这一层才需要建立连接。</p>\n<ul>\n<li>题目二：长连接是一种永久连接吗？</li>\n</ul>\n<p>事实上，长连接并不是永久连接的，在长连接建立以后，如果一段时间内没有 HTTP 请求发出，这个长连接就会断掉。这个超时的时间可以在 header 中进行设置。</p>\n<ul>\n<li>题目三：现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？</li>\n</ul>\n<p>在 HTTP 1.0 中，一个服务器在发送完一个 HTTP 响应后，会断开 TCP 链接。但 HTTP 1.1 中，默认开启 Connection：keep-alive，浏览器和服务器之间是会维持一段时间的 TCP 连接，不会一个请求结束就断掉。除非显式声明：Connection: close。</p>\n<ul>\n<li>题目四：一个 TCP 连接可以对应几个 HTTP 请求，这些 HTTP 请求发送是否可以一起发送？</li>\n</ul>\n<p>不管是 HTTP 1.0 还是 HTTP 1.1，单个 TCP 连接在同一时刻只能处理一个请求，意思是说：两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠。也就是上面说的“队头阻塞”。</p>\n<p>虽然 HTTP 1.1 规范中规定了 Pipelining 来试图解决这个问题，但是这个功能在浏览器中默认是关闭的。</p>\n<p>因此，在 HTTP 1.1 中，一个支持持久连接的客户端可以在一个连接中发送多个请求（不需要等待任意请求的响应），收到请求的服务器必须按照请求收到的顺序发送响应。HTTP 2.0 中，由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行。</p>\n<h3><a id=\"_177\"></a>总结</h3>\n<p>这一讲中，我们从 HTTP 的发展角度，解析了当前 HTTP 协议的现状和痛点，并详细介绍了 HTTP 2.0 相关内容。</p>\n<p>后面部分，从实时通信系统网络协议层面的解析，又一次巩固了相关知识。</p>\n<p>到此，我们在理论层面已经有了必要的知识储备。<strong>在整个课程完结时，感兴趣的同学可以跟我亲自动手，实践一下 HTTP 2.0，让我们从实战角度，探究一下「HTTP 2.0」的众多特性到底能不能优化应用。</strong></p>\n","createdAt":"2019-04-21T04:54:02.812Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":48,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FoThASW9dVEPMEo9nP-zaOfbKyLZ"},{"_id":"5c99c904ccb24267c1d01f7d","communication_start_time":null,"type":1,"audioPath":"","abstract":"","content":"安全是计算机科学永远无法忽视的话题。随着互联网的发展，安全问题越来越突出，也越来越重要：它是一个程序可用性、健壮性的基础。这个话题可大可小，大到系统的设计，小到一行代码的写法，都可能影响系统的安全。\n\n毫不例外，安全与前端开发的结合也持续走热。不管是经验丰富的程序员，还是尚在打基础的学生，也许都对 HTTPS、XSS、CSRF 等前端相关的安全问题不陌生。然而，这其中每一个主题都可以非常深入，都能系统地做一节课。但是，我认为面面俱到、走马观花地梳理这些内容，讲解这些概念价值不大。毕竟，这方面知识都已经比较成熟，社区上资料很多。\n\n本讲我想从一个大部分产品都要涉及的登录鉴权入手，结合单页面应用，从这个角度，管中窥豹，尽可能多地涉及一些常见的安全知识，帮助大家了解前端安全。\n\n接下来，让我们从应用场景入手，从前后端交互切入，以单页面应用为基础，呈现“鉴权”这个安全领域重要话题的全貌，并尽力覆盖到 XSS 和 CSRF 等攻击手段以及最佳实践。\n\n关于这个主题的知识点如下：\n\n<img src=\"https://images.gitbook.cn/545627c0-4ecf-11e9-97d1-9b2c5e38f63d\" width=550>\n\n### 单页应用鉴权简介\n\n首先，我们要分清单页应用鉴权与传统鉴权方式有所不同：\n\n<div style=\"color:#024727;background:#f9f9f9;\"><p style=\"padding:10px\">单页应用采用前后端分离的设计方式，路由由前端管理，前后端遵循一定规范（如 REST、GraphQL），通过 AJAX 进行通信。在这种情况下，用户对页面请求时，后端经常无法获取用户身份信息，更无法确定返回的数据。</p></div>\n\n同时一次鉴权完毕后，如何在单页应用的体验当中，保持这个鉴权状态也值得思考。一般来说，单页应用鉴权采用下面的步骤实现。\n\n- Step 1：前端根据用户交互，发送数据请求之前，需要准备用户信息，同数据请求一起发给后端处理。\n- Step 2-1：后端按照约定好的规则，根据请求中带有的用户身份信息，进行验证。如果验证不通过，返回 403 或者 401 相关状态码或其他状态，以表示鉴权失败。\n- Step 2-2：如果鉴权成功，后端返回相关数据。\n- Step 3：前端根据数据渲染视图。\n\n基本结构非常简单清晰：\n\n<img src=\"https://images.gitbook.cn/b99cdee0-4eba-11e9-aba8-d90fcdb25340\" width=550>\n\n在这个结构背后，隐藏的技术方案和安全细节非常值得我们思考，请继续阅读，我们将剖析几个重要概念和安全实践。\n\n#### HTTPS\n\n鉴权过程中，如果使用 HTTP 协议来传输敏感数据（用户昵称、用户密码、token……），那么很容易被中间人拦截获取。现代通信中，我们都使用 HTTPS 协议来对传输内容进行加密。关于 HTTPS 的应用及其原理，又是一个超级话题。这里由于内容的限制，不过多展开，给大家分享一下我收藏的关于 HTTPS  好的文章：\n\n- [https 连接的前几毫秒发生了什么](https://mp.weixin.qq.com/s/--KxUNzmBdKtOPBbovWCaA)\n- [完全图解 HTTPS](https://juejin.im/post/5c441073e51d455226654d60)\n- [更安全的 Web 通信 HTTPS](https://juejin.im/post/5b5f1289e51d4519601aeeda)\n- [图解基于 HTTPS 的 DNS](https://www.infoq.cn/article/a-cartoon-intro-to-dns-over-https)\n- [看图学 HTTPS](https://juejin.im/post/5b0274ac6fb9a07aaa118f49?utm_medium=fe&utm_source=weixinqun)\n- [http 与 https 的区别我真的知道吗](https://juejin.im/post/5af3e002f265da0b7c074ada)\n- [深入揭秘 HTTPS 安全问题&连接建立全过程](https://zhuanlan.zhihu.com/p/22142170)\n- [HTTPS系列干货（一）：HTTPS 原理详解](http://support.upyun.com/hc/kb/article/1031843/)\n- [HTTPS 为什么更安全，先看这些](http://support.upyun.com/hc/kb/article/1031843/https://juejin.im/post/58a8f3295c497d005fbd58b1)\n\n#### 不要使用 URL query 传递敏感数据\n\nURL query 会通过服务端日志、浏览器日志、浏览器历史记录查到。不要使用 URL query 传递敏感数据，这当然是最基本的准则之一。如果敏感数据在 URL query 中，这就给了恶意用户轻松获取数据的机会。同时，URL query 的长度也有限制，这也是其传递数据的弊端之一。\n\n#### 防止暴力攻击的手段\n\n攻击者可以通过暴力手段，尝试攻破用户的密码等信息。因此后端服务要时刻注意加入频率限制，限制一个用户短时间尝试密码的次数；也可以限制可疑用户（比如触发了过多服务端错误用户）的访问。另外，需要注意的是不要给任何人暴露服务端的技术细节信息，比如要记得关闭 X-Powered-By（服务器响应头隐藏）；Node 端在使用 express.js 的情况下，强烈建议使用 [Helmetjs](https://expressjs.com/en/advanced/best-practice-security.html#use-helmet)。 \n\nHelmet 帮助 Node.js 开发者通过设置合理的 HTTP header，预防一些常见的 Web 漏洞，比如上面提到的关闭 X-Powered-By。实际上它就是一组灵活的中间件函数，增强以下 HTTP header 的安全性：\n\n* Content-Security-Policy 响应头，它可以设置应用是否可以引用某些来源内容，进而防止 XSS\n* 关闭 X-Powered-By 响应头，以避免暴露服务端信息\n* 增加 [Public Key Pinning](https://developer.mozilla.org/en-US/docs/Web/Security/Public_Key_Pinning) 响应头，预防中间人伪造证书\n* 设置 Strict-Transport-Security 响应头，这样浏览器只能通过 HTTPS 访问当前资源 \n* 为 IE8+ 设置 X-Download-Options 响应头，目前只有 IE8+ 支持这个 header，用来预防下载内容的安全隐患\n* 设置 Cache-Control 和 Pragma header 以关闭浏览器端缓存\n* 设置 X-Content-Type-Options 响应头，以禁用浏览器内容嗅探\n* 设置 X-Frame-Options 响应头，以预防 [clickjacking](https://www.owasp.org/index.php/Clickjacking)，这个响应头给浏览器指示是否允许在 `<frame>` 或者 `<iframe>` 标签中渲染某个页面\n* 设置 X-XSS-Protection 响应头，当检测到跨站脚本攻击（XSS）时，浏览器停止加载页面\n\n它的使用非常简单：\n\n```\nconst express = require(&apos;express&apos;)\nconst helmet = require(&apos;helmet&apos;)\n\nconst app = express()\n\napp.use(helmet())\n```\n\n其源码是典型的 express 中间件写法，它依次加载相关中间件集。比如它将引用 X-Powered-By 中间件，这个中间件的源码非常简单：\n\n```\nmodule.exports = function hidePoweredBy (options) {\n  var setTo = (options || {}).setTo\n\n  if (setTo) {\n    return function hidePoweredBy (req, res, next) {\n      res.setHeader(&apos;X-Powered-By&apos;, setTo)\n      next()\n    }\n  } else {\n    return function hidePoweredBy (req, res, next) {\n      res.removeHeader(&apos;X-Powered-By&apos;)\n      next()\n    }\n  }\n}\n```\n\n通过 setHeader 和 removeHeader 方法，完成对 X-Powered-By 响应头的添加和删除。\n\n#### 升级依赖保证安全\n\n现如今我们的应用，大部分脚本都来自第三方依赖，第三方库出现安全隐患的新闻已经屡见不鲜。除了从源头把控依赖的引入外，适时合理地更新 npm 包，是值得倡导的做法，npm 便在 6.0 后有相关命令如下：\n\n```\n# npm 6.0 新增，扫描所有依赖，列出依赖中有安全隐患的包\nnpm audit\n# npm 6.0 新增，扫描所有依赖，并把不安全的依赖包升级到可兼容的版本\nnpm audit fix\n```\n\n### 单页应用鉴权实战\n\n言归正传，我们来看一下实现单页应用鉴权的两种主要手段：\n\n- JWT\n- Authentication cookie\n\n**这两种方式不尽相同，我们将逐一分析，并尝试合并这两种方案的优点，将它们结合为第三种方式。**\n\n#### 采用 JWT 实现鉴权\n\n在鉴权过程中，为了验证用户的身份，需要浏览器向服务器端提供一个验证信息，我们称为 token。这个 token 通常由 JSON 数据格式组成，通过 hash 散列算法生成一个字符串，称为 JSON Web Token（JSON 表示令牌的原始类型为 JSON 格式，Web 表示在互联网中进行传播，Token 表示令牌，简称 JWT）。任何 token 持有者都可以无差别地用它来访问相关的资源。\n\n我们可以在 HTTP Authorization header 中找到 token，其实就是一个字符串值。这个字符串用来表示用户的身份信息，进行身份认证或者从服务器获取合法资源。当然这个 token 往往是被加密的。那么这个 token 具体是如何生成的呢？\n\n我们先从 JWT 说起，一个 JWT 包含以下 3 个部分：\n\n- header（消息头）\n- payload（消息体，储存用户 id、用户角色等） + 过期时间（可选）\n- signature（签名）\n\n我们说过，JWT 就是 JSON 格式的数据，JWT  的前两个部分就是 JSON 数据，第三部分 signature 是基于前两部分 header 和 payload 生成的签名。前两部分分别通过 Base64URL 算法生成两组字符串，再和 signature 结合，三部分通过 . 号分割，就是最终的 token。\n\n更多这方面的信息，大家可以参考：\n\n- [5 Easy Steps to Understanding JSON Web Tokens (JWT)](https://medium.com/vandium-software/5-easy-steps-to-understanding-json-web-tokens-jwt-1164c0adfcec)\n- [Bearer Token](https://www.jianshu.com/p/8f7009456abc)\n- [OAuth 2.0: Bearer Token Usage](https://www.cnblogs.com/XiongMaoMengNan/p/6785155.html)\n\n正常来讲，当客户端在提交用户名/密码（或者其他方式）通过认证后，会获得 JWT 的 token，接着通过 JavaScript 脚本，对于所有数据请求都在其 HTTP header 中加上这个 JWT 的 token。服务端接到请求之后，验证 token 的 signature 是否等同于 payload，进而得知 payload 字段是否被中间人更改。\n\n细心的读者可能会发现，我们提到“通过 JavaScript 脚本，对于所有数据请求，都在 HTTP header 中加上这个 token”。这就涉及**客户端如何存储和维护 JWT** 的问题了。\n\n存储 JWT，我们可以考虑：\n\n- 内存存储\n- local/session cookie\n- local/session storage……\n\n这几种方式。我并不建议开发者将 token 存储在 local storage 当中，因为：\n\n- 当用户关掉浏览器后，JWT 仍然会被存储在 local storage 中，即便 JWT 过期，可能一直被存储（除非手动更新或清理）\n- 任何 JavaScript 都能轻而易举地获得 local storage 的内容\n- 无法被 web worker 使用\n\n但在实际项目中，笔者也在 local storage 中存储过 JWT，这需要我们分清利弊，结合实际场景选择方案。如果吃透概念，就能减少 bug 的出现，具体存储方案可以灵活一些。\n\n更好的选择之一是将 JWT 存储在 session cookie 中，auth0 有一篇很好的文章，感兴趣的读者可以参考：[Where to Store Tokens](https://auth0.com/docs/security/store-tokens)。\n\n#### JWT 隐患\n\nJWT 实现鉴权也存在的隐患，上面我们也简要提到了，隐患主要来自 [XSS](https://www.owasp.org/index.php/Cross-site_Scripting_%28XSS%29)。攻击者可以主动注入恶意脚本或者使用用户输入，通过 JavaScript 代码来偷取 token，接下来便能通过 token 冒充受害用户。\n\n比如，一个博客留言系统，用户可以在其留言内容中加入以下脚本：\n\n```\n<img src=x onerror=\"&#0000106&#0000097&#0000118&#0000097&#0000115&#0000099&#0000114&#0000105&#0000112&#0000116&#0000058&#0000097&#0000108&#0000101&#0000114&#0000116&#0000040&#0000039&#0000088&#0000083&#0000083&#0000039&#0000041\">\n```\n\n一般的防御手段是采用 HTML 转义来控制过滤用户输入（为了防止 XSS 攻击，常常需要将用户输入的特殊字符进行转义）。\n\n### 采用 Authentication cookie 实现鉴权\n\ncookie 是含有有效期和相关 domain，存储在浏览器中的键值对组合，可以由 JavaScript 创建：\n\n\tdocument.cookie = ‘my_cookie_name=my_cookie_value’\n\n也可以由服务端通过  response header 创建：\n\n```\nSet-Cookie: my_cookie_name=my_cookie_value\n```\n\n浏览器会自动在每个请求当中加入相关 domain 下的 cookie：\n\n```\nGET https://www.example.com/api/users\nCookie: my_cookie_name=my_cookie_value\n```\n\ncookie 一般分为两种（[出处](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies)）：\n\n> - Session cookie，这种 cookie 会随着用户关闭浏览器而被清除，不会被标记任何过期时间 Expires 或者最大时限 Max-Age。\n> - Permanent cookie，与 session cookie 相反，会在用户关闭浏览器之后被浏览器持久化存储。\n\n同时，服务端可以对 cookie 进行一些关键配置，以保障 cookie 的使用安全，诸如：\n\n- HttpOnly cookie：浏览器端 JavaScript 没有读 cookie 权限。\n- Secure cookie：传输链路只有在特定安全通道（通常指 HTTPS），请求才会自动加入相关 cookie。\n- SameSite cookie：在跨域情况下，相关 cookie 无法被请求携带，这里主要是为了防止 CSRF 攻击。\n\n一个经典场景就是使用 cookie 存储一个 session ID（session ID 由服务端管理，进行创建和计时，以便在必要的时候清除）。通过验证 cookie 和 session ID，服务端便能标记一个用户的访问信息。这种情况就是我们说的 stateful，而本节课的主角 JWT 是 stateless 的，因为它不需要服务端维护 session ID，是无状态的，更加利于横向扩展。\n\n#### Authentication cookie 隐患\n\n采用 Authentication cookie 实现单页应用鉴权的安全隐患主要有两种：\n\n- [XSS](https://www.owasp.org/index.php/Cross-site_Scripting_%28XSS%29)　如果没有使用 httpOnly 选项，那么攻击者可能会通过注入恶意脚本，任意读取用户 cookie。而 cookie 直接存储了用户的身份认证信息，这当然是非常可怕的。\n\n- [CSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)) 是常见的针对 cookie 展开进攻的手段。我们知道跨域访问技术（CORS，跨域资源共享）的同源策略能保证不同源的客户端脚本在没有明确授权的情况下，无法读写对方资源。同源策略只是针对浏览器侧的编程脚本语言，如果我们对另一个恶意服务器发送 AJAX 请求，同源策略会有所限制，但是如果请求直接通过 HTML form 发送，那么同源策略毫无办法。\n\n```\n<form action=\"http://someotherserver.com\">\n```\n\n另一个利用 CSRF 实施攻击的场景为：假如受害者在网页中登录了 Facebook，同时又打开了 bad.com，bad.com 属于攻击者的网站，这个网站中有这样的代码：\n\n```\n<img src=\"https://facebook.com/postComment?userId=dupont_123&comment=I_VE_BEEN_HACKED>\n```\n\n如此一来，攻击者网站的代码请求了 Facebook 发送个人状态的接口（https://facebook.com/postComment?），该受害者会莫名其妙地发送一个状态，内容为 \"I\\_VE\\_BEEN\\_HACKED\"。\n\n<div style=\"color:#024727;background:#f9f9f9;\"><p style=\"padding:10px\"><strong>总结</strong>　为了防御 XSS 攻击，需要开发者设置 <code>httpOnly</code> 选项；为了防御 XSRF，需要开发者设置 <code>SameSite</code> 选项。需要注意，并不是所有浏览器都支持 <a href=\"https://caniuse.com/#feat=same-site-cookie-attribute\">SameSite</a>。</p></div>\n\n**此外，一些其他防御手段有：**\n\n- Short session timeout：设置 session 过期时间，比如银行网站往往需要每 10 分钟或者更短时间就重新登录。\n- 关键操作需要用户重新进行鉴权认证。\n- Double submitted cookie：当用户浏览一个站点时，服务端生成一个伪随机数 pseudorandom value，并将其设置为 cookie，且不设置 httpOnly 标识。这样 JavaScript 就能够访问这个 pseudorandom value，并要求在提交每个表单时，一并将这个 pseudorandom value 作为 form value 提交上来，同时在 cookie 中也要提交 value。服务端便可以对比 form value 中的 pseudorandom value 和 cookie value 是否一致，以此来认证用户的安全身份。\n\nDouble submitted cookie 之所以能有效防范攻击，是因为同源策略致使攻击者无法读取来自攻击目标服务端的 cookie 值，更无法修改攻击网站的 cookie value。即便攻击者可以从 form 中提交任何 form value，但是无法通过服务端对 form value 中的 pseudorandom value 和 cookie value 的一致性进行验证。\n\n### 混合 JWT 和 cookie 进行鉴权\n\n设想我们要实现这样一个鉴权系统：\n\n- 尽可能抵御 XSS 和 CSRF\n- 做到 stateless\n\n考虑到安全性能，JWT 方案的主要问题在于攻击者存在直接读取 JWT 信息的可能。**如果我们将 JWT 和 cookie 方案结合呢**？即将 JWT 部分敏感信息放入 cookie 当中，这样一来，便可以结合前文两种方式的优点。\n\n如图，我们再总结一下存在的三种交互可能。第一种是经典 JWT 方式：\n\n<img src=\"https://images.gitbook.cn/b54a5600-4eac-11e9-9566-89cb1d9578c6\" width=550>\n\n这种情况下，前后端使用 JWT 进行鉴权交互，前端通过 JavaScript 操作 JWT 信息完成请求准备。\n\n第二种方式，将 JWT 信息在 session cookie 中维护：\n\n<img src=\"https://images.gitbook.cn/ba54c590-4eac-11e9-b1fa-0757868d211c\" width=550>\n\n在这种情况下，JWT 信息全部存储在 cookie 中， 并设置 cookie 的 httpOnly、SameSite、Secure 属性，前端无法读取 JWT 信息，但每次请求都会由浏览器带上必要的 JWT 数据（作为 cookie）。同时，由于采用 session cookie，也不存在 JWT 信息过期的情况，用户关闭页面之后不会将 JWT 信息持久化存储，下次再打开页面时，会重新进行鉴权流程。\n\n第一种方式有一定的安全隐患；第二种方式我们将 JWT 所有信息存储在 session cookie 当中，优点明显，但是无法做到持久化存储，在某种程度上也会带来不便。那么我们权衡之后进行了变通，结合前面两种方式产生了第三种方式：\n\n<img src=\"https://images.gitbook.cn/990f8c00-4eb9-11e9-b0b8-a9c8a3696845\" width=550>\n\n这样，JWT 的 signature 部分维护在设置了 httpOnly 的 cookie 中，这意味着 JavaScript 无法读取完整的 JWT 信息。同时，cookie 会在每次请求中被携带， 并由服务端返回后在浏览器中进行存储，这样 JWT 信息在每次请求时都可以被更新，JWT 过期时间也会被自动加入。\n\n这篇文章：[Getting Token Authentication Right in a Stateless Single Page Application](https://medium.com/lightrail/getting-token-authentication-right-in-a-stateless-single-page-application-57d0c6474e3) 就很好地对上述方式进行了总结。\n\n为了实现最大限度的安全保障，我们也可以考虑结合前文介绍的 Double submitted cookie 以及“关键操作需要用户重新进行鉴权认证”的处理。\n\n例如，我们认为用户更改邮箱地址，是一个关键操作。那么，在发生这个操作时，即便用户已经登录，系统还是要求用户重新填写用户密码，以确认修改。后端在收到修改请求后，产生一个随机 number（经过加密运算），作为 permanent cookie 返回给前端，JavaScript 需要读取这个值，并将这个随机 number 作为表单 form value 的一项，它需要随新的邮箱地址一起提交，服务端对这个随机 form value 进行验证，验证方式是对比表单中的 form value 和 cookie 当中的随机 number 是否一致。\n\n这样便更大限度地防御了 CSRF 攻击，流程如下：\n\n<img src=\"https://images.gitbook.cn/c59db7e0-4eac-11e9-b1fa-0757868d211c\" width=600>\n\n我们总结一下流程。\n\n- Step 1：单页应用检查 cookie 中是否存在 JWT payload，如果存在，表示用户已经成功进行鉴权；反之，重定向到类似 /login 的登录页面。\n- Step2：用户在未授权的情况下，在登录页面 /login 将用户名和密码提交给服务端，服务端返回信息中设置 authentication cookie，cookie 中含有 JWT 信息。\n\n第二步的具体操作方法可以采用上述第二种和第三种方式，或者增强 CSRF 防御的其他手段。\n\n### 总结\n\n我们再来总结一下单页应用进行鉴权的关键问题：token 最初由服务端下发，前端在请求时需要携带。这样一来：\n\n- 如果前端将 JWT 存储在 localStorage 或者 sessionStorage 当中，由于 localStorage 或者 sessionStorage 都可以被 JavaScript 访问，如果攻击者能够读取 localStorage 或者 sessionStorage，那么就能轻易获取 token，很容易进行 XSS 攻击。\n\n- 如果将 JWT 存储在 cookie 当中，我们就可以指定 cookie httpOnly 属性，来防止被 JavaScript 读取，也可以指定 secure 属性，来保证 JWT 信息只在 HTTPS 下被携带。但是这样容易遭到 CSRF 攻击，因此就出现了我们的增强方式。\n\n本节我们通过分析和设计单页应用鉴权方案，熟悉了 JWT 和传统 cookie-session。我们在介绍一些安全方面最佳实践的同时，覆盖了一些常见的攻击手段：XSS 和 CSRF 等。前端安全是一个庞大且复杂的课题，本节只是通过一个比较重要的话题带大家切入，要想全面熟悉前端安全，完全可以开一门新课了。虽然我的课程志不在此，不过下面我会根据相关安全话题，将我收藏的文章分享给大家。\n\n课程代码仓库：\n\n<a href=\"https://github.com/HOUCe/lucas-gitchat-courses\">https://github.com/HOUCe/lucas-gitchat-courses</a>\n\n### <font color=13aa6c>彩蛋分享</font>\n\n#### HTTPS 相关\n\n- [https 连接的前几毫秒发生了什么](https://mp.weixin.qq.com/s/--KxUNzmBdKtOPBbovWCaA)\n- [完全图解 HTTPS](https://juejin.im/post/5c441073e51d455226654d60)\n- [更安全的 Web 通信 HTTPS](https://juejin.im/post/5b5f1289e51d4519601aeeda)\n- [图解基于 HTTPS 的 DNS](https://www.infoq.cn/article/a-cartoon-intro-to-dns-over-https)\n- [看图学 HTTPS](https://juejin.im/post/5b0274ac6fb9a07aaa118f49?utm_medium=fe&utm_source=weixinqun)\n- [http 与 https 的区别我真的知道吗](https://juejin.im/post/5af3e002f265da0b7c074ada)\n- [深入揭秘 HTTPS 安全问题&连接建立全过程](https://zhuanlan.zhihu.com/p/22142170)\n- [HTTPS系列干货（一）：HTTPS 原理详解](http://support.upyun.com/hc/kb/article/1031843/)\n- [HTTPS 为什么更安全，先看这些](http://support.upyun.com/hc/kb/article/1031843/https://juejin.im/post/58a8f3295c497d005fbd58b1)\n\n####攻防\n\n- [Web 前端攻防，一不小心就中招了](https://juejin.im/entry/58481d33128fe100579cb8c5)\n- [聊一聊 WEB 前端安全那些事儿](https://segmentfault.com/a/1190000006672214)\n- [常见 Web 安全攻防总结](https://zoumiaojiang.com/article/common-web-security/)\n- [前端安全防御指南](http://www.guofengxian.com/2018/01/15/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E9%98%B2%E5%BE%A1%E6%8C%87%E5%8D%97/)\n- [对于 XSS 和 CSRF 你究竟了解多少](http://netsecurity.51cto.com/art/201407/446775.htm)\n- [浅析前端安全之 XSS](https://mp.weixin.qq.com/s/c_QTdLu6vsYcIiuPRZyjyA)\n- [懂这些，你将能构建更安全的 Web 应用](https://juejin.im/entry/5b461d866fb9a04fb745c256)\n- [浅说 XSS 和 CSRF](https://juejin.im/entry/5b4b56fd5188251b1a7b2ac1)\n- [快速找出网站中可能存在的 XSS 漏洞实践](https://juejin.im/post/5b7bdfa1f265da437174ae0d)\n- [前端安全系列之一：如何防止 XSS 攻击？](https://mp.weixin.qq.com/s/kWxnYcCTLAQp5CGFrw30mQ)\n- [前端安全系列之二：如何防止 CSRF 攻击？](https://juejin.im/post/5bc009996fb9a05d0a055192)\n- [Web 安全漏洞之 XSS 攻击](https://juejin.im/post/5bf214e151882579cf011c2a)\n- [前端技术演进（三）：前端安全](https://juejin.im/post/5c137f37f265da6133567735)\n- [Preventing CSRF and XSRF Attacks](https://blog.codinghorror.com/preventing-csrf-and-xsrf-attacks/)\n\n#### 同源策略和跨域理论相关\n\n- [跨域与同源策略探究](http://blog.w2fzu.com/2018/03/10/2018-04-02-same-origin/)\n- [同源策略和跨域请求研究](https://www.cnblogs.com/yincheng/p/cross-domain.html)\n- [为什么提交表单不受同源政策限制](https://segmentfault.com/q/1010000011535675/a-1020000011537760)\n- [跨域资源共享 CORS 一些知识点](https://juejin.im/post/5ab21717518825611a405da3)\n- [Content Security Policy (CSP) 介绍](https://juejin.im/entry/5b82b5e56fb9a01a02311b27)\n- [30 分钟理解 CORB 是什么](https://juejin.im/post/5b7e826ee51d4538b35c04e8)\n- [不要再问我跨域的问题了](https://mp.weixin.qq.com/s/T5gM7M9WsRMSxXzZPDagcA)\n\n#### 鉴权\n\n- [讲真，别再使用 JWT 了！](https://www.jianshu.com/p/af8360b83a9f)\n- [JWT Token 存储在 Cookie 还是 Web Storage](https://blog.csdn.net/hxg117/article/details/76954606)\n- [Getting Token Authentication Right in a Stateless Single Page Application](https://medium.com/lightrail/getting-token-authentication-right-in-a-stateless-single-page-application-57d0c6474e3)\n- [登录那些事儿](https://juejin.im/entry/58a298f4128fe100582bf5c1)\n- [登录工程：现代 Web 应用的典型身份验证需求](https://juejin.im/entry/58a3d6f561ff4b006c875ee1)\n- [前后端常见的几种鉴权方式](https://blog.csdn.net/wang839305939/article/details/78713124)\n- [前端关于单点登录的知识](https://juejin.im/post/5b73c71fe51d45666016655a)\n- [如何加密传输和存储用户密码](https://juejin.im/post/5af5711e5188254267261e3b)\n- [Web 登录其实没那么简单](https://mp.weixin.qq.com/s/G_Grk8YTlu9-0WDZP85xAg)\n\n#### CDN 劫持和其他安全问题\n\n- [危险的 target=\"_blank\" 与 “opener”](https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227961&amp;idx=1&amp;sn=d4eb72b910281a18fc35581e0e39096f&amp;chksm=bd495ebd8a3ed7ab2dcc8d6bbfdd6f336f5b80a301cd3e7f92f56bdd3c95c749d9d6fd77282f&amp;mpshare=1&amp;scene=1&amp;srcid=0310vrk1VnUROjJY9XZ51Hoc)\n- [浅谈流量劫持与防治](https://zhuanlan.zhihu.com/p/40682772)\n- [短网址安全浅谈](https://security.tencent.com/index.php/blog/msg/126)\n- [使用 SRI 解决 CDN 劫持](https://juejin.im/post/5c355a816fb9a049a42f3ac8)\n- [了解下 DDoS 攻击方式](https://mp.weixin.qq.com/s/gVLXJO0IXol4q_ademXMWg)\n- [主流浏览器图片反防盗链方法总结](https://mp.weixin.qq.com/s/govRdwkNTEBJ1NJ1ipA40w?add=add)","pdfUrl":"","reader":"","duration":"","title":"不可忽视的前端安全 - 单页应用鉴权设计","column":"5c91c813968b1d64b1e08fde","isNotification":false,"htmlContent":"<p>安全是计算机科学永远无法忽视的话题。随着互联网的发展，安全问题越来越突出，也越来越重要：它是一个程序可用性、健壮性的基础。这个话题可大可小，大到系统的设计，小到一行代码的写法，都可能影响系统的安全。</p>\n<p>毫不例外，安全与前端开发的结合也持续走热。不管是经验丰富的程序员，还是尚在打基础的学生，也许都对 HTTPS、XSS、CSRF 等前端相关的安全问题不陌生。然而，这其中每一个主题都可以非常深入，都能系统地做一节课。但是，我认为面面俱到、走马观花地梳理这些内容，讲解这些概念价值不大。毕竟，这方面知识都已经比较成熟，社区上资料很多。</p>\n<p>本讲我想从一个大部分产品都要涉及的登录鉴权入手，结合单页面应用，从这个角度，管中窥豹，尽可能多地涉及一些常见的安全知识，帮助大家了解前端安全。</p>\n<p>接下来，让我们从应用场景入手，从前后端交互切入，以单页面应用为基础，呈现“鉴权”这个安全领域重要话题的全貌，并尽力覆盖到 XSS 和 CSRF 等攻击手段以及最佳实践。</p>\n<p>关于这个主题的知识点如下：</p>\n<img src=\"https://images.gitbook.cn/545627c0-4ecf-11e9-97d1-9b2c5e38f63d\" width=550>\n<h3><a id=\"_12\"></a>单页应用鉴权简介</h3>\n<p>首先，我们要分清单页应用鉴权与传统鉴权方式有所不同：</p>\n<div style=\"color:#024727;background:#f9f9f9;\"><p style=\"padding:10px\">单页应用采用前后端分离的设计方式，路由由前端管理，前后端遵循一定规范（如 REST、GraphQL），通过 AJAX 进行通信。在这种情况下，用户对页面请求时，后端经常无法获取用户身份信息，更无法确定返回的数据。</p></div>\n<p>同时一次鉴权完毕后，如何在单页应用的体验当中，保持这个鉴权状态也值得思考。一般来说，单页应用鉴权采用下面的步骤实现。</p>\n<ul>\n<li>Step 1：前端根据用户交互，发送数据请求之前，需要准备用户信息，同数据请求一起发给后端处理。</li>\n<li>Step 2-1：后端按照约定好的规则，根据请求中带有的用户身份信息，进行验证。如果验证不通过，返回 403 或者 401 相关状态码或其他状态，以表示鉴权失败。</li>\n<li>Step 2-2：如果鉴权成功，后端返回相关数据。</li>\n<li>Step 3：前端根据数据渲染视图。</li>\n</ul>\n<p>基本结构非常简单清晰：</p>\n<img src=\"https://images.gitbook.cn/b99cdee0-4eba-11e9-aba8-d90fcdb25340\" width=550>\n<p>在这个结构背后，隐藏的技术方案和安全细节非常值得我们思考，请继续阅读，我们将剖析几个重要概念和安全实践。</p>\n<h4><a id=\"HTTPS_31\"></a>HTTPS</h4>\n<p>鉴权过程中，如果使用 HTTP 协议来传输敏感数据（用户昵称、用户密码、token……），那么很容易被中间人拦截获取。现代通信中，我们都使用 HTTPS 协议来对传输内容进行加密。关于 HTTPS 的应用及其原理，又是一个超级话题。这里由于内容的限制，不过多展开，给大家分享一下我收藏的关于 HTTPS  好的文章：</p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/--KxUNzmBdKtOPBbovWCaA\" target=\"_blank\">https 连接的前几毫秒发生了什么</a></li>\n<li><a href=\"https://juejin.im/post/5c441073e51d455226654d60\" target=\"_blank\">完全图解 HTTPS</a></li>\n<li><a href=\"https://juejin.im/post/5b5f1289e51d4519601aeeda\" target=\"_blank\">更安全的 Web 通信 HTTPS</a></li>\n<li><a href=\"https://www.infoq.cn/article/a-cartoon-intro-to-dns-over-https\" target=\"_blank\">图解基于 HTTPS 的 DNS</a></li>\n<li><a href=\"https://juejin.im/post/5b0274ac6fb9a07aaa118f49?utm_medium=fe&amp;utm_source=weixinqun\" target=\"_blank\">看图学 HTTPS</a></li>\n<li><a href=\"https://juejin.im/post/5af3e002f265da0b7c074ada\" target=\"_blank\">http 与 https 的区别我真的知道吗</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/22142170\" target=\"_blank\">深入揭秘 HTTPS 安全问题&amp;连接建立全过程</a></li>\n<li><a href=\"http://support.upyun.com/hc/kb/article/1031843/\" target=\"_blank\">HTTPS系列干货（一）：HTTPS 原理详解</a></li>\n<li><a href=\"http://support.upyun.com/hc/kb/article/1031843/https://juejin.im/post/58a8f3295c497d005fbd58b1\" target=\"_blank\">HTTPS 为什么更安全，先看这些</a></li>\n</ul>\n<h4><a id=\"_URL_query__45\"></a>不要使用 URL query 传递敏感数据</h4>\n<p>URL query 会通过服务端日志、浏览器日志、浏览器历史记录查到。不要使用 URL query 传递敏感数据，这当然是最基本的准则之一。如果敏感数据在 URL query 中，这就给了恶意用户轻松获取数据的机会。同时，URL query 的长度也有限制，这也是其传递数据的弊端之一。</p>\n<h4><a id=\"_49\"></a>防止暴力攻击的手段</h4>\n<p>攻击者可以通过暴力手段，尝试攻破用户的密码等信息。因此后端服务要时刻注意加入频率限制，限制一个用户短时间尝试密码的次数；也可以限制可疑用户（比如触发了过多服务端错误用户）的访问。另外，需要注意的是不要给任何人暴露服务端的技术细节信息，比如要记得关闭 X-Powered-By（服务器响应头隐藏）；Node 端在使用 express.js 的情况下，强烈建议使用 <a href=\"https://expressjs.com/en/advanced/best-practice-security.html#use-helmet\" target=\"_blank\">Helmetjs</a>。</p>\n<p>Helmet 帮助 Node.js 开发者通过设置合理的 HTTP header，预防一些常见的 Web 漏洞，比如上面提到的关闭 X-Powered-By。实际上它就是一组灵活的中间件函数，增强以下 HTTP header 的安全性：</p>\n<ul>\n<li>Content-Security-Policy 响应头，它可以设置应用是否可以引用某些来源内容，进而防止 XSS</li>\n<li>关闭 X-Powered-By 响应头，以避免暴露服务端信息</li>\n<li>增加 <a href=\"https://developer.mozilla.org/en-US/docs/Web/Security/Public_Key_Pinning\" target=\"_blank\">Public Key Pinning</a> 响应头，预防中间人伪造证书</li>\n<li>设置 Strict-Transport-Security 响应头，这样浏览器只能通过 HTTPS 访问当前资源</li>\n<li>为 IE8+ 设置 X-Download-Options 响应头，目前只有 IE8+ 支持这个 header，用来预防下载内容的安全隐患</li>\n<li>设置 Cache-Control 和 Pragma header 以关闭浏览器端缓存</li>\n<li>设置 X-Content-Type-Options 响应头，以禁用浏览器内容嗅探</li>\n<li>设置 X-Frame-Options 响应头，以预防 <a href=\"https://www.owasp.org/index.php/Clickjacking\" target=\"_blank\">clickjacking</a>，这个响应头给浏览器指示是否允许在 <code>&lt;frame&gt;</code> 或者 <code>&lt;iframe&gt;</code> 标签中渲染某个页面</li>\n<li>设置 X-XSS-Protection 响应头，当检测到跨站脚本攻击（XSS）时，浏览器停止加载页面</li>\n</ul>\n<p>它的使用非常简单：</p>\n<pre><code class=\"lang-\">const express = require(&apos;express&apos;)\nconst helmet = require(&apos;helmet&apos;)\n\nconst app = express()\n\napp.use(helmet())\n</code></pre>\n<p>其源码是典型的 express 中间件写法，它依次加载相关中间件集。比如它将引用 X-Powered-By 中间件，这个中间件的源码非常简单：</p>\n<pre><code class=\"lang-\">module.exports = function hidePoweredBy (options) {\n  var setTo = (options || {}).setTo\n\n  if (setTo) {\n    return function hidePoweredBy (req, res, next) {\n      res.setHeader(&apos;X-Powered-By&apos;, setTo)\n      next()\n    }\n  } else {\n    return function hidePoweredBy (req, res, next) {\n      res.removeHeader(&apos;X-Powered-By&apos;)\n      next()\n    }\n  }\n}\n</code></pre>\n<p>通过 setHeader 和 removeHeader 方法，完成对 X-Powered-By 响应头的添加和删除。</p>\n<h4><a id=\"_98\"></a>升级依赖保证安全</h4>\n<p>现如今我们的应用，大部分脚本都来自第三方依赖，第三方库出现安全隐患的新闻已经屡见不鲜。除了从源头把控依赖的引入外，适时合理地更新 npm 包，是值得倡导的做法，npm 便在 6.0 后有相关命令如下：</p>\n<pre><code class=\"lang-\"># npm 6.0 新增，扫描所有依赖，列出依赖中有安全隐患的包\nnpm audit\n# npm 6.0 新增，扫描所有依赖，并把不安全的依赖包升级到可兼容的版本\nnpm audit fix\n</code></pre>\n<h3><a id=\"_109\"></a>单页应用鉴权实战</h3>\n<p>言归正传，我们来看一下实现单页应用鉴权的两种主要手段：</p>\n<ul>\n<li>JWT</li>\n<li>Authentication cookie</li>\n</ul>\n<p><strong>这两种方式不尽相同，我们将逐一分析，并尝试合并这两种方案的优点，将它们结合为第三种方式。</strong></p>\n<h4><a id=\"_JWT__118\"></a>采用 JWT 实现鉴权</h4>\n<p>在鉴权过程中，为了验证用户的身份，需要浏览器向服务器端提供一个验证信息，我们称为 token。这个 token 通常由 JSON 数据格式组成，通过 hash 散列算法生成一个字符串，称为 JSON Web Token（JSON 表示令牌的原始类型为 JSON 格式，Web 表示在互联网中进行传播，Token 表示令牌，简称 JWT）。任何 token 持有者都可以无差别地用它来访问相关的资源。</p>\n<p>我们可以在 HTTP Authorization header 中找到 token，其实就是一个字符串值。这个字符串用来表示用户的身份信息，进行身份认证或者从服务器获取合法资源。当然这个 token 往往是被加密的。那么这个 token 具体是如何生成的呢？</p>\n<p>我们先从 JWT 说起，一个 JWT 包含以下 3 个部分：</p>\n<ul>\n<li>header（消息头）</li>\n<li>payload（消息体，储存用户 id、用户角色等） + 过期时间（可选）</li>\n<li>signature（签名）</li>\n</ul>\n<p>我们说过，JWT 就是 JSON 格式的数据，JWT  的前两个部分就是 JSON 数据，第三部分 signature 是基于前两部分 header 和 payload 生成的签名。前两部分分别通过 Base64URL 算法生成两组字符串，再和 signature 结合，三部分通过 . 号分割，就是最终的 token。</p>\n<p>更多这方面的信息，大家可以参考：</p>\n<ul>\n<li><a href=\"https://medium.com/vandium-software/5-easy-steps-to-understanding-json-web-tokens-jwt-1164c0adfcec\" target=\"_blank\">5 Easy Steps to Understanding JSON Web Tokens (JWT)</a></li>\n<li><a href=\"https://www.jianshu.com/p/8f7009456abc\" target=\"_blank\">Bearer Token</a></li>\n<li><a href=\"https://www.cnblogs.com/XiongMaoMengNan/p/6785155.html\" target=\"_blank\">OAuth 2.0: Bearer Token Usage</a></li>\n</ul>\n<p>正常来讲，当客户端在提交用户名/密码（或者其他方式）通过认证后，会获得 JWT 的 token，接着通过 JavaScript 脚本，对于所有数据请求都在其 HTTP header 中加上这个 JWT 的 token。服务端接到请求之后，验证 token 的 signature 是否等同于 payload，进而得知 payload 字段是否被中间人更改。</p>\n<p>细心的读者可能会发现，我们提到“通过 JavaScript 脚本，对于所有数据请求，都在 HTTP header 中加上这个 token”。这就涉及<strong>客户端如何存储和维护 JWT</strong> 的问题了。</p>\n<p>存储 JWT，我们可以考虑：</p>\n<ul>\n<li>内存存储</li>\n<li>local/session cookie</li>\n<li>local/session storage……</li>\n</ul>\n<p>这几种方式。我并不建议开发者将 token 存储在 local storage 当中，因为：</p>\n<ul>\n<li>当用户关掉浏览器后，JWT 仍然会被存储在 local storage 中，即便 JWT 过期，可能一直被存储（除非手动更新或清理）</li>\n<li>任何 JavaScript 都能轻而易举地获得 local storage 的内容</li>\n<li>无法被 web worker 使用</li>\n</ul>\n<p>但在实际项目中，笔者也在 local storage 中存储过 JWT，这需要我们分清利弊，结合实际场景选择方案。如果吃透概念，就能减少 bug 的出现，具体存储方案可以灵活一些。</p>\n<p>更好的选择之一是将 JWT 存储在 session cookie 中，auth0 有一篇很好的文章，感兴趣的读者可以参考：<a href=\"https://auth0.com/docs/security/store-tokens\" target=\"_blank\">Where to Store Tokens</a>。</p>\n<h4><a id=\"JWT__158\"></a>JWT 隐患</h4>\n<p>JWT 实现鉴权也存在的隐患，上面我们也简要提到了，隐患主要来自 <a href=\"https://www.owasp.org/index.php/Cross-site_Scripting_%28XSS%29\" target=\"_blank\">XSS</a>。攻击者可以主动注入恶意脚本或者使用用户输入，通过 JavaScript 代码来偷取 token，接下来便能通过 token 冒充受害用户。</p>\n<p>比如，一个博客留言系统，用户可以在其留言内容中加入以下脚本：</p>\n<pre><code class=\"lang-\">&lt;img src=x onerror=&quot;&amp;#0000106&amp;#0000097&amp;#0000118&amp;#0000097&amp;#0000115&amp;#0000099&amp;#0000114&amp;#0000105&amp;#0000112&amp;#0000116&amp;#0000058&amp;#0000097&amp;#0000108&amp;#0000101&amp;#0000114&amp;#0000116&amp;#0000040&amp;#0000039&amp;#0000088&amp;#0000083&amp;#0000083&amp;#0000039&amp;#0000041&quot;&gt;\n</code></pre>\n<p>一般的防御手段是采用 HTML 转义来控制过滤用户输入（为了防止 XSS 攻击，常常需要将用户输入的特殊字符进行转义）。</p>\n<h3><a id=\"_Authentication_cookie__170\"></a>采用 Authentication cookie 实现鉴权</h3>\n<p>cookie 是含有有效期和相关 domain，存储在浏览器中的键值对组合，可以由 JavaScript 创建：</p>\n<pre><code>document.cookie = ‘my_cookie_name=my_cookie_value’\n</code></pre>\n<p>也可以由服务端通过  response header 创建：</p>\n<pre><code class=\"lang-\">Set-Cookie: my_cookie_name=my_cookie_value\n</code></pre>\n<p>浏览器会自动在每个请求当中加入相关 domain 下的 cookie：</p>\n<pre><code class=\"lang-\">GET https://www.example.com/api/users\nCookie: my_cookie_name=my_cookie_value\n</code></pre>\n<p>cookie 一般分为两种（<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies\" target=\"_blank\">出处</a>）：</p>\n<blockquote>\n<ul>\n<li>Session cookie，这种 cookie 会随着用户关闭浏览器而被清除，不会被标记任何过期时间 Expires 或者最大时限 Max-Age。</li>\n<li>Permanent cookie，与 session cookie 相反，会在用户关闭浏览器之后被浏览器持久化存储。</li>\n</ul>\n</blockquote>\n<p>同时，服务端可以对 cookie 进行一些关键配置，以保障 cookie 的使用安全，诸如：</p>\n<ul>\n<li>HttpOnly cookie：浏览器端 JavaScript 没有读 cookie 权限。</li>\n<li>Secure cookie：传输链路只有在特定安全通道（通常指 HTTPS），请求才会自动加入相关 cookie。</li>\n<li>SameSite cookie：在跨域情况下，相关 cookie 无法被请求携带，这里主要是为了防止 CSRF 攻击。</li>\n</ul>\n<p>一个经典场景就是使用 cookie 存储一个 session ID（session ID 由服务端管理，进行创建和计时，以便在必要的时候清除）。通过验证 cookie 和 session ID，服务端便能标记一个用户的访问信息。这种情况就是我们说的 stateful，而本节课的主角 JWT 是 stateless 的，因为它不需要服务端维护 session ID，是无状态的，更加利于横向扩展。</p>\n<h4><a id=\"Authentication_cookie__202\"></a>Authentication cookie 隐患</h4>\n<p>采用 Authentication cookie 实现单页应用鉴权的安全隐患主要有两种：</p>\n<ul>\n<li>\n<p><a href=\"https://www.owasp.org/index.php/Cross-site_Scripting_%28XSS%29\" target=\"_blank\">XSS</a>　如果没有使用 httpOnly 选项，那么攻击者可能会通过注入恶意脚本，任意读取用户 cookie。而 cookie 直接存储了用户的身份认证信息，这当然是非常可怕的。</p>\n</li>\n<li>\n<p><a href=\"https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)\" target=\"_blank\">CSRF</a> 是常见的针对 cookie 展开进攻的手段。我们知道跨域访问技术（CORS，跨域资源共享）的同源策略能保证不同源的客户端脚本在没有明确授权的情况下，无法读写对方资源。同源策略只是针对浏览器侧的编程脚本语言，如果我们对另一个恶意服务器发送 AJAX 请求，同源策略会有所限制，但是如果请求直接通过 HTML form 发送，那么同源策略毫无办法。</p>\n</li>\n</ul>\n<pre><code class=\"lang-\">&lt;form action=&quot;http://someotherserver.com&quot;&gt;\n</code></pre>\n<p>另一个利用 CSRF 实施攻击的场景为：假如受害者在网页中登录了 Facebook，同时又打开了 bad.com，bad.com 属于攻击者的网站，这个网站中有这样的代码：</p>\n<pre><code class=\"lang-\">&lt;img src=&quot;https://facebook.com/postComment?userId=dupont_123&amp;comment=I_VE_BEEN_HACKED&gt;\n</code></pre>\n<p>如此一来，攻击者网站的代码请求了 Facebook 发送个人状态的接口（https://facebook.com/postComment?），该受害者会莫名其妙地发送一个状态，内容为 “I_VE_BEEN_HACKED”。</p>\n<div style=\"color:#024727;background:#f9f9f9;\"><p style=\"padding:10px\"><strong>总结</strong>　为了防御 XSS 攻击，需要开发者设置 <code>httpOnly</code> 选项；为了防御 XSRF，需要开发者设置 <code>SameSite</code> 选项。需要注意，并不是所有浏览器都支持 <a href=\"https://caniuse.com/#feat=same-site-cookie-attribute\">SameSite</a>。</p></div>\n<p><strong>此外，一些其他防御手段有：</strong></p>\n<ul>\n<li>Short session timeout：设置 session 过期时间，比如银行网站往往需要每 10 分钟或者更短时间就重新登录。</li>\n<li>关键操作需要用户重新进行鉴权认证。</li>\n<li>Double submitted cookie：当用户浏览一个站点时，服务端生成一个伪随机数 pseudorandom value，并将其设置为 cookie，且不设置 httpOnly 标识。这样 JavaScript 就能够访问这个 pseudorandom value，并要求在提交每个表单时，一并将这个 pseudorandom value 作为 form value 提交上来，同时在 cookie 中也要提交 value。服务端便可以对比 form value 中的 pseudorandom value 和 cookie value 是否一致，以此来认证用户的安全身份。</li>\n</ul>\n<p>Double submitted cookie 之所以能有效防范攻击，是因为同源策略致使攻击者无法读取来自攻击目标服务端的 cookie 值，更无法修改攻击网站的 cookie value。即便攻击者可以从 form 中提交任何 form value，但是无法通过服务端对 form value 中的 pseudorandom value 和 cookie value 的一致性进行验证。</p>\n<h3><a id=\"_JWT__cookie__232\"></a>混合 JWT 和 cookie 进行鉴权</h3>\n<p>设想我们要实现这样一个鉴权系统：</p>\n<ul>\n<li>尽可能抵御 XSS 和 CSRF</li>\n<li>做到 stateless</li>\n</ul>\n<p>考虑到安全性能，JWT 方案的主要问题在于攻击者存在直接读取 JWT 信息的可能。<strong>如果我们将 JWT 和 cookie 方案结合呢</strong>？即将 JWT 部分敏感信息放入 cookie 当中，这样一来，便可以结合前文两种方式的优点。</p>\n<p>如图，我们再总结一下存在的三种交互可能。第一种是经典 JWT 方式：</p>\n<img src=\"https://images.gitbook.cn/b54a5600-4eac-11e9-9566-89cb1d9578c6\" width=550>\n<p>这种情况下，前后端使用 JWT 进行鉴权交互，前端通过 JavaScript 操作 JWT 信息完成请求准备。</p>\n<p>第二种方式，将 JWT 信息在 session cookie 中维护：</p>\n<img src=\"https://images.gitbook.cn/ba54c590-4eac-11e9-b1fa-0757868d211c\" width=550>\n<p>在这种情况下，JWT 信息全部存储在 cookie 中， 并设置 cookie 的 httpOnly、SameSite、Secure 属性，前端无法读取 JWT 信息，但每次请求都会由浏览器带上必要的 JWT 数据（作为 cookie）。同时，由于采用 session cookie，也不存在 JWT 信息过期的情况，用户关闭页面之后不会将 JWT 信息持久化存储，下次再打开页面时，会重新进行鉴权流程。</p>\n<p>第一种方式有一定的安全隐患；第二种方式我们将 JWT 所有信息存储在 session cookie 当中，优点明显，但是无法做到持久化存储，在某种程度上也会带来不便。那么我们权衡之后进行了变通，结合前面两种方式产生了第三种方式：</p>\n<img src=\"https://images.gitbook.cn/990f8c00-4eb9-11e9-b0b8-a9c8a3696845\" width=550>\n<p>这样，JWT 的 signature 部分维护在设置了 httpOnly 的 cookie 中，这意味着 JavaScript 无法读取完整的 JWT 信息。同时，cookie 会在每次请求中被携带， 并由服务端返回后在浏览器中进行存储，这样 JWT 信息在每次请求时都可以被更新，JWT 过期时间也会被自动加入。</p>\n<p>这篇文章：<a href=\"https://medium.com/lightrail/getting-token-authentication-right-in-a-stateless-single-page-application-57d0c6474e3\" target=\"_blank\">Getting Token Authentication Right in a Stateless Single Page Application</a> 就很好地对上述方式进行了总结。</p>\n<p>为了实现最大限度的安全保障，我们也可以考虑结合前文介绍的 Double submitted cookie 以及“关键操作需要用户重新进行鉴权认证”的处理。</p>\n<p>例如，我们认为用户更改邮箱地址，是一个关键操作。那么，在发生这个操作时，即便用户已经登录，系统还是要求用户重新填写用户密码，以确认修改。后端在收到修改请求后，产生一个随机 number（经过加密运算），作为 permanent cookie 返回给前端，JavaScript 需要读取这个值，并将这个随机 number 作为表单 form value 的一项，它需要随新的邮箱地址一起提交，服务端对这个随机 form value 进行验证，验证方式是对比表单中的 form value 和 cookie 当中的随机 number 是否一致。</p>\n<p>这样便更大限度地防御了 CSRF 攻击，流程如下：</p>\n<img src=\"https://images.gitbook.cn/c59db7e0-4eac-11e9-b1fa-0757868d211c\" width=600>\n<p>我们总结一下流程。</p>\n<ul>\n<li>Step 1：单页应用检查 cookie 中是否存在 JWT payload，如果存在，表示用户已经成功进行鉴权；反之，重定向到类似 /login 的登录页面。</li>\n<li>Step2：用户在未授权的情况下，在登录页面 /login 将用户名和密码提交给服务端，服务端返回信息中设置 authentication cookie，cookie 中含有 JWT 信息。</li>\n</ul>\n<p>第二步的具体操作方法可以采用上述第二种和第三种方式，或者增强 CSRF 防御的其他手段。</p>\n<h3><a id=\"_276\"></a>总结</h3>\n<p>我们再来总结一下单页应用进行鉴权的关键问题：token 最初由服务端下发，前端在请求时需要携带。这样一来：</p>\n<ul>\n<li>\n<p>如果前端将 JWT 存储在 localStorage 或者 sessionStorage 当中，由于 localStorage 或者 sessionStorage 都可以被 JavaScript 访问，如果攻击者能够读取 localStorage 或者 sessionStorage，那么就能轻易获取 token，很容易进行 XSS 攻击。</p>\n</li>\n<li>\n<p>如果将 JWT 存储在 cookie 当中，我们就可以指定 cookie httpOnly 属性，来防止被 JavaScript 读取，也可以指定 secure 属性，来保证 JWT 信息只在 HTTPS 下被携带。但是这样容易遭到 CSRF 攻击，因此就出现了我们的增强方式。</p>\n</li>\n</ul>\n<p>本节我们通过分析和设计单页应用鉴权方案，熟悉了 JWT 和传统 cookie-session。我们在介绍一些安全方面最佳实践的同时，覆盖了一些常见的攻击手段：XSS 和 CSRF 等。前端安全是一个庞大且复杂的课题，本节只是通过一个比较重要的话题带大家切入，要想全面熟悉前端安全，完全可以开一门新课了。虽然我的课程志不在此，不过下面我会根据相关安全话题，将我收藏的文章分享给大家。</p>\n<p>课程代码仓库：</p>\n<p><a href=\"https://github.com/HOUCe/lucas-gitchat-courses\">https://github.com/HOUCe/lucas-gitchat-courses</a></p>\n<h3><a id=\"font_color13aa6cfont_290\"></a><font color=13aa6c>彩蛋分享</font></h3>\n<h4><a id=\"HTTPS__292\"></a>HTTPS 相关</h4>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/--KxUNzmBdKtOPBbovWCaA\" target=\"_blank\">https 连接的前几毫秒发生了什么</a></li>\n<li><a href=\"https://juejin.im/post/5c441073e51d455226654d60\" target=\"_blank\">完全图解 HTTPS</a></li>\n<li><a href=\"https://juejin.im/post/5b5f1289e51d4519601aeeda\" target=\"_blank\">更安全的 Web 通信 HTTPS</a></li>\n<li><a href=\"https://www.infoq.cn/article/a-cartoon-intro-to-dns-over-https\" target=\"_blank\">图解基于 HTTPS 的 DNS</a></li>\n<li><a href=\"https://juejin.im/post/5b0274ac6fb9a07aaa118f49?utm_medium=fe&amp;utm_source=weixinqun\" target=\"_blank\">看图学 HTTPS</a></li>\n<li><a href=\"https://juejin.im/post/5af3e002f265da0b7c074ada\" target=\"_blank\">http 与 https 的区别我真的知道吗</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/22142170\" target=\"_blank\">深入揭秘 HTTPS 安全问题&amp;连接建立全过程</a></li>\n<li><a href=\"http://support.upyun.com/hc/kb/article/1031843/\" target=\"_blank\">HTTPS系列干货（一）：HTTPS 原理详解</a></li>\n<li><a href=\"http://support.upyun.com/hc/kb/article/1031843/https://juejin.im/post/58a8f3295c497d005fbd58b1\" target=\"_blank\">HTTPS 为什么更安全，先看这些</a></li>\n</ul>\n<p>####攻防</p>\n<ul>\n<li><a href=\"https://juejin.im/entry/58481d33128fe100579cb8c5\" target=\"_blank\">Web 前端攻防，一不小心就中招了</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000006672214\" target=\"_blank\">聊一聊 WEB 前端安全那些事儿</a></li>\n<li><a href=\"https://zoumiaojiang.com/article/common-web-security/\" target=\"_blank\">常见 Web 安全攻防总结</a></li>\n<li><a href=\"http://www.guofengxian.com/2018/01/15/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E9%98%B2%E5%BE%A1%E6%8C%87%E5%8D%97/\" target=\"_blank\">前端安全防御指南</a></li>\n<li><a href=\"http://netsecurity.51cto.com/art/201407/446775.htm\" target=\"_blank\">对于 XSS 和 CSRF 你究竟了解多少</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/c_QTdLu6vsYcIiuPRZyjyA\" target=\"_blank\">浅析前端安全之 XSS</a></li>\n<li><a href=\"https://juejin.im/entry/5b461d866fb9a04fb745c256\" target=\"_blank\">懂这些，你将能构建更安全的 Web 应用</a></li>\n<li><a href=\"https://juejin.im/entry/5b4b56fd5188251b1a7b2ac1\" target=\"_blank\">浅说 XSS 和 CSRF</a></li>\n<li><a href=\"https://juejin.im/post/5b7bdfa1f265da437174ae0d\" target=\"_blank\">快速找出网站中可能存在的 XSS 漏洞实践</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/kWxnYcCTLAQp5CGFrw30mQ\" target=\"_blank\">前端安全系列之一：如何防止 XSS 攻击？</a></li>\n<li><a href=\"https://juejin.im/post/5bc009996fb9a05d0a055192\" target=\"_blank\">前端安全系列之二：如何防止 CSRF 攻击？</a></li>\n<li><a href=\"https://juejin.im/post/5bf214e151882579cf011c2a\" target=\"_blank\">Web 安全漏洞之 XSS 攻击</a></li>\n<li><a href=\"https://juejin.im/post/5c137f37f265da6133567735\" target=\"_blank\">前端技术演进（三）：前端安全</a></li>\n<li><a href=\"https://blog.codinghorror.com/preventing-csrf-and-xsrf-attacks/\" target=\"_blank\">Preventing CSRF and XSRF Attacks</a></li>\n</ul>\n<h4><a id=\"_321\"></a>同源策略和跨域理论相关</h4>\n<ul>\n<li><a href=\"http://blog.w2fzu.com/2018/03/10/2018-04-02-same-origin/\" target=\"_blank\">跨域与同源策略探究</a></li>\n<li><a href=\"https://www.cnblogs.com/yincheng/p/cross-domain.html\" target=\"_blank\">同源策略和跨域请求研究</a></li>\n<li><a href=\"https://segmentfault.com/q/1010000011535675/a-1020000011537760\" target=\"_blank\">为什么提交表单不受同源政策限制</a></li>\n<li><a href=\"https://juejin.im/post/5ab21717518825611a405da3\" target=\"_blank\">跨域资源共享 CORS 一些知识点</a></li>\n<li><a href=\"https://juejin.im/entry/5b82b5e56fb9a01a02311b27\" target=\"_blank\">Content Security Policy (CSP) 介绍</a></li>\n<li><a href=\"https://juejin.im/post/5b7e826ee51d4538b35c04e8\" target=\"_blank\">30 分钟理解 CORB 是什么</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/T5gM7M9WsRMSxXzZPDagcA\" target=\"_blank\">不要再问我跨域的问题了</a></li>\n</ul>\n<h4><a id=\"_331\"></a>鉴权</h4>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/af8360b83a9f\" target=\"_blank\">讲真，别再使用 JWT 了！</a></li>\n<li><a href=\"https://blog.csdn.net/hxg117/article/details/76954606\" target=\"_blank\">JWT Token 存储在 Cookie 还是 Web Storage</a></li>\n<li><a href=\"https://medium.com/lightrail/getting-token-authentication-right-in-a-stateless-single-page-application-57d0c6474e3\" target=\"_blank\">Getting Token Authentication Right in a Stateless Single Page Application</a></li>\n<li><a href=\"https://juejin.im/entry/58a298f4128fe100582bf5c1\" target=\"_blank\">登录那些事儿</a></li>\n<li><a href=\"https://juejin.im/entry/58a3d6f561ff4b006c875ee1\" target=\"_blank\">登录工程：现代 Web 应用的典型身份验证需求</a></li>\n<li><a href=\"https://blog.csdn.net/wang839305939/article/details/78713124\" target=\"_blank\">前后端常见的几种鉴权方式</a></li>\n<li><a href=\"https://juejin.im/post/5b73c71fe51d45666016655a\" target=\"_blank\">前端关于单点登录的知识</a></li>\n<li><a href=\"https://juejin.im/post/5af5711e5188254267261e3b\" target=\"_blank\">如何加密传输和存储用户密码</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/G_Grk8YTlu9-0WDZP85xAg\" target=\"_blank\">Web 登录其实没那么简单</a></li>\n</ul>\n<h4><a id=\"CDN__343\"></a>CDN 劫持和其他安全问题</h4>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227961&amp;idx=1&amp;sn=d4eb72b910281a18fc35581e0e39096f&amp;chksm=bd495ebd8a3ed7ab2dcc8d6bbfdd6f336f5b80a301cd3e7f92f56bdd3c95c749d9d6fd77282f&amp;mpshare=1&amp;scene=1&amp;srcid=0310vrk1VnUROjJY9XZ51Hoc\" target=\"_blank\">危险的 target=&quot;_blank&quot; 与 “opener”</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/40682772\" target=\"_blank\">浅谈流量劫持与防治</a></li>\n<li><a href=\"https://security.tencent.com/index.php/blog/msg/126\" target=\"_blank\">短网址安全浅谈</a></li>\n<li><a href=\"https://juejin.im/post/5c355a816fb9a049a42f3ac8\" target=\"_blank\">使用 SRI 解决 CDN 劫持</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/gVLXJO0IXol4q_ademXMWg\" target=\"_blank\">了解下 DDoS 攻击方式</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/govRdwkNTEBJ1NJ1ipA40w?add=add\" target=\"_blank\">主流浏览器图片反防盗链方法总结</a></li>\n</ul>\n","readingStatistics":0,"createdAt":"2019-03-26T06:39:00.970Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":49,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FoThASW9dVEPMEo9nP-zaOfbKyLZ"},{"_id":"5cbbf7f4bbbba80861a35c8a","communication_start_time":null,"type":1,"audioPath":"","abstract":"","content":"在西班牙语中，有一个很特别的的词语叫做“Sobremesa”，它专指「吃完饭后，大家在饭桌上意犹未尽交谈的那段短暂而美好时光」。我们的专栏也已经全部更新完毕，历经“枯燥的程序知识”，我希望在最后部分，让我们放松心情，我将会从两方面谈一谈“软素质”，作为全部专栏内容的结束语。\n\n### 融入社区\n\n我们每一个人作为全球开发者的一份子，如果能够参与到社区，这对于个人成长会很有帮助的。这其中一个非常重要的话题就是「Github 使用礼仪」。大家可能比较熟悉了 Github 中使用 star、fork、watch 等基本功能。如果想重深度参与社区并成为开源库的贡献者，一般有两种方式：\n\n- 提 issue\n- 提 pull request\n\n首先，提 issue 一般有两种情况：报 bug 和提需求。如果是报 bug，最重要的是确认 bug 和表达清楚复现方式。对于一些较为复杂的复现场景，我们可以写一个 demo 帮助维护者发现问题；如果是提需求，我们就要尽量把控需求的合理性，这一点对于天天和产品“撕逼”的我们来说，应该不是太大问题。\n\n提 pull request，就是申请往主库中合并代码。这其中涉及到一些 Git 的基本操作，主要流程是先 fork 目标仓库，进行修改之后进行推送，最后进入目标项目页面，发起 PR。\n\n当然，我们不仅仅可以给开源库贡献代码，也可以作为创始者，向社区贡献内容。这个环节中，“如何写好一个现代库”，这个问题涉及到了方方面面的知识。比如你要思考：\n\n- 证书如何设置\n- 文档如何设计，让使用者快速上手\n- TODO 和 CHANGELOG 需要遵循哪些规范\n- 如何设计构建流程\n- 如何设计编译范围和流程\n- 如何设计模块化方案和打包流程\n- 如何设计自动规范化链路\n- 如何保证版本规范和 commit 规范\n- 如何进行测试设计\n- 如何引入可持续集成\n- 其他最佳实践\n\n为此，我给大家推荐我作为核心开发者的一个开源项目：[Jslib-base](https://github.com/yanhaijing/jslib-base)，这是一个“为了写库而写的库”，它可以帮助开发者通过简单的命令就能创建出一个库的脚手架和基础代码。整个项目实现非常简单，但尽可能结合“最佳实践”。如果你想写一个库，那我建议你考虑使用它来开启第一步；如果你想了解如何从零设计一个项目，也许可以通过它收获启发。给大家推荐相关文章：\n\n- [8102年如何写一个现代的JavaScript库](https://zhuanlan.zhihu.com/p/46332833)\n\n如果有机会，我会专门介绍一下这个库的编写和设计思想，虽然这不复杂，但是我们从中能够延伸出来的问题都很有趣。\n\n### 自我修养\n\n论“程序员”的修养，这个话题非常开放。我们能想到很多关键词，比如：\n\n- 保持热情\n- 谦虚谨慎\n- 学会阅读\n- 学会提问\n- 善用搜索\n- 学会写作（文档/博客等）\n- “科学上网”\n- 时间管理\n- 知识管理\n- 英语学习\n\n我个人很不喜欢所谓的“成功学”和“方法论”，更讨厌“制造焦虑”，“兜售”鸡汤。免入俗套，我打算从两种动物来说一下“废话”。\n\n不管是学习进阶之路，还是工作中的项目，我们能够遇到的真正问题只有两类：第一种是**看不见的**，我把它比作为黑天鹅，总会在你意想不到的时间和地点出现，并彻底颠覆一切；第二种是被我们**视而不见的**，我把它比喻成灰犀牛：你知道且习惯于它的存在，但是它会在某个时刻突然爆发，一旦爆发就会席卷一切，无从抵抗。\n\n项目开发和个人成长都有黑天鹅和灰犀牛的危机。\n\n#### 黑天鹅\n\n「新技术的爆发，技术的更新换代」就是职业生涯的黑天鹅。但我们需要辩证地来认识他：对于菜鸟来说，新技术和未知领域让年轻人有机会弯道超车，减少因为欠缺经验和阅历而带来的劣势；对于有一定工作经验和阅历的程序员来说，「颠覆」和「变革」这样的词语似乎不那么友好。\n\n但是新技术说到底也只是工具，而真正资深程序员的核心价值在于：逻辑、分析、数据、算法等抽象能力。技术工具只是这些抽象能力的表述形式。从汇编语言转到 C 语言，其实更能发挥 C 的强大控制能力；从 C 转到 Java，只需要理解面向对象和虚拟机就能很快适应并脱颖而出；从 Java 转到 Python 的程序员，甚至都会感叹写代码“太简单了”！\n\n总之，黑天鹅即是危机，也是机会。新技术作为新工具，总能带来新的价值蓝海。如果能把黑天鹅当做机会，保持敏感、好奇和进取的心态，扩展技能树，就能驯服来势汹汹的新技术。我们所有人一起共勉。\n\n#### 灰犀牛\n\n社会中，很多职业是越老越值钱：老警察、老医生、老艺术家，说起来就让人觉得技术高超，令人信赖。\n\n职业进阶就是一只灰犀牛。在悄悄溜走的时间中，我们可能习惯了日复一日的重复劳动。程序员怕的不是变老，而是变老的同时没有变强。如何击退这只灰犀牛，这需要我们从天天接触的工作代码入手，从熟悉的事物出发，找到突破。\n\n比如，在这个专栏的工程化章节中，我重点突出了：如何增强程序的健硕性、如何让我们的开发效率提升、如何持续不断地完善项目、如何从零开始打磨基础构建体系。仔细思考，里面的内容也许就能接入你的项目当中。\n\n从机械的工作抽象出更完美的工程化流程，这样的话题似乎永远说不完。我也总有新的心得和体会想和大家一起分享、交流。专栏已完结，但是衷心希望我们的技术探险之旅，仅仅是拉开帷幕。\n\n### 最后\n\n站在跑道的起点，你不知道跑到哪里肌肉会开始发痛，呼吸急促，想要停下来休息；在二三十岁的年纪，我们无从得知学习了一份课程，能对自己的水平提高和职业发展起多大作用。但我记得，在开篇词中，提到了村上春树的《当我谈跑步时，我谈些什么》这本书：也许不论是跑步还是写代码，都是在探索生命的种种可能。\n\n—— 不去跑，永远不知道能跑多远；不去做，永远不知道能做多好。","pdfUrl":"","reader":"","duration":"","title":"大话社区和一名技术者的自我修养","column":"5c91c813968b1d64b1e08fde","isNotification":false,"readingStatistics":0,"htmlContent":"<p>在西班牙语中，有一个很特别的的词语叫做“Sobremesa”，它专指「吃完饭后，大家在饭桌上意犹未尽交谈的那段短暂而美好时光」。我们的专栏也已经全部更新完毕，历经“枯燥的程序知识”，我希望在最后部分，让我们放松心情，我将会从两方面谈一谈“软素质”，作为全部专栏内容的结束语。</p>\n<h3><a id=\"_2\"></a>融入社区</h3>\n<p>我们每一个人作为全球开发者的一份子，如果能够参与到社区，这对于个人成长会很有帮助的。这其中一个非常重要的话题就是「Github 使用礼仪」。大家可能比较熟悉了 Github 中使用 star、fork、watch 等基本功能。如果想重深度参与社区并成为开源库的贡献者，一般有两种方式：</p>\n<ul>\n<li>提 issue</li>\n<li>提 pull request</li>\n</ul>\n<p>首先，提 issue 一般有两种情况：报 bug 和提需求。如果是报 bug，最重要的是确认 bug 和表达清楚复现方式。对于一些较为复杂的复现场景，我们可以写一个 demo 帮助维护者发现问题；如果是提需求，我们就要尽量把控需求的合理性，这一点对于天天和产品“撕逼”的我们来说，应该不是太大问题。</p>\n<p>提 pull request，就是申请往主库中合并代码。这其中涉及到一些 Git 的基本操作，主要流程是先 fork 目标仓库，进行修改之后进行推送，最后进入目标项目页面，发起 PR。</p>\n<p>当然，我们不仅仅可以给开源库贡献代码，也可以作为创始者，向社区贡献内容。这个环节中，“如何写好一个现代库”，这个问题涉及到了方方面面的知识。比如你要思考：</p>\n<ul>\n<li>证书如何设置</li>\n<li>文档如何设计，让使用者快速上手</li>\n<li>TODO 和 CHANGELOG 需要遵循哪些规范</li>\n<li>如何设计构建流程</li>\n<li>如何设计编译范围和流程</li>\n<li>如何设计模块化方案和打包流程</li>\n<li>如何设计自动规范化链路</li>\n<li>如何保证版本规范和 commit 规范</li>\n<li>如何进行测试设计</li>\n<li>如何引入可持续集成</li>\n<li>其他最佳实践</li>\n</ul>\n<p>为此，我给大家推荐我作为核心开发者的一个开源项目：<a href=\"https://github.com/yanhaijing/jslib-base\" target=\"_blank\">Jslib-base</a>，这是一个“为了写库而写的库”，它可以帮助开发者通过简单的命令就能创建出一个库的脚手架和基础代码。整个项目实现非常简单，但尽可能结合“最佳实践”。如果你想写一个库，那我建议你考虑使用它来开启第一步；如果你想了解如何从零设计一个项目，也许可以通过它收获启发。给大家推荐相关文章：</p>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/46332833\" target=\"_blank\">8102年如何写一个现代的JavaScript库</a></li>\n</ul>\n<p>如果有机会，我会专门介绍一下这个库的编写和设计思想，虽然这不复杂，但是我们从中能够延伸出来的问题都很有趣。</p>\n<h3><a id=\"_33\"></a>自我修养</h3>\n<p>论“程序员”的修养，这个话题非常开放。我们能想到很多关键词，比如：</p>\n<ul>\n<li>保持热情</li>\n<li>谦虚谨慎</li>\n<li>学会阅读</li>\n<li>学会提问</li>\n<li>善用搜索</li>\n<li>学会写作（文档/博客等）</li>\n<li>“科学上网”</li>\n<li>时间管理</li>\n<li>知识管理</li>\n<li>英语学习</li>\n</ul>\n<p>我个人很不喜欢所谓的“成功学”和“方法论”，更讨厌“制造焦虑”，“兜售”鸡汤。免入俗套，我打算从两种动物来说一下“废话”。</p>\n<p>不管是学习进阶之路，还是工作中的项目，我们能够遇到的真正问题只有两类：第一种是<strong>看不见的</strong>，我把它比作为黑天鹅，总会在你意想不到的时间和地点出现，并彻底颠覆一切；第二种是被我们<strong>视而不见的</strong>，我把它比喻成灰犀牛：你知道且习惯于它的存在，但是它会在某个时刻突然爆发，一旦爆发就会席卷一切，无从抵抗。</p>\n<p>项目开发和个人成长都有黑天鹅和灰犀牛的危机。</p>\n<h4><a id=\"_54\"></a>黑天鹅</h4>\n<p>「新技术的爆发，技术的更新换代」就是职业生涯的黑天鹅。但我们需要辩证地来认识他：对于菜鸟来说，新技术和未知领域让年轻人有机会弯道超车，减少因为欠缺经验和阅历而带来的劣势；对于有一定工作经验和阅历的程序员来说，「颠覆」和「变革」这样的词语似乎不那么友好。</p>\n<p>但是新技术说到底也只是工具，而真正资深程序员的核心价值在于：逻辑、分析、数据、算法等抽象能力。技术工具只是这些抽象能力的表述形式。从汇编语言转到 C 语言，其实更能发挥 C 的强大控制能力；从 C 转到 Java，只需要理解面向对象和虚拟机就能很快适应并脱颖而出；从 Java 转到 Python 的程序员，甚至都会感叹写代码“太简单了”！</p>\n<p>总之，黑天鹅即是危机，也是机会。新技术作为新工具，总能带来新的价值蓝海。如果能把黑天鹅当做机会，保持敏感、好奇和进取的心态，扩展技能树，就能驯服来势汹汹的新技术。我们所有人一起共勉。</p>\n<h4><a id=\"_62\"></a>灰犀牛</h4>\n<p>社会中，很多职业是越老越值钱：老警察、老医生、老艺术家，说起来就让人觉得技术高超，令人信赖。</p>\n<p>职业进阶就是一只灰犀牛。在悄悄溜走的时间中，我们可能习惯了日复一日的重复劳动。程序员怕的不是变老，而是变老的同时没有变强。如何击退这只灰犀牛，这需要我们从天天接触的工作代码入手，从熟悉的事物出发，找到突破。</p>\n<p>比如，在这个专栏的工程化章节中，我重点突出了：如何增强程序的健硕性、如何让我们的开发效率提升、如何持续不断地完善项目、如何从零开始打磨基础构建体系。仔细思考，里面的内容也许就能接入你的项目当中。</p>\n<p>从机械的工作抽象出更完美的工程化流程，这样的话题似乎永远说不完。我也总有新的心得和体会想和大家一起分享、交流。专栏已完结，但是衷心希望我们的技术探险之旅，仅仅是拉开帷幕。</p>\n<h3><a id=\"_72\"></a>最后</h3>\n<p>站在跑道的起点，你不知道跑到哪里肌肉会开始发痛，呼吸急促，想要停下来休息；在二三十岁的年纪，我们无从得知学习了一份课程，能对自己的水平提高和职业发展起多大作用。但我记得，在开篇词中，提到了村上春树的《当我谈跑步时，我谈些什么》这本书：也许不论是跑步还是写代码，都是在探索生命的种种可能。</p>\n<p>—— 不去跑，永远不知道能跑多远；不去做，永远不知道能做多好。</p>\n","createdAt":"2019-04-21T04:56:20.428Z","likes":[],"comments":[],"status":0,"favNum":0,"isShowTitle":true,"isCompleted":true,"isHide":false,"commentNum":0,"index":50,"isFreeRead":false,"audioLarge":0,"banner":"https://images.gitbook.cn/FoThASW9dVEPMEo9nP-zaOfbKyLZ"}],"status":1,"tags":["前端开发","Web开发","前端面试","JS","JavaScript","前端"],"isGitAdis":false,"isUpdating":false,"isOffSale":false,"isShareReward":true,"isOffSaleForNewCustomer":false,"isOnHomePage":false,"virSubscriptionNum":0,"subscriptionNum":2552,"getFreeNum":0,"freeNum":0,"freeOn":false,"authorName":"LucasHC（侯策）"}' class="nav_view"><a href="/gitchat/columns">专栏列表 &gt;</a><a href="/gitchat/column/5c91c813968b1d64b1e08fde"> 专栏详情 &gt;</a><span> 专栏文章阅读</span></div><div class="nav_title_view"><h1 class="column_title">前端开发核心知识进阶</h1></div></div><article id="topicContainer" class="column_content"><h2 class="topic_title"></h2><div><p>数据结构是计算机中组织和存储数据的特定方式，它的目的是方便且高效地对数据进行访问和修改。数据结构表述了数据之间的关系，以及操作数据的一系列方法。数据又是程序的基本单元，因此无论是哪种语言、哪种领域，都离不开数据结构；另一方面，数据结构是算法的基础，其本身也包含了算法的部分内容。也就是说，想要掌握算法，先有一个巩固的数据结构基础是必要条件。</p>
<p>前端领域也到处体现着数据结构的应用，尤其是随着需求的复杂度上升，前端工程师越来越离不开数据结构。React、Vue 这些设计精巧的框架，在线文档编辑系统、大型管理系统，甚至一个简单的检索需求，都离不开数据结构的支持。是否能够掌握这个难点内容，将是进阶的重要考量。我们应该如何学习数据结构呢？</p>
<p>下图是本讲内容的提纲。</p>
<p><img src="https://images.gitbook.cn/87934440-d04f-11e9-bec2-e1649ddaac83" width = "70%" /></p>
<h3 id="">数据结构和学习方法概览</h3>
<p>我通常将数据结构分为八大类：</p>
<ul>
<li>数组：Array</li>
<li>堆栈：Stack</li>
<li>队列：Queue</li>
<li>链表：Linked Lists</li>
<li>树：Trees</li>
<li>图：Graphs</li>
<li>字典树：Trie</li>
<li>散列表（哈希表）：Hash Tables</li>
</ul>
<p>这么多的类型，这节课该如何介绍呢？我认为，按部就班地只是实现各种数据结构的意义不大，这些内容读者都可以从算法书籍中找到。更重要地是应用，也只有在应用中，才能真正地记住并掌握特定的数据结构，才能在下次有类似场景时，能够想起来相关的数据结构实现。因此，这节课程我将从前端出发，从前端类库或者典型场景入手，结合数据结构来剖析其实现和应用。这需要读者首先对每种数据结构有一个大概认知，我们可以先来细化感知一下：</p>
<ul>
<li>栈和队列是类似数组的结构，非常多的初级题目要求用数组实现栈和队列，他们在插入和删除的方式上和数组有所差异，但是实现还是非常简单的；</li>
<li>链表、树和图这种数据结构的特点是，其节点需要引用到其他节点，因此在增删时，需要注意对相关前驱和后继节点的影响；</li>
<li>可以从堆栈和队列出发，构建出链表；</li>
<li>树和图最为复杂，因为他们本质上是扩展了链表的概念；</li>
<li>散列表的关键是理解散列函数，明白依赖散列函数实现保存和定位数据的过程；</li>
<li>直观上认为，链表适合记录和存储数据；哈希表和字典树在检索数据以及搜索方面有更大的应用场景。</li>
</ul>
<p>以上这些“直观感性”的认知并不是“恒等式”， <strong>我们将在下面的学习中去印证这些“认知”，你将会看到熟悉的 React、Vue 框架的部分实现，将会看到典型的算法场景，也请读者做好基础知识的储备。</strong></p>
<h3 id="-1">堆栈和队列</h3>
<p>栈和队列是一种操作受限的线性结构，它们非常简单，虽然 JavaScript 并没有原生内置这样的数据结构，但是我们可以轻松地模拟出来。</p>
<p>栈的实现，后进先出 LIFO（Last in、First out）：</p>
<pre><code>class Stack {
  constructor(...args) {
    this.stack = [...args]
  }

  // Modifiers
  push(...items) {
    return this.stack.push(... items)
  }

  pop() {
    return this.stack.pop()
  }

  // Element access
  peek() {
    return this.isEmpty() 
        ? undefined
        : this.stack[this.size() - 1]
  }

  // Capacity
  isEmpty() {
    return this.size() == 0
  }

  size() {
    return this.stack.length
  }
}
</code></pre>
<p>队列的实现，先进先出 FIFO（First in、First out）：</p>
<pre><code>class Queue {
  constructor(...args) {
    this.queue = [...args]
  }

  // Modifiers
  enqueue(...items) {
    return this.queue.push(... items)
  }

  dequeue() {
    return this.queue.shift()
  }

  // Element access
  front() { 
    return this.isEmpty()
        ? undefined
        : this.queue[0]
  }

  back() {
    return this.isEmpty()
        ? undefined
        : this.queue[this.size() - 1]
  }

  // Capacity
  isEmpty() {
    return this.size() == 0
  }

  size() {
    return this.queue.length
  }
}
</code></pre>
<p>关于栈和队列的实际应用比比皆是：</p>
<ul>
<li>浏览器的历史记录，因为回退总是回退“上一个”最近的页面，它需要遵循栈的原则；</li>
<li>类似浏览器的历史记录，任何 undo/redo 都是一个栈的实现；</li>
<li>在代码中，广泛应用的递归产生的调用栈，同样也是栈思想的体现，想想我们常说的“栈溢出”就是这个道理；</li>
<li>同上，浏览器在抛出异常时，常规都会抛出调用栈信息；</li>
<li>在计算机科学领域应用广泛，如进制转换、括号匹配、栈混洗、表达式求值等；</li>
<li>队列的应用更为直观，我们常说的宏任务 / 微任务都是队列，不管是什么类型的任务，都是先进先执行；</li>
<li>后端也应用广泛，如消息队列、RabbitMQ、ActiveMQ 等，能起到延迟缓冲的功效。</li>
</ul>
<p>我们看到不管是栈还是队列，都是用数组来模拟的。数组是最基本的数据结构，但是它的价值是惊人的，这里稍微提一下 React hooks 的本质就是数组。给大家推荐文章：<a href="https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e">React hooks: not magic, just arrays</a></p>
<p>另外，与性能后话相关，HTTP 1.1 有一个队头阻塞问题，这个原因就在于队列这样的数据结构：我们先看 HTTP 1.0，对于同一个 tcp 连接，HTTP 1.0 是将所有请求都放入队列当中，这么一来，在客户端，“先进先出”，只有前一个请求得到了响应，下一个请求才会发出。在 HTTP 1.1 中，这样的情况得到了改观，每一个链接都默认是长链接，因此对于同一个 tcp 链接，不必等到前一个响应回来。但是这只是解决了客户端的队头阻塞问题，事实上，HTTP 1.1 规定：服务端的响应返回顺序需要遵循其接收到相应的顺序，这样的问题是：如果第一个请求处理需要较长时间，响应较慢，也都会“拖累”其他后续请求的响应，这仍然是一种队头阻塞。</p>
<p>HTTP 2 采用了二进制分帧和多路复用等方法， 同域名下的通信都是在同一个连接上完成，并且这种链接是双向的，在这个链接上可以并行请求和响应而互不干扰。</p>
<p>这里延伸的有点多了，主要是读者需要明白队列和栈这种数据结构的应用，以及利弊。</p>
<h3 id="-2">链表（单向链表和双向链表）</h3>
<p>堆栈和队列都可以用数组实现，链表同样和数组一样，都实现了<strong>按照一定的顺序</strong>存储元素，不同的地方在于链表不能像数组一样通过下标访问，而是每一个元素指向下一个元素。我们不再过多介绍链表方面的基础知识，对于链表仍不理解的读者可以先自行学习。</p>
<p>直观上我们就可以得出结论：链表不需要一段连续的存储空间，“指向下一个元素”的方式能够更大限度地利用内存。</p>
<p>根据上面结论可以继续总结，链表的优点在于：</p>
<ul>
<li>链表的插入和删除操作的时间复杂度是常数级的，我们只需要改变相关节点的指针指向即可；</li>
<li>链表可以像数组一样顺序访问，查找元素的时间复杂度是线性的。</li>
</ul>
<p>我们来看看链表的应用场景：</p>
<ul>
<li>React 的核心算法 Fiber 的实现就是链表</li>
</ul>
<p>关于此我们可以稍作展开。React 最早开始使用大名鼎鼎的 Stack reconciler 调度算法，关于此在之前的课程中已经有所涉及。Stack reconciler 调度算法最大的问题在于：<strong>它是像函数调用栈一样，递归地、自顶向下进行 diff 和 render 相关操作的</strong>，在 Stack reconciler 执行的过程当中，该调度算法始终会占据浏览器主线程。也就是说在此期间，用户的交互所触发的布局行为、动画执行任务都不会被立即响应，从而影响用户体验。</p>
<p>因此 React Fiber 将渲染和更新过程进行了拆解，简单来说，就是每次检查虚拟 DOM 的一小部分，在检查间隙会检查“是否还有时间继续执行下一个虚拟 DOM 树上某个分支任务”，同时观察是否有更优先的任务需要响应，如果“没有时间执行下一个虚拟 DOM 树上某个分支任务”，且有更高优先级，React 就会让出主线程，直到主线程“不忙”的时候继续执行任务。</p>
<p>React Fiber 因此也很简单，它是将 Stack reconciler 过程分成块，一次执行一块，执行完一块需要将结果保存起来，根据是否还有空闲的响应时间（requestIdleCallback）来决定下一步策略。当所有的块都已经执行完，就进入提交阶段，这个阶段需要更新 DOM，它是一口气完成的。</p>
<p>以上是比较主观地介绍，我们来看更具体的实现。</p>
<p>为了达到“随意中断调用栈并手动操作调用栈”，React Fiber 就是专门用于 React 组件堆栈调用的重新实现，也就是说一个 Fiber 就是一个虚拟堆栈帧，一个 Fiber 的结构类似：</p>
<pre><code>function FiberNode(
  tag: WorkTag,
  pendingProps: mixed,
  key: null | string,
  mode: TypeOfMode,
) {
  // Instance
  // ...
  this.tag = tag;                       

  // Fiber
  this.return = null;
  this.child = null;
  this.sibling = null;
  this.index = 0;

  this.ref = null;

  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;
  this.dependencies = null;

  // Effects
  // ...
  this.alternate = null; 
}
</code></pre>
<p>这么看 Fiber 就是一个对象，通过 parent、children、sibling 维护一个树形关系，同时 parent、children、sibling 也都是一个 Fiber 结构，FiberNode.alternate 这个属性来存储上一次渲染过的结果，事实上整个 Fiber 模式就是一个链表。React 也借此，从依赖于内置堆栈的同步递归模型，变为具有链表和指针的异步模型了。</p>
<p>具体的渲染过程：</p>
<pre><code>function renderNode(node) {
   // 判断是否需要渲染该节点，如果 props 发生变化，则调用 render
   if (node.memoizedProps !== node.pendingProps) {
      render(node)
   }

   // 是否有子节点，进行子节点渲染
   if (node.child !== null) {
      return node.child
   // 是否有兄弟节点，进行兄弟点渲染
   } else if (node.sibling !== null){
      return node.sibling
   // 没有子节点和兄弟节点
   } else if (node.return !== null){
      return node.return
   } else {
      return null
   }
}

function workloop(root) {
   nextNode = root
   while (nextNode !== null &amp;&amp; (no other high priority task)) {
      nextNode = renderNode(nextNode)
   }
}
</code></pre>
<p>注意在 workloop 当中，while 条件 nextNode !== null &amp;&amp; (no other high priority task)，这是描述 Fiber 工作原理的关键伪代码。</p>
<p>当然这里是为了说明链表的数据结构，伪代码较为简略，也没有深入：</p>
<ul>
<li>requestAnimationFrame(callback)</li>
<li>requestIdleCallback(callback)</li>
</ul>
<p>的实现和应用。React Fiber 的介绍我们先到此为止，重点是体会链表数据结构的思想。</p>
<h3 id="-3">链表实现</h3>
<p>实现链表，我们需要先对链表进行分类，常见的有：</p>
<ul>
<li>单链表：单链表是维护一系列节点的数据结构，其特点是：每个节点包含了数据，同时包含指向链表中下一个节点的指针。</li>
<li>双向链表：不同于单链表，双向链表特点：每个节点分除了包含其数据以外，还包含了分别指向其前驱和后继节点的指针。</li>
</ul>
<p>由于篇幅有原因，我们挑选更加复杂的双向链表进行实现，实现思路如下。</p>
<p>首先，根据双向链表的特点，我们实现一个节点构造函数（节点类）：</p>
<pre><code>class Node {
    constructor(data) {
        // data 为当前节点所储存的数据
        this.data = data
        // next 指向下一个节点
        this.next = null
        // prev 指向前一个节点
        this.prev = null
    }
}
</code></pre>
<p>有了节点类，我们来初步实现双向链表类：</p>
<pre><code>class DoublyLinkedList {
    constructor() {
        // 双向链表开头
        this.head = null
        // 双向链表结尾
      this.tail = null
    }

    // ...
}
</code></pre>
<p>接下来，需要实现双向链表原型上的一些方法，这些方法包括</p>
<ul>
<li>add：在链表尾部添加一个新的节点</li>
<li>addAt：在链表指定位置添加一个新的节点</li>
<li>remove：删除链表指定数据项节点</li>
<li>removeAt：删除链表指定位置节点</li>
<li>reverse：翻转链表</li>
<li>swap：交换两个节点数据</li>
<li>isEmpty：查询链表是否为空</li>
<li>length：查询链表长度</li>
<li>traverse：遍历链表</li>
<li>find：查找某个节点的索引</li>
</ul>
<p>add 方法：</p>
<pre><code>add(item) {
  // 实例化一个节点
  let node = new Node(item)

  // 如果当前链表还没有头
  if(!this.head) {
    this.head = node
    this.tail = node
  } 
  // 如果当前链表已经有了头，只需要在尾部加上该节点
  else {
    node.prev = this.tail
    this.tail.next = node
    this.tail = node
  }
}
</code></pre>
<p>addAt 方法：</p>
<pre><code>addAt(index, item) {
   let current = this.head
   // 维护查找时当前节点的索引
   let counter = 1
   let node = new Node(item)

   // 如果在头部插入
   if (index === 0) {
     this.head.prev = node
     node.next = this.head
     this.head = node
   } 
   // 非头部插入，需要从头开始，找寻插入位置
   else {
     while(current) {
      current = current.next
      if( counter === index) {
        node.prev = current.prev
        current.prev.next = node
        node.next = current
        current.prev = node
      }
      counter++
    }
  }
}
</code></pre>
<p>remove 方法：</p>
<pre><code>remove(item) {
  let current = this.head

  while (current) {
       // 找到了目标节点
    if (current.data === item ) {
      // 目标链表只有当前目标项，即目标节点即是链表头又是链表尾
      if (current == this.head &amp;&amp; current == this.tail) {
        this.head = null
        this.tail = null
      } 
      // 目标节点为链表头
      else if (current == this.head ) {
        this.head = this.head.next
        this.head.prev = null
      } 
      // 目标节点为链表尾部
      else if (current == this.tail ) {
        this.tail = this.tail.prev;
        this.tail.next = null;
      } 
      // 目标节点在链表收尾之间，中部
      else {
        current.prev.next = current.next;
        current.next.prev = current.prev;
      }
   }
   current = current.next
  }
}
</code></pre>
<p>removeAt 方法：</p>
<pre><code>removeAt(index) {
  // 都是从“头”开始遍历
  let current = this.head
  let counter = 1

  // 删除链表头部
  if (index === 0 ) {
   this.head = this.head.next
   this.head.prev = null
  } 
  else {
   while(current) {
    current = current.next
    // 如果目标节点在链表尾
    if (current == this.tail) {
     this.tail = this.tail.prev
     this.tail.next = null
    } 
    else if (counter === index) {
     current.prev.next = current.next
     current.next.prev = current.prev
     break
    }
    counter++
   }
  }
}
</code></pre>
<p>reverse 方法：</p>
<pre><code>reverse() {
  let current = this.head
  let prev = null

  while (current) {
   let next = current.next

   // 前后倒置
   current.next = prev
   current.prev = next

   prev = current
   current = next
  }

  this.tail = this.head
  this.head = prev
}
</code></pre>
<p>swap 方法，交换两个节点数据值：</p>
<pre><code>swap(index1, index2) {
  // 使 index1 始终小于 index2，方便后面查找交换
  if (index1 &gt; index2) {
    return this.swap(index2, index1)
  }

  let current = this.head
  let counter = 0
  let firstNode

  while(current !== null) {
    // 找到第一个节点，先存起来
    if (counter === index1 ){
        firstNode = current
    } 

    // 找到第二个节点，进行数据交换
    else if (counter === index2) {
      // ES 提供了更简洁交换数据的方法，这里我们用传统方式实现，更为直观
      let temp = current.data
      current.data = firstNode.data
      firstNode.data = temp
    }

    current = current.next
    counter++
  }
  return true
}
</code></pre>
<p>isEmpty 方法：</p>
<pre><code>isEmpty() {
  return this.length() &lt; 1
}
</code></pre>
<p>这里通过 DoublyLinkedList 类 length 的方法实现。马上看一下 length 方法：</p>
<pre><code>length() {
  let current = this.head
  let counter = 0
  while(current !== null) {
    counter++
    current = current.next
  }
  return counter
}
</code></pre>
<p>length 方法通过遍历链表，返回链表的长度。</p>
<p>traverse 方法：</p>
<pre><code>traverse(fn) {
  let current = this.head
  while(current !== null) {
    fn(current)
    current = current.next
  }
  return true
}
</code></pre>
<p>有了上面 length 方法的遍历实现，traverse 也就不难理解了，它接受一个遍历执行函数，在 while 循环中进行调用。</p>
<p>最后一个 search 方法：</p>
<pre><code>search(item) {
  let current = this.head
  let counter = 0

  while( current ) {
    if( current.data == item ) {
      return counter
    }
    current = current.next
    counter++
  }
  return false
}
</code></pre>
<p>到此，我们就实现了所有 DoublyLinkedList 类双向链表的方法。仔细分析整个实现过程，可以发现：双向链表的实现并不复杂，在手写过程当中，需要开发者做到心中有表，考虑到当前节点的 next 和 prev 取值，逻辑上还是很简单的。</p>
<p>掌握了这些内容，在回想一下链表的应用，回想 React Fiber 的设计和实现，也许一切都变的不再神秘。</p>
<h3 id="-4">树</h3>
<p>前端开发者应该对树这个数据结构丝毫不陌生，不同于之前介绍的所有数据结构，树是非线性的。因为树决定了其存储的数据直接有明确的层级关系，因此对于维护具有层级特性的数据，树是一个天然良好的选择。</p>
<p>在前面总领中，我们看到树有很多种分类，但是他们都具有以下特性：</p>
<ul>
<li>除了根节点以外，所有的节点都有一个父节点</li>
<li>每一个节点都<strong>可以有</strong>若干子节点，如果没有子节点，那么称此节点为叶子节点</li>
<li>一个节点所拥有的叶子节点的个数，称之为该节点的度，因此叶子节点的度为 0</li>
<li>所有节点中，最大的度为整棵树的度</li>
<li>树的最大层次称为树的深度</li>
</ul>
<p>从应用上来看，我们前端开发离不开的 DOM 就是一个树状结构；同理，不管是 React 还是 Vue 的虚拟 DOM 也都是树。</p>
<p>我们从最基本的二叉树入手，来慢慢深入。</p>
<h4 id="-5">二叉搜索树的实现和遍历</h4>
<p>说二叉树最为基本，因为他的结构最简单，每个节点至多包含两个子节点。二叉树又非常有用：因为根据二叉树，我们可以延伸出二叉搜索树（BST）、平衡二叉搜索树（AVL）、红黑树（R/B Tree）等。</p>
<p>二叉搜索树有以下特性：</p>
<ul>
<li>左子树上所有结点的值均小于或等于它的根结点的值</li>
<li>右子树上所有结点的值均大于或等于它的根结点的值</li>
<li>左、右子树也分别为二叉搜索树</li>
</ul>
<p>根据其特性，我们实现二叉搜索树还是应该先构造一个节点类：</p>
<pre><code>class Node { 
  constructor(data) { 
    this.left = null
    this.right = null
    this.value = data
  } 
} 
</code></pre>
<p>接着按照惯例，我们实现二叉搜索树的以下方法：</p>
<ul>
<li>insertNode：根据一个父节点，插入一个子节点</li>
<li>insert：插入一个新节点</li>
<li>removeNode：根据一个父节点，移除一个子节点</li>
<li>remove：移除一个节点</li>
<li>findMinNode：获取子节点的最小值</li>
<li>searchNode：根据一个父节点，查找子节点</li>
<li>search：查找节点</li>
<li>preOrder：前序遍历</li>
<li>InOrder：中序遍历</li>
<li>PostOrder：后续遍历</li>
</ul>
<pre><code>insertNode(root, newNode) {
  if (newNode.value &lt; root.value) {
    (!root.left) ? root.left = newNode : this.insertNode(root.left, newNode)
  } else {
    (!root.right) ? root.right = newNode : this.insertNode(root.right, newNode)
  }
}

insert(value) {
    let newNode = new Node(value)
    if (!this.root) {
      this.root = newNode
    } else {
      this.insertNode(this.root, newNode)
    }
}
</code></pre>
<p>理解这两个方法是理解二叉搜索树的关键，下面的其他方法也就“不在话下”。我们看，insertNode 方法先判断目标父节点和插入节点的值，如果插入节点的值更小，则考虑放到父节点的左边，接着递归调用 his.insertNode(root.left, newNode)；如果插入节点的值更大，以此类推即可。</p>
<p>insert 方法只是多了一步构造 Node 节点实例，接下来区分有无父节点的情况，调用 this.insertNode 方法即可。</p>
<pre><code> removeNode(root, value) {
    if (!root) {
      return null
    }

    if (value &lt; root.value) {
      root.left = this.removeNode(root.left, value)
      return root
    } else if (value &gt; root.value) {
      root.right = tis.removeNode(root.right, value)
      return root
    } else {
      // 找到了需要删除的节点 
      // 如果当前 root 节点无左右子节点
      if (!root.left &amp;&amp; !root.right) {
        root = null
        return root
      }

      // 只有左节点
      if (root.left &amp;&amp; !root.right) {
        root = root.left
        return root
      } 
      // 只有右节点
      else if (root.right) {
        root = root.right
        return root
      }

      // 有左右两个子节点
      let minRight = this.findMinNode(root.right)
      root.value = minRight.value
      root.right = this.removeNode(root.right, minRight.value)
      return root
    }
  }

remove(value) {
    if (this.root) {
      this.removeNode(this.root, value)
    }
}
</code></pre>
<p>上述代码不难理解，可能最需要读者思考的就是：</p>
<pre><code>// 有左右两个子节点
let minRight = this.findMinNode(root.right)
root.value = minRight.value
root.right = this.removeNode(root.right, minRight.value)
return root
</code></pre>
<p>我来特殊说明一下：当需要删除的节点含有左右两个子节点时，因为我们要把当前节点删除，就需要找到合适的“补位”节点，这个“补位”节点一定在该目标节点的右侧树当中，因为这样才能保证“补位”节点的值一定大于该目标节点的左侧树所有节点，而该目标节点的左侧树不需要调整；同时为了保证“补位”节点的值一定要小于该目标节点的右侧树值，因此要找的“补位”节点其实就是该目标节点的右侧树当中最小的那个节点。</p>
<p>这个过程我们借助 this.findMinNode 方法实现：</p>
<pre><code>findMinNode(root) {
    if (!root.left) {
      return root
    } else {
      return this.findMinNode(root.left)
    }
}
</code></pre>
<p>该方法不断递归，直到找到最左叶子节点即可。</p>
<p>查找方法：</p>
<pre><code>searchNode(root, value) {
    if (!root) {
      return null
    }

    if (value &lt; root.value) {
      return this.searchNode(root.left, value)
    } else if (value &gt; root.value) {
      return this.searchNode(root.right, value)
    }

    return root
}

search(value) {
    if (!this.root) {
      return false
    }
    return Boolean(this.searchNode(this.root, value))
}
</code></pre>
<p>这也比较简单，其实就是对递归的运用。最能体现递归简便优势的其实是对于树的遍历：</p>
<p>前序遍历：</p>
<pre><code>preOrder(root) {
    if (root) {
      console.log(root.value)
      this.preOrder(root.left)
      this.preOrder(root.right)
    }
}
</code></pre>
<p>中序遍历：</p>
<pre><code>inOrder(root) {
    if (root) {
      this.inOrder(root.left)
      console.log(root.value)
      this.inOrder(root.right)
    }
}
</code></pre>
<p>后序遍历：</p>
<pre><code>postOrder(root) {
    if (root) {
      this.postOrder(root.left)
      this.postOrder(root.right)
      console.log(root.value)
    }
}
</code></pre>
<p>前后中序遍历其实就在于 console.log(root.value) 方法执行的位置。</p>
<h4 id="-6">字典树</h4>
<p>字典树（Trie）是针对特定类型的搜索而优化的树数据结构。典型的例子是 autoComplete，也就是说它适合实现：通过部分值得到完整值的场景。字典树因此也是一种搜索树，我们有时候也叫做前缀树，因为任意一个节点的后代都存在共同的前缀。更多基础概念请读者先做了解。我们总结一下它的特点：</p>
<ul>
<li>字典树能做到高效查询和插入，时间复杂度为 O(k)，k 为字符串长度</li>
<li>但是如果大量字符串没有共同前缀，那就很耗内存，读者可以想象一下最极端的情况，所有单词都没有共同前缀时，这颗字典树是什么样子</li>
<li>字典树的核心就是减少没必要的字符比较，使查询高效率，也就是说用空间换时间，再利用共同前缀来提高查询效率</li>
</ul>
<p>除了我们刚刚提到的 autoComplete 自动填充的情况，字典树还有很多其他应用场景：</p>
<ul>
<li>搜索</li>
<li>输入法选项</li>
<li>分类</li>
<li>IP 地址检索</li>
<li>电话号码检索</li>
</ul>
<h4 id="-7">字典树的实现和遍历</h4>
<p>字典树的实现也不复杂，我们慢慢一步步来，首先实现一个字典树上的节点：</p>
<pre><code>class PrefixTreeNode {
  constructor(value) {
    // 存储子节点
    this.children = {}
    this.isEnd = null
    this.value = value
  }
}
</code></pre>
<p>一个字典树继承 PrefixTreeNode 类：</p>
<pre><code>class PrefixTree extends PrefixTreeNode {
  constructor() {
    super(null)
  }
}
</code></pre>
<p>我们实现方法：</p>
<ul>
<li>addWord：创建一个字典树节点</li>
<li>predictWord：给定一个字符串，返回字典树中以该字符串开头的所有单词</li>
</ul>
<p>addWord 实现：</p>
<pre><code>addWord(str) {
    const addWordHelper = (node, str) =&gt; {
          // 当前 node 不含当前 str 开头的目标
        if (!node.children[str[0]]) {
            // 以当前 str 开头的第一个字母，创建一个 PrefixTreeNode 实例
            node.children[str[0]] = new PrefixTreeNode(str[0])
            if (str.length === 1) {
                node.children[str[0]].isEnd = true
            } 
            else if (str.length &gt; 1) {
                addWordHelper(node.children[str[0]], str.slice(1))
            }
        }
    }
    addWordHelper(this, str)
}
</code></pre>
<p>predictWord 实现：</p>
<pre><code>predictWord(str) {
    let getRemainingTree = function(str, tree) {
      let node = tree
      while (str) {
        node = node.children[str[0]]
        str = str.substr(1)
      }
      return node
    }

    // 该数组维护所有以 str 开头的单词
    let allWords = []

    let allWordsHelper = function(stringSoFar, tree) {
      for (let k in tree.children) {
        const child = tree.children[k]
        let newString = stringSoFar + child.value
        if (child.endWord) {
          allWords.push(newString)
        }
        allWordsHelper(newString, child)
      }
    }

    let remainingTree = getRemainingTree(str, this)

    if (remainingTree) {
      allWordsHelper(str, remainingTree)
    }

    return allWords
}
</code></pre>
<h3 id="-8">图</h3>
<p>图是由具有边的节点集合组成的数据结构，图可以是定向的或不定向的。因此图可以分为好多种类，这里不一一讲解，主要看图的应用场景：</p>
<ul>
<li>LBS 地图服务以及 GPS 系统</li>
<li>社交媒体网站的用户关系图</li>
<li>前端工程化中的开发依赖图</li>
<li>搜索算法使用图，保证搜索结果的相关性</li>
<li>寻找降低运输和交付货物和服务成本的最佳途径</li>
</ul>
<p>图也是应用最广泛的数据结构之一，真实场景中处处有图。更多概念还是需要读者先进行了解，尤其是图的几种基本元素：</p>
<ul>
<li>节点 Node</li>
<li>边 Edge</li>
<li>|V| 图中顶点（节点）的总数</li>
<li>|E| 图中的连接总数（边）</li>
</ul>
<h4 id="-9">图的实现和遍历</h4>
<p>这里我们主要实现一个有向图，Graph 类：</p>
<pre><code>class Graph {
  constructor() {
    this.AdjList = new Map()
  }
}
</code></pre>
<p>使用 Map 数据结构表述图中顶点关系。</p>
<p>实现方法：</p>
<ul>
<li>添加顶点：addVertex</li>
<li>添加边：addEdge</li>
<li>打印图：print</li>
<li>广度优先算法遍历</li>
<li>深度优先算法</li>
</ul>
<p>addVertex 方法：</p>
<pre><code>addVertex(vertex) {
  if (!this.AdjList.has(vertex)) {
    this.AdjList.set(vertex, [])
  } else {
    throw 'vertex already exist!'
  }
}
</code></pre>
<p>创建顶点：</p>
<pre><code>let graph = new Graph();
graph.addVertex('A')
graph.addVertex('B')
graph.addVertex('C')
graph.addVertex('D')
</code></pre>
<p>其中 A、B、C、D 顶点都对应一个数组：</p>
<pre><code>  'A' =&gt; [],
  'B' =&gt; [],
  'C' =&gt; [],
  'D' =&gt; []
</code></pre>
<p>该数组将用来存储边。我们设计图预计得到如下关系：</p>
<pre><code>Map {
  'A' =&gt; ['B', 'C', 'D'],
  'B' =&gt; [],
  'C' =&gt; ['B'],
  'D' =&gt; ['C']
}
</code></pre>
<p>根据此描述，其实已经可以把图画出来了。addEdge 因此需要两个参数：一个是顶点，一个是连接对象 Node：</p>
<pre><code> addEdge(vertex, node) {
    if (this.AdjList.has(vertex)) {
      if (this.AdjList.has(node)){
        let arr = this.AdjList.get(vertex)
        if(!arr.includes(node)){
          arr.push(node)
        }
      }else {
        throw `Can't add non-existing vertex -&gt;'${node}'`
      }
    } else {
      throw `You should add '${vertex}' first`
    }
}
</code></pre>
<p>理清楚数据关系，我们就可以打印图了，其实就是一个很简单的 for...of 循环：</p>
<pre><code>print() {
  for (let [key, value] of this.AdjList) {
    console.log(key, value)
  }
}
</code></pre>
<p>剩下的内容就是遍历图了。</p>
<p>广度优先算法（BFS），是一种利用队列实现的搜索算法。对于图，其搜索过程和 “湖面丢进一块石头激起层层涟漪” 类似。换成算法语言，就是从起点出发，对于每次出队列的点，都要遍历其四周的点。</p>
<p>因此 BFS 的实现步骤：</p>
<ul>
<li>起始节点作为起始，并初始化一个空对象：visited</li>
<li>初始化一个空数组，该数组将模拟一个队列</li>
<li>将起始节点标记为已访问</li>
<li>将起始节点放入队列中</li>
<li>循环直到队列为空</li>
</ul>
<p>实现：</p>
<pre><code>createVisitedObject() {
  let map = {}
  for(let key of this.AdjList.keys()) {
    arr[key] = false
  }
  return map
}

bfs(initialNode) {
  // 创建一个已访问节点的 map
  let visited = this.createVisitedObject()
  // 模拟一个队列
  let queue = []

  // 第一个节点已访问
  visited[initialNode] = true
  // 第一个节点入队列
  queue.push(initialNode)

  while(queue.length) {
    let current = queue.shift()
    console.log(current)

     // 获得该节点的其他节点关系
    let arr = this.AdjList.get(current)

    for (let elem of arr) {
      // 如果当前节点没有访问过
      if (!visited[elem]) {
        visited[elem] = true
        q.push(elem)
      }
    }
  }
}
</code></pre>
<p>那么对于深度优先搜索算法（DFS），我把它总结为：“不撞南墙不回头”，从起点出发，先把一个方向的点都遍历完才会改变方向。换成程序语言就是：“DFS 是利用递归实现的搜索算法”。</p>
<p>因此 DFS 过程：</p>
<ul>
<li>起始节点作为起始，创建访问对象</li>
<li>调用辅助函数递归起始节点</li>
</ul>
<p>实现代码：</p>
<pre><code>createVisitedObject() {
  let map = {}
  for (let key of this.AdjList.keys()) {
    arr[key] = false
  }
  return map
}

 dfs(initialNode) {
    let visited = this.createVisitedObject()
    this.dfsHelper(initialNode, visited)
  }

  dfsHelper(node, visited) {
    visited[node] = true
    console.log(node)

    let arr = this.AdjList.get(node)

    for (let elem of arr) {
      if (!visited[elem]) {
        this.dfsHelper(elem, visited)
      }
    }
  }
}
</code></pre>
<p>BFS 的重点在于队列，而 DFS 的重点在于递归，这是它们的本质区别。</p>
<h4 id="-10">图在前端中的应用</h4>
<p>图其实在前端中应用不算特别多，但绝对还是不容忽视的一部分。这里我举一个我现实中应用的例子——循环图。</p>
<p>在前端工程化发展的今天，理清项目中的依赖关系：比如查找项目中的循环依赖，可视化依赖都是图的应用，有助于开发者在宏观上把控工程化项目。在我们的项目中，我借助 <a href="https://mermaidjs.github.io/#/">mermaidj</a> 画图工具，实现了项目依赖的完全可视化。并借助 npm script 来生成图片结果，相关 script 脚本：</p>
<pre><code>yarn graph
</code></pre>
<p>脚本：</p>
<pre><code>import glob from 'glob'
import readJSON from 'XXX/utils/readJSON'

const pkgs = glob.sync('packages/*/package.json').map(readJSON)

const deps = {}

for (const pkg of pkgs) {
  deps[pkg.name] = Object.keys(pkg.dependencies || []).filter(dep =&gt;
    // ...
  )
}

const graph = { code: '', mermaid: { theme: 'default' } }

graph.code += 'graph TD;'
for (const name in deps) {
  for (const dep of deps[name]) {
    graph.code += `${name}--&gt;${dep};`
  }
}

const base64 = Buffer.from(JSON.stringify(graph)).toString('base64')

/* eslint-disable-next-line */
console.log(
  `Open in browser: https://mermaidjs.github.io/mermaid-live-editor/#/edit/${base64}`
)
</code></pre>
<p>上述代码，我首先获取到 packages/*/package.json 中声明的所有依赖，然后对依赖进行必要性过滤之后，维护到 deps 对象当中，按照 mermaid 需求，将 monorepo 项目中的每一个子项目名和依赖按照 → 的间隔维护为 graph.code，最后通过生成 base64 交给 mermaid 进行绘图，绘图过程会根据约定（→ 的标记），成生可视化的依赖图。</p>
<p>最终效果：</p>
<p><img src="https://images.gitbook.cn/d92587a0-d04f-11e9-82a1-439033eb1f8a" alt="enter image description here" /></p>
<p>那么 mermaid 是如何对图进行绘制的呢？了解了课程前面实现图的代码，我们再看 mermaid 绘制图的部分源码实现：</p>
<pre><code>export const addVertices = function (vert, g, svgId) {
  const svg = d3.select(`[id="${svgId}"]`)
  const keys = Object.keys(vert)

  const styleFromStyleArr = function (styleStr, arr) {
    // Create a compound style definition from the style definitions found for the node in the graph definition
    for (let i = 0; i &lt; arr.length; i++) {
      if (typeof arr[i] !== 'undefined') {
        styleStr = styleStr + arr[i] + ';'
      }
    }

    return styleStr
  }

  // Iterate through each item in the vertex object (containing all the vertices found) in the graph definition
  keys.forEach(function (id) {
    const vertex = vert[id]

    /**
     * Variable for storing the classes for the vertex
     * @type {string}
     */
    let classStr = ''
    if (vertex.classes.length &gt; 0) {
      classStr = vertex.classes.join(' ')
    }

    /**
     * Variable for storing the extracted style for the vertex
     * @type {string}
     */
    let style = ''
    // Create a compound style definition from the style definitions found for the node in the graph definition
    style = styleFromStyleArr(style, vertex.styles)

    // Use vertex id as text in the box if no text is provided by the graph definition
    let vertexText = vertex.text !== undefined ? vertex.text : vertex.id

    // We create a SVG label, either by delegating to addHtmlLabel or manually
    let vertexNode
    if (conf.htmlLabels) {
      // TODO: addHtmlLabel accepts a labelStyle. Do we possibly have that?
      const node = { label: vertexText.replace(/fa[lrsb]?:fa-[\w-]+/g, s =&gt; `&lt;i class='${s.replace(':', ' ')}'&gt;&lt;/i&gt;`) }
      vertexNode = addHtmlLabel(svg, node).node()
      vertexNode.parentNode.removeChild(vertexNode)
    } else {
      const svgLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text')

      const rows = vertexText.split(/&lt;br[/]{0,1}&gt;/)

      for (let j = 0; j &lt; rows.length; j++) {
        const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan')
        tspan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve')
        tspan.setAttribute('dy', '1em')
        tspan.setAttribute('x', '1')
        tspan.textContent = rows[j]
        svgLabel.appendChild(tspan)
      }
      vertexNode = svgLabel
    }

    // If the node has a link, we wrap it in a SVG link
    if (vertex.link) {
      const link = document.createElementNS('http://www.w3.org/2000/svg', 'a')
      link.setAttributeNS('http://www.w3.org/2000/svg', 'href', vertex.link)
      link.setAttributeNS('http://www.w3.org/2000/svg', 'rel', 'noopener')
      link.appendChild(vertexNode)
      vertexNode = link
    }

    let radious = 0
    let _shape = ''
    // Set the shape based parameters
    switch (vertex.type) {
      case 'round':
        radious = 5
        _shape = 'rect'
        break
      case 'square':
        _shape = 'rect'
        break
      case 'diamond':
        _shape = 'question'
        break
      case 'odd':
        _shape = 'rect_left_inv_arrow'
        break
      case 'lean_right':
        _shape = 'lean_right'
        break
      case 'lean_left':
        _shape = 'lean_left'
        break
      case 'trapezoid':
        _shape = 'trapezoid'
        break
      case 'inv_trapezoid':
        _shape = 'inv_trapezoid'
        break
      case 'odd_right':
        _shape = 'rect_left_inv_arrow'
        break
      case 'circle':
        _shape = 'circle'
        break
      case 'ellipse':
        _shape = 'ellipse'
        break
      case 'group':
        _shape = 'rect'
        break
      default:
        _shape = 'rect'
    }
    // Add the node
    g.setNode(vertex.id, { labelType: 'svg', shape: _shape, label: vertexNode, rx: radious, ry: radious, 'class': classStr, style: style, id: vertex.id })
  })
}

/**
 * Add edges to graph based on parsed graph defninition
 * @param {Object} edges The edges to add to the graph
 * @param {Object} g The graph object
 */
export const addEdges = function (edges, g) {
  let cnt = 0

  let defaultStyle
  if (typeof edges.defaultStyle !== 'undefined') {
    defaultStyle = edges.defaultStyle.toString().replace(/,/g, ';')
  }

  edges.forEach(function (edge) {
    cnt++
    const edgeData = {}

    // Set link type for rendering
    if (edge.type === 'arrow_open') {
      edgeData.arrowhead = 'none'
    } else {
      edgeData.arrowhead = 'normal'
    }

    let style = ''
    if (typeof edge.style !== 'undefined') {
      edge.style.forEach(function (s) {
        style = style + s + ';'
      })
    } else {
      switch (edge.stroke) {
        case 'normal':
          style = 'fill:none'
          if (typeof defaultStyle !== 'undefined') {
            style = defaultStyle
          }
          break
        case 'dotted':
          style = 'stroke: #333; fill:none;stroke-width:2px;stroke-dasharray:3;'
          break
        case 'thick':
          style = 'stroke: #333; stroke-width: 3.5px;fill:none'
          break
      }
    }
    edgeData.style = style

    if (typeof edge.interpolate !== 'undefined') {
      edgeData.curve = interpolateToCurve(edge.interpolate, d3.curveLinear)
    } else if (typeof edges.defaultInterpolate !== 'undefined') {
      edgeData.curve = interpolateToCurve(edges.defaultInterpolate, d3.curveLinear)
    } else {
      edgeData.curve = interpolateToCurve(conf.curve, d3.curveLinear)
    }

    if (typeof edge.text === 'undefined') {
      if (typeof edge.style !== 'undefined') {
        edgeData.arrowheadStyle = 'fill: #333'
      }
    } else {
      edgeData.arrowheadStyle = 'fill: #333'
      if (typeof edge.style === 'undefined') {
        edgeData.labelpos = 'c'
        if (conf.htmlLabels) {
          edgeData.labelType = 'html'
          edgeData.label = '&lt;span class="edgeLabel"&gt;' + edge.text + '&lt;/span&gt;'
        } else {
          edgeData.labelType = 'text'
          edgeData.style = edgeData.style || 'stroke: #333; stroke-width: 1.5px;fill:none'
          edgeData.label = edge.text.replace(/&lt;br&gt;/g, '\n')
        }
      } else {
        edgeData.label = edge.text.replace(/&lt;br&gt;/g, '\n')
      }
    }
    // Add the edge to the graph
    g.setEdge(edge.start, edge.end, edgeData, cnt)
  })
}
</code></pre>
<p><strong>那么根据我的脚本，用 → 表现的依赖关系，除了可视化以外，还有其他用处吗？</strong> 其实肯定是有的，除了“花架子”，这个依赖图对于项目的部署构建也有非常重要的作用。比如在对 monorepo 项目进行构建时，因为子项目过多，导致构建时间过长。为此，我给出的方案是增量构建，如果这次改动只设计项目 A、项目 B，以及公共依赖 C，那么项目 C，项目 D 等其他项目在构建时只需要读取缓存构建结果即可。思路是很简单，但是一个直接问题是，如果检测说真正需要构建的项目呢？</p>
<p>举个例子，项目 A 依赖公共依赖 C，那么及时通过 git hook 拿到的 diff 表明项目 A 并没有代码变动，但是可能因为 C 变了，我们还需要重新构建项目 A（因为 A 依赖 C）。按照正常的思路，需要遍历整个项目，这样带来的问题是增加了回溯构建的可能：构建时先遍历到 A，读取缓存，再遍历到 C 时，不得不回退到 A，重新构建。解决思路就是使用一个拓扑图，根据拓扑图，按照一定的顺序进行遍历和编译构建即可。</p>
<p>这是我近期一个使用到拓扑图数据结构的经典场景。具体实施过程因为机密性，我不在贴代码了，对于读者来说，更重要地是体会思想，相信自己动手实现也不会困难。</p>
<h3 id="-11">散列表（哈希表）</h3>
<p>散列表是一种以 key-value 形式存储数据的数据结构，可以把散列表理解为一种高级的数组，这种数组的下标可以是很大的整数，浮点数，字符串甚至结构体。这种数据结构非常有用，js 里的 Map/Set/WeakMap/WeakSet 在 v8 里都是通过散列表来实现的，再比如 LRU Cache、数据库索引等非常多的场景也都能看到散列表的身影。</p>
<p>散列并不仅仅是一种技术，从某种意义上讲，它甚至是一种思想。接下来让我们一起揭开散列表神秘的面纱。</p>
<p>假如，我们要存储 key 为 6、2019、2333333 的三组数据，如果用数组来存，至少需要一个长度为 2333333 的数组来做这件事情，显然这种做法存在大量的空间浪费。</p>
<p>我们也可以像下图一样，准备一个长度为 10 的数组（bucket array），将每一个 key 通过一个散列函数（hash function），映射到桶数组中的一位，将 key 相应的值直接存入即可。可以看到这种方式只需使用一个长度为 10 的数组，同时查找和插入的时间复杂度都是 O(1)。这就是散列表的核心思想。</p>
<p><img src="https://images.gitbook.cn/52397840-c57e-11e9-9d70-f58ea827d9ae" width = "70%" /></p>
<p>散列表中的几个概念：</p>
<ul>
<li>桶（bucket），用来直接存放或间接指向一个数据</li>
<li>桶数组（bucket array）由桶组成的数组</li>
<li>散列函数（hash function）将 key 转换为桶数组下标的函数</li>
</ul>
<p>上面的例子比较简单，如果我们继续在之前的基础上再存储一个 key 为 9 的数据，通过 9 % 10 计算得出的也是落在下标为 9 的 bucket 上，此时有两个不同的 key 落在了同一个 bucket 上，这一现象被称为散列冲突。</p>
<p>散列冲突理论上是不可避免的，我们能做的优化主要从以下两个方面入手：</p>
<ul>
<li>精心设计桶数组长度及散列函数，尽可能降低冲突的概率</li>
<li>发生冲突时，能对冲突进行排解</li>
</ul>
<p>假设不用散列表直接用数组来存储需要的数组长度为 R，用散列表存储需要的桶数组长度为 M，需要存储的元素个数为 N，则一定存在以下关系 <code>N &lt; M &lt;&lt; R</code>，只有这样散列表才能既保持操作的高效同时起到节省空间的效果。</p>
<p>其中，N / M 称为散列表的装载因子，当装载因子超过一定的阈值时，需要对桶数组扩容并 rehash。</p>
<p>理想的散列函数遵循以下的设计原则：</p>
<ul>
<li>确定：同一 key 总是被映射至同一地址</li>
<li>高效：插入/查找/删除 excepted-O(1) 时间复杂度</li>
<li>满射：尽可能充分地覆盖整个桶数组空间</li>
<li>均匀：key 映射到桶数组各位置的概率尽量接近</li>
</ul>
<p>常用的散列函数如下。</p>
<p><strong>除余法</strong> </p>
<p><code>hash(key) = key % M</code>，直接对 key 按桶数组的长度取余，这种方法非常简单，但存在以下缺陷。</p>
<ul>
<li>存在不动点：无论桶数组长度 M 取何值，总有 <code>hash(0) = 0</code>，这与任何元素都有均等的概率被映射到任何位置的原则相违背。</li>
<li>零阶均匀：<code>[0, R)</code> 的关键码，平均分配至 M 个桶；但相邻关键码的散列地址也必相邻。</li>
</ul>
<p><strong>MAD 法 multiply-add-divide</strong></p>
<p><code>hash(key) = (a x key + b) % M</code>，跟除余法相比，引入的变量 b 可以视作偏移量，可有效的消除不动点，另一个变量 a 扮演着步长的角色，也就是说原本相邻的关键码在经过散列后步长为 a，从而不再继续相邻。</p>
<p><strong>平方取中 mid-square</strong></p>
<p>取 <code>key^2</code> 的中间若干位，构成地址：</p>
<ul>
<li><code>hash(123) = 512</code> // 保留 key^2 = 123^2 = 15219 的中间 3 位</li>
<li><code>hash(1234567) = 556</code> // 1234567^2 = 1524155677489</li>
</ul>
<p>我们可以将一个数的平方运算，分解为一系列的左移操作以及若干次加法，从下图中不难看出，每一个数位都是由原关键码中的若干数位经求和得到的，因此两侧的数位由更少的原数位求和而得，越是居中的数位，则是由更多的原数位积累而得，因此截取居中的若干位，可使得原关键码的各数位都能对最终结果产生影响，从而实现更好的均匀性</p>
<p><img src="https://images.gitbook.cn/c06093f0-c71b-11e9-9e56-8d3dec542204" width = "70%" /></p>
<p><strong>多项式法</strong></p>
<p>在实际应用中，我们的 key 不一定都是整数形式，因此往往需要一个预处理将其转换为散列码(hashcode)，然后才可以对其进一步处理为桶数组的下标地址。整个过程可以描述为 key → hashcode → bucket addr，多项式法就是一种有效的将字符串 key 转换为 hashcode 的方法
对于一个长度为 n 的字符串，其计算过程如下：</p>
<pre><code>hash(x0 x1 ... xn-1) = x0 * a^(n-1) + x1 * a^(n-2) ... + xn-2 * a + xn-1 
// 如果上面的不是很理解，它其实等价于下面这样
(...((x0 * a + x1) * a + x2) * a + ... xn-2) * a + xn-1)
</code></pre>
<p>这个多项式可以在 O(n) 而不是 O(n2) 的时间复杂度内计算出结果，具体证明的过程这里就不详细展开了。</p>
<p>在实际的工程中会采用如下这种近似多项式，但更快捷的做法：</p>
<pre><code>function hash(key) {
    let h = 0
    for (let n = key.length, i = 0; i != n; i++) {
        h = (h &lt;&lt; 5 | h &gt;&gt; 27)
        h += key[i].charCodeAt()
    }
    return h &gt;&gt;&gt; 0
}
</code></pre>
<p>通过一个循环依次处理字符串的每一个字符，对于每一个字符将它转换为整数后累加，在累加之前对原有的累积值，都按照 h << 5 | h >&gt; 27 这样的规则做一个数位变换</p>
<p><img src="https://images.gitbook.cn/81040300-c747-11e9-a05e-8fabd2e19d71" alt="bit-operations" /></p>
<p>这一不断调整累加的过程，实际上可以是作为是对以上多项式计算的近似，只不过这里消除掉了相对耗时的乘法运算，至于如何理解和解释这种近似的效果，可以作为本文课后的一项作业。</p>
<p>除了上文讲到的方法外，还有非常多的散列函数的方法，如折叠法、位异或法、（伪）随机数法，此类方法林林总总，每种方法都有各自的特点及应用的场景，由于篇幅原因这里就不再展开了，感兴趣的读者可以在读者群中继续研究和探讨。</p>
<p>总之散列函数产生的关键码越是随机，越是没有规律就越好。</p>
<p><strong>冲突解决方法</strong></p>
<p>主要的处理散列表冲突的方法有开链法和探测法这两类。</p>
<ul>
<li><strong>开链法（linked-list chaining / seperate chaining）</strong></li>
</ul>
<p>每个桶存放一个指针，将冲突的 key 以链表的形式组织起来，这种处理方式最大的优点是能解决任意次数的冲突，但缺点也很明显，最极端的情况所有的 key 数据都落在一个桶上时，散列表将退化为一个链表，查找插入删除的复杂度都将变成 O(n)。</p>
<p><img src="https://images.gitbook.cn/23cf29b0-c749-11e9-9e56-8d3dec542204" width = "35%" /></p>
<ul>
<li><strong>探测法（open addressing / closed hashing）</strong></li>
</ul>
<p>探测法所有的冲突都在这块连续的空间中加以排解，而不用像开链法那样申请额外的空间。当存入一个 key 时，所有的桶都按照某种优先级关系排成一个序列，从本该属于该 key 的桶出发，顺次查看每一个桶直到找到可用的桶。每个 key 对应的这样的一个序列，称为试探序列或者查找链，在查找 key 时，沿查找链查找有两种结果，在桶中找到了查询的 key 也就是查找成功，还有的一种可能是找到一个空桶，则说明查找失败，没有这个 key。</p>
<p>最简单的试探序列的生成方法叫做线性试探（Linear probing），具体做法是一旦发生冲突，则试探后一个紧邻的桶单元，直到成功或失败。这种做法的优点是无需附加的（指针、链表等）空间，缺点也很明显，以往的冲突会导致后续的冲突。</p>
<pre><code>[hash(key) + 1] % M
[hash(key) + 2] % M
[hash(key) + 3] % M
...
</code></pre>
<p>线性试探的问题根源在于大部分的试探位置都集中在某一个相对较小的局部，因此优化线性试探的方式就是适当的拉开各次探测的间距，平方试探（Quadratic Probing）就是基于这一优化思路的具体实现方式，所谓平方试探顾名思义就是以平方数为距离，确定下一试探桶单元。</p>
<pre><code>[hash(key) + 1^2] % M
[hash(key) + 2^2] % M
[hash(key) + 3^2] % M
...
</code></pre>
<p>相对于线性试探，平方探测的确可以在很大程度上缓解数据聚集的现象，查找链上，各桶间距线性递增，一旦冲突，可从没地逃离是非之地。</p>
<h3 id="-12">散列表的实现</h3>
<p>最后用 JavaScript 来模拟实现一下 hashtable，这里我们采用开链法来解决散列的冲突。</p>
<pre><code>// 单向链表节点
class ForwardListNode {
    constructor(key, value) {
        this.key = key
        this.value = value
        this.next = null
    }
}

class Hashtable {
  constructor(bucketSize = 97) {
    this._bucketSize = bucketSize
    this._size = 0
    this._buckets = new Array(this._bucketSize)
  }

  hash(key) {
    let h = 0
    for (let n = key.length, i = 0; i != n; i++) {
      h = (h &lt;&lt; 5 | h &gt;&gt; 27)
      h += key[i].charCodeAt()
    }
    return (h &gt;&gt;&gt; 0) % this._bucketSize
  }

  // Modifiers
  put(key, value){
    let index = this.hash(key);
    let node = new ForwardListNode(key, value)

    if (!this._buckets[index]) {
      // 如果桶是空的，则直接把新节点放入桶中即可
      this._buckets[index] = node
    } else {
      // 如果桶不为空，则在链表头插入新节点
      node.next = this._buckets[index]
      this._buckets[index] = node
    }
    this._size++
    return index
  }  

  delete(key) {
    let index = this.hash(key)
    if (!this._buckets[index]) {
      return false
    }

    // 添加一个虚拟头节点，方便后面的删除操作
    let dummy = new ForwardListNode(null, null)
    dummy.next = this._buckets[index]
    let cur = dummy.next, pre = dummy
    while (cur) {
      if (cur.key === key) {
        // 从链表删除该节点
        pre.next = cur.next
        cur = pre.next
        this._size--
      } else {
        pre =  cur
        cur = cur.next
      }
    }
    this._buckets[index] = dummy.next
    return true
  }

  // Lookup
  find(key){
    let index = this.hash(key);
    // 如果对应的 bucket 为空，说明不存在此 key
    if (!this._buckets[index]) {
      return null
    }

    // 遍历对应桶的链表
    let p = this._buckets[index]
    while (p) {
      // 找到 key
      if (p.key === key) {
        return p.value
      }
      p = p.next
    }
    return null
  } 

  // Capacity
  size() {
      return this._size
  }

  isEmpty() {
      return this._size == 0
  }
}
</code></pre>
<h3 id="-13">总结</h3>
<p>这一节课我们介绍了和前端最为贴合的几种数据结构，虽然篇幅较长，但是内容算不上太难。一些基本概念并没有深入讲解， 因为数据结构更重要的是应用，我希望读者能够做到的是：在需要的场景，能够想到最为适合的数据结构处理问题。请读者务必掌握好这些内容，接下来的算法章节需要对数据结构有一个较为熟练地掌握和了解。</p></div></article>