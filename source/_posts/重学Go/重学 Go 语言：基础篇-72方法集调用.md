---
title: 重学 Go 语言：基础篇-72
---
<article id="topicContainer" class="column_content"><h2 class="topic_title"></h2><div><h3 id="">方法集调用</h3>
<p>N类型，有两个方法，当我们用N类型调用的时候，理论上只执行String，但是如果我们用N类型调用Inc是不是合法的呢？</p>
<pre><code class="go language-go">type N int

func (n *N) Inc() {
    *n++
}

func (n N) String() string {
    return strconv.Itoa(int(n))
}

func main() {
    var n N = 100

    (*N).Inc(&amp;n)

    s := (*N).String(&amp;n)
    println(s)
}
</code></pre>
<pre><code class="bash language-bash">$ go build -gcflags "-l" -o test call.go
$ go tool objdump -s "main\.main" test
</code></pre>
<p>我们注意到<code>CALL main.(*N).Inc(SB)</code>调用方式并没有运行期的行为，都是静态绑定。因为调用的哪些方法虽然源码不存在但是编译器生成了，这个方法实际上已经存在了，我们刚刚看到编译器实际上替我们生成了这些间接调用，既然说这个函数或者方法已经存在了，那直接用call间接方法就可以了。</p>
<p>如果A嵌入B，B有个方法叫x，那么编译器会自动帮我们生成A.X方法，方法内部调用A.B.X方法，这实际上是编译器自动生成的。如果我们源码里写A.X的话实际上会被编译器翻译成对自动包装函数的调用，所以从语法上A.X看上去好像A继承X方法，实际上是因为编译器翻译成A.B.X的调用。</p>
<h3 id="tt">方法集区分基础类型T和指针类型*T</h3>
<p>看看编译器怎么做这事情的？</p>
<pre><code class="go language-go">type N int

func (n *N) Inc() {
    *n++
}

func (n N) String() string {
    return strconv.Itoa(int(n))
}

func listMethods(a interface{}) {
    t := reflect.TypeOf(a)
    fmt.Printf("\n--- %v ---------\n", t)

    for i := 0; i &lt; t.NumMethod(); i++ {
        m := t.Method(i)
        fmt.Printf("%s: %v\n", m.Name, m.Type)
    }
}

func main() {
    var n N

    listMethods(n)
    listMethods(&amp;n)
}
</code></pre>
<p>listMethods方法是利用反射把当前方法的方法集全部列出来。方法集具体的区别在于Go语言很大的不同在于可以显式的提供参数，提供参数可以指定类型的*N或者N。这地方就会形成这样一个概念。</p>
<p>比如声明类型<code>N</code>，假如说有两个方法A、B，但是它们的this参数可以是<code>N</code>也可以是指针<code>*N</code>，这样的话A和B就会属于不同的类型，一个是N，一个是N的指针。一个类型和一个类型的指针属于两种类型，<code>*N</code>长度是8，<code>N</code>长度是32,64之类的，虽然类型不是一回事，一个是指针一个是普通类型，这就造成实现方法的时候，是针对<code>N</code>实现的还是针对<code>*N</code>实现的，这就造成了<code>N</code>的方法集和<code>*N</code>的方法集是不一样的。</p>
<p>上面代码定义类型N，实现了两个方法，一个方法针对<code>N</code>本身实现，一个方法针对<code>*N</code>实现。我们分别列出它们的方法集究竟有哪些。在main函数中定义了N实例，分别列出<code>N</code>和<code>*N</code>有哪些方法集。</p>
<pre><code>--- main.N ---------
String: func(main.N) string

--- *main.N ---------
Inc: func(*main.N)
String: func(*main.N) string
</code></pre>
<p>我们可以看到<code>N</code>方法集就有1个<code>N</code>基础类型的方法，<code>*N</code>方法集除了<code>*N</code>类型的方法以外还包含<code>N</code>类型的方法。<code>func(*main.N) string</code>做了类型转换。</p>
<p>简单的来说，我们有个类型<code>T</code>，<code>T</code>的方法集只包含<code>T</code>自身的，但是<code>*T</code>方法集等于<code>T</code>+<code>*T</code>的方法，这就是差别。</p>
<p>不同的语言在这块的做法会有一些细微的差别。Java和C#为什么没有这东西，因为它们默认的话this就有一种引用方式，没有说把this分为引用和值两种方式。就是你引用实例，说白了就相当于只有<code>*T</code>没有<code>T</code>，指针类型和指针的基础类型不是一回事。</p>
<p>当我们拿到一个对象指针<code>*T</code>的时候，调用对象T的方法是不是安全的呢？因为我们可以把指针里面数据取出来，然后作为T参数。但是我们拥有T，未必就能获得T的指针<code>*T</code>，因为它有可能是个临时对象，临时对象是没有办法取得它的指针的，指针也就意味着这个对象肯定是在栈上或者堆上分配过的，但是拥有临时对象的实例未必能拿到临时对象的指针，不见得是合法的。我们假如访问字典里面一个元素，如果编译器对字典元素本身做了不允许访问地址，那访问元素的时候拿不到指针的，这时候获取到它的指针没有意义，还有跨栈帧获取指针也没有意义。所以说用指针获取指针目标是安全的，用目标未必能获得它的指针。这是因为内存安全模型决定的，因为Go语言并不完全区分值类型和引用类型，它是由编译器决定对象到底分配到哪。</p>
<p><code>String: func(*main.N) string</code>方法哪里来的？</p>
<pre><code class="bash language-bash">$ go build -gcflags "-N -l" -o test test.go #编译
$ nm test | grep "[^\.]main\." #输出符号
</code></pre>
<p>输出</p>
<pre><code>T main.init
B main.initdone.
T main.listMethods
T main.main
T main.(*N).Inc
T main.(*N).String
T main.N.String
</code></pre>
<p>我们注意到String有两个，<code>main.(*N).String</code>和<code>main.N.String</code>，<code>main.N.String</code>是我们自己定义的，<code>main.(*N).String</code>是程序执行时候输出的，两个地址都不一样，这表明最终生成机器代码的时候是存在两个这样函数，很显然<code>main.(*N).String</code>是编译器生成的。</p>
<p>反汇编看看到底什么样的：</p>
<pre><code>$ go tool objdump -s "main\." test | grep "TEXT.*autogenerated"
</code></pre>
<pre><code>TEXT main.(*N).String(SB) &lt;autogenerated&gt;
</code></pre>
<p><code>main.(*N).String(SB)</code>是机器生成的，地址是<code>00000000004b1f60</code>和符号表里面一致，实际上在符号表里面已经打上了<code>&lt;autogenerated&gt;</code>标记。为什么打上这个标记，因为我们自己写的代码在符号表里面有信息可以对应到哪一行，但是很显然有些东西不是我们写的，所以从源码上没有办法对应关系，所以符号表标记这些信息由编译器生成的。</p>
<p>现在知道，当我们想实现一个方法集的时候，源码层面和机器码层面其实是不一样的，因为源码层面嵌入一个类型的时候会自动拥有它的方法。对于机器码来说，调用函数必须给一个合法的地址，这个合法的地址必须生成对应的代码，这个代码高级语言称之为规则，规则就是编译器支持这种理论，编译器替我们完成这些。</p>
<p>所谓的方法集就是嵌入一个类型的时候，就拥有它的方法，准确的说，编译器自动生成嵌入类型的方法。</p>
<p>Go语言虽然没有继承的概念，编译器替我们补全了这种间接调用。这样一来有点类似于A继承B的方法，但是这不是继承，因为是继承的话就不会有自动代码生成，直接通过类型表去调用。Go语言所谓的自动拥有方法集不是继承而是语法糖层面上的代码补全。</p></div></article>