---
title: 重学 Go 语言：基础篇-73
---
<article id="topicContainer" class="column_content"><h2 class="topic_title"></h2><div><h3 id="">匿名嵌入方法集</h3>
<ul>
<li>嵌入S，T += receiver S。</li>
<li>嵌入*S，T += receiver (S + *S)。</li>
<li>嵌入S或*S， *T += receiver (S + *S)。</li>
</ul>
<p>匿名嵌入字段时基本规则大概这样。如果在一个类型里嵌入<code>S</code>，那么<code>T</code>的方法集包含<code>S</code>。如果嵌入<code>*S</code>那么包含全部。不管S还是<code>*S</code>，以<code>*T</code>的方式获取方法集的时候包含全部。所以用指针方式获取方法集时等于全部，当用<code>T</code>方式获取时，分嵌入<code>S</code>还是<code>*S</code>。不管一级还是两级都严格区分<code>T</code>和<code>*T</code>。</p>
<h3 id="-1">匿名嵌入字段方法集</h3>
<pre><code class="go language-go">type S int
type X struct {
    S
}

func (S) A()  {}
func (*S) B() {}
func main() {
    var o X
    t := reflect.TypeOf(o)
    // t := reflect.TypeOf(&amp;o)
    for i := 0; i &lt; t.NumMethod(); i++ {
        fmt.Println(t.Method(i).Name)
    }
}
</code></pre>
<p>S有A和B两个方法，X里嵌入S或者*S。测试不同嵌入情况下的方法集有什么不同。</p>
<p>在很多语言接口不是实际意义上的概念，可能在运行期并不存在，Python甚至没有接口这种概念，它称之为协议。在go里接口是独立数据结构，所以导致通过接口调用方法的时候和它的内存布局有关系。了解方法集概念以后，第一个概念是一个类型能调用的方法和它对应的方法集不一样。第二个概念就是上面公式。</p>
<h3 id="-2">匿名嵌入对方法集的影响</h3>
<p>当匿名嵌入一个对象的时候，编译器会帮我们自动生成间接代码调用，所以看上去拥有了对象的方法，实际上不是拥有而是编译器做了代码补全。这个语法糖实际上是代码补全而不是动态行为是静态行为。</p>
<pre><code class="go language-go">type N int

type X struct {
    N
}

type Y struct {
    *N
}

func (n *N) Inc() {
    *n++
}

func (n N) String() string {
    return strconv.Itoa(int(n))
}

func listMethods(a interface{}) {
    t := reflect.TypeOf(a)
    fmt.Printf("\n--- %v ---------\n", t)

    for i := 0; i &lt; t.NumMethod(); i++ {
        m := t.Method(i)
        fmt.Printf("%s: %v\n", m.Name, m.Type)
    }
}

func main() {
    var x X
    listMethods(x)
    listMethods(&amp;x)

    var y Y
    listMethods(y)
    listMethods(&amp;y)
}
</code></pre>
<p>X嵌入了N，Y嵌入了*N。</p>
<pre><code>--- main.X ---------
String: func(main.X) string

--- *main.X ---------
Inc: func(*main.X)
String: func(*main.X) string

--- main.Y ---------
Inc: func(main.Y)
String: func(main.Y) string

--- *main.Y ---------
Inc: func(*main.Y)
String: func(*main.Y) string
</code></pre>
<p>我们注意到<code>X</code>只拥有<code>X</code>自身的方法，<code>X</code>指针拥有<code>X</code>和<code>X</code>指针的方法。<code>Y</code>因为嵌入了<code>X</code>，只能获得对应值类型的方法，<code>Y</code>指针拥有对应的指针类型。</p>
<p>接下来看看匿名嵌入的时候用哪些东西是自动生成的，我们注意到这里面有很多自动生成的方法来实现方法集。</p>
<pre><code class="bash language-bash">$ go build -gcflags "-N -l" -o test embed.go
$ nm test | grep "[^\.]main\."
$ go tool objdump -s "main\." test | grep "TEXT.*autogenerated"
$ nm test | grep "[^\.]main\."
</code></pre>
<pre><code>T main.init
B main.initdone.
T main.listMethods
T main.main
T main.(*N).Inc
T main.(*N).String
T main.N.String
T main.(*X).Inc
T main.(*X).String
T main.X.String
T main.(*Y).Inc
T main.Y.Inc
T main.(*Y).String
T main.Y.String
</code></pre>
<pre><code class="bash language-bash">go tool objdump -s "main\." test | grep "TEXT.*autogenerated"
</code></pre>
<pre><code>TEXT main.init(SB) &lt;autogenerated&gt;
TEXT main.(*N).String(SB) &lt;autogenerated&gt;
TEXT main.(*X).Inc(SB) &lt;autogenerated&gt;
TEXT main.(*X).String(SB) &lt;autogenerated&gt;
TEXT main.X.String(SB) &lt;autogenerated&gt;
TEXT main.(*Y).Inc(SB) &lt;autogenerated&gt;
TEXT main.(*Y).String(SB) &lt;autogenerated&gt;
TEXT main.Y.Inc(SB) &lt;autogenerated&gt;
TEXT main.Y.String(SB) &lt;autogenerated&gt;
</code></pre></div></article>