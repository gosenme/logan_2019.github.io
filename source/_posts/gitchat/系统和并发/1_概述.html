---
title: 概述
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>概述</title>
</head>
<body>
<article id="articleDiv" style="overflow: hidden;padding-bottom:20px;text-align: justify;"><div class="mazi-article-content dont-break-out"><h3 id="">引入</h3>
<p>现在编程语言抽象化越来越剧烈，我们时刻提醒自己有上下两条分界线拘束着，下面的分界线称之为系统层面，上面的分界线称之为创意层面，系统层面偏向于基础研究，包括像操作系统、编译器和其他东西，而上面一层更多的是各种创意。我们大部分在中间，因为大部分人对于研究基础不感兴趣，往上创意层面非常需要灵感和天赋的，不是努力就能做到的，所以尽量扩展我们的层面越广阔越好。</p>
<p>系统层面上的各种各样的创新扩宽了整个世界，它给创意层面提供了更广阔的舞台，而创意层面除了把现在的东西发挥的很好以外还提供了各种各样的创意反过来促进底层的研究。现在很多科技在很早就出现在早期的科幻小说电影里慢慢的变成现实。系统层面的封装特别多，创意层面各种各样设计让大家使用起来越来越简单。</p>
<p>换句话说，对于中间层面的人来说可怕的在于表面上接触了越来越多的东西，实际上离底层和上层越来越远。一些语言把原来需要自己处理的东西做了一层包装 Runtime，造成了我们是很普通的使用者。科技越来越发展，我们甚至写的程序放在哪里怎么运行都不关心，服务器虚拟化调度越来越简单，甚至连服务器优化都不用管了。系统底层实际上用各种各样手段进一步的封装，把原来复杂的设计搞得越来越简单，所以对 Runtime 的了解是非常有必要的。</p>
<p>现代语言大部分会有 Runtime，类似在操作系统以外再抽象出一层虚拟机，它接管着很多东西，比如内存、垃圾回收、甚至包含现在的并发调度任务执行。内存管理、垃圾回收、并发调度是 Go 语言的 Runtime 中最核心的东西，这个系列深入剖析 Runtime 三大组件，内存分配器、垃圾回收器、Goroutine 调度。</p>
<h3 id="-1">内容介绍</h3>
<p>现在用几句话概括这个系列的内容。</p>
<p>内存管理涉及两个核心问题，第一是快速分配，第二是适可而止。Go 语言基于 tcmalloc 实现的<strong>内存分配器</strong>，tcmalloc 就是 Google 开发的快速内存分配器，它本身就是基于并发设计的，目的是找到相对比较好的平衡，既有很高的性能同时内存消耗不会太夸张。Go 语言使用了 Heap、Central、Cache 三级机构实现分解锁，两级平衡，既照顾了快速分配同时又照顾了内存节约。</p>
<p>Go 语言<strong>垃圾回收器</strong>使用三色标记的方式扫描标记对象，使用写屏障模式实现并发标记和并发清理，使用控制器辅助回收一系列的措施做到垃圾回收。垃圾回收器只是一种辅助装置，它从来不是核心装置它只是辅助回收，它没有办法让程序变的很好，只不过现在不需要用代码时时刻刻去关心释放内存，但是它永远不可能让程序变的更好，因为它不够聪明。</p>
<p>Go 语言提供的 <strong>Goroutine 模型</strong>相对设计的相当不错的，Goroutine 本身就是基于并发设计的。如果有一个虚拟机的话，必须要有处理器，各种各样的运行的并发任务和具体执行机构线程，处理器的数量决定了并发的任务数量，通过相关的命令创建大量的任务。Goroutine 这样的 G、M、P 模型实际上就为了摆脱对操作系统层面上的依赖，不用考虑线程，不用考虑并发对于核的处理。</p>
<p>Go 语言的 <strong>Channel 模型</strong>只能在进程内进行通讯，在各种各样的算法里面频繁的使用，显然比内存共享要花的代价大很多，但是它的抽象层面可以做到解耦。Channel 模型根本不需要对方是谁，只要约定好格式化数据放到某个通道里去，在通道上面与使用者无关，这实际上都是架构层面上的解耦。</p>
<p><strong>同步</strong>模块中提供了互斥锁（Mutex）、读写锁（RWMutex）、条件锁（Cond）、信号量（Semaphore）、自旋锁（SpinLock）、原子操作（Atomic），平常开发中肯定会使用锁这样概念，为了数据竞争我们需要加个锁，他们有不同的性能差别，也就意味着不同的锁适合用在不同的场合。</p>
<h3 id="-2">内容大纲</h3>
<p>系统模块（内存管理、垃圾回收、Goroutine 调度）：</p>
<ul>
<li>自主实现内存管理</li>
<li>内存管理面临的问题</li>
<li>Go 基于 tcmalloc 实现的内存分配器工作原理</li>
<li>如何释放物理内存</li>
<li>垃圾回收常用方式：引用计数、代龄、标记清理</li>
<li>垃圾回收何时启动？如何避免内存膨胀，避免影响性能</li>
<li>Go 三色标记 + 写屏障模式如何实现并发标记和并发清理</li>
<li>控制器和辅助回收的作用</li>
<li>Goroutine 调度 G、M、P 模型</li>
<li>如何创建 Goroutine</li>
<li>如何启动并发任务</li>
<li>调度器如何执行</li>
<li>M/P 对应关系</li>
<li>分段栈的问题是什么</li>
<li>连续栈如何实现</li>
<li>连续栈回收</li>
<li>连续栈扩张问题演示</li>
<li>系统监控的用途</li>
<li>强制垃圾回收</li>
<li>释放物理内存</li>
<li>抢占调度</li>
<li>处理系统调用</li>
<li>I/O 事件</li>
</ul>
<p>并发模块（进程、线程、协程、通信、同步）：</p>
<ul>
<li>进程、线程的区别</li>
<li>系统线程和用户线程的区别</li>
<li>CPU 时间片分配方式</li>
<li>协程基本原理、优点和缺点</li>
<li>上下文切换以及对性能的影响</li>
<li>通道基本原理</li>
<li>同步通道和异步通道的区别</li>
<li>Goroutine 资源泄漏</li>
<li>常见同步方式</li>
<li>互斥锁（Mutex）</li>
<li>读写锁（RWMutex）</li>
<li>条件锁（Cond）</li>
<li>信号量（Semaphore）</li>
<li>自旋锁（SpinLock）</li>
<li>原子操作（Atomic）</li>
<li>单核和多核指令是否原子</li>
<li>如何实现原子操作</li>
<li>CAS（Compare-and-swap）</li>
<li>用原子操作实现自旋锁</li>
</ul></div></article>
</body>
</html>