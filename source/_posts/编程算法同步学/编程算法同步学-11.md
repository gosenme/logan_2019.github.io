---
title: 编程算法同步学-11
---
<article id="topicContainer" class="column_content"><h2 class="topic_title"></h2><div><p>数组、链表这些结构限制条件的根本原因来自于 <strong><em>计算机硬件的体系结构</em></strong>。</p>
<p>在现今的计算机教育体系中，编程语言、数据结构（含算法）、计算机原理及体系结构几门课是计算机专业的本科生都要学习的。</p>
<p>实际上这几门课之间，也包括其他一些课程（例如编译原理、自动机、数电、模电、操作系统等等 ），有不少overlap的知识点和相互引用的地方，要从一个方向讲清楚某个知识点，就不得不涉及其他几个领域的知识。但是因为内容实在太多，不得已被分割为几门课程。</p>
<p>大学课程如此，我们这类入门性质的课程就要灵活得多，不必特意割裂知识间原本的联系，而是用到什么就讲什么。</p>
<p>今天这一章，虽然目标是说明数据结构受限的原因，但为了把它讲明白，我们先从计算机原理开始。</p>
<h3 id="">电子计算机的前世今生</h3>
<h4 id="-1">从人、算盘、到专用计算器</h4>
<p>计算机对应的英文原词是computer，这个词在英语里原本指从事数据计算的人——即使到了上世纪六七十年代，许多从事计算工作的人，仍然被称为computer。</p>
<p>下图是1949年，NASA的人形计算机（human computers）：</p>
<p><img src="https://images.gitbook.cn/e4f55610-755e-11e9-a205-f7d1a4415027" alt="enter image description here" /></p>
<p>由于计算任务的必要性和痛苦性，通过工具或者设备来代替人承担计算任务一直是人类的追求。从古老的算筹、算盘等简易工具，到计算尺、手摇计算机等机械工具，都是这种追求的体现。</p>
<p><img src="https://images.gitbook.cn/cbede820-755f-11e9-8a4b-e1c136eff7f7" alt="enter image description here" /></p>
<p>到了20世纪前半叶，为了满足科学计算的需求，使用电子模拟器或液压机械的模拟计算机被发明出来。但它们都是用来进行特定问题计算的。</p>
<p>这类计算器，内置了固定用途的程序，形象点说，就是程序被“焊死”在了机器里，一旦机器造出来，程序就定了，既不能修改也不能删除。</p>
<p>现在某些特定类型的计算机依然维持这样的设计方式，通常是为了简化或教育目的。例如：便携式计算器，就内置了固定的数学计算程序。</p>
<p><img src="https://images.gitbook.cn/f6272680-755d-11e9-8a4b-e1c136eff7f7" alt="enter image description here" /></p>
<h4 id="-2">通用计算机</h4>
<p>20世纪30至40年代，随着社会发展，人们对计算机性能和通用性的需求越来越强。</p>
<p>1936年，英国数学家<strong>图灵</strong>提出了一种被称为图灵机（Turing machine）的抽象计算模型，用来模拟人们用纸笔进行数学运算的过程。</p>
<p><img src="https://images.gitbook.cn/673b37f0-6f03-11e9-9e09-352d593876a5" alt="英国数学家图灵" /></p>
<p>这一数学模型，<strong>从理论上证明了通用计算的可行</strong>，也因此成为了现代电子计算机的计算模型。</p>
<p>1937年，美国数学家<strong>香农</strong>发表了论文：《对继电器和开关电路中的符号分析》。</p>
<p><img src="https://images.gitbook.cn/8111e750-6f03-11e9-9e09-352d593876a5" alt="美国数学家香农" /></p>
<p>该论文标志着<strong>二进制电子电路设计和逻辑门应用</strong>的开始，为人们制造模拟图灵机的物理机器提供了基础元器件。</p>
<p>二十世纪40年代，欧美各国造出了一系列电子计算机，有Z3，ABC，Colossus computer，Mark I等。</p>
<p>电子数值积分计算机（Electronic Numerical Integrator And Computer，缩写<strong>ENIAC</strong>）是其中的翘楚，它由美国陆军资助建造，是世界上第一台通用计算机。</p>
<p>ENIAC由电路管线构成，通过编程来解决各种各样的计算问题。不过在ENIAC上编程可不是像现在编程这样，敲几个键盘就行了，而是要重新设计电路连接方式，并由一个人类小组进行重新配接线路才可以。</p>
<p>下图就是ENIAC的编程小组，在重构电路连接：</p>
<p><img src="https://images.gitbook.cn/a9f43650-6f03-11e9-8592-1f032fcfe7bb" alt="enter image description here" /></p>
<h3 id="-3">冯·诺依曼结构</h3>
<p>以约翰·冯·诺伊曼为代表的一批数学家、计算机科学家在使用ENIAC和Mark I等计算机时发现了存储的重要性。</p>
<p><img src="https://images.gitbook.cn/b81241a0-6f03-11e9-a2c5-297479f960f8" alt="美国数学家冯·诺依曼" /></p>
<p>1945年6月30日，ENIAC机密计划的安全官戈德斯坦发表了一篇由冯·诺伊曼撰写的101页报告，史称《EDVAC报告书的第一份草案》。其中提出了“<strong>冯·诺伊曼结构（Von Neumann architecture）</strong>”这个术语。</p>
<p>冯·诺伊曼结构一种设计计算机的概念结构，具体见下图：</p>
<p><img src="https://images.gitbook.cn/e06f0cf0-6f03-11e9-8592-1f032fcfe7bb" alt="enter image description here" /></p>
<p>冯·诺依曼结构的<strong>要点</strong>主要包括：</p>
<p>1.计算机硬件由运算器、控制器、存储器、输入设备和输出设备五大部分组成，其中运算器和控制器组成了中心处理单元（CPU）；</p>
<p>2.指令——指令是单个的CPU操作，一款CPU能够进行哪些操作是在设计时就确定了的，和数据都以二进制编码；</p>
<p>3.存储器中既存储数据又存储指令。</p>
<p>这一结构<strong>将存储设备与处理单元（运算器、控制器）分开</strong>，依此结构设计出的计算机又称<strong>存储程序型计算机</strong>。</p>
<p>存储程序型计算机改变了若要改变程序，就要改变计算机线路的情况。它将运算操作转化成一串程序指令，又<strong><em>将程序指令当成一种特别类型的数据和其他数据一起存储在存储器中</em></strong>。这样，一台存储程序型计算机就<strong>可以像变更数据一样改变程序</strong>了。</p>
<h3 id="-4">存储空间的地址和内容</h3>
<h4 id="-5">存储空间</h4>
<p>存储器在逻辑上是一个空间，这个空间被叫做存储空间。</p>
<p>存储空间被分为若干存储单元，每个存储单元又分为两个部分：</p>
<ul>
<li><strong>地址</strong>：每个存储单元对应的序号，标识内容在存储空间中位置的编码；</li>
<li><strong>内容</strong>：存储单元中存放的信息。</li>
</ul>
<p>无论地址还是内容均以二进制的形式表示：</p>
<p><img src="https://images.gitbook.cn/f99271e0-6f03-11e9-9e09-352d593876a5" alt="enter image description here" /></p>
<p>换言之，存储空间<strong>线性编址，按地址访问</strong>，存储在其中的每一条指令或数据，都是空间里存放的内容，它们都拥有自己的地址。</p>
<h3 id="-6">类比仓库</h3>
<p>我们可以将存储空间类比成一个<strong><em>仓库</em></strong>，里面有许多的货架，相当于一个个的存储单元，每个货架都有自己的编号（存储单元地址），货架上还会有相应的货物（存储单元的内容），就像下面这样：</p>
<p><img src="https://images.gitbook.cn/03b4be80-6f04-11e9-9f49-6f4505f5df5e" alt="enter image description here" /> </p>
<p>当我们想要拿到其中某一个货物的时候，我们首先要知道该货物所在的货架编号，然后根据编号找到货架，从上面把货物取下来。比如：告诉我们去拿001号货架上的货物，我们就去把小红盒拿下来就是了。</p>
<p>反之放置货物，就是将货物放到对应编号的货架上去。</p>
<p>总结一下：</p>
<ul>
<li><p>在这些货架上的“货物”，可能是指令，也可能是数据；</p></li>
<li><p>“拿货”就是读操作，而“放置”则对应写操作；</p></li>
<li><p>指令和数据一样可以被读、被写、被修改（用新“货物”替代旧“货物”）；变更指令或者数据，都只要修改存储空间内的内容就好了，无须变更硬件设置。</p></li>
</ul>
<h3 id="-7">一条指令是怎么被执行的？</h3>
<p>计算机运行的过程，就是一条条执行指令的过程。</p>
<p>由运算器和控制器组成的CPU，是计算机的“执行机构”。可以类比于我们人脑的神经中枢，“思维”专用。<strong>CPU负责顺序执行程序的每一条指令</strong>。</p>
<p>每一条指令的执行过程，大致是这样的：</p>
<p>1.<strong>取指令</strong>（Instruction Fetch，IF）：根据指令地址，从存储器里取出相应指令；</p>
<p>2.<strong>指令解码</strong>（Instruction Decode，ID）：分析指令的操作类型（读/写操作，输入/输出操作，或者算术逻辑运算操作等）和获取操作数的方法；</p>
<p>3.<strong>执行</strong>（Execute，EX）：完成指令功能（例如控制运算器对操作数进行运算），并控制数据在CPU、存储器和输入/输出设备之间流动；</p>
<p>4.<strong>写回</strong>（Writeback，WB）：将运算结果写入CPU或存储器。</p>
<p>一个完整的指令执行过程所需要的时间，称作一个<strong>指令周期</strong>。</p>
<p>在一条指令被执行完毕，结果数据写回之后，若无意外事件（如结果溢出等）发生，则计算机根据程序的控制结构（顺序结构、条件结构、循环结构）确定下一步要执行的指令，开始新一轮执行指令的循环。</p>
<h3 id="-8">冯诺依曼结构的直观解释</h3>
<p>我们打个形象的比于：冯诺依曼结构的计算机就像一家餐厅——</p>
<p>【1】 <strong><em>存储器</em></strong>相当于<strong><em>仓库</em></strong>：</p>
<p><img src="https://images.gitbook.cn/4344de90-6f04-11e9-9f49-6f4505f5df5e" alt="enter image description here" /></p>
<p>仓库（存储空间）里的货架都有编号，货架上，要么放着食谱（指令），要么放着食材（数据）。</p>
<p>【2】 <strong><em>CPU</em></strong>则相当于<strong><em>厨师</em></strong>（控制器）和<strong><em>炊具</em></strong>（运算器）：</p>
<p><img src="https://images.gitbook.cn/4fe74660-6f04-11e9-a2c5-297479f960f8" alt="enter image description here" /> </p>
<p>【3】 执行一条指令的过程就像做一道菜：</p>
<blockquote>
  <p>1.从仓库里拿食谱——取指令；</p>
  <p>2.阅读食谱，搞清楚要烹调的方式和要使用的食材——指令解码；</p>
  <p>3.根据食谱拿食材，并烹饪制作——执行；</p>
  <p>4.把做好的菜放回到货架上——回写。</p>
</blockquote>
<p>这道菜做完，再去做下一道菜。</p>
<p>【4】 程序更新类似于换菜单：</p>
<p>假设，今天这顿饭总共做了两道菜：炒萝卜和烤鱼。</p>
<p>明天客人不想吃烤鱼了，想吃蒸鱼，那只要把仓库中“第1格“的食谱换成”蒸“就可以了，餐厅的所有硬件，包括厨师，都不会受影响，其他位置的食谱和食材也不会受影响。</p>
<p>这就是冯诺依曼结构的直观解释。</p>
<h3 id="-9">冯诺依曼结构的应用</h3>
<p>现代计算机，大部分都基于冯诺依曼结构。</p>
<p>下图是一台普通PC的硬件结构图，我们可以来看一下其中不同部件和冯诺伊曼结构的对应：</p>
<p><img src="https://images.gitbook.cn/9703ed00-6f04-11e9-9f49-6f4505f5df5e" alt="enter image description here" /></p>
<ul>
<li><p>红框里的CPU——运算器、控制器；</p></li>
<li><p>黄框里的内存条——存储器；</p></li>
<li><p>绿框里的键盘接口和显卡——输入设备和输出设备。</p></li>
</ul>
<p>这是一个典型的冯诺依曼结构。</p>
<h3 id="-10">冯·诺依曼结构的瓶颈</h3>
<h4 id="-11">导致瓶颈的原因</h4>
<p>冯·诺依曼结构在运行中会导致一个瓶颈，叫做冯·诺伊曼瓶颈（von Neumann bottleneck），其产生原因是现实当中不同计算机部件的客观性能：</p>
<ul>
<li>CPU的处理速度特别快</li>
<li>CPU与存储器之间的数据传输速率与存储器的容量相比起来相当小</li>
</ul>
<p>这个瓶颈的表现就是：CPU的高效工作与低速的数据传输之间不平衡，<strong><em>CPU不得不在数据输入输出的时候闲置，因而严重影响了整体效率</em></strong>。</p>
<h4 id="-12">通过直观例子理解瓶颈</h4>
<p>还用餐厅的例子来说明：</p>
<blockquote>
  <p>我们的Hello Kitty厨师是个超级快手，她的平底锅也是厨界神奇，任何食材无论煎炒烹炸全都能一秒钟完成：</p>
  <p><img src="https://images.gitbook.cn/f1f8d680-6f04-11e9-8592-1f032fcfe7bb" alt="enter image description here" /></p>
  <p>偏偏负责给她拿食谱和食材的助手是个慢吞吞：</p>
  <p><img src="https://images.gitbook.cn/ad57de40-6f04-11e9-a2c5-297479f960f8" alt="enter image description here" /></p>
  <p>每次往返一趟厨房和仓库得半个小时，而且能拿的东西还特别少，每次只能拿50g以下的东西，食谱还可以一次拿完，要是拿食材，得往返个百八十回的。</p>
  <p>这种情况下，Hello Kitty只能整天闲着，慢吞吞先生却累得要死。这个问题会越来越严重，而餐厅的整体运行效率则受限于慢吞吞先生的工作效率。</p>
</blockquote>
<h4 id="-13">缓解瓶颈的办法</h4>
<p>针对冯诺依曼瓶颈，人们想了很多办法来缓解它，这些法子包括：</p>
<ul>
<li><p>在CPU与存储器之间加入高速缓存;</p></li>
<li><p>采用分支预测（branch prediction）算法;</p></li>
<li><p>通过编程方式的改变（现代的函数式编程以及面向对象编程），在宏观上减少将大量数值从存储器搬入搬出的操作；</p></li>
<li><p>等等</p></li>
</ul>
<p>这些方法的确大幅缓解了瓶颈问题。</p>
<h3 id="-14">哈佛结构</h3>
<p>上面我们提到了一台和ENIAC同时期的电子计算机Mark I，它虽然不如ENIAC那样通用，却是美国第一部大尺度自动数位电脑，由IBM制造出来之后被哈佛大学接管。</p>
<p>它<strong><em>将指令和数据区别对待</em></strong>，将它们<strong><em>分开存储</em></strong>，这种结构被称为 “<strong>哈佛结构（Harvard architecture）</strong>”。</p>
<p>因为指令和数据分别放在不同的存储器中，可以在同时读取两者，因此哈佛结构相对冯·诺依曼结构，效率会更高。</p>
<p>但是这种高效的代价很大：</p>
<ul>
<li><p>哈佛结构比冯诺依曼结构要复杂得多；</p></li>
<li><p>在动态加载程序时，哈佛结构需要先将静态程序代码作为数据读入数据存储器，再将其传输到指令存储器中去——这样既增加了存储负担又增加了传输负担，还使得过程非常复杂。</p></li>
</ul>
<p>过高的复杂度限制了哈佛结构的推广。</p>
<p>现在，我们日常使用的计算机，在整体体系结构上基本上都采用冯诺依曼结构。不过许多CPU内核，会采取类哈佛结构的设计，在CPU内的缓存中区分指令缓存和数据缓存。这也可以说是在现实应用中冯诺依曼结构和哈佛结构的一种折中。</p>
<p><strong>分享交流</strong></p>
<p>为了方便与作者交流与学习，GitChat 编辑团队组织了一个《编程算法同步学》读者交流群，添加小助手-伽利略微信：「GitChatty6」，回复关键字「229」给小助手-伽利略获取入群资格。</p>
<p>阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者提问（作者看到后抽空回复）。你的分享不仅帮助他人，更会提升自己。</p></div></article>