---
title: 编程算法同步学-43
---
<article id="topicContainer" class="column_content"><h2 class="topic_title"></h2><div><p>终于，我们要正式开始讲解排序算法啦！今天先来讲一个最最简单的排序算法：选择排序。</p>
<h3 id="">扑克牌小游戏</h3>
<h4 id="110">排列 1-10</h4>
<p>开始讲算法之前，我们还是先来看一个小游戏：</p>
<p>以一副扑克牌为道具，取出其中某一花色的 1-10，打乱顺序，扔在桌上，然后对它们进行人肉排序。我们该怎么做呢？</p>
<p><img src="https://images.gitbook.cn/5f3ddc10-a496-11e9-8efd-09cc8f7db509" alt="enter image description here" /></p>
<p>既然都知道是 1-10 了，那就先找 A，再找 2，然后 3，4，5，……，10 不就得了。</p>
<p>这样做当然可以做到把同一花色牌的 1-10 排出来，我们可以先预留出 10 个“空位”，然后每捡起一张牌就将它放到对应的位置上，比如先捡起黑桃 6，就放在第 6 个“空位”上，然后捡起黑桃 A，再放在第 1 个“空位”……</p>
<p>如此，很容就把 10 张牌都排好了，而且是有序的：</p>
<p><img src="https://images.gitbook.cn/82435050-a496-11e9-b802-f18daf16e87f" alt="enter image description here" /></p>
<p><center><font color=orange><strong>但是，这不叫排序！</strong></font></center></p>
<h4 id="dned">填空 $\ne$ 排序</h4>
<p>为什么上述“填空”式的方法不叫排序呢？</p>
<p>很简单，如果我们让小伙伴随便从目前的 1-10 里抽掉几张牌，那个时候我们既不知道余下的牌数是多少，也不知道其中到底少了哪些张，我们还能用这个方法将剩下的牌按序排列吗？</p>
<p>如果还是强行流出 10 个“空位”出来，然后再把牌填进去，最后就算被排出来的牌有序，但中间却难免有空着的空间。</p>
<p><img src="https://images.gitbook.cn/781c48c0-a496-11e9-a080-df9e620cefb4" alt="enter image description here" /></p>
<p>如果这些“空位”只是桌上的空间还好，可是当我们运用算法的时候，数据都是要用数据结构来装载的，这些空间可能就变成了数组中的单元，如此也太浪费空间了。</p>
<p>不仅如此，当我们平时排序的时候，既不知道所有数据的取值范围，也不知道其中是否有重复数据，如何才能预留空位呢？</p>
<p>因此，这种“留好了空往里填”的方法，并非排序。</p>
<h4 id="-1">排序要解决的问题</h4>
<p>排序的定义很简单，就是将一组无序的元素序列调整为有序的过程。但作为一种计算机算法，排序有很多隐含的限制条件。</p>
<p>一般而言，对于那组无序的元素，算法能够识别其中每个元素的值，也能对不同的元素进行比较，但是却既不知道所有这些值的起止，也不知道其中有否缺失和重复的值。</p>
<p>而作为称得上是“算法”的方法，必然要：</p>
<pre><code>1）能够保证的出正确结果；
2）过程中不接受异常；
3）要尽量节约空间和时间。
</code></pre>
<p>在这种条件限制之下，很多想当然的想法（例如上面说的“填空法”）就完全不能成立了。</p>
<p>在学习具体排序算法的时候，希望大家能常常回顾排序的隐含限制，并与所学习的排序算法相比对。</p>
<h3 id="-2">基于直觉的排序算法</h3>
<p>如果一个人拿到了一串数字，TA在没有学习过任何排序算法的时候，会怎么排序呢？</p>
<h4 id="-3">一个人类学实验</h4>
<p>关于这个问题，作者曾经做过一个人类学小实验——</p>
<blockquote>
  <p><strong>实验对象</strong>是一个年方三岁半，刚刚能认识 10 以内的阿拉伯数字的小朋友。</p>
  <p><strong>实验过程</strong>如下：</p>
  <p>step-1：作者找了一副扑克牌，从其中选出黑桃 2、3、5、6、7、9、10。</p>
  <p>step-2：将这 7 张牌散乱地仍在桌上，告诉小朋友：把这些牌从小到大排列好。</p>
  <p>step-3：作者就退到一旁，在那里观察小朋友的举动。结果发现：实验对象逡巡了一圈，拿起了黑桃 2；之后嘀嘀咕咕不知念叨着什么，又扒拉了一圈牌，拿起了黑桃 3；之后是 5，6……</p>
  <p><strong>实验发现</strong>：实验对象小朋友所采用的方法是每次找到现在还没有排序的所有牌中最小的那张——这不就是简单排序算法中的选择排序嘛！难怪叫简单排序啊，果然简单得幼儿都会！</p>
</blockquote>
<h4 id="-4">每次选出当前最小值</h4>
<p>当然，这个实验只在仅有一个实验对象的情况下进行了一次，对于人类学的研究没有什么支持作用。但它对排序还是有点启发性的。</p>
<p>假设给你一串不知底细的整数，要把它们排成升序，好像最简单的，确实是每次找到剩下的数字中最小的那个，然后一个个排列起来。</p>
<p>这种方法非常直观，操作起来也很简单。在我们的排序算法中，它叫做<strong>选择排序</strong>。</p>
<h3 id="selectionsort">选择排序（Selection Sort）</h3>
<p>排序算法有些还是颇为复杂的，不过也有一些简单直观的，对于后者，我们统称为<strong>简单排序算法</strong>，选择排序就是其一种。</p>
<h4 id="-5">算法原理</h4>
<p>选择排序的<strong>原理</strong>非常之简单：它是一个迭代算法，每次迭代从待排序的数据元素中选择最小的那个元素，排到升序序列的最后；如此循环，直到所有元素排完为止。</p>
<p>下图就是一个具体的例子：</p>
<p><img src="https://images.gitbook.cn/9475ab60-a496-11e9-8efd-09cc8f7db509" alt="enter image description here" /></p>
<p>原理简单若此，一说就明白了。那么下一步，就是该怎么实现的问题了。</p>
<h4 id="-6">数据结构</h4>
<p>在此我们采用整数作为排序对象。</p>
<p>首先考虑：<strong>采用哪种数据结构</strong>来承载最初无序的一串整数，以及最后排好序后的一串整数。</p>
<p>既然还是“一串”元素，数据结构是现成的，还是用逻辑上的数组，Python 语言中的列表（List）来实现。</p>
<p>这里还有一个小问题：下面两个解决方案选择哪一个：</p>
<p>1） 用两个列表分别承载开始无序的和后来有序的两个“串”；</p>
<p>2） 总共就用一个列表承载所有数据，排序过程就在这个列表中进行。</p>
<p>用两个肯定更占地方，所以我们还是尝试用一个吧。</p>
<p>OK，至此我们确定了要用列表来存储待排序的若干整数；而且排序结束后，仍然用同一个列表装载排好序的数字。</p>
<h4 id="-7">算法步骤</h4>
<p>因为算法是一个迭代过程，我们就来看看每次迭代中的具体步骤——</p>
<p>假设，现在是第 $k$ 次迭代（$k\geqslant1$），也就是说，之前已经进行了 $k-1$ 次迭代，那么整个列表里最小的 $k-1$ 个数字应该都已经顺序排到了本列表的前 $k-1$ 个位置上。</p>
<p>于是，本次迭代的任务就是：</p>
<ol>
<li><p>从列表的第 $k$ 个位置到最后的所有元素中，找出最小的一个——找到当前最小待排数；</p></li>
<li><p>把它放到第 $k$ 个位置上去——原本在第 $k$ 个位置上的数字怎么办呢？直接把它换到原本属于当前最小待排数的位置上去！</p></li>
</ol>
<p>下图就是一个例子：本轮迭代 $k=4$，那么我们就从列表中第 4 个位置开始到最后所有的数字中选出最小的那个——位于第 6 个位置的数字，然后将它和第 4 个位置的数字交换：</p>
<p><img src="https://images.gitbook.cn/a2d812b0-a496-11e9-a080-df9e620cefb4" alt="enter image description here" /></p>
<p>如此，本轮迭代后，就已经总共进行了 $k=4$ 次迭代，整个列表中最小的 4 个数字分别排列在了第1到第4的位置上。</p>
<h4 id="-8">编程实现</h4>
<p>步骤都已经这么清晰了，我们直接就来写代码吧！</p>
<pre><code>def selectionSort(arr):
    # startPosition 表示本次迭代的起始位置下标，与前述步骤中的k相对应：startPosition == k - 1
    for startPosition in range(0, len(arr)): 
        minPosition = startPosition # minPosition用来记录本次迭代中最小数值所在位置下标
        # 和其后所有位置上的数字比较，如果有哪个位置上的数字更小，则用该位置替代当前的minPosition
        for i in range(startPosition+1, len(arr)): 
            if (arr[i] &lt; arr[minPosition]):
                minPosition = i
        swap(arr, startPosition, minPosition) #经过一轮比较，当前的minPosition已经是当前待排序数字中的最小值，将它和本次迭代第一个位置上的数字交换
    return
</code></pre>
<p>这个算法是不是一目了然啊！</p>
<blockquote>
  <p><strong>NOTE</strong>：和前面讲过的 swap() 函数类似，selectionSort() 函数没有返回值，因为它唯一的参数——列表类型的 arr 是传对象引用的。</p>
</blockquote>
<p>对 selectionSort() 的调用是这样的：</p>
<pre><code>arr = [3,2,1,5,8,7,9,10,13]
selectionSort(arr)
print(arr)
</code></pre>
<p>运行后的输出为：</p>
<blockquote>
  <p>[1, 2, 3, 5, 7, 8, 9, 10, 13]</p>
</blockquote></div></article>