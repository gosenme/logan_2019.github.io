{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/img/辛普森公式法.png","path":"img/辛普森公式法.png","modified":0,"renderable":0},{"_id":"source/img/梯型公式法.png","path":"img/梯型公式法.png","modified":0,"renderable":0},{"_id":"source/img/变长梯型公式法.png","path":"img/变长梯型公式法.png","modified":0,"renderable":0},{"_id":"themes/landscape/source/images/favicon-192x192.png","path":"images/favicon-192x192.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/images/apple-touch-icon.png","path":"images/apple-touch-icon.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/rtl.styl","path":"css/rtl.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Black.woff2","path":"lib/vazir-font/Vazir-Black.woff2","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Black.woff","path":"lib/vazir-font/Vazir-Black.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Bold.woff2","path":"lib/vazir-font/Vazir-Bold.woff2","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Bold.woff","path":"lib/vazir-font/Vazir-Bold.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Light.woff","path":"lib/vazir-font/Vazir-Light.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Light.woff2","path":"lib/vazir-font/Vazir-Light.woff2","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Medium.woff","path":"lib/vazir-font/Vazir-Medium.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Medium.woff2","path":"lib/vazir-font/Vazir-Medium.woff2","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Thin.woff","path":"lib/vazir-font/Vazir-Thin.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Thin.woff2","path":"lib/vazir-font/Vazir-Thin.woff2","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/font-face.css","path":"lib/vazir-font/font-face.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir.woff","path":"lib/vazir-font/Vazir.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir.woff2","path":"lib/vazir-font/Vazir.woff2","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/jquery/jquery.min.js","path":"lib/jquery/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Black.ttf","path":"lib/vazir-font/Vazir-Black.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Black.eot","path":"lib/vazir-font/Vazir-Black.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Bold.eot","path":"lib/vazir-font/Vazir-Bold.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Bold.ttf","path":"lib/vazir-font/Vazir-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Light.eot","path":"lib/vazir-font/Vazir-Light.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Light.ttf","path":"lib/vazir-font/Vazir-Light.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Medium.eot","path":"lib/vazir-font/Vazir-Medium.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Medium.ttf","path":"lib/vazir-font/Vazir-Medium.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Thin.eot","path":"lib/vazir-font/Vazir-Thin.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Thin.ttf","path":"lib/vazir-font/Vazir-Thin.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir.eot","path":"lib/vazir-font/Vazir.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir.ttf","path":"lib/vazir-font/Vazir.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/images/logo.png","path":"images/logo.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-regular-400.woff","path":"lib/font-awesome/webfonts/fa-regular-400.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-regular-400.eot","path":"lib/font-awesome/webfonts/fa-regular-400.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-regular-400.ttf","path":"lib/font-awesome/webfonts/fa-regular-400.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/justified-gallery/css/justifiedGallery.min.css","path":"lib/justified-gallery/css/justifiedGallery.min.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/justified-gallery/js/jquery.justifiedGallery.min.js","path":"lib/justified-gallery/js/jquery.justifiedGallery.min.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-brands-400.woff","path":"lib/font-awesome/webfonts/fa-brands-400.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-brands-400.ttf","path":"lib/font-awesome/webfonts/fa-brands-400.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-solid-900.woff","path":"lib/font-awesome/webfonts/fa-solid-900.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-brands-400.eot","path":"lib/font-awesome/webfonts/fa-brands-400.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-regular-400.svg","path":"lib/font-awesome/webfonts/fa-regular-400.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-solid-900.eot","path":"lib/font-awesome/webfonts/fa-solid-900.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGM-BoldItalic.ttf","path":"lib/meslo-LG/MesloLGM-BoldItalic.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGS-Italic.ttf","path":"lib/meslo-LG/MesloLGS-Italic.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGS-BoldItalic.ttf","path":"lib/meslo-LG/MesloLGS-BoldItalic.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGL-BoldItalic.ttf","path":"lib/meslo-LG/MesloLGL-BoldItalic.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGM-Italic.ttf","path":"lib/meslo-LG/MesloLGM-Italic.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGL-Italic.ttf","path":"lib/meslo-LG/MesloLGL-Italic.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGM-Bold.ttf","path":"lib/meslo-LG/MesloLGM-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-solid-900.ttf","path":"lib/font-awesome/webfonts/fa-solid-900.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGS-Bold.ttf","path":"lib/meslo-LG/MesloLGS-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGL-Bold.ttf","path":"lib/meslo-LG/MesloLGL-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGM-Regular.ttf","path":"lib/meslo-LG/MesloLGM-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGL-Regular.ttf","path":"lib/meslo-LG/MesloLGL-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGS-Regular.ttf","path":"lib/meslo-LG/MesloLGS-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-brands-400.svg","path":"lib/font-awesome/webfonts/fa-brands-400.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-solid-900.svg","path":"lib/font-awesome/webfonts/fa-solid-900.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/landscape/.gitignore","hash":"c5345a2c5fa6c136dbe2020a405e541b4755a259","modified":1554081277000},{"_id":"themes/landscape/.stylintrc","hash":"eb5f48e83657928cb0cbee031373b2cd36ca0083","modified":1554081277000},{"_id":"themes/landscape/.jshintrc","hash":"2548bd6ce44422edc7e6f9f68061ab47f26c4f57","modified":1554081277000},{"_id":"themes/landscape/LICENSE","hash":"346ece39a983b0e7858c11f785cd846cef9eb875","modified":1554081277000},{"_id":"themes/landscape/_config.yml","hash":"c986259b700208a4205f739fd89e74e7b6777c8e","modified":1554126582204},{"_id":"themes/landscape/README.md","hash":"859d11941c46be4f7b4a6d62297ccbeb4f732bc9","modified":1554081277000},{"_id":"themes/landscape/package.json","hash":"5bbdbc429e9d46acf97baf7ac5654edde0781064","modified":1554081277000},{"_id":"themes/landscape/gulpfile.js","hash":"2bae290993507026a509665ee5a5326b616f8d68","modified":1554081277000},{"_id":"source/_posts/动态规划05.md","hash":"64cc4da343731a4e7857a6d2f4e9e5b40e73168a","modified":1555311720837},{"_id":"source/_posts/动态规划法01.md","hash":"47c3340e73c21c2bdc60ed848e8880aad379d09e","modified":1554992096057},{"_id":"source/_posts/28天训练营课程表.md","hash":"572ce8a78986c23466692dc0e4c849d6e3062d52","modified":1554112789319},{"_id":"source/_posts/hello-world.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1554081324453},{"_id":"source/_posts/unpacking_tuple_of_lists.md","hash":"b9889c4867550424875abc30fe2f3fff04217b52","modified":1558764226792},{"_id":"source/_posts/基础卡01-贪婪法.md","hash":"d04f26d2b691ebb7617bb9e029cfc98b313aae9d","modified":1554266810040},{"_id":"source/_posts/基础卡02-分治法.md","hash":"8d6b0e8d65b5c9d3d1a7f50440f281a8b34e7254","modified":1554127979024},{"_id":"source/_posts/基础卡03-动态规划.md","hash":"8885bee18843096d6a789545349e7c0c67e8adf6","modified":1554275857311},{"_id":"source/_posts/基础卡04-穷举法.md","hash":"c324918126bd59517f1f79b5b729b484b293438e","modified":1554272156591},{"_id":"source/_posts/基础卡05-迭代法.md","hash":"94a14272caff73ed343b382fae33dc44546a1c53","modified":1554459120665},{"_id":"source/_posts/游戏算法卡01-A*算法.md","hash":"4bc0ce2a8556f871ec1d5d720c30174dd2f4d1f8","modified":1555649341314},{"_id":"source/_posts/基础卡06-基础开胃菜.md","hash":"b4939934aa6fd31a7e53590c73700c434912672c","modified":1554391424593},{"_id":"source/_posts/挂载硬盘的一些命令.md","hash":"be9f1701caf7f20056adcd73180c906038ec17d1","modified":1554356588786},{"_id":"source/_posts/热身卡01-开篇词：算法是程序的灵魂.md","hash":"eb4e6e6f6fca03f106bc16b57e0f7b153dc3bc98","modified":1554112789338},{"_id":"source/_posts/热身卡02-入门测试题.md","hash":"cccf8a298396f91a4ff4c58facf7c5195dcd53cd","modified":1554112789330},{"_id":"source/_posts/热身卡03-如何\"玩\"算法.md","hash":"55e7657d06c17567ebe1fdf35e3dfd8400f79086","modified":1554112789335},{"_id":"source/_posts/穷举搜索卡01.md","hash":"210233ac9951cf2d15d9fa0d3ad66bfef2561aa7","modified":1554555081328},{"_id":"source/_posts/开营仪式.md","hash":"baddb420d6ebbc321702b61b1e706d5c10c3a0a4","modified":1554127140284},{"_id":"source/_posts/穷举搜索卡03.md","hash":"69eb1be397251d14ae262d70d1fcf0014b6e18a1","modified":1554642815552},{"_id":"source/_posts/穷举搜索卡04.md","hash":"850e020f8e574f41bdc15816a230cbdb10e30385","modified":1554643509670},{"_id":"source/_posts/穷举搜索卡02.md","hash":"0a1b49996b5e505f56f74c621fcaa77f51c65853","modified":1554559752518},{"_id":"source/_posts/穷举搜索法05.md","hash":"d66e42b8e15e3556a94f510bf8a33c1a0cb866ac","modified":1554732494224},{"_id":"source/_posts/穷举搜索法06.md","hash":"3a8cf3c3a187e42df9d56ddf515c216ff498f2da","modified":1554741949390},{"_id":"source/_posts/穷举搜索法08.md","hash":"6e83a52d06624cf3af3d7c5f84e12b8d55a0839e","modified":1554822330183},{"_id":"source/_posts/穷举搜索法07.md","hash":"61fd2649d3effee2b78c61f7b26cb98747c7dfbc","modified":1554818058913},{"_id":"source/_posts/穷举搜索法09.md","hash":"114d3fd1a7dfecbf60f0e3decc42ff6eea642372","modified":1554902773369},{"_id":"source/_posts/穷举搜索法10.md","hash":"0fe0fe2bd186f9517f900ab703fb4fffa187c268","modified":1554902881068},{"_id":"source/_posts/迭代递推卡01.md","hash":"5fcdca9bb8f3be94ac352d674e87ea7aa875c94d","modified":1554465356750},{"_id":"source/_posts/迭代递推卡03.md","hash":"3f679fb0f6eb8b168c05a2165475143f0cf5fab1","modified":1554468014491},{"_id":"source/_posts/迭代递推卡02.md","hash":"815aa79d1a71591e6a8b3dce828af13b4f761f91","modified":1554466176409},{"_id":"themes/landscape/languages/ca.yml","hash":"b79dd2c21dc6697c635e92db1f661a4b8d5d2305","modified":1554081277000},{"_id":"source/img/辛普森公式法.png","hash":"bdfdc4ec6767f6b6f69d6fe321dfdf2a44319c84","modified":1554467817506},{"_id":"themes/landscape/languages/default.yml","hash":"ca5582329d9721d58fe8504725108769080e9993","modified":1554081277000},{"_id":"themes/landscape/languages/en.yml","hash":"ea91a271db1a49386f97955ed72b2a668e2aea5e","modified":1554081277000},{"_id":"themes/landscape/languages/default_old.yml","hash":"ea91a271db1a49386f97955ed72b2a668e2aea5e","modified":1554081277000},{"_id":"themes/landscape/languages/es.yml","hash":"2b1fc8b0d636123e9ee39017fa20053bd1913a5a","modified":1554081277000},{"_id":"themes/landscape/languages/fr.yml","hash":"4fea266d3c522903f3eee4fffee6e66c44775005","modified":1554081277000},{"_id":"themes/landscape/languages/it.yml","hash":"62800bcae1f2d2454f87f4bcf4d7593848424f61","modified":1554081277000},{"_id":"themes/landscape/languages/fa.yml","hash":"63f32e50953af1c4bd0308a4fca5862b5287c2cb","modified":1554081277000},{"_id":"themes/landscape/languages/ru.yml","hash":"81b57fcd1977ef534f4bf303dbc1b4710cc7f057","modified":1554081277000},{"_id":"themes/landscape/languages/nl.yml","hash":"ac0573352ad2c737a7686bcca498b985e7bd6447","modified":1554081277000},{"_id":"themes/landscape/languages/pt-br.yml","hash":"4859aba788a050c2d5d0b997693b0c8c24b349f7","modified":1554081277000},{"_id":"themes/landscape/languages/pl.yml","hash":"8a2d6dc874d86c38d42c2c861c39590647b5d536","modified":1554081277000},{"_id":"themes/landscape/layout/archive.ejs","hash":"53de8817e37be01b3ba8fa5ca31b9cafa2f3c011","modified":1554081277000},{"_id":"themes/landscape/languages/tr.yml","hash":"2702914007e6bade9d6861078c0e179ac05bf48c","modified":1554081277000},{"_id":"themes/landscape/languages/vi.yml","hash":"f84893c3ec3e45875c90069e14b17ed3016ed973","modified":1554081277000},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"2f4e050c9b35a67f4a7278cec3a949533c2ac16a","modified":1554081277000},{"_id":"themes/landscape/layout/index.ejs","hash":"c53484094a7c30ab82b0ea984404157ab9711e71","modified":1554081277000},{"_id":"themes/landscape/layout/page.ejs","hash":"c5465d5315a7544aa466b01fd8cfb62917a8bb1d","modified":1554081277000},{"_id":"themes/landscape/layout/layout.ejs","hash":"8504004f2ed78914f806c6699d9bd722318cbe56","modified":1554081277000},{"_id":"themes/landscape/scripts/meta.js","hash":"fa6055a39851c9953d033e70c1614547b94dce60","modified":1554081277000},{"_id":"themes/landscape/scripts/page_title.js","hash":"fa662dbdb82779af1b95e35ed7ccdf4866a53dee","modified":1554081277000},{"_id":"themes/landscape/scripts/thumbnail.js","hash":"df8829fd8c3119650037eba5ec11bdce06acff9d","modified":1554081277000},{"_id":"themes/landscape/scripts/merge-configs.js","hash":"2048c3415d96b17b9d84aa44bc0c25f1210525f8","modified":1554081277000},{"_id":"themes/landscape/layout/post.ejs","hash":"a7d164ce888a60cd3eddd9c04bc6762428fa66bb","modified":1554081277000},{"_id":"source/img/梯型公式法.png","hash":"8342a1d9226a276e3d033e1490fce6ddc16e5887","modified":1554467201498},{"_id":"source/img/变长梯型公式法.png","hash":"74d6534f051befad7fd9849099a9993ab6a4e5b2","modified":1554467657180},{"_id":"themes/landscape/layout/_partial/comments.ejs","hash":"4cf8d0059e5f8bc8ae1dd1a426293583fd398052","modified":1554081277000},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"c3a80e347cb11022baf5e65fb4d0209b8d205693","modified":1554081277000},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"753dcb513c6f21f6f46e673942c7261cf50da886","modified":1554081277000},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"9b2b7d6e9ab514107adf408c7ec8530fd612b3d5","modified":1554081277000},{"_id":"themes/landscape/layout/_partial/pagination.ejs","hash":"23bf862b3b8a3cd831850504d9b5a24d21b005e7","modified":1554081277000},{"_id":"themes/landscape/layout/_partial/scripts.ejs","hash":"78e3e290ab8bb6450a04b2a9c7c5b7b3da74abb8","modified":1554081277000},{"_id":"themes/landscape/layout/_partial/search.ejs","hash":"8b4bf9cf5db0ce762a31fc3baae0f2fc004bece4","modified":1554081277000},{"_id":"themes/landscape/layout/_partial/styles.ejs","hash":"be1b54388eb02176dd4722285dda19e3dce2e62e","modified":1554081277000},{"_id":"themes/landscape/source/images/favicon-192x192.png","hash":"96e6fcbbb13a5914a6131391e210eb7dfd13d692","modified":1554081277000},{"_id":"themes/landscape/source/images/apple-touch-icon.png","hash":"57e2def34682655f41a0be2d083f16765ba7858b","modified":1554081277000},{"_id":"themes/landscape/source/css/_fonts.styl","hash":"354809b5a64e8a47a66c66fd1a28ac597c1460a6","modified":1554081277000},{"_id":"themes/landscape/source/images/favicon.ico","hash":"189f9842bcb79a6f8f9e8445bc8bbd773443826b","modified":1554081277000},{"_id":"themes/landscape/source/css/_extend.styl","hash":"2c8751d132e62f5f068dc3a184d160670737ba1f","modified":1554081277000},{"_id":"themes/landscape/source/css/_mixins.styl","hash":"1a9e309523df9685e8d088dcff0a809c58e2c392","modified":1554081277000},{"_id":"themes/landscape/source/css/_util.styl","hash":"2bfeb2e2605dd5235693b00c71a212646d2e0410","modified":1554081277000},{"_id":"themes/landscape/source/css/style.styl","hash":"d9be82f7e7145cde78e04183afc8ff13d6a16059","modified":1554081277000},{"_id":"themes/landscape/source/css/rtl.styl","hash":"98355abe9ef3a398a5b4cb40d3d33bf86ac8d1d4","modified":1554081277000},{"_id":"themes/landscape/source/css/_variables.styl","hash":"02079fb71b7d1c01d15fa512a1948ad4cbb416b5","modified":1554081277000},{"_id":"themes/landscape/source/js/main.js","hash":"584c5a69ac81a483a1c4377a2e2cf326c2795e7b","modified":1554081277000},{"_id":"themes/landscape/source/js/search.js","hash":"a74d0c601f820160825a2e4ad13618074d714933","modified":1554081277000},{"_id":"themes/landscape/layout/_partial/post/actions_desktop.ejs","hash":"38aadd1ed890303dde582b722486138afee09b0a","modified":1554081277000},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6f2d1aa9562df343b797d25705f1945323c465fb","modified":1554081277000},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"b5bfa049f17868fb09d9d2a7e1d5279fa0381d37","modified":1554081277000},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"e08fae30da060f49c087f6c121868b08eb55c795","modified":1554081277000},{"_id":"themes/landscape/layout/_partial/post/actions_mobile.ejs","hash":"79b234ff3c264e66b2e71c819228e62bf92b48e4","modified":1554081277000},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"9aecd8908e8a684f33dc20c02497c0f1774137c7","modified":1554081277000},{"_id":"themes/landscape/layout/_partial/post/share.ejs","hash":"847a400e79b775246ca9067e40c3f104d571413d","modified":1554081277000},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"a060f1c6e3718494a6b1d0e1981ea0bf4e549828","modified":1554081277000},{"_id":"themes/landscape/source/css/_colors/classic.styl","hash":"0f0ec41a4165814ce69688425d5ac4d701b7cc70","modified":1554081277000},{"_id":"themes/landscape/source/css/_colors/light.styl","hash":"d09f781cb02394850737b3a9efc6693307d5bf09","modified":1554081277000},{"_id":"themes/landscape/source/css/_colors/white.styl","hash":"2b25ad24573bded8b42f9d80112eab9fadbed1a5","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/agate.styl","hash":"53027913ed8d4f75ac3e49e76aad824f0df62da3","modified":1554081277000},{"_id":"themes/landscape/source/css/_colors/dark.styl","hash":"9c9655b42b85f754b8a573a1d4634c23c680e1bf","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/arta.styl","hash":"b3e81e3e694ceb8deed178adb8b91013c5120e30","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/arduino-light.styl","hash":"15e8572585cd708221c513dea4bdd89d8fe56c10","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/androidstudio.styl","hash":"2af0861725f97f0ee2ded67c3d2d4548c62b2d16","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-cave-dark.styl","hash":"ce63dd8548688d88254405eedfa75b1d7c82449e","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/ascetic.styl","hash":"32cff3bef6fac3760fe78f203096477052a90552","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-cave-light.styl","hash":"a5be0744a7ecf4a08f600ade4cfd555afc67bc15","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-dune-light.styl","hash":"931435fbc6f974e8ce9e32722680035d248a9dc1","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-estuary-dark.styl","hash":"0bb16a4eff93688f40787abc2f9e56e7d5cc93e7","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-dune-dark.styl","hash":"c196ff0ee064af0e507823694ae39020addfc280","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-forest-light.styl","hash":"95228d9f2102fad425536aac44b80b2cba1f5950","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-estuary-light.styl","hash":"344276ca9b27e51d4c907f76afe5d13cf8e60bdf","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-heath-dark.styl","hash":"9a2e9a1d0a01bbdf158560c3ed1c134e098b2c68","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-forest-dark.styl","hash":"effbc5d75fa87203c847039869c22031b40d5b7d","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-lakeside-light.styl","hash":"2c54cb9bdb259ae3b5b29f63ac2469ed34b08578","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-plateau-dark.styl","hash":"84c80e6f67f62fce958d25817c277d2360272617","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-lakeside-dark.styl","hash":"10ee3882fca7b97a37bd309d2d35fce9868647bb","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-savanna-dark.styl","hash":"e32c1c70def8060fce5e790979a126da650ac642","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-heath-light.styl","hash":"8c8c2e445abef85273be966d59770e9ced6aac21","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-plateau-light.styl","hash":"d1a05fdd1ededc9063d181ab25bad55a164aeb4a","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-savanna-light.styl","hash":"f8244c93711c7cb59dd79d2df966806b30d171ea","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-seaside-dark.styl","hash":"2edf385215bbe1985b1a10106525d362667d28c2","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-seaside-light.styl","hash":"0597342da6e2d0c5bdcc7d42dabb07322b1a4177","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-sulphurpool-dark.styl","hash":"538a14321193cd8abf2ddc484306631e54149ffb","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-sulphurpool-light.styl","hash":"efa52713efc468abeeb2b9299704371583b857de","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/brown-paper.styl","hash":"c2326ba20a5020a66ca7895258d18833327d4334","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/codepen-embed.styl","hash":"8b7b34484f76a6c2c3b1a9e49abb9b382f439ae8","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/dark.styl","hash":"f5e6e75958de59e87fc6be3a1668e870e20bc836","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/color-brewer.styl","hash":"2a439d6214430e2f45dd4939b4dfe1fe1a20aa0f","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/darkula.styl","hash":"9717efa9194837ba3fb4d762997d33075dcf8bfa","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/far.styl","hash":"aaac3028f5e33123cd123a583cddc9290c45ec8e","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/docco.styl","hash":"b1c176378bb275f2e8caa759f36294e42d614bf1","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/github-gist.styl","hash":"48211a03d33e7f7ada0b261162bea06676155a71","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/github.styl","hash":"3336aeba324c6d34a6fd41fef9b47bc598f7064c","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/foundation.styl","hash":"bf8ddc94b4ad995b8b8805b5a4cf95004553fdac","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/grayscale.styl","hash":"bf37d8b8d1e602126c51526f0cc28807440228ed","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/googlecode.styl","hash":"bda816beee7b439814b514e6869dc678822be1bc","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/hopscotch.styl","hash":"1378a6bc67a32c0cbff72ab771268b53f9aa586d","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/highlightjs.styl","hash":"0e198b7a59191c7a39b641a4ddd22c948edb9358","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/index.styl","hash":"002d5596f6379cc87dbd43d9145bc764aa666be1","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/hybrid.styl","hash":"b8eb5c69d12f2ee5ebc50265ae271699d7f1a8d3","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/idea.styl","hash":"a02967cb51c16a34e0ee895d33ded2b823d35b21","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/gruvbox-dark.styl","hash":"76b744c14fd5600bea64731c05df97c2df75523f","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/kimbie.dark.styl","hash":"45dbb168f22d739d0109745d2decd66b5f94e786","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/ir-black.styl","hash":"53e5d74326a4527b92272bbd6946d4fec92720e8","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/kimbie.light.styl","hash":"61f8baed25be05288c8604d5070afbcd9f183f49","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/kimbie.styl","hash":"51b889ca7c6fe178cfbbe28d875a6ea427184441","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/magula.styl","hash":"16d323f989b1420a0f72ef989242ece9bf17a456","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/mono-blue.styl","hash":"4c89a6ae29de67c0700585af82a60607e85df928","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/monokai.styl","hash":"f87be027848ea6bee623a08ad1e17b2f5b7937ee","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/obsidian.styl","hash":"199e28326be8590883f0813ebbd54fcfaa4750fd","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/paraiso-light.styl","hash":"d224d1df0eb3395d9eea1344cee945c228af2911","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/paraiso.styl","hash":"75f181eece6b71d033ea0c8d6cf00ae7efb9e29b","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/paraiso-dark.styl","hash":"f1537bd868579fa018ecdbfd2eb922dcf3ba2cac","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/monokai-sublime.styl","hash":"c385b11345894be7e6ce3c5f08663e199933b8e4","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/rainbow.styl","hash":"c0cf97aae3e10fdcd10414547a711c9effbc39b8","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/pojoaque.styl","hash":"4e7b6b046b8575ac749f6aec4e953a62ada27a36","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/pojoaque.jpg","hash":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/solarized-dark.styl","hash":"90c9da5aa594383697e5b18892a7f95beb053f55","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/school-book.styl","hash":"d43560fe519a931ce6da7d57416d7aa148441b83","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/railscasts.styl","hash":"b6674db9210e0c4444e4835fff2d1361f3ebd64c","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/sunburst.styl","hash":"af3eec0fd56151e55bbd49c31b151f36717611d8","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/solarized-light.styl","hash":"aa0dd3fd25c464183b59c5575c9bee8756b397f2","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/tomorrow-night-bright.styl","hash":"7674fecb6d27350727dc0d2dc93bc018382ebbd0","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/tomorrow-night-eighties.styl","hash":"28d751075ebabf7d0327a36f725076fe82fdf626","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/tomorrow-night.styl","hash":"16ba09b2db501e4e3e2e7d62595d9bf935bf27c4","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/zenburn.styl","hash":"68ff9332ccc03f9389b15b713415cde016f8088f","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/tomorrow.styl","hash":"15779cf6846725c7c35fc56cac39047d7e0aec1c","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/tomorrow-night-blue.styl","hash":"f24c17d0ab815dcfaab3438cb9fe2ab4839f5e0d","modified":1554081277000},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"ef8fc52337c4c7b010cad7c427cb78009b30f9d8","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/vs.styl","hash":"959a746f4b37aacb5d1d6ff1d57e0c045289d75d","modified":1554081277000},{"_id":"themes/landscape/source/css/_partial/comments.styl","hash":"1e90f1fb9d4c155df518cacb5a537e9de9c042c1","modified":1554081277000},{"_id":"themes/landscape/source/css/_partial/categories.styl","hash":"a43f00e61b3507f130b8a3f8108a4eeca147c2a0","modified":1554081277000},{"_id":"themes/landscape/source/css/_partial/index.styl","hash":"59c99f4ea3a73bf47ce030df166c5e33d5de31fb","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/xcode.styl","hash":"5e8532ae8366dcf6a4ef5e4813dc3d42ab3d0a50","modified":1554081277000},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"d9b13e402808175dc90761cc4fdfe3d4808034f8","modified":1554081277000},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"7ff5b6a28dc3f2cd4ebfc4f5351054a18800bf96","modified":1554081277000},{"_id":"themes/landscape/source/css/_partial/pagination.styl","hash":"950bf517bbe7adb9a9aa4eb5ddec74ffc7598787","modified":1554081277000},{"_id":"themes/landscape/source/css/_partial/search.styl","hash":"159be002780c62a77f46947cf854a7342fba24f4","modified":1554081277000},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"662667942cc9a2caf55caa84a0fc73617d0c3aa4","modified":1554081277000},{"_id":"themes/landscape/source/css/_partial/tags.styl","hash":"d571d5c7c960300d29c5f0ec3fe1140322ecd6b3","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Black.woff2","hash":"0a257c8b60e0f20802c1dc8daeed2d3cb0d44f17","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Black.woff","hash":"37443d0040f0d7af381c955e4c15919a15d0349e","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Bold.woff2","hash":"62447a951d48b21c4696ae72df4bc4adef636e26","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Bold.woff","hash":"df15fd1e74b6f4a50bea57e2b44d9627f38495b5","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Light.woff","hash":"32ae5c0d1d5943c8bb8e0f6ab07c3269c6f8b8a8","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Light.woff2","hash":"ef07a250766fea840c1049e67c0405d9216ee0a8","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Medium.woff","hash":"f5653059b2a5929516e4aab02329a978600b9b67","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Medium.woff2","hash":"668400ae92700965f03f2371faaee0ab8c8347c3","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Thin.woff","hash":"ad4d46a99a1daf6353c86c79ac3a2b030213859c","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Thin.woff2","hash":"c3be79b553ec394db71268d604b1d29183b867dc","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/font-face.css","hash":"8f2bf6b59ae1f2ed4c2fead6cea4b8314fcf62e5","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir.woff","hash":"bbee70033f0f5882e9869e417b69c6a38f56f187","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir.woff2","hash":"30ce165216db078951a690a6ad665b9b78f5dd81","modified":1554081277000},{"_id":"themes/landscape/source/lib/jquery/jquery.min.js","hash":"0dc32db4aa9c5f03f3b38c47d883dbd4fed13aae","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Black.ttf","hash":"594dc3344ad14903c247615427d1009709f0f5a4","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Black.eot","hash":"13d026ff857c853cbd0dc519b6e58669db309441","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Bold.eot","hash":"f76ec625e15522ff60d21f7a9a3b71c65bc27556","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Bold.ttf","hash":"2e6c9df9f775373fb1988ae8529aa8f05313dae6","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Light.eot","hash":"3edffd7bb61eee8cd46b57225f9f9e5264e3362b","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Light.ttf","hash":"9f1e2934098a6a4a7c5584c8f3fa24a707070da3","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Medium.eot","hash":"1f5a73db7947ef22c8a2bb19d6449b80496c03c4","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Medium.ttf","hash":"295f7e02c9b157e7ea63ad09613b00ceab85c5cd","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Thin.eot","hash":"08e1503d1181188690fd9c81860d6c890c1465f6","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Thin.ttf","hash":"a6aa450ee6e0f85786474ca6b04827ef97e81af4","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir.eot","hash":"31a9219c25fe1991fb745ec8dbbcf45c6094a702","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir.ttf","hash":"f22b219824026e490a581ddb3b36b07997dff0e3","modified":1554081277000},{"_id":"themes/landscape/source/images/logo.png","hash":"0e3029251dfda26adee2761f71377297e8c26871","modified":1554081277000},{"_id":"themes/landscape/source/css/_partial/post/actions_mobile.styl","hash":"0d2966c1d870392476864af8ee3ba312ba30cb82","modified":1554081277000},{"_id":"themes/landscape/source/css/_partial/post/actions_desktop.styl","hash":"4ef72ea70f7c840b2843bf7717aaafae3b6fc241","modified":1554081277000},{"_id":"themes/landscape/source/lib/font-awesome/css/all.min.css","hash":"cf1a3fd771900af34f2af22142beecfb47367548","modified":1554081277000},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-regular-400.woff","hash":"7b3f44b4d3028f3c87ddf0f4bd62511c9bf4a87e","modified":1554081277000},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-regular-400.eot","hash":"42ff503f20e97503cef8e5b2ec10ae07699d7c01","modified":1554081277000},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"9784edb76f8a2ed595ea4bf74d46cda4eff3b303","modified":1554081277000},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-regular-400.ttf","hash":"c140085833a38abec6b7df99d4ccac93eb266031","modified":1554081277000},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"92da6e3c7121e21cdfde25ef08797a3937a683e1","modified":1554081277000},{"_id":"themes/landscape/source/lib/justified-gallery/css/justifiedGallery.min.css","hash":"92bb6e468a1db7fbd99ccb960e15e28572254263","modified":1554081277000},{"_id":"themes/landscape/source/lib/justified-gallery/js/jquery.justifiedGallery.min.js","hash":"82ab395176c927ffbb2f7c95132ee0a06cd5d64a","modified":1554081277000},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"d902f8db3e021155f177f698a252fb98d6e61768","modified":1554081277000},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-brands-400.woff","hash":"f9d835a0f9248b1bb33d66968e87c4a50103ed8d","modified":1554081277000},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-brands-400.ttf","hash":"19e302760e39e25a5f8d90d6cd0164ef6cd74f8c","modified":1554081277000},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-solid-900.woff","hash":"80d33a73cbb60e206ef6f5c898988641576c7dda","modified":1554081277000},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-brands-400.eot","hash":"644ece8263d2f96b087eebf7f6d4e309e5898eb5","modified":1554081277000},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-regular-400.svg","hash":"33e86c0ad6fb9c5c0c8c2af4cb2d790c6b14a8aa","modified":1554081277000},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-solid-900.eot","hash":"10740942ec6b3f4985529d343402d0bf32f9f847","modified":1554081277000},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGM-BoldItalic.ttf","hash":"b542b9591fbf33925d93f0695b6e123a9f0cfd43","modified":1554081277000},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGS-Italic.ttf","hash":"9d757cc9f928fc83b2133283dd639c12b11d94ad","modified":1554081277000},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGS-BoldItalic.ttf","hash":"926035f0156cccf1b0ca507347f39bf9c510f51e","modified":1554081277000},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGL-BoldItalic.ttf","hash":"b7d24ab1e4fad720f31a2b0cca1904ce1740d846","modified":1554081277000},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGM-Italic.ttf","hash":"93ebc5098cf57a32b7b8d297681f31692c09bdfa","modified":1554081277000},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGL-Italic.ttf","hash":"9a23c6898b0943bd3d96c04df9a0f66e919451d8","modified":1554081277000},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGM-Bold.ttf","hash":"58be4b7760e9a84daa81929d046f9a15c4fd1c1a","modified":1554081277000},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-solid-900.ttf","hash":"c445864a9646948e0d7ff44930ad732ee61427d8","modified":1554081277000},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGS-Bold.ttf","hash":"f9918fb93d6ab6850f5d38069a999c311af78816","modified":1554081277000},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGL-Bold.ttf","hash":"34f7db59f1d023294e69976aa20b7d52b86165a4","modified":1554081277000},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGM-Regular.ttf","hash":"20ce1fc7ae1254558ca044ae48283faaa58897e5","modified":1554081277000},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGL-Regular.ttf","hash":"6c090d6bff3928fbf8a5f4104e58ed7f421aea7c","modified":1554081277000},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGS-Regular.ttf","hash":"de559f8d70d5b1ab2810597bfd0b1b9506f3ef01","modified":1554081277000},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-brands-400.svg","hash":"b0bb9e6ac7709206b9510f1718516d89aead5b21","modified":1554081277000},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-solid-900.svg","hash":"ed6c1ed8f24df909f40fe5e5c652d7ff9570c821","modified":1554081277000},{"_id":"public/2019/04/19/游戏算法卡01-A*算法/index.html","hash":"3842123c1ef474ef7ec0ed09fece87f99eb6468f","modified":1558765569143},{"_id":"public/2019/04/15/动态规划05/index.html","hash":"42f9cfa25244a5600c605be5bbc48ebc4e1a5144","modified":1558763174829},{"_id":"public/2019/04/11/动态规划法01/index.html","hash":"9d8efc415c7f97867c52d424457d18e829445417","modified":1558763174829},{"_id":"public/2019/04/10/穷举搜索法10/index.html","hash":"bb8515e229e67beae5ffc59af8f1507fec87b7e7","modified":1558763174829},{"_id":"public/2019/04/10/穷举搜索法09/index.html","hash":"165a83d79a3b3b5980421ae04631844bdadcf526","modified":1558763174830},{"_id":"public/2019/04/09/穷举搜索法08/index.html","hash":"8ae0ec71581d50855cc5575f2718e599741ab30d","modified":1558763174830},{"_id":"public/2019/04/09/穷举搜索法07/index.html","hash":"177e419cc2fea6b9c32b82624291b46f809b6d32","modified":1558763174830},{"_id":"public/2019/04/08/穷举搜索法05/index.html","hash":"d51db647a4ca71f7d1fdd354f25412b6b48c1fe2","modified":1558765569144},{"_id":"public/2019/04/08/unpacking_tuple_of_lists/index.html","hash":"5ce7772b1909be4acd492d0d50b5aed89fd51727","modified":1558763174830},{"_id":"public/2019/04/07/穷举搜索卡04/index.html","hash":"a70befa44aa4708b62ba04ae3300e807cc473fa1","modified":1558765569173},{"_id":"public/2019/04/07/穷举搜索卡03/index.html","hash":"469652429c98dcb22e47ac0aee732d45a8469423","modified":1558763174830},{"_id":"public/2019/04/06/穷举搜索卡01/index.html","hash":"c4d4694569b7637caa33250e0ac65fff55baf0d1","modified":1558763174830},{"_id":"public/2019/04/05/迭代递推卡03/index.html","hash":"bb7ccece278ae650b91d7415f0edde9c8f7d33ac","modified":1558763174830},{"_id":"public/2019/04/05/迭代递推卡02/index.html","hash":"ace1129b556c1d72dae003d9de104cd5d1ea25b6","modified":1558763174830},{"_id":"public/2019/04/05/迭代递推卡01/index.html","hash":"6417c13e73e703c6d0339e3a3f7880246e892b93","modified":1558763174830},{"_id":"public/2019/04/04/基础卡06-基础开胃菜/index.html","hash":"81e8bb4d1af9746e515bf860c20a817a0490091a","modified":1558763174830},{"_id":"public/2019/04/04/挂载硬盘的一些命令/index.html","hash":"1ab6145b32222997d39b20abe76826fff5903db7","modified":1558763174830},{"_id":"public/2019/04/01/开营仪式/index.html","hash":"60d661d6b649ee162a10cb197a2a6053002df4b1","modified":1558763174831},{"_id":"public/2019/04/01/热身卡01-开篇词：算法是程序的灵魂/index.html","hash":"5365cd2cb5cc87f5b44d1a96ff62b7687d89e88b","modified":1558763174831},{"_id":"public/2019/04/01/热身卡03-如何\"玩\"算法/index.html","hash":"14716c7babdf6b60d1d1d1a1b17fef4c2e3fed14","modified":1558763174831},{"_id":"public/2019/04/01/28天训练营课程表/index.html","hash":"c26eac356c83b417737471cf8e389dcd32b63add","modified":1558765569173},{"_id":"public/2019/04/01/hello-world/index.html","hash":"25163ac5467791b1fb6719a1915a8799db571c22","modified":1558763174831},{"_id":"public/archives/index.html","hash":"06754c71334423b1b87fd5e780fc7bea247f66c8","modified":1558765569174},{"_id":"public/archives/page/2/index.html","hash":"80484bf80c2a1b90115eada9590d9174c5a981a1","modified":1558765569174},{"_id":"public/archives/page/3/index.html","hash":"925cfed5a5c75a002cfd13e881240ba64d71acbf","modified":1558765569174},{"_id":"public/archives/2019/index.html","hash":"e50d756bdade4a564b3dff0d989c143e5b45441d","modified":1558765569174},{"_id":"public/archives/2019/page/2/index.html","hash":"e7464029e23085f82046681eda0f51eba9d4fcbb","modified":1558765569174},{"_id":"public/archives/2019/page/3/index.html","hash":"b582bebd806b41a270b88886012c4bde8a343fac","modified":1558765569174},{"_id":"public/archives/2019/04/index.html","hash":"a52fb559aa32a2fd65349252b97115d277d55c04","modified":1558765569174},{"_id":"public/archives/2019/04/page/2/index.html","hash":"82de45effc39c5131fc7edd41d8d7562e47a643d","modified":1558765569174},{"_id":"public/archives/2019/04/page/3/index.html","hash":"28ec64c5f8b861395f14ddc61e52bb20ffa7a1d4","modified":1558765569175},{"_id":"public/index.html","hash":"99f12f7066201ed136e70ed62b0909ae26404784","modified":1558765569175},{"_id":"public/page/2/index.html","hash":"ecbe07651f8628e55b95fd5b51a9029c0b431505","modified":1558765569175},{"_id":"public/page/3/index.html","hash":"e780e92a3f858d9046fb5f6b5a80b5c520d2531f","modified":1558765569175},{"_id":"public/2019/04/09/穷举搜索法06/index.html","hash":"6c1fc09ea611610eb7993c9aa4631cce6b5dbd18","modified":1558763174832},{"_id":"public/2019/04/06/穷举搜索卡02/index.html","hash":"944312374b373426266d0069cd0635bde8d7f91d","modified":1558763174832},{"_id":"public/2019/04/05/基础卡05-迭代法/index.html","hash":"d101ee37e5593f9c6be3bf78e74dddfd90d37a7c","modified":1558763174832},{"_id":"public/2019/04/03/基础卡03-动态规划/index.html","hash":"bcf02e32736e4923a42824f9d0d01621c62db1b5","modified":1558763174832},{"_id":"public/2019/04/03/基础卡04-穷举法/index.html","hash":"a8af4b3f01647d43216298674a8dde6820f47b45","modified":1558763174832},{"_id":"public/2019/04/03/基础卡01-贪婪法/index.html","hash":"8e0127d4be7e2cbfacca3bd194af9c7621e8541a","modified":1558763174832},{"_id":"public/2019/04/01/基础卡02-分治法/index.html","hash":"b8a458c45c4ee8cadff94079438e76254a1159f5","modified":1558763174832},{"_id":"public/2019/04/01/热身卡02-入门测试题/index.html","hash":"f2556da1f2240a3ccbbc23a9fbbb03ee30e60f45","modified":1558763174832},{"_id":"public/images/apple-touch-icon.png","hash":"57e2def34682655f41a0be2d083f16765ba7858b","modified":1558763174843},{"_id":"public/images/favicon.ico","hash":"189f9842bcb79a6f8f9e8445bc8bbd773443826b","modified":1558763174843},{"_id":"public/lib/vazir-font/Vazir-Black.woff2","hash":"0a257c8b60e0f20802c1dc8daeed2d3cb0d44f17","modified":1558763174843},{"_id":"public/lib/vazir-font/Vazir-Bold.woff2","hash":"62447a951d48b21c4696ae72df4bc4adef636e26","modified":1558763174843},{"_id":"public/lib/vazir-font/Vazir-Bold.woff","hash":"df15fd1e74b6f4a50bea57e2b44d9627f38495b5","modified":1558763174843},{"_id":"public/lib/vazir-font/Vazir-Black.woff","hash":"37443d0040f0d7af381c955e4c15919a15d0349e","modified":1558763174843},{"_id":"public/lib/vazir-font/Vazir-Light.woff","hash":"32ae5c0d1d5943c8bb8e0f6ab07c3269c6f8b8a8","modified":1558763174843},{"_id":"public/lib/vazir-font/Vazir-Light.woff2","hash":"ef07a250766fea840c1049e67c0405d9216ee0a8","modified":1558763174844},{"_id":"public/lib/vazir-font/Vazir-Medium.woff","hash":"f5653059b2a5929516e4aab02329a978600b9b67","modified":1558763174844},{"_id":"public/lib/vazir-font/Vazir-Thin.woff","hash":"ad4d46a99a1daf6353c86c79ac3a2b030213859c","modified":1558763174844},{"_id":"public/lib/vazir-font/Vazir-Thin.woff2","hash":"c3be79b553ec394db71268d604b1d29183b867dc","modified":1558763174844},{"_id":"public/lib/vazir-font/Vazir-Medium.woff2","hash":"668400ae92700965f03f2371faaee0ab8c8347c3","modified":1558763174844},{"_id":"public/lib/vazir-font/Vazir.woff","hash":"bbee70033f0f5882e9869e417b69c6a38f56f187","modified":1558763174844},{"_id":"public/lib/vazir-font/Vazir.woff2","hash":"30ce165216db078951a690a6ad665b9b78f5dd81","modified":1558763174844},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff","hash":"7b3f44b4d3028f3c87ddf0f4bd62511c9bf4a87e","modified":1558763174844},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"9784edb76f8a2ed595ea4bf74d46cda4eff3b303","modified":1558763174844},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.eot","hash":"42ff503f20e97503cef8e5b2ec10ae07699d7c01","modified":1558763174844},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.ttf","hash":"c140085833a38abec6b7df99d4ccac93eb266031","modified":1558763174844},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"92da6e3c7121e21cdfde25ef08797a3937a683e1","modified":1558763174844},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"d902f8db3e021155f177f698a252fb98d6e61768","modified":1558763174845},{"_id":"public/img/辛普森公式法.png","hash":"bdfdc4ec6767f6b6f69d6fe321dfdf2a44319c84","modified":1558763175080},{"_id":"public/img/梯型公式法.png","hash":"8342a1d9226a276e3d033e1490fce6ddc16e5887","modified":1558763175080},{"_id":"public/img/变长梯型公式法.png","hash":"74d6534f051befad7fd9849099a9993ab6a4e5b2","modified":1558763175081},{"_id":"public/images/favicon-192x192.png","hash":"96e6fcbbb13a5914a6131391e210eb7dfd13d692","modified":1558763175081},{"_id":"public/lib/vazir-font/Vazir-Black.ttf","hash":"594dc3344ad14903c247615427d1009709f0f5a4","modified":1558763175081},{"_id":"public/lib/vazir-font/Vazir-Black.eot","hash":"13d026ff857c853cbd0dc519b6e58669db309441","modified":1558763175081},{"_id":"public/lib/vazir-font/Vazir-Bold.eot","hash":"f76ec625e15522ff60d21f7a9a3b71c65bc27556","modified":1558763175081},{"_id":"public/lib/vazir-font/Vazir-Bold.ttf","hash":"2e6c9df9f775373fb1988ae8529aa8f05313dae6","modified":1558763175081},{"_id":"public/lib/vazir-font/Vazir-Light.eot","hash":"3edffd7bb61eee8cd46b57225f9f9e5264e3362b","modified":1558763175081},{"_id":"public/lib/vazir-font/Vazir-Light.ttf","hash":"9f1e2934098a6a4a7c5584c8f3fa24a707070da3","modified":1558763175081},{"_id":"public/lib/vazir-font/Vazir-Medium.eot","hash":"1f5a73db7947ef22c8a2bb19d6449b80496c03c4","modified":1558763175082},{"_id":"public/lib/vazir-font/Vazir-Medium.ttf","hash":"295f7e02c9b157e7ea63ad09613b00ceab85c5cd","modified":1558763175082},{"_id":"public/lib/vazir-font/Vazir.eot","hash":"31a9219c25fe1991fb745ec8dbbcf45c6094a702","modified":1558763175082},{"_id":"public/lib/vazir-font/Vazir-Thin.eot","hash":"08e1503d1181188690fd9c81860d6c890c1465f6","modified":1558763175082},{"_id":"public/lib/vazir-font/Vazir.ttf","hash":"f22b219824026e490a581ddb3b36b07997dff0e3","modified":1558763175082},{"_id":"public/lib/vazir-font/Vazir-Thin.ttf","hash":"a6aa450ee6e0f85786474ca6b04827ef97e81af4","modified":1558763175082},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff","hash":"f9d835a0f9248b1bb33d66968e87c4a50103ed8d","modified":1558763175082},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.ttf","hash":"19e302760e39e25a5f8d90d6cd0164ef6cd74f8c","modified":1558763175082},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff","hash":"80d33a73cbb60e206ef6f5c898988641576c7dda","modified":1558763175082},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.eot","hash":"644ece8263d2f96b087eebf7f6d4e309e5898eb5","modified":1558763175083},{"_id":"public/css/rtl.css","hash":"c2c2bc4ce311b3129275e009e903088b45e7ed77","modified":1558763175088},{"_id":"public/js/main.js","hash":"584c5a69ac81a483a1c4377a2e2cf326c2795e7b","modified":1558763175088},{"_id":"public/js/search.js","hash":"a74d0c601f820160825a2e4ad13618074d714933","modified":1558763175088},{"_id":"public/lib/vazir-font/font-face.css","hash":"8f2bf6b59ae1f2ed4c2fead6cea4b8314fcf62e5","modified":1558763175088},{"_id":"public/lib/justified-gallery/css/justifiedGallery.min.css","hash":"92bb6e468a1db7fbd99ccb960e15e28572254263","modified":1558763175088},{"_id":"public/css/style.css","hash":"65a6371478e578f261dfabd29cc430ea48e8445e","modified":1558763175088},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.svg","hash":"33e86c0ad6fb9c5c0c8c2af4cb2d790c6b14a8aa","modified":1558763175094},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.ttf","hash":"c445864a9646948e0d7ff44930ad732ee61427d8","modified":1558763175094},{"_id":"public/lib/justified-gallery/js/jquery.justifiedGallery.min.js","hash":"82ab395176c927ffbb2f7c95132ee0a06cd5d64a","modified":1558763175098},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.eot","hash":"10740942ec6b3f4985529d343402d0bf32f9f847","modified":1558763175098},{"_id":"public/images/logo.png","hash":"0e3029251dfda26adee2761f71377297e8c26871","modified":1558763175103},{"_id":"public/lib/meslo-LG/MesloLGM-BoldItalic.ttf","hash":"b542b9591fbf33925d93f0695b6e123a9f0cfd43","modified":1558763175108},{"_id":"public/lib/meslo-LG/MesloLGS-BoldItalic.ttf","hash":"926035f0156cccf1b0ca507347f39bf9c510f51e","modified":1558763175108},{"_id":"public/lib/meslo-LG/MesloLGL-BoldItalic.ttf","hash":"b7d24ab1e4fad720f31a2b0cca1904ce1740d846","modified":1558763175108},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"cf1a3fd771900af34f2af22142beecfb47367548","modified":1558763175113},{"_id":"public/lib/meslo-LG/MesloLGL-Italic.ttf","hash":"9a23c6898b0943bd3d96c04df9a0f66e919451d8","modified":1558763175113},{"_id":"public/lib/meslo-LG/MesloLGM-Italic.ttf","hash":"93ebc5098cf57a32b7b8d297681f31692c09bdfa","modified":1558763175113},{"_id":"public/lib/meslo-LG/MesloLGS-Bold.ttf","hash":"f9918fb93d6ab6850f5d38069a999c311af78816","modified":1558763175118},{"_id":"public/lib/meslo-LG/MesloLGL-Regular.ttf","hash":"6c090d6bff3928fbf8a5f4104e58ed7f421aea7c","modified":1558763175118},{"_id":"public/lib/meslo-LG/MesloLGS-Regular.ttf","hash":"de559f8d70d5b1ab2810597bfd0b1b9506f3ef01","modified":1558763175119},{"_id":"public/lib/meslo-LG/MesloLGM-Regular.ttf","hash":"20ce1fc7ae1254558ca044ae48283faaa58897e5","modified":1558763175120},{"_id":"public/lib/meslo-LG/MesloLGS-Italic.ttf","hash":"9d757cc9f928fc83b2133283dd639c12b11d94ad","modified":1558763175126},{"_id":"public/lib/meslo-LG/MesloLGM-Bold.ttf","hash":"58be4b7760e9a84daa81929d046f9a15c4fd1c1a","modified":1558763175126},{"_id":"public/lib/meslo-LG/MesloLGL-Bold.ttf","hash":"34f7db59f1d023294e69976aa20b7d52b86165a4","modified":1558763175129},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.svg","hash":"ed6c1ed8f24df909f40fe5e5c652d7ff9570c821","modified":1558763175134},{"_id":"public/lib/jquery/jquery.min.js","hash":"0dc32db4aa9c5f03f3b38c47d883dbd4fed13aae","modified":1558763175135},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.svg","hash":"b0bb9e6ac7709206b9510f1718516d89aead5b21","modified":1558763175139},{"_id":"source/_posts/安装步骤.md","hash":"014939865334f9276b8e44ab74384cbf5544fe3b","modified":1558765559300},{"_id":"public/2019/05/25/安装步骤/index.html","hash":"5102eeff04f45429e5a3a8e804627a005b6f1e52","modified":1558765569177},{"_id":"public/2019/05/25/unpacking_tuple_of_lists/index.html","hash":"ac4956b1bf6e2d26947aca892721e02af5674630","modified":1558765569177},{"_id":"public/archives/2019/05/index.html","hash":"f735c42d7b3ee575dd2db1bc5d3c43b9347c7657","modified":1558765569177}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"如何理解动态规划法","_content":"\n动态规划需要明确的三个问题：\n    \n    子问题与决策阶段状态的定义\n    状态递推关系式\n    边界条件\n\n动态规划\n    \n    带备忘录的穷举 + 分治\n\n上楼梯的备忘录升级\n题目来源：小米OJ第10题\n```python\nimport sys\n\nd = [0, 1, 2]\n\nN = 0\n\n\ndef dp():\n    for _ in range(2, N-len(d)+3):\n        d.append(d[-1] + d[-2])\n\n\nfor line in sys.stdin:\n    line = int(line.strip())\n    if N < line:\n        N = line\n        dp()\n    print(d[line])\n```","source":"_posts/动态规划法01.md","raw":"---\ntitle: 如何理解动态规划法\n---\n\n动态规划需要明确的三个问题：\n    \n    子问题与决策阶段状态的定义\n    状态递推关系式\n    边界条件\n\n动态规划\n    \n    带备忘录的穷举 + 分治\n\n上楼梯的备忘录升级\n题目来源：小米OJ第10题\n```python\nimport sys\n\nd = [0, 1, 2]\n\nN = 0\n\n\ndef dp():\n    for _ in range(2, N-len(d)+3):\n        d.append(d[-1] + d[-2])\n\n\nfor line in sys.stdin:\n    line = int(line.strip())\n    if N < line:\n        N = line\n        dp()\n    print(d[line])\n```","slug":"动态规划法01","published":1,"date":"2019-04-11T14:14:56.056Z","updated":"2019-04-11T14:14:56.057Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw32rpbk0000vw72sl8hekf5","content":"<p>动态规划需要明确的三个问题：</p>\n<pre><code>子问题与决策阶段状态的定义\n状态递推关系式\n边界条件\n</code></pre><p>动态规划</p>\n<pre><code>带备忘录的穷举 + 分治\n</code></pre><p>上楼梯的备忘录升级<br>题目来源：小米OJ第10题<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"></span><br><span class=\"line\">d = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">N = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dp</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, N-len(d)+<span class=\"number\">3</span>):</span><br><span class=\"line\">        d.append(d[<span class=\"number\">-1</span>] + d[<span class=\"number\">-2</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> sys.stdin:</span><br><span class=\"line\">    line = int(line.strip())</span><br><span class=\"line\">    <span class=\"keyword\">if</span> N &lt; line:</span><br><span class=\"line\">        N = line</span><br><span class=\"line\">        dp()</span><br><span class=\"line\">    print(d[line])</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>动态规划需要明确的三个问题：</p>\n<pre><code>子问题与决策阶段状态的定义\n状态递推关系式\n边界条件\n</code></pre><p>动态规划</p>\n<pre><code>带备忘录的穷举 + 分治\n</code></pre><p>上楼梯的备忘录升级<br>题目来源：小米OJ第10题<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"></span><br><span class=\"line\">d = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">N = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dp</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, N-len(d)+<span class=\"number\">3</span>):</span><br><span class=\"line\">        d.append(d[<span class=\"number\">-1</span>] + d[<span class=\"number\">-2</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> sys.stdin:</span><br><span class=\"line\">    line = int(line.strip())</span><br><span class=\"line\">    <span class=\"keyword\">if</span> N &lt; line:</span><br><span class=\"line\">        N = line</span><br><span class=\"line\">        dp()</span><br><span class=\"line\">    print(d[line])</span><br></pre></td></tr></table></figure></p>\n"},{"title":"投资问题","_content":"\n动态规划理论的提出\n    \n    最早是用来解决资源的有效分配问题。\n    在总资源量有限，要分配给若干个项目，\n    每个项目都有一个投入与收益的关系，\n    最终的问题是求如何规划在不同项目上的投资，\n    使得收益能够最大化。\n\n问题分析\n\n项目投资/回报表, 可投资600万元 \n\n![](https://images.gitbook.cn/eb8bacc0-eba9-11e8-af4c-6f74b09e97f2)\n\n显然，投资和收益不是线性等比例关系，否则的话，把钱全投到收益比最高的那个项目上就行了，也没啥好规划的了。这个算法也可以用穷举法，因为 N 不是固定的值，所以穷举时可以考虑用递归的方式实现，但是这一课我们考虑用动态规划法来设计这个算法。\n\n投资 N 个项目，看起来好像是毫无关系的离散事件，但是因为投资的总钱数是固定的，这就使它们有了关系。如果我们换个角度看投资的项目，把所有的投资看作是一个求最优解的操作，把对每个项目的投资看作这个操作的一个阶段，就成功地将其转换成了多阶段决策问题。如果要考虑用动态规划解决这个多阶段决策问题，就需要首先证明每个阶段的决策能满足无后向性的要求。在这之前，先要确定决策状态的定义。\n\n状态里肯定要有一个量是标识决策阶段（也就是当前决策的项目）的，不妨用 i 表示决策阶段。肯定还要有一个量是标识投资的钱数，如果我们定义 j 为当前项目（阶段）i 投入的钱数，那么状态 \nd\n[\ni\n,\nj\n]\nd[i,j] 就表示项目 i 投入 j 万元获取的最大收益。现在考虑一下这个状态的定义是否满足无后向性，我们假设给第 2 个项目投入 2 百万元时获取的最大收益为 \nd\n[\n2\n,\n2\n]\nd[2,2]，这个 \nd\n[\n2\n,\n2\n]\nd[2,2] 包含两部分收益，一部分是第 2 个项目投 2 百万元获得的 85 万元固定收益，另一部分是给另两个项目投入剩下的（M − 2）百万元获取的收益。很显然，这（M − 2）百万元在第 1 个项目中有很多种投资方法，每种方法获取的收益都不一样，这会使得通过不同的 d[1,x] 计算出来的 \nd\n[\n2\n,\n2\n]\nd[2,2] 各不相同，后续依赖 \nd\n[\n2\n,\n2\n]\nd[2,2] 的决策就如同建立在浮沙之上，因此不满足无后向性要求。\n\n单独对第 i 个项目定义状态不能满足无后向性要求，现在换个思路，我们将前 i 个项目合在一起考虑，即定义状态 \nd\n[\ni\n,\nj\n]\nd[i,j] 为给前 i 个项目投入 j 万元时能获得的最大收益。前 i 个项目无论怎么分配这 j 万元投资，总能得到一个确定的最大收益，并且这个最大收益在到达 \nd\n[\ni\n,\nj\n]\nd[i,j] 状态后不会因为之前的分配方式不同而变化，后续做决策时也不会变化，因此满足无后向性要求。","source":"_posts/动态规划05.md","raw":"---\ntitle: 投资问题\n---\n\n动态规划理论的提出\n    \n    最早是用来解决资源的有效分配问题。\n    在总资源量有限，要分配给若干个项目，\n    每个项目都有一个投入与收益的关系，\n    最终的问题是求如何规划在不同项目上的投资，\n    使得收益能够最大化。\n\n问题分析\n\n项目投资/回报表, 可投资600万元 \n\n![](https://images.gitbook.cn/eb8bacc0-eba9-11e8-af4c-6f74b09e97f2)\n\n显然，投资和收益不是线性等比例关系，否则的话，把钱全投到收益比最高的那个项目上就行了，也没啥好规划的了。这个算法也可以用穷举法，因为 N 不是固定的值，所以穷举时可以考虑用递归的方式实现，但是这一课我们考虑用动态规划法来设计这个算法。\n\n投资 N 个项目，看起来好像是毫无关系的离散事件，但是因为投资的总钱数是固定的，这就使它们有了关系。如果我们换个角度看投资的项目，把所有的投资看作是一个求最优解的操作，把对每个项目的投资看作这个操作的一个阶段，就成功地将其转换成了多阶段决策问题。如果要考虑用动态规划解决这个多阶段决策问题，就需要首先证明每个阶段的决策能满足无后向性的要求。在这之前，先要确定决策状态的定义。\n\n状态里肯定要有一个量是标识决策阶段（也就是当前决策的项目）的，不妨用 i 表示决策阶段。肯定还要有一个量是标识投资的钱数，如果我们定义 j 为当前项目（阶段）i 投入的钱数，那么状态 \nd\n[\ni\n,\nj\n]\nd[i,j] 就表示项目 i 投入 j 万元获取的最大收益。现在考虑一下这个状态的定义是否满足无后向性，我们假设给第 2 个项目投入 2 百万元时获取的最大收益为 \nd\n[\n2\n,\n2\n]\nd[2,2]，这个 \nd\n[\n2\n,\n2\n]\nd[2,2] 包含两部分收益，一部分是第 2 个项目投 2 百万元获得的 85 万元固定收益，另一部分是给另两个项目投入剩下的（M − 2）百万元获取的收益。很显然，这（M − 2）百万元在第 1 个项目中有很多种投资方法，每种方法获取的收益都不一样，这会使得通过不同的 d[1,x] 计算出来的 \nd\n[\n2\n,\n2\n]\nd[2,2] 各不相同，后续依赖 \nd\n[\n2\n,\n2\n]\nd[2,2] 的决策就如同建立在浮沙之上，因此不满足无后向性要求。\n\n单独对第 i 个项目定义状态不能满足无后向性要求，现在换个思路，我们将前 i 个项目合在一起考虑，即定义状态 \nd\n[\ni\n,\nj\n]\nd[i,j] 为给前 i 个项目投入 j 万元时能获得的最大收益。前 i 个项目无论怎么分配这 j 万元投资，总能得到一个确定的最大收益，并且这个最大收益在到达 \nd\n[\ni\n,\nj\n]\nd[i,j] 状态后不会因为之前的分配方式不同而变化，后续做决策时也不会变化，因此满足无后向性要求。","slug":"动态规划05","published":1,"date":"2019-04-15T07:02:00.836Z","updated":"2019-04-15T07:02:00.837Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw32rpcj0001vw72qwnbjq1q","content":"<p>动态规划理论的提出</p>\n<pre><code>最早是用来解决资源的有效分配问题。\n在总资源量有限，要分配给若干个项目，\n每个项目都有一个投入与收益的关系，\n最终的问题是求如何规划在不同项目上的投资，\n使得收益能够最大化。\n</code></pre><p>问题分析</p>\n<p>项目投资/回报表, 可投资600万元 </p>\n<p><img src=\"https://images.gitbook.cn/eb8bacc0-eba9-11e8-af4c-6f74b09e97f2\" alt></p>\n<p>显然，投资和收益不是线性等比例关系，否则的话，把钱全投到收益比最高的那个项目上就行了，也没啥好规划的了。这个算法也可以用穷举法，因为 N 不是固定的值，所以穷举时可以考虑用递归的方式实现，但是这一课我们考虑用动态规划法来设计这个算法。</p>\n<p>投资 N 个项目，看起来好像是毫无关系的离散事件，但是因为投资的总钱数是固定的，这就使它们有了关系。如果我们换个角度看投资的项目，把所有的投资看作是一个求最优解的操作，把对每个项目的投资看作这个操作的一个阶段，就成功地将其转换成了多阶段决策问题。如果要考虑用动态规划解决这个多阶段决策问题，就需要首先证明每个阶段的决策能满足无后向性的要求。在这之前，先要确定决策状态的定义。</p>\n<p>状态里肯定要有一个量是标识决策阶段（也就是当前决策的项目）的，不妨用 i 表示决策阶段。肯定还要有一个量是标识投资的钱数，如果我们定义 j 为当前项目（阶段）i 投入的钱数，那么状态<br>d<br>[<br>i<br>,<br>j<br>]<br>d[i,j] 就表示项目 i 投入 j 万元获取的最大收益。现在考虑一下这个状态的定义是否满足无后向性，我们假设给第 2 个项目投入 2 百万元时获取的最大收益为<br>d<br>[<br>2<br>,<br>2<br>]<br>d[2,2]，这个<br>d<br>[<br>2<br>,<br>2<br>]<br>d[2,2] 包含两部分收益，一部分是第 2 个项目投 2 百万元获得的 85 万元固定收益，另一部分是给另两个项目投入剩下的（M − 2）百万元获取的收益。很显然，这（M − 2）百万元在第 1 个项目中有很多种投资方法，每种方法获取的收益都不一样，这会使得通过不同的 d[1,x] 计算出来的<br>d<br>[<br>2<br>,<br>2<br>]<br>d[2,2] 各不相同，后续依赖<br>d<br>[<br>2<br>,<br>2<br>]<br>d[2,2] 的决策就如同建立在浮沙之上，因此不满足无后向性要求。</p>\n<p>单独对第 i 个项目定义状态不能满足无后向性要求，现在换个思路，我们将前 i 个项目合在一起考虑，即定义状态<br>d<br>[<br>i<br>,<br>j<br>]<br>d[i,j] 为给前 i 个项目投入 j 万元时能获得的最大收益。前 i 个项目无论怎么分配这 j 万元投资，总能得到一个确定的最大收益，并且这个最大收益在到达<br>d<br>[<br>i<br>,<br>j<br>]<br>d[i,j] 状态后不会因为之前的分配方式不同而变化，后续做决策时也不会变化，因此满足无后向性要求。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>动态规划理论的提出</p>\n<pre><code>最早是用来解决资源的有效分配问题。\n在总资源量有限，要分配给若干个项目，\n每个项目都有一个投入与收益的关系，\n最终的问题是求如何规划在不同项目上的投资，\n使得收益能够最大化。\n</code></pre><p>问题分析</p>\n<p>项目投资/回报表, 可投资600万元 </p>\n<p><img src=\"https://images.gitbook.cn/eb8bacc0-eba9-11e8-af4c-6f74b09e97f2\" alt></p>\n<p>显然，投资和收益不是线性等比例关系，否则的话，把钱全投到收益比最高的那个项目上就行了，也没啥好规划的了。这个算法也可以用穷举法，因为 N 不是固定的值，所以穷举时可以考虑用递归的方式实现，但是这一课我们考虑用动态规划法来设计这个算法。</p>\n<p>投资 N 个项目，看起来好像是毫无关系的离散事件，但是因为投资的总钱数是固定的，这就使它们有了关系。如果我们换个角度看投资的项目，把所有的投资看作是一个求最优解的操作，把对每个项目的投资看作这个操作的一个阶段，就成功地将其转换成了多阶段决策问题。如果要考虑用动态规划解决这个多阶段决策问题，就需要首先证明每个阶段的决策能满足无后向性的要求。在这之前，先要确定决策状态的定义。</p>\n<p>状态里肯定要有一个量是标识决策阶段（也就是当前决策的项目）的，不妨用 i 表示决策阶段。肯定还要有一个量是标识投资的钱数，如果我们定义 j 为当前项目（阶段）i 投入的钱数，那么状态<br>d<br>[<br>i<br>,<br>j<br>]<br>d[i,j] 就表示项目 i 投入 j 万元获取的最大收益。现在考虑一下这个状态的定义是否满足无后向性，我们假设给第 2 个项目投入 2 百万元时获取的最大收益为<br>d<br>[<br>2<br>,<br>2<br>]<br>d[2,2]，这个<br>d<br>[<br>2<br>,<br>2<br>]<br>d[2,2] 包含两部分收益，一部分是第 2 个项目投 2 百万元获得的 85 万元固定收益，另一部分是给另两个项目投入剩下的（M − 2）百万元获取的收益。很显然，这（M − 2）百万元在第 1 个项目中有很多种投资方法，每种方法获取的收益都不一样，这会使得通过不同的 d[1,x] 计算出来的<br>d<br>[<br>2<br>,<br>2<br>]<br>d[2,2] 各不相同，后续依赖<br>d<br>[<br>2<br>,<br>2<br>]<br>d[2,2] 的决策就如同建立在浮沙之上，因此不满足无后向性要求。</p>\n<p>单独对第 i 个项目定义状态不能满足无后向性要求，现在换个思路，我们将前 i 个项目合在一起考虑，即定义状态<br>d<br>[<br>i<br>,<br>j<br>]<br>d[i,j] 为给前 i 个项目投入 j 万元时能获得的最大收益。前 i 个项目无论怎么分配这 j 万元投资，总能得到一个确定的最大收益，并且这个最大收益在到达<br>d<br>[<br>i<br>,<br>j<br>]<br>d[i,j] 状态后不会因为之前的分配方式不同而变化，后续做决策时也不会变化，因此满足无后向性要求。</p>\n"},{"title":"课程表","_content":"\n![课程表](https://images.gitbook.cn/FjeEXocmnhe7jHum9TRrHYj03OQR)","source":"_posts/28天训练营课程表.md","raw":"---\ntitle: 课程表\n---\n\n![课程表](https://images.gitbook.cn/FjeEXocmnhe7jHum9TRrHYj03OQR)","slug":"28天训练营课程表","published":1,"date":"2019-04-01T09:59:49.319Z","updated":"2019-04-01T09:59:49.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw32rpcl0002vw72uzee5drx","content":"<p><img src=\"https://images.gitbook.cn/FjeEXocmnhe7jHum9TRrHYj03OQR\" alt=\"课程表\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://images.gitbook.cn/FjeEXocmnhe7jHum9TRrHYj03OQR\" alt=\"课程表\"></p>\n"},{"title":"unpacking tuple of list","_content":"\n[原文地址](https://www.geeksforgeeks.org/python-unpacking-tuple-of-lists/)\n\n第四种方法\n```python\ndef unpack_tuple(tups):\n    res = list()\n    for lst in tups:\n        res.extend(lst)\n    return res\n```","source":"_posts/unpacking_tuple_of_lists.md","raw":"---\ntitle: unpacking tuple of list\n---\n\n[原文地址](https://www.geeksforgeeks.org/python-unpacking-tuple-of-lists/)\n\n第四种方法\n```python\ndef unpack_tuple(tups):\n    res = list()\n    for lst in tups:\n        res.extend(lst)\n    return res\n```","slug":"unpacking_tuple_of_lists","published":1,"date":"2019-05-25T06:03:46.792Z","updated":"2019-05-25T06:03:46.792Z","_id":"cjw32rpcn0003vw72rz5rgdpb","comments":1,"layout":"post","photos":[],"link":"","content":"<p><a href=\"https://www.geeksforgeeks.org/python-unpacking-tuple-of-lists/\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n<p>第四种方法<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">unpack_tuple</span><span class=\"params\">(tups)</span>:</span></span><br><span class=\"line\">    res = list()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> lst <span class=\"keyword\">in</span> tups:</span><br><span class=\"line\">        res.extend(lst)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.geeksforgeeks.org/python-unpacking-tuple-of-lists/\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n<p>第四种方法<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">unpack_tuple</span><span class=\"params\">(tups)</span>:</span></span><br><span class=\"line\">    res = list()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> lst <span class=\"keyword\">in</span> tups:</span><br><span class=\"line\">        res.extend(lst)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure></p>\n"},{"title":"算法设计常用思想之贪婪法","_content":"\n介绍\n    \n    贪婪法(Greedy Alogorithm), 又称贪心算法，\n    是寻找最优解的常用方法，\n    但是只有在很少的情况下可以得到真正的最优解，\n    如最短路径问题、图的最小生成树问题。\n    \n特点\n    \n    贪婪法简单、高效、省去了为找最优解可能需要的穷举操作，\n    可以得到与最优解比较接近的最优解，\n    通常作为其他算法的辅助算法来使用。\n    \n步骤\n    \n    1. 建立对问题精确描述的数学模型，\n       包括定义最优解的模型；\n    2. 将问题分解为一系列的子问题，\n       同时定义子问题的最优解结构；\n    3. 应用贪心原则确定每个子问题的局部最优解，\n       并根据最优解的模型，\n       用子问题的局部最优解来堆叠出全局最优解。\n    \n0-1背包问题 使用Python语言实现\n```python\n\"\"\"\n    思路\n    目标：在背包容量范围内，装入更多价值的物品\n    原则：p/w -> 价值质量密度\n         优先取出密度大的物品\n         已操作并可存放背包设置密度为 -1\n         已操作但不能放入背包的设置密度为 -2\n\"\"\"\nW_Max = 150\n\nWi = [35, 30, 60, 50, 40, 10, 25]\nPi = [10, 40, 30, 50, 35, 40, 30]\ndensity = [p / w for w, p in zip(Wi, Pi)]\n\nindex_list = []\nwhile 0 < max(density) <= W_Max:\n\n    Max = max(density)\n    index = density.index(Max)\n    if W_Max >= Wi[index]:\n        W_Max -= Wi[index]\n        density[index] = -1\n        index_list.append(index + 1)\n    else:\n        density[index] = -2\n\nprint(index_list)\n```\n\n需要刻意学习的算法\n    \n    Prim\n    Kruskal\n    Dijkstra ","source":"_posts/基础卡01-贪婪法.md","raw":"---\ntitle: 算法设计常用思想之贪婪法\n---\n\n介绍\n    \n    贪婪法(Greedy Alogorithm), 又称贪心算法，\n    是寻找最优解的常用方法，\n    但是只有在很少的情况下可以得到真正的最优解，\n    如最短路径问题、图的最小生成树问题。\n    \n特点\n    \n    贪婪法简单、高效、省去了为找最优解可能需要的穷举操作，\n    可以得到与最优解比较接近的最优解，\n    通常作为其他算法的辅助算法来使用。\n    \n步骤\n    \n    1. 建立对问题精确描述的数学模型，\n       包括定义最优解的模型；\n    2. 将问题分解为一系列的子问题，\n       同时定义子问题的最优解结构；\n    3. 应用贪心原则确定每个子问题的局部最优解，\n       并根据最优解的模型，\n       用子问题的局部最优解来堆叠出全局最优解。\n    \n0-1背包问题 使用Python语言实现\n```python\n\"\"\"\n    思路\n    目标：在背包容量范围内，装入更多价值的物品\n    原则：p/w -> 价值质量密度\n         优先取出密度大的物品\n         已操作并可存放背包设置密度为 -1\n         已操作但不能放入背包的设置密度为 -2\n\"\"\"\nW_Max = 150\n\nWi = [35, 30, 60, 50, 40, 10, 25]\nPi = [10, 40, 30, 50, 35, 40, 30]\ndensity = [p / w for w, p in zip(Wi, Pi)]\n\nindex_list = []\nwhile 0 < max(density) <= W_Max:\n\n    Max = max(density)\n    index = density.index(Max)\n    if W_Max >= Wi[index]:\n        W_Max -= Wi[index]\n        density[index] = -1\n        index_list.append(index + 1)\n    else:\n        density[index] = -2\n\nprint(index_list)\n```\n\n需要刻意学习的算法\n    \n    Prim\n    Kruskal\n    Dijkstra ","slug":"基础卡01-贪婪法","published":1,"date":"2019-04-03T04:46:50.040Z","updated":"2019-04-03T04:46:50.040Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw32rpcp0004vw720am2cdo7","content":"<p>介绍</p>\n<pre><code>贪婪法(Greedy Alogorithm), 又称贪心算法，\n是寻找最优解的常用方法，\n但是只有在很少的情况下可以得到真正的最优解，\n如最短路径问题、图的最小生成树问题。\n</code></pre><p>特点</p>\n<pre><code>贪婪法简单、高效、省去了为找最优解可能需要的穷举操作，\n可以得到与最优解比较接近的最优解，\n通常作为其他算法的辅助算法来使用。\n</code></pre><p>步骤</p>\n<pre><code>1. 建立对问题精确描述的数学模型，\n   包括定义最优解的模型；\n2. 将问题分解为一系列的子问题，\n   同时定义子问题的最优解结构；\n3. 应用贪心原则确定每个子问题的局部最优解，\n   并根据最优解的模型，\n   用子问题的局部最优解来堆叠出全局最优解。\n</code></pre><p>0-1背包问题 使用Python语言实现<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    思路</span></span><br><span class=\"line\"><span class=\"string\">    目标：在背包容量范围内，装入更多价值的物品</span></span><br><span class=\"line\"><span class=\"string\">    原则：p/w -&gt; 价值质量密度</span></span><br><span class=\"line\"><span class=\"string\">         优先取出密度大的物品</span></span><br><span class=\"line\"><span class=\"string\">         已操作并可存放背包设置密度为 -1</span></span><br><span class=\"line\"><span class=\"string\">         已操作但不能放入背包的设置密度为 -2</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\">W_Max = <span class=\"number\">150</span></span><br><span class=\"line\"></span><br><span class=\"line\">Wi = [<span class=\"number\">35</span>, <span class=\"number\">30</span>, <span class=\"number\">60</span>, <span class=\"number\">50</span>, <span class=\"number\">40</span>, <span class=\"number\">10</span>, <span class=\"number\">25</span>]</span><br><span class=\"line\">Pi = [<span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>, <span class=\"number\">50</span>, <span class=\"number\">35</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>]</span><br><span class=\"line\">density = [p / w <span class=\"keyword\">for</span> w, p <span class=\"keyword\">in</span> zip(Wi, Pi)]</span><br><span class=\"line\"></span><br><span class=\"line\">index_list = []</span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"number\">0</span> &lt; max(density) &lt;= W_Max:</span><br><span class=\"line\"></span><br><span class=\"line\">    Max = max(density)</span><br><span class=\"line\">    index = density.index(Max)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> W_Max &gt;= Wi[index]:</span><br><span class=\"line\">        W_Max -= Wi[index]</span><br><span class=\"line\">        density[index] = <span class=\"number\">-1</span></span><br><span class=\"line\">        index_list.append(index + <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        density[index] = <span class=\"number\">-2</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(index_list)</span><br></pre></td></tr></table></figure></p>\n<p>需要刻意学习的算法</p>\n<pre><code>Prim\nKruskal\nDijkstra \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>介绍</p>\n<pre><code>贪婪法(Greedy Alogorithm), 又称贪心算法，\n是寻找最优解的常用方法，\n但是只有在很少的情况下可以得到真正的最优解，\n如最短路径问题、图的最小生成树问题。\n</code></pre><p>特点</p>\n<pre><code>贪婪法简单、高效、省去了为找最优解可能需要的穷举操作，\n可以得到与最优解比较接近的最优解，\n通常作为其他算法的辅助算法来使用。\n</code></pre><p>步骤</p>\n<pre><code>1. 建立对问题精确描述的数学模型，\n   包括定义最优解的模型；\n2. 将问题分解为一系列的子问题，\n   同时定义子问题的最优解结构；\n3. 应用贪心原则确定每个子问题的局部最优解，\n   并根据最优解的模型，\n   用子问题的局部最优解来堆叠出全局最优解。\n</code></pre><p>0-1背包问题 使用Python语言实现<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    思路</span></span><br><span class=\"line\"><span class=\"string\">    目标：在背包容量范围内，装入更多价值的物品</span></span><br><span class=\"line\"><span class=\"string\">    原则：p/w -&gt; 价值质量密度</span></span><br><span class=\"line\"><span class=\"string\">         优先取出密度大的物品</span></span><br><span class=\"line\"><span class=\"string\">         已操作并可存放背包设置密度为 -1</span></span><br><span class=\"line\"><span class=\"string\">         已操作但不能放入背包的设置密度为 -2</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\">W_Max = <span class=\"number\">150</span></span><br><span class=\"line\"></span><br><span class=\"line\">Wi = [<span class=\"number\">35</span>, <span class=\"number\">30</span>, <span class=\"number\">60</span>, <span class=\"number\">50</span>, <span class=\"number\">40</span>, <span class=\"number\">10</span>, <span class=\"number\">25</span>]</span><br><span class=\"line\">Pi = [<span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>, <span class=\"number\">50</span>, <span class=\"number\">35</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>]</span><br><span class=\"line\">density = [p / w <span class=\"keyword\">for</span> w, p <span class=\"keyword\">in</span> zip(Wi, Pi)]</span><br><span class=\"line\"></span><br><span class=\"line\">index_list = []</span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"number\">0</span> &lt; max(density) &lt;= W_Max:</span><br><span class=\"line\"></span><br><span class=\"line\">    Max = max(density)</span><br><span class=\"line\">    index = density.index(Max)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> W_Max &gt;= Wi[index]:</span><br><span class=\"line\">        W_Max -= Wi[index]</span><br><span class=\"line\">        density[index] = <span class=\"number\">-1</span></span><br><span class=\"line\">        index_list.append(index + <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        density[index] = <span class=\"number\">-2</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(index_list)</span><br></pre></td></tr></table></figure></p>\n<p>需要刻意学习的算法</p>\n<pre><code>Prim\nKruskal\nDijkstra \n</code></pre>"},{"title":"算法设计常用思想之分治法","_content":"\n介绍\n    \n    分治，顾名思义，分而治之。\n    将无法着手解决的大问题分解为一系列规模较小的相同问题，\n    然后逐个解决小问题。\n    \n    只要是数学归纳法可以证明的问题，一般也可以应用分治法解决，\n    这是一个应用分治法的强烈信号。\n\n\n作用\n    \n    1. 通过分解问题，使得无法着手解决的大问题变成容易解决的小问题。\n    2. 通过减小问题的规模，降低解决问题的复杂度。\n    \n\n步骤\n    \n    1. 分解：将问题分解为若干个规模较小，\n            相互独立且与原问题形式相同的子问题，\n            确保各个子问题的解具有相同的子结构。\n    2. 解决：如果上一步分解得到的子问题可以解决，\n            则解决这些子问题，否则，\n            对每个子问题使用和上一步相同的方法再次分解，\n            然后求解分解后的子问题，\n            这个过程可能是个递归的过程。\n    3. 合并：将上一步解决的各个子问题的解通过某种规则合并起来，\n            得到原问题的解。\n    \n    分治法伪代码\n    T DivideAndConquer(P)\n    {\n        if(P 可以直接解决)\n        {\n            T <- P 的结果;\n            return T;\n        }\n    \n        将 P 分解为子问题{P1, P2,..., Pn};\n        for_each(Pi : {P1, P2,..., Pn})\n        {\n            ti <- DivideAndConquer(Pi); //递归解决子问题 Pi\n        }\n        T <- Merge(t1, t2,...,tn); //合并子问题的解\n    \n        return T;\n    }\n\n\n递归实现和分治法\n    \n    分解问题肯定不是一步到位，往往需要反复使用分治手段，\n    在多个层次上层层分解，这种分解的方法很自然地导致了递归方式的使用。\n    从算法的角度看，分治法得到的子问题和原问题是相同的，\n    当然可以使用相同的函数来解决，区别在于问题的规模和范围不同。\n    而通过特定的函数参数安排，使得同一函数可以解决不同规模的相同问题，\n    这是递归方法的基础。\n    \n使用Python语言实现 快速排序\n```python\ndef quick_sort(array, left, right):\n    if left < right:\n        mid = partition(array, left, right)\n        quick_sort(array, left,  mid-1)\n        quick_sort(array, mid+1, right)\n\ndef partition(array, left, right):\n    tmp = array[left]\n    while left < right:\n        while left < right and array[right] >= tmp:\n            right -= 1\n        array[left] = array[right]\n        while left < right and array[left] <= tmp:\n            left += 1\n        array[right] = array[left]\n    array[left] = tmp\n    return left\n```\n\n作业之 二分查找实现\n```python\n\"\"\"\n    二分查找\n\n    首先，假设表中元素是按升序排列，\n    将表中间位置记录的关键字与查找关键字比较，\n    如果两者相等，则查找成功；\n    否则利用中间位置记录将表分成前、后两个子表，\n    如果中间位置记录的关键字大于查找关键字，\n    则进一步查找前一子表，否则进一步查找后一子表。\n    重复以上过程，直到找到满足条件的记录，\n    使查找成功，或直到子表不存在为止，此时查找不成功。\n\"\"\"\n\ndef bin_search(data_list, val):\n    low = 0  # 最小数下标\n    high = len(data_list) - 1  # 最大数下标\n    while low <= high:\n        mid = (low + high) // 2  # 中间数下标\n        if data_list[mid] == val:  # 如果中间数下标等于val, 返回\n            return mid\n        elif data_list[mid] > val:  # 如果val在中间数左边, 移动high下标\n            high = mid - 1\n        else:  # 如果val在中间数右边, 移动low下标\n            low = mid + 1\n    return -1   # val不存在, 返回 -1\n     \n```\n    ","source":"_posts/基础卡02-分治法.md","raw":"---\ntitle: 算法设计常用思想之分治法\n---\n\n介绍\n    \n    分治，顾名思义，分而治之。\n    将无法着手解决的大问题分解为一系列规模较小的相同问题，\n    然后逐个解决小问题。\n    \n    只要是数学归纳法可以证明的问题，一般也可以应用分治法解决，\n    这是一个应用分治法的强烈信号。\n\n\n作用\n    \n    1. 通过分解问题，使得无法着手解决的大问题变成容易解决的小问题。\n    2. 通过减小问题的规模，降低解决问题的复杂度。\n    \n\n步骤\n    \n    1. 分解：将问题分解为若干个规模较小，\n            相互独立且与原问题形式相同的子问题，\n            确保各个子问题的解具有相同的子结构。\n    2. 解决：如果上一步分解得到的子问题可以解决，\n            则解决这些子问题，否则，\n            对每个子问题使用和上一步相同的方法再次分解，\n            然后求解分解后的子问题，\n            这个过程可能是个递归的过程。\n    3. 合并：将上一步解决的各个子问题的解通过某种规则合并起来，\n            得到原问题的解。\n    \n    分治法伪代码\n    T DivideAndConquer(P)\n    {\n        if(P 可以直接解决)\n        {\n            T <- P 的结果;\n            return T;\n        }\n    \n        将 P 分解为子问题{P1, P2,..., Pn};\n        for_each(Pi : {P1, P2,..., Pn})\n        {\n            ti <- DivideAndConquer(Pi); //递归解决子问题 Pi\n        }\n        T <- Merge(t1, t2,...,tn); //合并子问题的解\n    \n        return T;\n    }\n\n\n递归实现和分治法\n    \n    分解问题肯定不是一步到位，往往需要反复使用分治手段，\n    在多个层次上层层分解，这种分解的方法很自然地导致了递归方式的使用。\n    从算法的角度看，分治法得到的子问题和原问题是相同的，\n    当然可以使用相同的函数来解决，区别在于问题的规模和范围不同。\n    而通过特定的函数参数安排，使得同一函数可以解决不同规模的相同问题，\n    这是递归方法的基础。\n    \n使用Python语言实现 快速排序\n```python\ndef quick_sort(array, left, right):\n    if left < right:\n        mid = partition(array, left, right)\n        quick_sort(array, left,  mid-1)\n        quick_sort(array, mid+1, right)\n\ndef partition(array, left, right):\n    tmp = array[left]\n    while left < right:\n        while left < right and array[right] >= tmp:\n            right -= 1\n        array[left] = array[right]\n        while left < right and array[left] <= tmp:\n            left += 1\n        array[right] = array[left]\n    array[left] = tmp\n    return left\n```\n\n作业之 二分查找实现\n```python\n\"\"\"\n    二分查找\n\n    首先，假设表中元素是按升序排列，\n    将表中间位置记录的关键字与查找关键字比较，\n    如果两者相等，则查找成功；\n    否则利用中间位置记录将表分成前、后两个子表，\n    如果中间位置记录的关键字大于查找关键字，\n    则进一步查找前一子表，否则进一步查找后一子表。\n    重复以上过程，直到找到满足条件的记录，\n    使查找成功，或直到子表不存在为止，此时查找不成功。\n\"\"\"\n\ndef bin_search(data_list, val):\n    low = 0  # 最小数下标\n    high = len(data_list) - 1  # 最大数下标\n    while low <= high:\n        mid = (low + high) // 2  # 中间数下标\n        if data_list[mid] == val:  # 如果中间数下标等于val, 返回\n            return mid\n        elif data_list[mid] > val:  # 如果val在中间数左边, 移动high下标\n            high = mid - 1\n        else:  # 如果val在中间数右边, 移动low下标\n            low = mid + 1\n    return -1   # val不存在, 返回 -1\n     \n```\n    ","slug":"基础卡02-分治法","published":1,"date":"2019-04-01T14:12:59.024Z","updated":"2019-04-01T14:12:59.024Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw32rpcq0005vw72fztn9sbe","content":"<p>介绍</p>\n<pre><code>分治，顾名思义，分而治之。\n将无法着手解决的大问题分解为一系列规模较小的相同问题，\n然后逐个解决小问题。\n\n只要是数学归纳法可以证明的问题，一般也可以应用分治法解决，\n这是一个应用分治法的强烈信号。\n</code></pre><p>作用</p>\n<pre><code>1. 通过分解问题，使得无法着手解决的大问题变成容易解决的小问题。\n2. 通过减小问题的规模，降低解决问题的复杂度。\n</code></pre><p>步骤</p>\n<pre><code>1. 分解：将问题分解为若干个规模较小，\n        相互独立且与原问题形式相同的子问题，\n        确保各个子问题的解具有相同的子结构。\n2. 解决：如果上一步分解得到的子问题可以解决，\n        则解决这些子问题，否则，\n        对每个子问题使用和上一步相同的方法再次分解，\n        然后求解分解后的子问题，\n        这个过程可能是个递归的过程。\n3. 合并：将上一步解决的各个子问题的解通过某种规则合并起来，\n        得到原问题的解。\n\n分治法伪代码\nT DivideAndConquer(P)\n{\n    if(P 可以直接解决)\n    {\n        T &lt;- P 的结果;\n        return T;\n    }\n\n    将 P 分解为子问题{P1, P2,..., Pn};\n    for_each(Pi : {P1, P2,..., Pn})\n    {\n        ti &lt;- DivideAndConquer(Pi); //递归解决子问题 Pi\n    }\n    T &lt;- Merge(t1, t2,...,tn); //合并子问题的解\n\n    return T;\n}\n</code></pre><p>递归实现和分治法</p>\n<pre><code>分解问题肯定不是一步到位，往往需要反复使用分治手段，\n在多个层次上层层分解，这种分解的方法很自然地导致了递归方式的使用。\n从算法的角度看，分治法得到的子问题和原问题是相同的，\n当然可以使用相同的函数来解决，区别在于问题的规模和范围不同。\n而通过特定的函数参数安排，使得同一函数可以解决不同规模的相同问题，\n这是递归方法的基础。\n</code></pre><p>使用Python语言实现 快速排序<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">quick_sort</span><span class=\"params\">(array, left, right)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> left &lt; right:</span><br><span class=\"line\">        mid = partition(array, left, right)</span><br><span class=\"line\">        quick_sort(array, left,  mid<span class=\"number\">-1</span>)</span><br><span class=\"line\">        quick_sort(array, mid+<span class=\"number\">1</span>, right)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">partition</span><span class=\"params\">(array, left, right)</span>:</span></span><br><span class=\"line\">    tmp = array[left]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> left &lt; right:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt; right <span class=\"keyword\">and</span> array[right] &gt;= tmp:</span><br><span class=\"line\">            right -= <span class=\"number\">1</span></span><br><span class=\"line\">        array[left] = array[right]</span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt; right <span class=\"keyword\">and</span> array[left] &lt;= tmp:</span><br><span class=\"line\">            left += <span class=\"number\">1</span></span><br><span class=\"line\">        array[right] = array[left]</span><br><span class=\"line\">    array[left] = tmp</span><br><span class=\"line\">    <span class=\"keyword\">return</span> left</span><br></pre></td></tr></table></figure></p>\n<p>作业之 二分查找实现<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    二分查找</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    首先，假设表中元素是按升序排列，</span></span><br><span class=\"line\"><span class=\"string\">    将表中间位置记录的关键字与查找关键字比较，</span></span><br><span class=\"line\"><span class=\"string\">    如果两者相等，则查找成功；</span></span><br><span class=\"line\"><span class=\"string\">    否则利用中间位置记录将表分成前、后两个子表，</span></span><br><span class=\"line\"><span class=\"string\">    如果中间位置记录的关键字大于查找关键字，</span></span><br><span class=\"line\"><span class=\"string\">    则进一步查找前一子表，否则进一步查找后一子表。</span></span><br><span class=\"line\"><span class=\"string\">    重复以上过程，直到找到满足条件的记录，</span></span><br><span class=\"line\"><span class=\"string\">    使查找成功，或直到子表不存在为止，此时查找不成功。</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bin_search</span><span class=\"params\">(data_list, val)</span>:</span></span><br><span class=\"line\">    low = <span class=\"number\">0</span>  <span class=\"comment\"># 最小数下标</span></span><br><span class=\"line\">    high = len(data_list) - <span class=\"number\">1</span>  <span class=\"comment\"># 最大数下标</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> low &lt;= high:</span><br><span class=\"line\">        mid = (low + high) // <span class=\"number\">2</span>  <span class=\"comment\"># 中间数下标</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> data_list[mid] == val:  <span class=\"comment\"># 如果中间数下标等于val, 返回</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> data_list[mid] &gt; val:  <span class=\"comment\"># 如果val在中间数左边, 移动high下标</span></span><br><span class=\"line\">            high = mid - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:  <span class=\"comment\"># 如果val在中间数右边, 移动low下标</span></span><br><span class=\"line\">            low = mid + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>   <span class=\"comment\"># val不存在, 返回 -1</span></span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>介绍</p>\n<pre><code>分治，顾名思义，分而治之。\n将无法着手解决的大问题分解为一系列规模较小的相同问题，\n然后逐个解决小问题。\n\n只要是数学归纳法可以证明的问题，一般也可以应用分治法解决，\n这是一个应用分治法的强烈信号。\n</code></pre><p>作用</p>\n<pre><code>1. 通过分解问题，使得无法着手解决的大问题变成容易解决的小问题。\n2. 通过减小问题的规模，降低解决问题的复杂度。\n</code></pre><p>步骤</p>\n<pre><code>1. 分解：将问题分解为若干个规模较小，\n        相互独立且与原问题形式相同的子问题，\n        确保各个子问题的解具有相同的子结构。\n2. 解决：如果上一步分解得到的子问题可以解决，\n        则解决这些子问题，否则，\n        对每个子问题使用和上一步相同的方法再次分解，\n        然后求解分解后的子问题，\n        这个过程可能是个递归的过程。\n3. 合并：将上一步解决的各个子问题的解通过某种规则合并起来，\n        得到原问题的解。\n\n分治法伪代码\nT DivideAndConquer(P)\n{\n    if(P 可以直接解决)\n    {\n        T &lt;- P 的结果;\n        return T;\n    }\n\n    将 P 分解为子问题{P1, P2,..., Pn};\n    for_each(Pi : {P1, P2,..., Pn})\n    {\n        ti &lt;- DivideAndConquer(Pi); //递归解决子问题 Pi\n    }\n    T &lt;- Merge(t1, t2,...,tn); //合并子问题的解\n\n    return T;\n}\n</code></pre><p>递归实现和分治法</p>\n<pre><code>分解问题肯定不是一步到位，往往需要反复使用分治手段，\n在多个层次上层层分解，这种分解的方法很自然地导致了递归方式的使用。\n从算法的角度看，分治法得到的子问题和原问题是相同的，\n当然可以使用相同的函数来解决，区别在于问题的规模和范围不同。\n而通过特定的函数参数安排，使得同一函数可以解决不同规模的相同问题，\n这是递归方法的基础。\n</code></pre><p>使用Python语言实现 快速排序<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">quick_sort</span><span class=\"params\">(array, left, right)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> left &lt; right:</span><br><span class=\"line\">        mid = partition(array, left, right)</span><br><span class=\"line\">        quick_sort(array, left,  mid<span class=\"number\">-1</span>)</span><br><span class=\"line\">        quick_sort(array, mid+<span class=\"number\">1</span>, right)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">partition</span><span class=\"params\">(array, left, right)</span>:</span></span><br><span class=\"line\">    tmp = array[left]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> left &lt; right:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt; right <span class=\"keyword\">and</span> array[right] &gt;= tmp:</span><br><span class=\"line\">            right -= <span class=\"number\">1</span></span><br><span class=\"line\">        array[left] = array[right]</span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt; right <span class=\"keyword\">and</span> array[left] &lt;= tmp:</span><br><span class=\"line\">            left += <span class=\"number\">1</span></span><br><span class=\"line\">        array[right] = array[left]</span><br><span class=\"line\">    array[left] = tmp</span><br><span class=\"line\">    <span class=\"keyword\">return</span> left</span><br></pre></td></tr></table></figure></p>\n<p>作业之 二分查找实现<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    二分查找</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    首先，假设表中元素是按升序排列，</span></span><br><span class=\"line\"><span class=\"string\">    将表中间位置记录的关键字与查找关键字比较，</span></span><br><span class=\"line\"><span class=\"string\">    如果两者相等，则查找成功；</span></span><br><span class=\"line\"><span class=\"string\">    否则利用中间位置记录将表分成前、后两个子表，</span></span><br><span class=\"line\"><span class=\"string\">    如果中间位置记录的关键字大于查找关键字，</span></span><br><span class=\"line\"><span class=\"string\">    则进一步查找前一子表，否则进一步查找后一子表。</span></span><br><span class=\"line\"><span class=\"string\">    重复以上过程，直到找到满足条件的记录，</span></span><br><span class=\"line\"><span class=\"string\">    使查找成功，或直到子表不存在为止，此时查找不成功。</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bin_search</span><span class=\"params\">(data_list, val)</span>:</span></span><br><span class=\"line\">    low = <span class=\"number\">0</span>  <span class=\"comment\"># 最小数下标</span></span><br><span class=\"line\">    high = len(data_list) - <span class=\"number\">1</span>  <span class=\"comment\"># 最大数下标</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> low &lt;= high:</span><br><span class=\"line\">        mid = (low + high) // <span class=\"number\">2</span>  <span class=\"comment\"># 中间数下标</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> data_list[mid] == val:  <span class=\"comment\"># 如果中间数下标等于val, 返回</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> data_list[mid] &gt; val:  <span class=\"comment\"># 如果val在中间数左边, 移动high下标</span></span><br><span class=\"line\">            high = mid - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:  <span class=\"comment\"># 如果val在中间数右边, 移动low下标</span></span><br><span class=\"line\">            low = mid + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>   <span class=\"comment\"># val不存在, 返回 -1</span></span><br></pre></td></tr></table></figure></p>\n"},{"title":"算法设计常用思想之动态规划法","_content":"\n动态规划\n\n    是解决多阶段决策问题常用的最优化理论\n    想法简单，落地困难，\n    需要经由大量实践\n    积累对子问题的分解和\n    决策状态的定义的经验。\n    比穷举法高效，\n    但效率在很大程度上还是取决于问题本身\n    内在机制为广域搜索\n    需要满足条件：\n        1. 最优化原理\n        2. 子问题的\"无后向性\"\n\n最优化原理：\n\n    最优化原理其实就是问题的最优子结构的性质，\n    如果一个问题的最优子结构是不论过去状态和决策如何，\n    对前面的决策所形成的状态而言，\n    其后的决策必须构成最优策略。也就是说，\n    不管之前的决策是否是最优决策，\n    都必须保证从现在开始的决策是在之前决策基础上的最优决策，\n    则这样的最优子结构就符合最优化原理。\n\n无后向性：\n\n    所谓“无后向性”，就是当各个阶段的子问题确定以后，\n    对于某个特定阶段的子问题来说，\n    它之前各个阶段的子问题的决策只影响该阶段的决策，\n    对该阶段之后的决策不产生影响。\n    即前面的不被后面的影响。\n    \n\n步骤\n    \n    定义最优子问题（最优解的子结构）\n    定义状态（最优解的值）\n    定义决策和状态转换方程（定义计算最优解的值的方法）\n    确定边界条件\n    \n难点\n    \n    状态如何描述\n    状态转移方程如何定义\n\n最长公共子序列（LCS）问题 使用Python实现\n```python\ndef lcs(str1, str2):\n    length_1 = len(str1)\n    length_2 = len(str2)\n\n    dp = [[0] * (length_2 + 1) for _ in range(length_1 + 1)]\n\n    for i in range(1, length_1 + 1):\n\n        for j in range(1, length_2 + 1):\n\n            if str1[i - 1] == str2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[length_1][length_2]\n```","source":"_posts/基础卡03-动态规划.md","raw":"---\ntitle: 算法设计常用思想之动态规划法\n---\n\n动态规划\n\n    是解决多阶段决策问题常用的最优化理论\n    想法简单，落地困难，\n    需要经由大量实践\n    积累对子问题的分解和\n    决策状态的定义的经验。\n    比穷举法高效，\n    但效率在很大程度上还是取决于问题本身\n    内在机制为广域搜索\n    需要满足条件：\n        1. 最优化原理\n        2. 子问题的\"无后向性\"\n\n最优化原理：\n\n    最优化原理其实就是问题的最优子结构的性质，\n    如果一个问题的最优子结构是不论过去状态和决策如何，\n    对前面的决策所形成的状态而言，\n    其后的决策必须构成最优策略。也就是说，\n    不管之前的决策是否是最优决策，\n    都必须保证从现在开始的决策是在之前决策基础上的最优决策，\n    则这样的最优子结构就符合最优化原理。\n\n无后向性：\n\n    所谓“无后向性”，就是当各个阶段的子问题确定以后，\n    对于某个特定阶段的子问题来说，\n    它之前各个阶段的子问题的决策只影响该阶段的决策，\n    对该阶段之后的决策不产生影响。\n    即前面的不被后面的影响。\n    \n\n步骤\n    \n    定义最优子问题（最优解的子结构）\n    定义状态（最优解的值）\n    定义决策和状态转换方程（定义计算最优解的值的方法）\n    确定边界条件\n    \n难点\n    \n    状态如何描述\n    状态转移方程如何定义\n\n最长公共子序列（LCS）问题 使用Python实现\n```python\ndef lcs(str1, str2):\n    length_1 = len(str1)\n    length_2 = len(str2)\n\n    dp = [[0] * (length_2 + 1) for _ in range(length_1 + 1)]\n\n    for i in range(1, length_1 + 1):\n\n        for j in range(1, length_2 + 1):\n\n            if str1[i - 1] == str2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[length_1][length_2]\n```","slug":"基础卡03-动态规划","published":1,"date":"2019-04-03T07:17:37.311Z","updated":"2019-04-03T07:17:37.311Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw32rpcs0007vw72eizui4dl","content":"<p>动态规划</p>\n<pre><code>是解决多阶段决策问题常用的最优化理论\n想法简单，落地困难，\n需要经由大量实践\n积累对子问题的分解和\n决策状态的定义的经验。\n比穷举法高效，\n但效率在很大程度上还是取决于问题本身\n内在机制为广域搜索\n需要满足条件：\n    1. 最优化原理\n    2. 子问题的&quot;无后向性&quot;\n</code></pre><p>最优化原理：</p>\n<pre><code>最优化原理其实就是问题的最优子结构的性质，\n如果一个问题的最优子结构是不论过去状态和决策如何，\n对前面的决策所形成的状态而言，\n其后的决策必须构成最优策略。也就是说，\n不管之前的决策是否是最优决策，\n都必须保证从现在开始的决策是在之前决策基础上的最优决策，\n则这样的最优子结构就符合最优化原理。\n</code></pre><p>无后向性：</p>\n<pre><code>所谓“无后向性”，就是当各个阶段的子问题确定以后，\n对于某个特定阶段的子问题来说，\n它之前各个阶段的子问题的决策只影响该阶段的决策，\n对该阶段之后的决策不产生影响。\n即前面的不被后面的影响。\n</code></pre><p>步骤</p>\n<pre><code>定义最优子问题（最优解的子结构）\n定义状态（最优解的值）\n定义决策和状态转换方程（定义计算最优解的值的方法）\n确定边界条件\n</code></pre><p>难点</p>\n<pre><code>状态如何描述\n状态转移方程如何定义\n</code></pre><p>最长公共子序列（LCS）问题 使用Python实现<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lcs</span><span class=\"params\">(str1, str2)</span>:</span></span><br><span class=\"line\">    length_1 = len(str1)</span><br><span class=\"line\">    length_2 = len(str2)</span><br><span class=\"line\"></span><br><span class=\"line\">    dp = [[<span class=\"number\">0</span>] * (length_2 + <span class=\"number\">1</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(length_1 + <span class=\"number\">1</span>)]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, length_1 + <span class=\"number\">1</span>):</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, length_2 + <span class=\"number\">1</span>):</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> str1[i - <span class=\"number\">1</span>] == str2[j - <span class=\"number\">1</span>]:</span><br><span class=\"line\">                dp[i][j] = dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                dp[i][j] = max(dp[i - <span class=\"number\">1</span>][j], dp[i][j - <span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[length_1][length_2]</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>动态规划</p>\n<pre><code>是解决多阶段决策问题常用的最优化理论\n想法简单，落地困难，\n需要经由大量实践\n积累对子问题的分解和\n决策状态的定义的经验。\n比穷举法高效，\n但效率在很大程度上还是取决于问题本身\n内在机制为广域搜索\n需要满足条件：\n    1. 最优化原理\n    2. 子问题的&quot;无后向性&quot;\n</code></pre><p>最优化原理：</p>\n<pre><code>最优化原理其实就是问题的最优子结构的性质，\n如果一个问题的最优子结构是不论过去状态和决策如何，\n对前面的决策所形成的状态而言，\n其后的决策必须构成最优策略。也就是说，\n不管之前的决策是否是最优决策，\n都必须保证从现在开始的决策是在之前决策基础上的最优决策，\n则这样的最优子结构就符合最优化原理。\n</code></pre><p>无后向性：</p>\n<pre><code>所谓“无后向性”，就是当各个阶段的子问题确定以后，\n对于某个特定阶段的子问题来说，\n它之前各个阶段的子问题的决策只影响该阶段的决策，\n对该阶段之后的决策不产生影响。\n即前面的不被后面的影响。\n</code></pre><p>步骤</p>\n<pre><code>定义最优子问题（最优解的子结构）\n定义状态（最优解的值）\n定义决策和状态转换方程（定义计算最优解的值的方法）\n确定边界条件\n</code></pre><p>难点</p>\n<pre><code>状态如何描述\n状态转移方程如何定义\n</code></pre><p>最长公共子序列（LCS）问题 使用Python实现<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lcs</span><span class=\"params\">(str1, str2)</span>:</span></span><br><span class=\"line\">    length_1 = len(str1)</span><br><span class=\"line\">    length_2 = len(str2)</span><br><span class=\"line\"></span><br><span class=\"line\">    dp = [[<span class=\"number\">0</span>] * (length_2 + <span class=\"number\">1</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(length_1 + <span class=\"number\">1</span>)]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, length_1 + <span class=\"number\">1</span>):</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, length_2 + <span class=\"number\">1</span>):</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> str1[i - <span class=\"number\">1</span>] == str2[j - <span class=\"number\">1</span>]:</span><br><span class=\"line\">                dp[i][j] = dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                dp[i][j] = max(dp[i - <span class=\"number\">1</span>][j], dp[i][j - <span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[length_1][length_2]</span><br></pre></td></tr></table></figure></p>\n"},{"title":"算法设计常用思想之穷举法","_content":"\n穷举法\n    \n    是一种在问题域的解空间中对所有可能的解穷举搜索，\n    并根据条件选择最优解的方法的总称。\n    \n    穷举法作为计算机算法使用时，\n    就是依赖计算机不知疲倦的计算能力。\n    \n    穷举法作为一种算法模式，\n    也常常与其他模式配合使用，\n    成为某个具体算法中的一部分。\n\n\n难点\n    \n    1. 解空间或状态空间的定义没有具体的模式，\n       不同问题的解空间形式上也差异巨大\n    2. 针对不同问题要选择不同的搜索算法，\n       有很多问题的搜索算法并不直观，\n       需要对问题做细致的分析并且依靠丰富的经验才能设计出来。\n    3. 在问题的规模大到一定范围时，穷举法只是理论可行。\n       在这种不能对解空间进行完全搜索时，\n       需要对搜索算法进行评估，\n       并确定一些收敛原则。   \n       \n步骤\n\n    1. 确定问题的解（或状态）的定义、\n       解空间的范围以及正确解的判定条件。\n    2. 根据解空间的特点来选择搜索策略，\n       逐个检验解空间中的候选解是否正确。\n    \n\n解空间的定义\n    \n    解空间就是全部可能的候选解的一个约束范围，\n    确定问题的解就在这个约束范围内，\n    将搜索策略应用到这个约束范围就可以找到问题的解。\n\n\n穷举解空间的策略\n    \n    1. 盲目搜索\n        不带任何假设的穷举搜索，\n        把所有可能的解都检查一遍。\n        -- 广度优先\n            需要额外的存储空间，则应考虑额外空间的规模\n        -- 深度优先\n            容易陷入死循环，则要做状态循环的判断和避免\n    \n    2. 启发式搜索\n        由启发函数策动有目的的搜索行为，\n        这些策略和依据通常能够加快算法的收敛速度，\n        或能够划定一个更小的、最有可能出现解的空间上搜索。\n        -- 假设解空间符合正态分布\n            可以从分布中间值开始向两边搜索。\n     \n    3. 剪枝策略\n        在对解空间穷举搜索时，\n        如果有一些状态节点可以根据问题所提供的信息，\n        明确地判定为不可能演化出最优解，\n        则可以跳过此状态节点的遍历。\n        \n\n剪枝和启发\n\n    剪枝是对已产生的结果，根据最优解的判断条件，\n        确定在该方向上不可能存在最优解，\n        从而放弃对这个方向的搜素。\n        \n    启发是根据启发函数给出的评估值，\n        在结果出来之前就朝着最优解方向搜索\n    \n\n评估与收敛\n    \n    收敛原则是只要能找到一个比较好的解就返回，\n    根据解的评估判断是否需要继续下一次搜索。  \n\n\n百钱买百鸡 Python语言实现\n```python\np_m = 5\np_w = 3\np_x = 1 / 3\n\nn = 100\nfor i in range(0, n // p_m):\n\n    for j in range(0, n // p_w):\n\n        if i * p_m + j * p_w + (100 - i - j) * p_x == 100:\n            print(i, j, 100 - i - j)\n\n```\n\n作业之 鸡兔同笼\n```python\nt = 50\nj = 120\nji = 2\ntu = 4\n\nfor tu_num in range(j // tu):\n\n    if tu_num * tu + (t - tu_num) * ji == j:\n        print(tu_num, t - tu_num)\n\n```","source":"_posts/基础卡04-穷举法.md","raw":"---\ntitle: 算法设计常用思想之穷举法\n---\n\n穷举法\n    \n    是一种在问题域的解空间中对所有可能的解穷举搜索，\n    并根据条件选择最优解的方法的总称。\n    \n    穷举法作为计算机算法使用时，\n    就是依赖计算机不知疲倦的计算能力。\n    \n    穷举法作为一种算法模式，\n    也常常与其他模式配合使用，\n    成为某个具体算法中的一部分。\n\n\n难点\n    \n    1. 解空间或状态空间的定义没有具体的模式，\n       不同问题的解空间形式上也差异巨大\n    2. 针对不同问题要选择不同的搜索算法，\n       有很多问题的搜索算法并不直观，\n       需要对问题做细致的分析并且依靠丰富的经验才能设计出来。\n    3. 在问题的规模大到一定范围时，穷举法只是理论可行。\n       在这种不能对解空间进行完全搜索时，\n       需要对搜索算法进行评估，\n       并确定一些收敛原则。   \n       \n步骤\n\n    1. 确定问题的解（或状态）的定义、\n       解空间的范围以及正确解的判定条件。\n    2. 根据解空间的特点来选择搜索策略，\n       逐个检验解空间中的候选解是否正确。\n    \n\n解空间的定义\n    \n    解空间就是全部可能的候选解的一个约束范围，\n    确定问题的解就在这个约束范围内，\n    将搜索策略应用到这个约束范围就可以找到问题的解。\n\n\n穷举解空间的策略\n    \n    1. 盲目搜索\n        不带任何假设的穷举搜索，\n        把所有可能的解都检查一遍。\n        -- 广度优先\n            需要额外的存储空间，则应考虑额外空间的规模\n        -- 深度优先\n            容易陷入死循环，则要做状态循环的判断和避免\n    \n    2. 启发式搜索\n        由启发函数策动有目的的搜索行为，\n        这些策略和依据通常能够加快算法的收敛速度，\n        或能够划定一个更小的、最有可能出现解的空间上搜索。\n        -- 假设解空间符合正态分布\n            可以从分布中间值开始向两边搜索。\n     \n    3. 剪枝策略\n        在对解空间穷举搜索时，\n        如果有一些状态节点可以根据问题所提供的信息，\n        明确地判定为不可能演化出最优解，\n        则可以跳过此状态节点的遍历。\n        \n\n剪枝和启发\n\n    剪枝是对已产生的结果，根据最优解的判断条件，\n        确定在该方向上不可能存在最优解，\n        从而放弃对这个方向的搜素。\n        \n    启发是根据启发函数给出的评估值，\n        在结果出来之前就朝着最优解方向搜索\n    \n\n评估与收敛\n    \n    收敛原则是只要能找到一个比较好的解就返回，\n    根据解的评估判断是否需要继续下一次搜索。  \n\n\n百钱买百鸡 Python语言实现\n```python\np_m = 5\np_w = 3\np_x = 1 / 3\n\nn = 100\nfor i in range(0, n // p_m):\n\n    for j in range(0, n // p_w):\n\n        if i * p_m + j * p_w + (100 - i - j) * p_x == 100:\n            print(i, j, 100 - i - j)\n\n```\n\n作业之 鸡兔同笼\n```python\nt = 50\nj = 120\nji = 2\ntu = 4\n\nfor tu_num in range(j // tu):\n\n    if tu_num * tu + (t - tu_num) * ji == j:\n        print(tu_num, t - tu_num)\n\n```","slug":"基础卡04-穷举法","published":1,"date":"2019-04-03T06:15:56.590Z","updated":"2019-04-03T06:15:56.591Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw32rpct0008vw72lj1d4ez2","content":"<p>穷举法</p>\n<pre><code>是一种在问题域的解空间中对所有可能的解穷举搜索，\n并根据条件选择最优解的方法的总称。\n\n穷举法作为计算机算法使用时，\n就是依赖计算机不知疲倦的计算能力。\n\n穷举法作为一种算法模式，\n也常常与其他模式配合使用，\n成为某个具体算法中的一部分。\n</code></pre><p>难点</p>\n<pre><code>1. 解空间或状态空间的定义没有具体的模式，\n   不同问题的解空间形式上也差异巨大\n2. 针对不同问题要选择不同的搜索算法，\n   有很多问题的搜索算法并不直观，\n   需要对问题做细致的分析并且依靠丰富的经验才能设计出来。\n3. 在问题的规模大到一定范围时，穷举法只是理论可行。\n   在这种不能对解空间进行完全搜索时，\n   需要对搜索算法进行评估，\n   并确定一些收敛原则。   \n</code></pre><p>步骤</p>\n<pre><code>1. 确定问题的解（或状态）的定义、\n   解空间的范围以及正确解的判定条件。\n2. 根据解空间的特点来选择搜索策略，\n   逐个检验解空间中的候选解是否正确。\n</code></pre><p>解空间的定义</p>\n<pre><code>解空间就是全部可能的候选解的一个约束范围，\n确定问题的解就在这个约束范围内，\n将搜索策略应用到这个约束范围就可以找到问题的解。\n</code></pre><p>穷举解空间的策略</p>\n<pre><code>1. 盲目搜索\n    不带任何假设的穷举搜索，\n    把所有可能的解都检查一遍。\n    -- 广度优先\n        需要额外的存储空间，则应考虑额外空间的规模\n    -- 深度优先\n        容易陷入死循环，则要做状态循环的判断和避免\n\n2. 启发式搜索\n    由启发函数策动有目的的搜索行为，\n    这些策略和依据通常能够加快算法的收敛速度，\n    或能够划定一个更小的、最有可能出现解的空间上搜索。\n    -- 假设解空间符合正态分布\n        可以从分布中间值开始向两边搜索。\n\n3. 剪枝策略\n    在对解空间穷举搜索时，\n    如果有一些状态节点可以根据问题所提供的信息，\n    明确地判定为不可能演化出最优解，\n    则可以跳过此状态节点的遍历。\n</code></pre><p>剪枝和启发</p>\n<pre><code>剪枝是对已产生的结果，根据最优解的判断条件，\n    确定在该方向上不可能存在最优解，\n    从而放弃对这个方向的搜素。\n\n启发是根据启发函数给出的评估值，\n    在结果出来之前就朝着最优解方向搜索\n</code></pre><p>评估与收敛</p>\n<pre><code>收敛原则是只要能找到一个比较好的解就返回，\n根据解的评估判断是否需要继续下一次搜索。  \n</code></pre><p>百钱买百鸡 Python语言实现<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p_m = <span class=\"number\">5</span></span><br><span class=\"line\">p_w = <span class=\"number\">3</span></span><br><span class=\"line\">p_x = <span class=\"number\">1</span> / <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">n = <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, n // p_m):</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, n // p_w):</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i * p_m + j * p_w + (<span class=\"number\">100</span> - i - j) * p_x == <span class=\"number\">100</span>:</span><br><span class=\"line\">            print(i, j, <span class=\"number\">100</span> - i - j)</span><br></pre></td></tr></table></figure></p>\n<p>作业之 鸡兔同笼<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t = <span class=\"number\">50</span></span><br><span class=\"line\">j = <span class=\"number\">120</span></span><br><span class=\"line\">ji = <span class=\"number\">2</span></span><br><span class=\"line\">tu = <span class=\"number\">4</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> tu_num <span class=\"keyword\">in</span> range(j // tu):</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> tu_num * tu + (t - tu_num) * ji == j:</span><br><span class=\"line\">        print(tu_num, t - tu_num)</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>穷举法</p>\n<pre><code>是一种在问题域的解空间中对所有可能的解穷举搜索，\n并根据条件选择最优解的方法的总称。\n\n穷举法作为计算机算法使用时，\n就是依赖计算机不知疲倦的计算能力。\n\n穷举法作为一种算法模式，\n也常常与其他模式配合使用，\n成为某个具体算法中的一部分。\n</code></pre><p>难点</p>\n<pre><code>1. 解空间或状态空间的定义没有具体的模式，\n   不同问题的解空间形式上也差异巨大\n2. 针对不同问题要选择不同的搜索算法，\n   有很多问题的搜索算法并不直观，\n   需要对问题做细致的分析并且依靠丰富的经验才能设计出来。\n3. 在问题的规模大到一定范围时，穷举法只是理论可行。\n   在这种不能对解空间进行完全搜索时，\n   需要对搜索算法进行评估，\n   并确定一些收敛原则。   \n</code></pre><p>步骤</p>\n<pre><code>1. 确定问题的解（或状态）的定义、\n   解空间的范围以及正确解的判定条件。\n2. 根据解空间的特点来选择搜索策略，\n   逐个检验解空间中的候选解是否正确。\n</code></pre><p>解空间的定义</p>\n<pre><code>解空间就是全部可能的候选解的一个约束范围，\n确定问题的解就在这个约束范围内，\n将搜索策略应用到这个约束范围就可以找到问题的解。\n</code></pre><p>穷举解空间的策略</p>\n<pre><code>1. 盲目搜索\n    不带任何假设的穷举搜索，\n    把所有可能的解都检查一遍。\n    -- 广度优先\n        需要额外的存储空间，则应考虑额外空间的规模\n    -- 深度优先\n        容易陷入死循环，则要做状态循环的判断和避免\n\n2. 启发式搜索\n    由启发函数策动有目的的搜索行为，\n    这些策略和依据通常能够加快算法的收敛速度，\n    或能够划定一个更小的、最有可能出现解的空间上搜索。\n    -- 假设解空间符合正态分布\n        可以从分布中间值开始向两边搜索。\n\n3. 剪枝策略\n    在对解空间穷举搜索时，\n    如果有一些状态节点可以根据问题所提供的信息，\n    明确地判定为不可能演化出最优解，\n    则可以跳过此状态节点的遍历。\n</code></pre><p>剪枝和启发</p>\n<pre><code>剪枝是对已产生的结果，根据最优解的判断条件，\n    确定在该方向上不可能存在最优解，\n    从而放弃对这个方向的搜素。\n\n启发是根据启发函数给出的评估值，\n    在结果出来之前就朝着最优解方向搜索\n</code></pre><p>评估与收敛</p>\n<pre><code>收敛原则是只要能找到一个比较好的解就返回，\n根据解的评估判断是否需要继续下一次搜索。  \n</code></pre><p>百钱买百鸡 Python语言实现<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p_m = <span class=\"number\">5</span></span><br><span class=\"line\">p_w = <span class=\"number\">3</span></span><br><span class=\"line\">p_x = <span class=\"number\">1</span> / <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">n = <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, n // p_m):</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, n // p_w):</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i * p_m + j * p_w + (<span class=\"number\">100</span> - i - j) * p_x == <span class=\"number\">100</span>:</span><br><span class=\"line\">            print(i, j, <span class=\"number\">100</span> - i - j)</span><br></pre></td></tr></table></figure></p>\n<p>作业之 鸡兔同笼<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t = <span class=\"number\">50</span></span><br><span class=\"line\">j = <span class=\"number\">120</span></span><br><span class=\"line\">ji = <span class=\"number\">2</span></span><br><span class=\"line\">tu = <span class=\"number\">4</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> tu_num <span class=\"keyword\">in</span> range(j // tu):</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> tu_num * tu + (t - tu_num) * ji == j:</span><br><span class=\"line\">        print(tu_num, t - tu_num)</span><br></pre></td></tr></table></figure></p>\n"},{"title":"算法设计常用思想之迭代法","_content":"\n迭代法\n\n    数字意义上是一种不断用变量的旧值递推新值的过程，\n    其相应的迭代算法也是用计算机解决问题的一种基本方法。\n    \n    迭代法，还有一种更广泛的观点，\n    就是所有使用了迭代思想的算法实现，\n    都可以理解为是使用了迭代法。\n    从这个角度理解，\n    除了线性动态规划算法、\n    遗传算法、退火算法等算法\n    也可归入迭代法的范畴。\n    \n迭代法的实现\n\n    确定迭代变量：\n        迭代变量一般就是要求解的问题的解，\n        利用迭代递推公式可以不断地由旧值递推出新值。\n        根据问题的不同，迭代变量可以是一个，也可以是多个。\n        确定迭代变量，通常还要根据迭代递推关系给出迭代变量的初始值，\n        这一点也很重要。\n    \n    确定迭代递推关系：\n        迭代递推关系是根据旧值计算新值的关系或公式，\n        这是迭代法实现的关键，如果不能确定迭代关系，\n        则无法用迭代法实现算法。\n    \n    确定迭代终止条件：\n        迭代终止条件是控制迭代过程退出的关键条件。\n        迭代不可能无休止地进行，必须设置迭代终止条件，\n        在适当的时候退出迭代。\n        \n        迭代终止条件一般有三种假设：\n        其一是迭代变量已经求得问题的精确值；\n        其二是迭代变量无法得到精确值，\n        但是某个迭代的值的精度已经满足要求；\n        其三是指定明确的迭代计算次数。\n        \n        迭代算法的具体实现，可根据问题的类型选择迭代终止条件。\n        一般情况下，为了防止迭代关系在某个区间上发散（不收敛）\n        使得算法进入死循环，都会把第三个条件作为异常退出条件\n        和其他迭代终止条件配合使用，也就是说，\n        即使无法得到符合条件的解，\n        只要迭代计算次数达到某个限制值，\n        也退出迭代过程。\n\n    \n常见的迭代法\n    \n    梯度法\n    最小二乘法\n    牛顿迭代法\n\n迭代法和递推法\n\n    迭代法作为很多数学问题的求解算法，\n    是解决数学问题的一种常用的算法模式，\n    可以独立构成解决问题的算法。\n    \n    递推法作为一种设计算法的常用思想，\n    没有固定的算法实现模式，\n    通常是与其他算法模式配合形成算法实现。\n    比如线性动态规划问题，\n    一般都有明确的子问题最优解递推公式，\n    递推思想常常作为算法实现的一部分\n    融入到动态规划算法的实现中。\n\n使用Python实现 求根函数 并与内置求根函数对比\n```python\nimport math\n\n\ndef like_sqrt(num: int):\n    xi = num / 2\n    xt = xi\n    xi = (xt + num / xt) / 2\n    count = 1\n    eps = 0.1 ** 6\n\n    while abs(xi - xt) > eps:\n        xt = xi\n        xi = (xt + num / xt) / 2\n\n        count += 1\n    print(xi)\n\n\nprint(math.sqrt(3))\nlike_sqrt(3)\n```","source":"_posts/基础卡05-迭代法.md","raw":"---\ntitle: 算法设计常用思想之迭代法\n---\n\n迭代法\n\n    数字意义上是一种不断用变量的旧值递推新值的过程，\n    其相应的迭代算法也是用计算机解决问题的一种基本方法。\n    \n    迭代法，还有一种更广泛的观点，\n    就是所有使用了迭代思想的算法实现，\n    都可以理解为是使用了迭代法。\n    从这个角度理解，\n    除了线性动态规划算法、\n    遗传算法、退火算法等算法\n    也可归入迭代法的范畴。\n    \n迭代法的实现\n\n    确定迭代变量：\n        迭代变量一般就是要求解的问题的解，\n        利用迭代递推公式可以不断地由旧值递推出新值。\n        根据问题的不同，迭代变量可以是一个，也可以是多个。\n        确定迭代变量，通常还要根据迭代递推关系给出迭代变量的初始值，\n        这一点也很重要。\n    \n    确定迭代递推关系：\n        迭代递推关系是根据旧值计算新值的关系或公式，\n        这是迭代法实现的关键，如果不能确定迭代关系，\n        则无法用迭代法实现算法。\n    \n    确定迭代终止条件：\n        迭代终止条件是控制迭代过程退出的关键条件。\n        迭代不可能无休止地进行，必须设置迭代终止条件，\n        在适当的时候退出迭代。\n        \n        迭代终止条件一般有三种假设：\n        其一是迭代变量已经求得问题的精确值；\n        其二是迭代变量无法得到精确值，\n        但是某个迭代的值的精度已经满足要求；\n        其三是指定明确的迭代计算次数。\n        \n        迭代算法的具体实现，可根据问题的类型选择迭代终止条件。\n        一般情况下，为了防止迭代关系在某个区间上发散（不收敛）\n        使得算法进入死循环，都会把第三个条件作为异常退出条件\n        和其他迭代终止条件配合使用，也就是说，\n        即使无法得到符合条件的解，\n        只要迭代计算次数达到某个限制值，\n        也退出迭代过程。\n\n    \n常见的迭代法\n    \n    梯度法\n    最小二乘法\n    牛顿迭代法\n\n迭代法和递推法\n\n    迭代法作为很多数学问题的求解算法，\n    是解决数学问题的一种常用的算法模式，\n    可以独立构成解决问题的算法。\n    \n    递推法作为一种设计算法的常用思想，\n    没有固定的算法实现模式，\n    通常是与其他算法模式配合形成算法实现。\n    比如线性动态规划问题，\n    一般都有明确的子问题最优解递推公式，\n    递推思想常常作为算法实现的一部分\n    融入到动态规划算法的实现中。\n\n使用Python实现 求根函数 并与内置求根函数对比\n```python\nimport math\n\n\ndef like_sqrt(num: int):\n    xi = num / 2\n    xt = xi\n    xi = (xt + num / xt) / 2\n    count = 1\n    eps = 0.1 ** 6\n\n    while abs(xi - xt) > eps:\n        xt = xi\n        xi = (xt + num / xt) / 2\n\n        count += 1\n    print(xi)\n\n\nprint(math.sqrt(3))\nlike_sqrt(3)\n```","slug":"基础卡05-迭代法","published":1,"date":"2019-04-05T10:12:00.664Z","updated":"2019-04-05T10:12:00.665Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw32rpcu0009vw72epdf8q8u","content":"<p>迭代法</p>\n<pre><code>数字意义上是一种不断用变量的旧值递推新值的过程，\n其相应的迭代算法也是用计算机解决问题的一种基本方法。\n\n迭代法，还有一种更广泛的观点，\n就是所有使用了迭代思想的算法实现，\n都可以理解为是使用了迭代法。\n从这个角度理解，\n除了线性动态规划算法、\n遗传算法、退火算法等算法\n也可归入迭代法的范畴。\n</code></pre><p>迭代法的实现</p>\n<pre><code>确定迭代变量：\n    迭代变量一般就是要求解的问题的解，\n    利用迭代递推公式可以不断地由旧值递推出新值。\n    根据问题的不同，迭代变量可以是一个，也可以是多个。\n    确定迭代变量，通常还要根据迭代递推关系给出迭代变量的初始值，\n    这一点也很重要。\n\n确定迭代递推关系：\n    迭代递推关系是根据旧值计算新值的关系或公式，\n    这是迭代法实现的关键，如果不能确定迭代关系，\n    则无法用迭代法实现算法。\n\n确定迭代终止条件：\n    迭代终止条件是控制迭代过程退出的关键条件。\n    迭代不可能无休止地进行，必须设置迭代终止条件，\n    在适当的时候退出迭代。\n\n    迭代终止条件一般有三种假设：\n    其一是迭代变量已经求得问题的精确值；\n    其二是迭代变量无法得到精确值，\n    但是某个迭代的值的精度已经满足要求；\n    其三是指定明确的迭代计算次数。\n\n    迭代算法的具体实现，可根据问题的类型选择迭代终止条件。\n    一般情况下，为了防止迭代关系在某个区间上发散（不收敛）\n    使得算法进入死循环，都会把第三个条件作为异常退出条件\n    和其他迭代终止条件配合使用，也就是说，\n    即使无法得到符合条件的解，\n    只要迭代计算次数达到某个限制值，\n    也退出迭代过程。\n</code></pre><p>常见的迭代法</p>\n<pre><code>梯度法\n最小二乘法\n牛顿迭代法\n</code></pre><p>迭代法和递推法</p>\n<pre><code>迭代法作为很多数学问题的求解算法，\n是解决数学问题的一种常用的算法模式，\n可以独立构成解决问题的算法。\n\n递推法作为一种设计算法的常用思想，\n没有固定的算法实现模式，\n通常是与其他算法模式配合形成算法实现。\n比如线性动态规划问题，\n一般都有明确的子问题最优解递推公式，\n递推思想常常作为算法实现的一部分\n融入到动态规划算法的实现中。\n</code></pre><p>使用Python实现 求根函数 并与内置求根函数对比<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">like_sqrt</span><span class=\"params\">(num: int)</span>:</span></span><br><span class=\"line\">    xi = num / <span class=\"number\">2</span></span><br><span class=\"line\">    xt = xi</span><br><span class=\"line\">    xi = (xt + num / xt) / <span class=\"number\">2</span></span><br><span class=\"line\">    count = <span class=\"number\">1</span></span><br><span class=\"line\">    eps = <span class=\"number\">0.1</span> ** <span class=\"number\">6</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> abs(xi - xt) &gt; eps:</span><br><span class=\"line\">        xt = xi</span><br><span class=\"line\">        xi = (xt + num / xt) / <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">        count += <span class=\"number\">1</span></span><br><span class=\"line\">    print(xi)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">print(math.sqrt(<span class=\"number\">3</span>))</span><br><span class=\"line\">like_sqrt(<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>迭代法</p>\n<pre><code>数字意义上是一种不断用变量的旧值递推新值的过程，\n其相应的迭代算法也是用计算机解决问题的一种基本方法。\n\n迭代法，还有一种更广泛的观点，\n就是所有使用了迭代思想的算法实现，\n都可以理解为是使用了迭代法。\n从这个角度理解，\n除了线性动态规划算法、\n遗传算法、退火算法等算法\n也可归入迭代法的范畴。\n</code></pre><p>迭代法的实现</p>\n<pre><code>确定迭代变量：\n    迭代变量一般就是要求解的问题的解，\n    利用迭代递推公式可以不断地由旧值递推出新值。\n    根据问题的不同，迭代变量可以是一个，也可以是多个。\n    确定迭代变量，通常还要根据迭代递推关系给出迭代变量的初始值，\n    这一点也很重要。\n\n确定迭代递推关系：\n    迭代递推关系是根据旧值计算新值的关系或公式，\n    这是迭代法实现的关键，如果不能确定迭代关系，\n    则无法用迭代法实现算法。\n\n确定迭代终止条件：\n    迭代终止条件是控制迭代过程退出的关键条件。\n    迭代不可能无休止地进行，必须设置迭代终止条件，\n    在适当的时候退出迭代。\n\n    迭代终止条件一般有三种假设：\n    其一是迭代变量已经求得问题的精确值；\n    其二是迭代变量无法得到精确值，\n    但是某个迭代的值的精度已经满足要求；\n    其三是指定明确的迭代计算次数。\n\n    迭代算法的具体实现，可根据问题的类型选择迭代终止条件。\n    一般情况下，为了防止迭代关系在某个区间上发散（不收敛）\n    使得算法进入死循环，都会把第三个条件作为异常退出条件\n    和其他迭代终止条件配合使用，也就是说，\n    即使无法得到符合条件的解，\n    只要迭代计算次数达到某个限制值，\n    也退出迭代过程。\n</code></pre><p>常见的迭代法</p>\n<pre><code>梯度法\n最小二乘法\n牛顿迭代法\n</code></pre><p>迭代法和递推法</p>\n<pre><code>迭代法作为很多数学问题的求解算法，\n是解决数学问题的一种常用的算法模式，\n可以独立构成解决问题的算法。\n\n递推法作为一种设计算法的常用思想，\n没有固定的算法实现模式，\n通常是与其他算法模式配合形成算法实现。\n比如线性动态规划问题，\n一般都有明确的子问题最优解递推公式，\n递推思想常常作为算法实现的一部分\n融入到动态规划算法的实现中。\n</code></pre><p>使用Python实现 求根函数 并与内置求根函数对比<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">like_sqrt</span><span class=\"params\">(num: int)</span>:</span></span><br><span class=\"line\">    xi = num / <span class=\"number\">2</span></span><br><span class=\"line\">    xt = xi</span><br><span class=\"line\">    xi = (xt + num / xt) / <span class=\"number\">2</span></span><br><span class=\"line\">    count = <span class=\"number\">1</span></span><br><span class=\"line\">    eps = <span class=\"number\">0.1</span> ** <span class=\"number\">6</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> abs(xi - xt) &gt; eps:</span><br><span class=\"line\">        xt = xi</span><br><span class=\"line\">        xi = (xt + num / xt) / <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">        count += <span class=\"number\">1</span></span><br><span class=\"line\">    print(xi)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">print(math.sqrt(<span class=\"number\">3</span>))</span><br><span class=\"line\">like_sqrt(<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure></p>\n"},{"title":"A*算法","_content":"\n","source":"_posts/游戏算法卡01-A*算法.md","raw":"---\ntitle: A*算法\n---\n\n","slug":"游戏算法卡01-A*算法","published":1,"date":"2019-04-19T04:49:01.314Z","updated":"2019-04-19T04:49:01.314Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw32rpcv000avw72akdovt2v","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"基础开胃菜","_content":"\n常用技巧\n\n    哨兵位\n        \n        通常起到两个作用，\n        一个是作为一个临时存储空间使用，\n        另一个是减少不必要的越界判断，\n        简化算法代码复杂度。\n    \n    \n    巧用数组下标\n        \n        数组的下标是一个隐含的很有用的属性，\n        巧妙地使用这个属性，\n        对简化算法实现有很大的帮助。\n        \n    \n    取余的用法\n    \n        取余运算基本上还是一个除法运算，\n        如果仅仅是判断奇偶数，\n        判断（number & 1）是否等于 0 是更好的方法。\n        \n        更一般的情况，当取余运算的除数是 2 的 n 次方的时候，\n        用 & 运算符代替取余会更高效。比如当 x=2n 的时候，\n        a % x 的结果与 a & (x - 1) 的结果是等价的。\n        \n    使用双指针来判断链表是否有环\n    \n    \n    数组链表\n        \n        数组的特点是存储空间固定，数据存取高效，\n        但是缺点是数据插入和删除需要移动数组元素，\n        不适合插入和删除比较频繁的场合。\n        链表的特点恰恰是插入和删除比较高效，\n        但是缺点是需要动态申请存储空间，在一些系统上，\n        内存申请和释放的开销比较大，使用链表存在性能问题。\n    \n    \n    topN 问题和最小堆\n        \n    常用的 hash 算法 作字符串比较\n    \n    以空间换时间的策略\n","source":"_posts/基础卡06-基础开胃菜.md","raw":"---\ntitle: 基础开胃菜\n---\n\n常用技巧\n\n    哨兵位\n        \n        通常起到两个作用，\n        一个是作为一个临时存储空间使用，\n        另一个是减少不必要的越界判断，\n        简化算法代码复杂度。\n    \n    \n    巧用数组下标\n        \n        数组的下标是一个隐含的很有用的属性，\n        巧妙地使用这个属性，\n        对简化算法实现有很大的帮助。\n        \n    \n    取余的用法\n    \n        取余运算基本上还是一个除法运算，\n        如果仅仅是判断奇偶数，\n        判断（number & 1）是否等于 0 是更好的方法。\n        \n        更一般的情况，当取余运算的除数是 2 的 n 次方的时候，\n        用 & 运算符代替取余会更高效。比如当 x=2n 的时候，\n        a % x 的结果与 a & (x - 1) 的结果是等价的。\n        \n    使用双指针来判断链表是否有环\n    \n    \n    数组链表\n        \n        数组的特点是存储空间固定，数据存取高效，\n        但是缺点是数据插入和删除需要移动数组元素，\n        不适合插入和删除比较频繁的场合。\n        链表的特点恰恰是插入和删除比较高效，\n        但是缺点是需要动态申请存储空间，在一些系统上，\n        内存申请和释放的开销比较大，使用链表存在性能问题。\n    \n    \n    topN 问题和最小堆\n        \n    常用的 hash 算法 作字符串比较\n    \n    以空间换时间的策略\n","slug":"基础卡06-基础开胃菜","published":1,"date":"2019-04-04T15:23:44.593Z","updated":"2019-04-04T15:23:44.593Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw32rpcx000bvw72ydu6d4yd","content":"<p>常用技巧</p>\n<pre><code>哨兵位\n\n    通常起到两个作用，\n    一个是作为一个临时存储空间使用，\n    另一个是减少不必要的越界判断，\n    简化算法代码复杂度。\n\n\n巧用数组下标\n\n    数组的下标是一个隐含的很有用的属性，\n    巧妙地使用这个属性，\n    对简化算法实现有很大的帮助。\n\n\n取余的用法\n\n    取余运算基本上还是一个除法运算，\n    如果仅仅是判断奇偶数，\n    判断（number &amp; 1）是否等于 0 是更好的方法。\n\n    更一般的情况，当取余运算的除数是 2 的 n 次方的时候，\n    用 &amp; 运算符代替取余会更高效。比如当 x=2n 的时候，\n    a % x 的结果与 a &amp; (x - 1) 的结果是等价的。\n\n使用双指针来判断链表是否有环\n\n\n数组链表\n\n    数组的特点是存储空间固定，数据存取高效，\n    但是缺点是数据插入和删除需要移动数组元素，\n    不适合插入和删除比较频繁的场合。\n    链表的特点恰恰是插入和删除比较高效，\n    但是缺点是需要动态申请存储空间，在一些系统上，\n    内存申请和释放的开销比较大，使用链表存在性能问题。\n\n\ntopN 问题和最小堆\n\n常用的 hash 算法 作字符串比较\n\n以空间换时间的策略\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>常用技巧</p>\n<pre><code>哨兵位\n\n    通常起到两个作用，\n    一个是作为一个临时存储空间使用，\n    另一个是减少不必要的越界判断，\n    简化算法代码复杂度。\n\n\n巧用数组下标\n\n    数组的下标是一个隐含的很有用的属性，\n    巧妙地使用这个属性，\n    对简化算法实现有很大的帮助。\n\n\n取余的用法\n\n    取余运算基本上还是一个除法运算，\n    如果仅仅是判断奇偶数，\n    判断（number &amp; 1）是否等于 0 是更好的方法。\n\n    更一般的情况，当取余运算的除数是 2 的 n 次方的时候，\n    用 &amp; 运算符代替取余会更高效。比如当 x=2n 的时候，\n    a % x 的结果与 a &amp; (x - 1) 的结果是等价的。\n\n使用双指针来判断链表是否有环\n\n\n数组链表\n\n    数组的特点是存储空间固定，数据存取高效，\n    但是缺点是数据插入和删除需要移动数组元素，\n    不适合插入和删除比较频繁的场合。\n    链表的特点恰恰是插入和删除比较高效，\n    但是缺点是需要动态申请存储空间，在一些系统上，\n    内存申请和释放的开销比较大，使用链表存在性能问题。\n\n\ntopN 问题和最小堆\n\n常用的 hash 算法 作字符串比较\n\n以空间换时间的策略\n</code></pre>"},{"_content":"查看硬盘分区列表\n\n    diskutil list\n    \n进行挂载\n    \n    diskutil mount 硬盘号","source":"_posts/挂载硬盘的一些命令.md","raw":"查看硬盘分区列表\n\n    diskutil list\n    \n进行挂载\n    \n    diskutil mount 硬盘号","slug":"挂载硬盘的一些命令","published":1,"date":"2019-04-04T05:43:08.785Z","updated":"2019-04-04T05:43:08.786Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw32rpcy000cvw72sia0h04d","content":"<p>查看硬盘分区列表</p>\n<pre><code>diskutil list\n</code></pre><p>进行挂载</p>\n<pre><code>diskutil mount 硬盘号\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>查看硬盘分区列表</p>\n<pre><code>diskutil list\n</code></pre><p>进行挂载</p>\n<pre><code>diskutil mount 硬盘号\n</code></pre>"},{"title":"算法是程序的\"灵魂\"","_content":"\n目标\n    \n    通过学习各算法的实现，掌握算法设计方法，在面对实际问题的时候，具备设计并实现解决问题的算法\n\n\n算法的两大特点\n    \n    纷繁复杂、知识多广。\n    设计数学模型并不会因为设计模式的完善而变得简单。\n\n常见的算法设计方法\n    \n    迭代法\n    穷举搜索法\n    分界界限法(剪枝法)\n    递推法\n    递归法\n    回溯法\n    分治法\n    贪婪法\n    动态规划法\n    \n注意\n    \n    尽管算法设计的常用方法很多，但是这些放法之间并不是孤立的。\n    如牛顿迭代法，还有些递推关系需要通过广域搜索来实现，比如常见的动态规划算法。\n    贪婪法很少单独用于解决最优解问题，但是贪婪法的思想体现在很多算法中，\n    比如著名的“Dijkstra 算法”，在确定某个顶点的下一个最短路径点时，\n    就使用了贪婪法的思想，每次选择距离最近的那个点作为下一个顶点。","source":"_posts/热身卡01-开篇词：算法是程序的灵魂.md","raw":"---\ntitle: 算法是程序的\"灵魂\"\n---\n\n目标\n    \n    通过学习各算法的实现，掌握算法设计方法，在面对实际问题的时候，具备设计并实现解决问题的算法\n\n\n算法的两大特点\n    \n    纷繁复杂、知识多广。\n    设计数学模型并不会因为设计模式的完善而变得简单。\n\n常见的算法设计方法\n    \n    迭代法\n    穷举搜索法\n    分界界限法(剪枝法)\n    递推法\n    递归法\n    回溯法\n    分治法\n    贪婪法\n    动态规划法\n    \n注意\n    \n    尽管算法设计的常用方法很多，但是这些放法之间并不是孤立的。\n    如牛顿迭代法，还有些递推关系需要通过广域搜索来实现，比如常见的动态规划算法。\n    贪婪法很少单独用于解决最优解问题，但是贪婪法的思想体现在很多算法中，\n    比如著名的“Dijkstra 算法”，在确定某个顶点的下一个最短路径点时，\n    就使用了贪婪法的思想，每次选择距离最近的那个点作为下一个顶点。","slug":"热身卡01-开篇词：算法是程序的灵魂","published":1,"date":"2019-04-01T09:59:49.338Z","updated":"2019-04-01T09:59:49.338Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw32rpd0000dvw72rteb5u8a","content":"<p>目标</p>\n<pre><code>通过学习各算法的实现，掌握算法设计方法，在面对实际问题的时候，具备设计并实现解决问题的算法\n</code></pre><p>算法的两大特点</p>\n<pre><code>纷繁复杂、知识多广。\n设计数学模型并不会因为设计模式的完善而变得简单。\n</code></pre><p>常见的算法设计方法</p>\n<pre><code>迭代法\n穷举搜索法\n分界界限法(剪枝法)\n递推法\n递归法\n回溯法\n分治法\n贪婪法\n动态规划法\n</code></pre><p>注意</p>\n<pre><code>尽管算法设计的常用方法很多，但是这些放法之间并不是孤立的。\n如牛顿迭代法，还有些递推关系需要通过广域搜索来实现，比如常见的动态规划算法。\n贪婪法很少单独用于解决最优解问题，但是贪婪法的思想体现在很多算法中，\n比如著名的“Dijkstra 算法”，在确定某个顶点的下一个最短路径点时，\n就使用了贪婪法的思想，每次选择距离最近的那个点作为下一个顶点。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>目标</p>\n<pre><code>通过学习各算法的实现，掌握算法设计方法，在面对实际问题的时候，具备设计并实现解决问题的算法\n</code></pre><p>算法的两大特点</p>\n<pre><code>纷繁复杂、知识多广。\n设计数学模型并不会因为设计模式的完善而变得简单。\n</code></pre><p>常见的算法设计方法</p>\n<pre><code>迭代法\n穷举搜索法\n分界界限法(剪枝法)\n递推法\n递归法\n回溯法\n分治法\n贪婪法\n动态规划法\n</code></pre><p>注意</p>\n<pre><code>尽管算法设计的常用方法很多，但是这些放法之间并不是孤立的。\n如牛顿迭代法，还有些递推关系需要通过广域搜索来实现，比如常见的动态规划算法。\n贪婪法很少单独用于解决最优解问题，但是贪婪法的思想体现在很多算法中，\n比如著名的“Dijkstra 算法”，在确定某个顶点的下一个最短路径点时，\n就使用了贪婪法的思想，每次选择距离最近的那个点作为下一个顶点。\n</code></pre>"},{"title":"如何\"玩\"算法","_content":"\n目标\n    \n    1. 对遇到的特殊的问题要能够设计出算法实现\n    2. 对原理公开的知名算法，要能够翻译成具体的算法代码\n    3. 对已有具体实现的算法，要能够设计出合适的数学模型，将算法应用到实际问题中。\n\n条件\n\n    1. 了解算法设计的常用思想和模式，并将题目转换成数据模型\n    2. 进一步用数据结构实现数据模型的一般方法。\n\n\n将问题抽象成数据模型\n\n    信息数据化：把自然语言描述转换成方便代码数据模型表达的数字化信息。\n    类比和转化：像使用模式一样使用那些经典的或常用的模型，\n              或者根据不同对象的某些相似性，借用已知领域的模型。\n\n\n堆[深有体会。某游戏公司有考察]\n    \n    在问题规模比较大的时候，每次查找dist数组中的最小值可能会成为效率的瓶颈，\n    可以用最小的堆来维护dist的结果，使得每次取出最小值的操作为O(1)时间复杂度，\n    因为堆顶即为最小值。\n    \n    \n穷举法[想法简单, 遗漏情况]\n    \n    尽管部分人看不起穷举法，但是不可否认，有些人却连基本的穷举算法都设计不出来。\n\n\n需要刻意补充的知识点\n    \n    区间树\n    有向图\n    \n    \n需要刻意练习的算法\n    \n    图论\n","source":"_posts/热身卡03-如何\"玩\"算法.md","raw":"---\ntitle: 如何\"玩\"算法\n---\n\n目标\n    \n    1. 对遇到的特殊的问题要能够设计出算法实现\n    2. 对原理公开的知名算法，要能够翻译成具体的算法代码\n    3. 对已有具体实现的算法，要能够设计出合适的数学模型，将算法应用到实际问题中。\n\n条件\n\n    1. 了解算法设计的常用思想和模式，并将题目转换成数据模型\n    2. 进一步用数据结构实现数据模型的一般方法。\n\n\n将问题抽象成数据模型\n\n    信息数据化：把自然语言描述转换成方便代码数据模型表达的数字化信息。\n    类比和转化：像使用模式一样使用那些经典的或常用的模型，\n              或者根据不同对象的某些相似性，借用已知领域的模型。\n\n\n堆[深有体会。某游戏公司有考察]\n    \n    在问题规模比较大的时候，每次查找dist数组中的最小值可能会成为效率的瓶颈，\n    可以用最小的堆来维护dist的结果，使得每次取出最小值的操作为O(1)时间复杂度，\n    因为堆顶即为最小值。\n    \n    \n穷举法[想法简单, 遗漏情况]\n    \n    尽管部分人看不起穷举法，但是不可否认，有些人却连基本的穷举算法都设计不出来。\n\n\n需要刻意补充的知识点\n    \n    区间树\n    有向图\n    \n    \n需要刻意练习的算法\n    \n    图论\n","slug":"热身卡03-如何\"玩\"算法","published":1,"date":"2019-04-01T09:59:49.335Z","updated":"2019-04-01T09:59:49.335Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw32rpd5000evw72uusz6rjh","content":"<p>目标</p>\n<pre><code>1. 对遇到的特殊的问题要能够设计出算法实现\n2. 对原理公开的知名算法，要能够翻译成具体的算法代码\n3. 对已有具体实现的算法，要能够设计出合适的数学模型，将算法应用到实际问题中。\n</code></pre><p>条件</p>\n<pre><code>1. 了解算法设计的常用思想和模式，并将题目转换成数据模型\n2. 进一步用数据结构实现数据模型的一般方法。\n</code></pre><p>将问题抽象成数据模型</p>\n<pre><code>信息数据化：把自然语言描述转换成方便代码数据模型表达的数字化信息。\n类比和转化：像使用模式一样使用那些经典的或常用的模型，\n          或者根据不同对象的某些相似性，借用已知领域的模型。\n</code></pre><p>堆[深有体会。某游戏公司有考察]</p>\n<pre><code>在问题规模比较大的时候，每次查找dist数组中的最小值可能会成为效率的瓶颈，\n可以用最小的堆来维护dist的结果，使得每次取出最小值的操作为O(1)时间复杂度，\n因为堆顶即为最小值。\n</code></pre><p>穷举法[想法简单, 遗漏情况]</p>\n<pre><code>尽管部分人看不起穷举法，但是不可否认，有些人却连基本的穷举算法都设计不出来。\n</code></pre><p>需要刻意补充的知识点</p>\n<pre><code>区间树\n有向图\n</code></pre><p>需要刻意练习的算法</p>\n<pre><code>图论\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>目标</p>\n<pre><code>1. 对遇到的特殊的问题要能够设计出算法实现\n2. 对原理公开的知名算法，要能够翻译成具体的算法代码\n3. 对已有具体实现的算法，要能够设计出合适的数学模型，将算法应用到实际问题中。\n</code></pre><p>条件</p>\n<pre><code>1. 了解算法设计的常用思想和模式，并将题目转换成数据模型\n2. 进一步用数据结构实现数据模型的一般方法。\n</code></pre><p>将问题抽象成数据模型</p>\n<pre><code>信息数据化：把自然语言描述转换成方便代码数据模型表达的数字化信息。\n类比和转化：像使用模式一样使用那些经典的或常用的模型，\n          或者根据不同对象的某些相似性，借用已知领域的模型。\n</code></pre><p>堆[深有体会。某游戏公司有考察]</p>\n<pre><code>在问题规模比较大的时候，每次查找dist数组中的最小值可能会成为效率的瓶颈，\n可以用最小的堆来维护dist的结果，使得每次取出最小值的操作为O(1)时间复杂度，\n因为堆顶即为最小值。\n</code></pre><p>穷举法[想法简单, 遗漏情况]</p>\n<pre><code>尽管部分人看不起穷举法，但是不可否认，有些人却连基本的穷举算法都设计不出来。\n</code></pre><p>需要刻意补充的知识点</p>\n<pre><code>区间树\n有向图\n</code></pre><p>需要刻意练习的算法</p>\n<pre><code>图论\n</code></pre>"},{"title":"入门测试题","_content":"\n目标\n    \n    定位自我\n    \n\n思考点1 [只是了解一般不用 == 判断浮点数相等，对于能够判断的浮点数集认识不深刻]\n    \n    在诸如Java、C++或Python语言中，一般不用 \"==\" 判断两个浮点数相等。\n    浮点数在计算机内的表达有误差，直接使用 \"==\" 来判断两个浮点数是否相等是不安全的。\n    只有部分能够精确表达的浮点数，如0.0, 0.5(1/2)，0.25(1/4)等浮点数，使用 \"==\" 判断\n    浮点数值相等是没问题的，其他情况则会产生意想不到的结果。\n    \n\n思考点2 [动态规划和分治法的区别，增加例子来理解]\n    \n    动态规划区别于分治法是其子问题具备\"无后向性\"，在各阶段的子问题确定后，\n    对于特定阶段的子问题来说，它之前各个阶段的子问题的决策只影响该阶段的决策，\n    对该阶段之后的决策不产生影响。\n    \n\n思考点3 [对诸如Dijkstra、A*等经典算法生疏，对图结构生疏]\n\n\n思考点4 [由排序算法时间复杂度引出的讨论]\n\n>@5年-余努力-成都-杂家 \n\n    桶排序的平均时间复杂度为线性的O(N+C)，其中C=N*(logN-logM)。\n    如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。\n    当N=M时，就是计数排序。\n    \n   \n>@应届-乌凌-c++    \n```c++\nvoid radix_sort(int *num, int n) {\n#define MAX 65536\n\tint *temp = (int*)calloc(n, sizeof(int));\n\tint *cnt = (int*)calloc(MAX + 5, sizeof(int));\n\tfor (int i = 0; i < n; i++) {\n\t\tcnt[(num[i] & 65535) + 1] += 1;\n\t}\n\tfor (int i = 0; i < MAX; i++) cnt[i] += cnt[i - 1];\n\tfor (int i = 0; i < n; i++) {\n\t\ttemp[cnt[num[i] & 65535]++] = num[i];\n\t}\n\tmemset(cnt, 0, sizeof(int) * MAX);\n\tint *p = temp;\n\ttemp = num;\n\tnum = p;\n\tfor (int i = 0; i < n; i++) {\n\t\tcnt[((num[i] >> 16) & 65535) + 1] += 1;\n\t}\n\tfor (int i = 0; i < MAX; i++) cnt[i] += cnt[i - 1];\n\tfor (int i = 0; i < n; i++) {\n\t\ttemp[cnt[(num[i] >> 16) & 65535]++] = num[i];\n\t}\n\tfree(num);\n\tnum = temp;\n\tfree(cnt);\n#undef MAX\n}\n\n```\n\n>个人对排序的补充\n    \n    快速排序\n    归并排序\n    堆排序","source":"_posts/热身卡02-入门测试题.md","raw":"---\ntitle: 入门测试题\n---\n\n目标\n    \n    定位自我\n    \n\n思考点1 [只是了解一般不用 == 判断浮点数相等，对于能够判断的浮点数集认识不深刻]\n    \n    在诸如Java、C++或Python语言中，一般不用 \"==\" 判断两个浮点数相等。\n    浮点数在计算机内的表达有误差，直接使用 \"==\" 来判断两个浮点数是否相等是不安全的。\n    只有部分能够精确表达的浮点数，如0.0, 0.5(1/2)，0.25(1/4)等浮点数，使用 \"==\" 判断\n    浮点数值相等是没问题的，其他情况则会产生意想不到的结果。\n    \n\n思考点2 [动态规划和分治法的区别，增加例子来理解]\n    \n    动态规划区别于分治法是其子问题具备\"无后向性\"，在各阶段的子问题确定后，\n    对于特定阶段的子问题来说，它之前各个阶段的子问题的决策只影响该阶段的决策，\n    对该阶段之后的决策不产生影响。\n    \n\n思考点3 [对诸如Dijkstra、A*等经典算法生疏，对图结构生疏]\n\n\n思考点4 [由排序算法时间复杂度引出的讨论]\n\n>@5年-余努力-成都-杂家 \n\n    桶排序的平均时间复杂度为线性的O(N+C)，其中C=N*(logN-logM)。\n    如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。\n    当N=M时，就是计数排序。\n    \n   \n>@应届-乌凌-c++    \n```c++\nvoid radix_sort(int *num, int n) {\n#define MAX 65536\n\tint *temp = (int*)calloc(n, sizeof(int));\n\tint *cnt = (int*)calloc(MAX + 5, sizeof(int));\n\tfor (int i = 0; i < n; i++) {\n\t\tcnt[(num[i] & 65535) + 1] += 1;\n\t}\n\tfor (int i = 0; i < MAX; i++) cnt[i] += cnt[i - 1];\n\tfor (int i = 0; i < n; i++) {\n\t\ttemp[cnt[num[i] & 65535]++] = num[i];\n\t}\n\tmemset(cnt, 0, sizeof(int) * MAX);\n\tint *p = temp;\n\ttemp = num;\n\tnum = p;\n\tfor (int i = 0; i < n; i++) {\n\t\tcnt[((num[i] >> 16) & 65535) + 1] += 1;\n\t}\n\tfor (int i = 0; i < MAX; i++) cnt[i] += cnt[i - 1];\n\tfor (int i = 0; i < n; i++) {\n\t\ttemp[cnt[(num[i] >> 16) & 65535]++] = num[i];\n\t}\n\tfree(num);\n\tnum = temp;\n\tfree(cnt);\n#undef MAX\n}\n\n```\n\n>个人对排序的补充\n    \n    快速排序\n    归并排序\n    堆排序","slug":"热身卡02-入门测试题","published":1,"date":"2019-04-01T09:59:49.330Z","updated":"2019-04-01T09:59:49.330Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw32rpd6000fvw72c18gpoxi","content":"<p>目标</p>\n<pre><code>定位自我\n</code></pre><p>思考点1 [只是了解一般不用 == 判断浮点数相等，对于能够判断的浮点数集认识不深刻]</p>\n<pre><code>在诸如Java、C++或Python语言中，一般不用 &quot;==&quot; 判断两个浮点数相等。\n浮点数在计算机内的表达有误差，直接使用 &quot;==&quot; 来判断两个浮点数是否相等是不安全的。\n只有部分能够精确表达的浮点数，如0.0, 0.5(1/2)，0.25(1/4)等浮点数，使用 &quot;==&quot; 判断\n浮点数值相等是没问题的，其他情况则会产生意想不到的结果。\n</code></pre><p>思考点2 [动态规划和分治法的区别，增加例子来理解]</p>\n<pre><code>动态规划区别于分治法是其子问题具备&quot;无后向性&quot;，在各阶段的子问题确定后，\n对于特定阶段的子问题来说，它之前各个阶段的子问题的决策只影响该阶段的决策，\n对该阶段之后的决策不产生影响。\n</code></pre><p>思考点3 [对诸如Dijkstra、A*等经典算法生疏，对图结构生疏]</p>\n<p>思考点4 [由排序算法时间复杂度引出的讨论]</p>\n<blockquote>\n<p>@5年-余努力-成都-杂家 </p>\n</blockquote>\n<pre><code>桶排序的平均时间复杂度为线性的O(N+C)，其中C=N*(logN-logM)。\n如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。\n当N=M时，就是计数排序。\n</code></pre><blockquote>\n<p>@应届-乌凌-c++<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">radix_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> *num, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX 65536</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *temp = (<span class=\"keyword\">int</span>*)<span class=\"built_in\">calloc</span>(n, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *cnt = (<span class=\"keyword\">int</span>*)<span class=\"built_in\">calloc</span>(MAX + <span class=\"number\">5</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">\t\tcnt[(num[i] &amp; <span class=\"number\">65535</span>) + <span class=\"number\">1</span>] += <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; MAX; i++) cnt[i] += cnt[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">\t\ttemp[cnt[num[i] &amp; <span class=\"number\">65535</span>]++] = num[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(cnt, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * MAX);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *p = temp;</span><br><span class=\"line\">\ttemp = num;</span><br><span class=\"line\">\tnum = p;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">\t\tcnt[((num[i] &gt;&gt; <span class=\"number\">16</span>) &amp; <span class=\"number\">65535</span>) + <span class=\"number\">1</span>] += <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; MAX; i++) cnt[i] += cnt[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">\t\ttemp[cnt[(num[i] &gt;&gt; <span class=\"number\">16</span>) &amp; <span class=\"number\">65535</span>]++] = num[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(num);</span><br><span class=\"line\">\tnum = temp;</span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(cnt);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">undef</span> MAX</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>个人对排序的补充</p>\n</blockquote>\n<pre><code>快速排序\n归并排序\n堆排序\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>目标</p>\n<pre><code>定位自我\n</code></pre><p>思考点1 [只是了解一般不用 == 判断浮点数相等，对于能够判断的浮点数集认识不深刻]</p>\n<pre><code>在诸如Java、C++或Python语言中，一般不用 &quot;==&quot; 判断两个浮点数相等。\n浮点数在计算机内的表达有误差，直接使用 &quot;==&quot; 来判断两个浮点数是否相等是不安全的。\n只有部分能够精确表达的浮点数，如0.0, 0.5(1/2)，0.25(1/4)等浮点数，使用 &quot;==&quot; 判断\n浮点数值相等是没问题的，其他情况则会产生意想不到的结果。\n</code></pre><p>思考点2 [动态规划和分治法的区别，增加例子来理解]</p>\n<pre><code>动态规划区别于分治法是其子问题具备&quot;无后向性&quot;，在各阶段的子问题确定后，\n对于特定阶段的子问题来说，它之前各个阶段的子问题的决策只影响该阶段的决策，\n对该阶段之后的决策不产生影响。\n</code></pre><p>思考点3 [对诸如Dijkstra、A*等经典算法生疏，对图结构生疏]</p>\n<p>思考点4 [由排序算法时间复杂度引出的讨论]</p>\n<blockquote>\n<p>@5年-余努力-成都-杂家 </p>\n</blockquote>\n<pre><code>桶排序的平均时间复杂度为线性的O(N+C)，其中C=N*(logN-logM)。\n如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。\n当N=M时，就是计数排序。\n</code></pre><blockquote>\n<p>@应届-乌凌-c++<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">radix_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> *num, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX 65536</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *temp = (<span class=\"keyword\">int</span>*)<span class=\"built_in\">calloc</span>(n, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *cnt = (<span class=\"keyword\">int</span>*)<span class=\"built_in\">calloc</span>(MAX + <span class=\"number\">5</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">\t\tcnt[(num[i] &amp; <span class=\"number\">65535</span>) + <span class=\"number\">1</span>] += <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; MAX; i++) cnt[i] += cnt[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">\t\ttemp[cnt[num[i] &amp; <span class=\"number\">65535</span>]++] = num[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(cnt, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * MAX);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *p = temp;</span><br><span class=\"line\">\ttemp = num;</span><br><span class=\"line\">\tnum = p;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">\t\tcnt[((num[i] &gt;&gt; <span class=\"number\">16</span>) &amp; <span class=\"number\">65535</span>) + <span class=\"number\">1</span>] += <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; MAX; i++) cnt[i] += cnt[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">\t\ttemp[cnt[(num[i] &gt;&gt; <span class=\"number\">16</span>) &amp; <span class=\"number\">65535</span>]++] = num[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(num);</span><br><span class=\"line\">\tnum = temp;</span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(cnt);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">undef</span> MAX</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>个人对排序的补充</p>\n</blockquote>\n<pre><code>快速排序\n归并排序\n堆排序\n</code></pre>"},{"title":"开营仪式","_content":"\n什么是算法\n    \n    任何一个解决问题的方法都不会凭空出现，\n    而在计算机中解决问题的方法统称为算法。\n    \n    一系列的数学计算或解题步骤，\n    算法存在的意义是解决问题，\n    软件开发工作着的日常就是开发各种能够解决问题的算法。\n    \n    算法并非不食人间烟火之物，\n    更不是ACM竞赛选手的特权，\n    大部分人在工作中遇到的问题并非像ACM竞赛那样的难题。\n    \n\n算法的作用：\n\n    编程能力大致体现在，\n    逻辑思维能力、\n    抽象建模能力、\n    编程方法和技巧，\n    都需要通过实践获得。\n    \n    时间复杂度，\n    空间复杂度，\n    计算效率，\n    计算过程对其他模块的影响。\n\n\n开营的目的：\n    \n    掌握设计算法的方法与技巧\n    \n    也是软件开发人员必备的条件\n        \n    掌握常用设计模式\n    \n    在练习中积累经验\n    \n分类：\n    \n    1. 已知的并有成熟或高效的实现方法\n    2. 只有理论但是没有具体实现的算法，\n       需要掌握算法原理，翻译成代码实现。\n        遗传算法，基本思想 迭代法，\n        根据迭代中的遗传和变异，\n        淘汰掉不符合的个体，\n        得到优良的种群。\n        不同的问题针对基因有不同的建模，\n        需要根据算法的原理，基因的不同，方法的实现进行调整。\n    3. 工作中遇见的实际问题，\n       或竞赛中具有针对性的问题\n        需要掌握常用的算法模式。\n        文字信息数字化。\n    \n课后练习：\n    \n    针对知识点设计的练习题，要按时按量完成。\n\n\n学习强度高，跟着走，坚持\n\n    长风破浪会有时，直挂云帆济沧海\n    动手能力\n    解决问题的能力","source":"_posts/开营仪式.md","raw":"---\ntitle: 开营仪式\n---\n\n什么是算法\n    \n    任何一个解决问题的方法都不会凭空出现，\n    而在计算机中解决问题的方法统称为算法。\n    \n    一系列的数学计算或解题步骤，\n    算法存在的意义是解决问题，\n    软件开发工作着的日常就是开发各种能够解决问题的算法。\n    \n    算法并非不食人间烟火之物，\n    更不是ACM竞赛选手的特权，\n    大部分人在工作中遇到的问题并非像ACM竞赛那样的难题。\n    \n\n算法的作用：\n\n    编程能力大致体现在，\n    逻辑思维能力、\n    抽象建模能力、\n    编程方法和技巧，\n    都需要通过实践获得。\n    \n    时间复杂度，\n    空间复杂度，\n    计算效率，\n    计算过程对其他模块的影响。\n\n\n开营的目的：\n    \n    掌握设计算法的方法与技巧\n    \n    也是软件开发人员必备的条件\n        \n    掌握常用设计模式\n    \n    在练习中积累经验\n    \n分类：\n    \n    1. 已知的并有成熟或高效的实现方法\n    2. 只有理论但是没有具体实现的算法，\n       需要掌握算法原理，翻译成代码实现。\n        遗传算法，基本思想 迭代法，\n        根据迭代中的遗传和变异，\n        淘汰掉不符合的个体，\n        得到优良的种群。\n        不同的问题针对基因有不同的建模，\n        需要根据算法的原理，基因的不同，方法的实现进行调整。\n    3. 工作中遇见的实际问题，\n       或竞赛中具有针对性的问题\n        需要掌握常用的算法模式。\n        文字信息数字化。\n    \n课后练习：\n    \n    针对知识点设计的练习题，要按时按量完成。\n\n\n学习强度高，跟着走，坚持\n\n    长风破浪会有时，直挂云帆济沧海\n    动手能力\n    解决问题的能力","slug":"开营仪式","published":1,"date":"2019-04-01T13:59:00.284Z","updated":"2019-04-01T13:59:00.284Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw32rpd7000gvw72yrb5c8o7","content":"<p>什么是算法</p>\n<pre><code>任何一个解决问题的方法都不会凭空出现，\n而在计算机中解决问题的方法统称为算法。\n\n一系列的数学计算或解题步骤，\n算法存在的意义是解决问题，\n软件开发工作着的日常就是开发各种能够解决问题的算法。\n\n算法并非不食人间烟火之物，\n更不是ACM竞赛选手的特权，\n大部分人在工作中遇到的问题并非像ACM竞赛那样的难题。\n</code></pre><p>算法的作用：</p>\n<pre><code>编程能力大致体现在，\n逻辑思维能力、\n抽象建模能力、\n编程方法和技巧，\n都需要通过实践获得。\n\n时间复杂度，\n空间复杂度，\n计算效率，\n计算过程对其他模块的影响。\n</code></pre><p>开营的目的：</p>\n<pre><code>掌握设计算法的方法与技巧\n\n也是软件开发人员必备的条件\n\n掌握常用设计模式\n\n在练习中积累经验\n</code></pre><p>分类：</p>\n<pre><code>1. 已知的并有成熟或高效的实现方法\n2. 只有理论但是没有具体实现的算法，\n   需要掌握算法原理，翻译成代码实现。\n    遗传算法，基本思想 迭代法，\n    根据迭代中的遗传和变异，\n    淘汰掉不符合的个体，\n    得到优良的种群。\n    不同的问题针对基因有不同的建模，\n    需要根据算法的原理，基因的不同，方法的实现进行调整。\n3. 工作中遇见的实际问题，\n   或竞赛中具有针对性的问题\n    需要掌握常用的算法模式。\n    文字信息数字化。\n</code></pre><p>课后练习：</p>\n<pre><code>针对知识点设计的练习题，要按时按量完成。\n</code></pre><p>学习强度高，跟着走，坚持</p>\n<pre><code>长风破浪会有时，直挂云帆济沧海\n动手能力\n解决问题的能力\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>什么是算法</p>\n<pre><code>任何一个解决问题的方法都不会凭空出现，\n而在计算机中解决问题的方法统称为算法。\n\n一系列的数学计算或解题步骤，\n算法存在的意义是解决问题，\n软件开发工作着的日常就是开发各种能够解决问题的算法。\n\n算法并非不食人间烟火之物，\n更不是ACM竞赛选手的特权，\n大部分人在工作中遇到的问题并非像ACM竞赛那样的难题。\n</code></pre><p>算法的作用：</p>\n<pre><code>编程能力大致体现在，\n逻辑思维能力、\n抽象建模能力、\n编程方法和技巧，\n都需要通过实践获得。\n\n时间复杂度，\n空间复杂度，\n计算效率，\n计算过程对其他模块的影响。\n</code></pre><p>开营的目的：</p>\n<pre><code>掌握设计算法的方法与技巧\n\n也是软件开发人员必备的条件\n\n掌握常用设计模式\n\n在练习中积累经验\n</code></pre><p>分类：</p>\n<pre><code>1. 已知的并有成熟或高效的实现方法\n2. 只有理论但是没有具体实现的算法，\n   需要掌握算法原理，翻译成代码实现。\n    遗传算法，基本思想 迭代法，\n    根据迭代中的遗传和变异，\n    淘汰掉不符合的个体，\n    得到优良的种群。\n    不同的问题针对基因有不同的建模，\n    需要根据算法的原理，基因的不同，方法的实现进行调整。\n3. 工作中遇见的实际问题，\n   或竞赛中具有针对性的问题\n    需要掌握常用的算法模式。\n    文字信息数字化。\n</code></pre><p>课后练习：</p>\n<pre><code>针对知识点设计的练习题，要按时按量完成。\n</code></pre><p>学习强度高，跟着走，坚持</p>\n<pre><code>长风破浪会有时，直挂云帆济沧海\n动手能力\n解决问题的能力\n</code></pre>"},{"title":"装配线与工作站问题","_content":"","source":"_posts/穷举搜索卡01.md","raw":"---\ntitle: 装配线与工作站问题\n---\n","slug":"穷举搜索卡01","published":1,"date":"2019-04-06T12:51:21.328Z","updated":"2019-04-06T12:51:21.328Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw32rpd8000hvw72ao9c3p6l","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"过河","_content":"\n问题描述：\n\n    农夫需要把狼、羊、菜和自己运到河对岸去，\n    只有农夫能够划船，而且船比较小，\n    除农夫之外每次只能运一种东西，\n    还有一个棘手的问题，就是如果没有农夫看着，\n    羊会偷吃菜，狼会吃羊。\n    请考虑一种方法，\n    让农夫能够安全地安排这些东西和他自己过河。\n    \n\n主要思路：\n    \n    在狼、羊和菜这个食物链上，\n    关键是中间的羊，因为狼不吃菜，\n    所以要安全过河，\n    农夫的第一件事就是带羊走，\n    拆开这个食物链。\n    \n目标：\n    \n    [0,0,0,0] -> [1,1,1,1]\n\n过程：\n\n    [0,0,0,0]\n    [1,0,1,0]\n    [0,0,1,0]\n    [1,1,1,0]\n    [0,1,0,0]\n    [1,1,0,1]\n    [0,1,0,1]\n    [1,1,1,1]\n","source":"_posts/穷举搜索卡03.md","raw":"---\ntitle: 过河\n---\n\n问题描述：\n\n    农夫需要把狼、羊、菜和自己运到河对岸去，\n    只有农夫能够划船，而且船比较小，\n    除农夫之外每次只能运一种东西，\n    还有一个棘手的问题，就是如果没有农夫看着，\n    羊会偷吃菜，狼会吃羊。\n    请考虑一种方法，\n    让农夫能够安全地安排这些东西和他自己过河。\n    \n\n主要思路：\n    \n    在狼、羊和菜这个食物链上，\n    关键是中间的羊，因为狼不吃菜，\n    所以要安全过河，\n    农夫的第一件事就是带羊走，\n    拆开这个食物链。\n    \n目标：\n    \n    [0,0,0,0] -> [1,1,1,1]\n\n过程：\n\n    [0,0,0,0]\n    [1,0,1,0]\n    [0,0,1,0]\n    [1,1,1,0]\n    [0,1,0,0]\n    [1,1,0,1]\n    [0,1,0,1]\n    [1,1,1,1]\n","slug":"穷举搜索卡03","published":1,"date":"2019-04-07T13:13:35.552Z","updated":"2019-04-07T13:13:35.552Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw32rpd9000ivw720etoyb4v","content":"<p>问题描述：</p>\n<pre><code>农夫需要把狼、羊、菜和自己运到河对岸去，\n只有农夫能够划船，而且船比较小，\n除农夫之外每次只能运一种东西，\n还有一个棘手的问题，就是如果没有农夫看着，\n羊会偷吃菜，狼会吃羊。\n请考虑一种方法，\n让农夫能够安全地安排这些东西和他自己过河。\n</code></pre><p>主要思路：</p>\n<pre><code>在狼、羊和菜这个食物链上，\n关键是中间的羊，因为狼不吃菜，\n所以要安全过河，\n农夫的第一件事就是带羊走，\n拆开这个食物链。\n</code></pre><p>目标：</p>\n<pre><code>[0,0,0,0] -&gt; [1,1,1,1]\n</code></pre><p>过程：</p>\n<pre><code>[0,0,0,0]\n[1,0,1,0]\n[0,0,1,0]\n[1,1,1,0]\n[0,1,0,0]\n[1,1,0,1]\n[0,1,0,1]\n[1,1,1,1]\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>问题描述：</p>\n<pre><code>农夫需要把狼、羊、菜和自己运到河对岸去，\n只有农夫能够划船，而且船比较小，\n除农夫之外每次只能运一种东西，\n还有一个棘手的问题，就是如果没有农夫看着，\n羊会偷吃菜，狼会吃羊。\n请考虑一种方法，\n让农夫能够安全地安排这些东西和他自己过河。\n</code></pre><p>主要思路：</p>\n<pre><code>在狼、羊和菜这个食物链上，\n关键是中间的羊，因为狼不吃菜，\n所以要安全过河，\n农夫的第一件事就是带羊走，\n拆开这个食物链。\n</code></pre><p>目标：</p>\n<pre><code>[0,0,0,0] -&gt; [1,1,1,1]\n</code></pre><p>过程：</p>\n<pre><code>[0,0,0,0]\n[1,0,1,0]\n[0,0,1,0]\n[1,1,1,0]\n[0,1,0,0]\n[1,1,0,1]\n[0,1,0,1]\n[1,1,1,1]\n</code></pre>"},{"title":"24点计数器","_content":"\n问题描述：\n    \n    任给四个小于10的数，\n    对四个数字用各种组合\n    进行加、减、乘、除四则运算，\n    看看结果是否能等于 24？\n\n\n\n策略：\n    \n    穷举法+分治法\n\n分治：\n    \n    原始问题的规模是 4 个数字计算 24 点，\n    那么分解子问题可以从两个方向考虑：\n    一种是只考虑减少问题的规模，\n    对于这个问题来说，\n    减少规模不就是变成 3 个数字计算 24 点吗？\n    然后再减少为两个数字计算 24 点，\n    以此类推，直到问题能够直接求解为止；\n    另一种是在减少问题规模的同时，\n    调整结果的范围，同样，对这个问题来说，\n    假如说我将问题规模从 4 个变成 3 个，\n    被排除的数字是 3，那么子问题就应该变成\n    “3 个数字计算 21 点”。\n    进一步将问题规模减少成两个数字时，\n    假如被排除的数字是 7，\n    则子问题就变成“2 个数字计算 14 点”，\n    以此类推，直到问题能直接解决为止。\n\n\n以空间换时间","source":"_posts/穷举搜索卡04.md","raw":"---\ntitle: 24点计数器\n---\n\n问题描述：\n    \n    任给四个小于10的数，\n    对四个数字用各种组合\n    进行加、减、乘、除四则运算，\n    看看结果是否能等于 24？\n\n\n\n策略：\n    \n    穷举法+分治法\n\n分治：\n    \n    原始问题的规模是 4 个数字计算 24 点，\n    那么分解子问题可以从两个方向考虑：\n    一种是只考虑减少问题的规模，\n    对于这个问题来说，\n    减少规模不就是变成 3 个数字计算 24 点吗？\n    然后再减少为两个数字计算 24 点，\n    以此类推，直到问题能够直接求解为止；\n    另一种是在减少问题规模的同时，\n    调整结果的范围，同样，对这个问题来说，\n    假如说我将问题规模从 4 个变成 3 个，\n    被排除的数字是 3，那么子问题就应该变成\n    “3 个数字计算 21 点”。\n    进一步将问题规模减少成两个数字时，\n    假如被排除的数字是 7，\n    则子问题就变成“2 个数字计算 14 点”，\n    以此类推，直到问题能直接解决为止。\n\n\n以空间换时间","slug":"穷举搜索卡04","published":1,"date":"2019-04-07T13:25:09.670Z","updated":"2019-04-07T13:25:09.670Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw32rpda000jvw72pbzgtgzq","content":"<p>问题描述：</p>\n<pre><code>任给四个小于10的数，\n对四个数字用各种组合\n进行加、减、乘、除四则运算，\n看看结果是否能等于 24？\n</code></pre><p>策略：</p>\n<pre><code>穷举法+分治法\n</code></pre><p>分治：</p>\n<pre><code>原始问题的规模是 4 个数字计算 24 点，\n那么分解子问题可以从两个方向考虑：\n一种是只考虑减少问题的规模，\n对于这个问题来说，\n减少规模不就是变成 3 个数字计算 24 点吗？\n然后再减少为两个数字计算 24 点，\n以此类推，直到问题能够直接求解为止；\n另一种是在减少问题规模的同时，\n调整结果的范围，同样，对这个问题来说，\n假如说我将问题规模从 4 个变成 3 个，\n被排除的数字是 3，那么子问题就应该变成\n“3 个数字计算 21 点”。\n进一步将问题规模减少成两个数字时，\n假如被排除的数字是 7，\n则子问题就变成“2 个数字计算 14 点”，\n以此类推，直到问题能直接解决为止。\n</code></pre><p>以空间换时间</p>\n","site":{"data":{}},"excerpt":"","more":"<p>问题描述：</p>\n<pre><code>任给四个小于10的数，\n对四个数字用各种组合\n进行加、减、乘、除四则运算，\n看看结果是否能等于 24？\n</code></pre><p>策略：</p>\n<pre><code>穷举法+分治法\n</code></pre><p>分治：</p>\n<pre><code>原始问题的规模是 4 个数字计算 24 点，\n那么分解子问题可以从两个方向考虑：\n一种是只考虑减少问题的规模，\n对于这个问题来说，\n减少规模不就是变成 3 个数字计算 24 点吗？\n然后再减少为两个数字计算 24 点，\n以此类推，直到问题能够直接求解为止；\n另一种是在减少问题规模的同时，\n调整结果的范围，同样，对这个问题来说，\n假如说我将问题规模从 4 个变成 3 个，\n被排除的数字是 3，那么子问题就应该变成\n“3 个数字计算 21 点”。\n进一步将问题规模减少成两个数字时，\n假如被排除的数字是 7，\n则子问题就变成“2 个数字计算 14 点”，\n以此类推，直到问题能直接解决为止。\n</code></pre><p>以空间换时间</p>\n"},{"title":"3个桶等分8升水","_content":"\n给出容量分别为8、5和3升的桶，需要等分成2个4升水。\n    \n    [8,0,0]\n    [3,5,0] [5,0,3] [3,5,0]\n    [3,2,3] [0,5,3] [0,5,3]\n    [6,2,0] [3,5,0]\n    [6,0,2] [3,2,3]\n    [1,5,2]\n    [1,4,3]\n    [4,4,0]\n    \n    \n```python\nfrom collections import deque\n\n\nclass WaterStatus(object):\n    def __init__(self, limit, water):\n        self.limit = limit  # 最大容量\n        self.water = water  # 装水容量\n\n\ndef change_water(src: WaterStatus, dst: WaterStatus):\n    if src.water == 0 or dst.water == dst.limit:\n        water = 0\n    if src.water >= dst.limit - dst.water:\n        water = dst.limit - dst.water\n    else:\n        water = src.water\n    src.water -= water\n    dst.water += water\n\n\nif __name__ == '__main__':\n    a = WaterStatus(8, 8)\n    b = WaterStatus(5, 0)\n    c = WaterStatus(3, 0)\n    water_list = [a, b, c]\n    # 队列\n    water_queue = deque()\n    water_queue.append([8, 0, 0])\n\n    cur_status = []\n    cnt = 1\n    while True:\n        print('***第 %d 次循环***' % cnt)\n        cnt += 1\n        if [4, 4, 0] == cur_status:\n            print('find it!')\n            break\n        for water1 in water_list:\n            for water2 in water_list:\n                # 记录当前状态，深拷贝deepcopy，创建新的对象\n                cur_status = list(water_queue[-1])\n                water_list[0].water = cur_status[0]\n                water_list[1].water = cur_status[1]\n                water_list[2].water = cur_status[2]\n                # print water_list[0].water, water_list[1].water, water_list[2].water\n                # 计算一次迁移\n                if water1.limit != water2.limit:\n                    change_water(water1, water2)\n                    next_status = [water_list[0].water, water_list[1].water, water_list[2].water]\n                    # print 'next_status' , next_status\n                    if next_status in water_queue:\n                        # print '迁移后的状态在记录中存在，将当前状态转到迁移之前的状态'\n                        pass\n                    else:\n                        # print '记录迁移后的状态,一定要用list()来新建一个对象'\n                        cur_status = next_status\n                        water_queue.append(list(next_status))\n                    # print water1.limit , water2.limit, cur_status\n                    print('---', water_queue)\n\n```","source":"_posts/穷举搜索卡02.md","raw":"---\ntitle: 3个桶等分8升水\n---\n\n给出容量分别为8、5和3升的桶，需要等分成2个4升水。\n    \n    [8,0,0]\n    [3,5,0] [5,0,3] [3,5,0]\n    [3,2,3] [0,5,3] [0,5,3]\n    [6,2,0] [3,5,0]\n    [6,0,2] [3,2,3]\n    [1,5,2]\n    [1,4,3]\n    [4,4,0]\n    \n    \n```python\nfrom collections import deque\n\n\nclass WaterStatus(object):\n    def __init__(self, limit, water):\n        self.limit = limit  # 最大容量\n        self.water = water  # 装水容量\n\n\ndef change_water(src: WaterStatus, dst: WaterStatus):\n    if src.water == 0 or dst.water == dst.limit:\n        water = 0\n    if src.water >= dst.limit - dst.water:\n        water = dst.limit - dst.water\n    else:\n        water = src.water\n    src.water -= water\n    dst.water += water\n\n\nif __name__ == '__main__':\n    a = WaterStatus(8, 8)\n    b = WaterStatus(5, 0)\n    c = WaterStatus(3, 0)\n    water_list = [a, b, c]\n    # 队列\n    water_queue = deque()\n    water_queue.append([8, 0, 0])\n\n    cur_status = []\n    cnt = 1\n    while True:\n        print('***第 %d 次循环***' % cnt)\n        cnt += 1\n        if [4, 4, 0] == cur_status:\n            print('find it!')\n            break\n        for water1 in water_list:\n            for water2 in water_list:\n                # 记录当前状态，深拷贝deepcopy，创建新的对象\n                cur_status = list(water_queue[-1])\n                water_list[0].water = cur_status[0]\n                water_list[1].water = cur_status[1]\n                water_list[2].water = cur_status[2]\n                # print water_list[0].water, water_list[1].water, water_list[2].water\n                # 计算一次迁移\n                if water1.limit != water2.limit:\n                    change_water(water1, water2)\n                    next_status = [water_list[0].water, water_list[1].water, water_list[2].water]\n                    # print 'next_status' , next_status\n                    if next_status in water_queue:\n                        # print '迁移后的状态在记录中存在，将当前状态转到迁移之前的状态'\n                        pass\n                    else:\n                        # print '记录迁移后的状态,一定要用list()来新建一个对象'\n                        cur_status = next_status\n                        water_queue.append(list(next_status))\n                    # print water1.limit , water2.limit, cur_status\n                    print('---', water_queue)\n\n```","slug":"穷举搜索卡02","published":1,"date":"2019-04-06T14:09:12.518Z","updated":"2019-04-06T14:09:12.518Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw32rpdb000kvw72f14nbw5q","content":"<p>给出容量分别为8、5和3升的桶，需要等分成2个4升水。</p>\n<pre><code>[8,0,0]\n[3,5,0] [5,0,3] [3,5,0]\n[3,2,3] [0,5,3] [0,5,3]\n[6,2,0] [3,5,0]\n[6,0,2] [3,2,3]\n[1,5,2]\n[1,4,3]\n[4,4,0]\n</code></pre><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> deque</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WaterStatus</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, limit, water)</span>:</span></span><br><span class=\"line\">        self.limit = limit  <span class=\"comment\"># 最大容量</span></span><br><span class=\"line\">        self.water = water  <span class=\"comment\"># 装水容量</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">change_water</span><span class=\"params\">(src: WaterStatus, dst: WaterStatus)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> src.water == <span class=\"number\">0</span> <span class=\"keyword\">or</span> dst.water == dst.limit:</span><br><span class=\"line\">        water = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> src.water &gt;= dst.limit - dst.water:</span><br><span class=\"line\">        water = dst.limit - dst.water</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        water = src.water</span><br><span class=\"line\">    src.water -= water</span><br><span class=\"line\">    dst.water += water</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    a = WaterStatus(<span class=\"number\">8</span>, <span class=\"number\">8</span>)</span><br><span class=\"line\">    b = WaterStatus(<span class=\"number\">5</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    c = WaterStatus(<span class=\"number\">3</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    water_list = [a, b, c]</span><br><span class=\"line\">    <span class=\"comment\"># 队列</span></span><br><span class=\"line\">    water_queue = deque()</span><br><span class=\"line\">    water_queue.append([<span class=\"number\">8</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    cur_status = []</span><br><span class=\"line\">    cnt = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">        print(<span class=\"string\">'***第 %d 次循环***'</span> % cnt)</span><br><span class=\"line\">        cnt += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> [<span class=\"number\">4</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>] == cur_status:</span><br><span class=\"line\">            print(<span class=\"string\">'find it!'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> water1 <span class=\"keyword\">in</span> water_list:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> water2 <span class=\"keyword\">in</span> water_list:</span><br><span class=\"line\">                <span class=\"comment\"># 记录当前状态，深拷贝deepcopy，创建新的对象</span></span><br><span class=\"line\">                cur_status = list(water_queue[<span class=\"number\">-1</span>])</span><br><span class=\"line\">                water_list[<span class=\"number\">0</span>].water = cur_status[<span class=\"number\">0</span>]</span><br><span class=\"line\">                water_list[<span class=\"number\">1</span>].water = cur_status[<span class=\"number\">1</span>]</span><br><span class=\"line\">                water_list[<span class=\"number\">2</span>].water = cur_status[<span class=\"number\">2</span>]</span><br><span class=\"line\">                <span class=\"comment\"># print water_list[0].water, water_list[1].water, water_list[2].water</span></span><br><span class=\"line\">                <span class=\"comment\"># 计算一次迁移</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> water1.limit != water2.limit:</span><br><span class=\"line\">                    change_water(water1, water2)</span><br><span class=\"line\">                    next_status = [water_list[<span class=\"number\">0</span>].water, water_list[<span class=\"number\">1</span>].water, water_list[<span class=\"number\">2</span>].water]</span><br><span class=\"line\">                    <span class=\"comment\"># print 'next_status' , next_status</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> next_status <span class=\"keyword\">in</span> water_queue:</span><br><span class=\"line\">                        <span class=\"comment\"># print '迁移后的状态在记录中存在，将当前状态转到迁移之前的状态'</span></span><br><span class=\"line\">                        <span class=\"keyword\">pass</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                        <span class=\"comment\"># print '记录迁移后的状态,一定要用list()来新建一个对象'</span></span><br><span class=\"line\">                        cur_status = next_status</span><br><span class=\"line\">                        water_queue.append(list(next_status))</span><br><span class=\"line\">                    <span class=\"comment\"># print water1.limit , water2.limit, cur_status</span></span><br><span class=\"line\">                    print(<span class=\"string\">'---'</span>, water_queue)</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>给出容量分别为8、5和3升的桶，需要等分成2个4升水。</p>\n<pre><code>[8,0,0]\n[3,5,0] [5,0,3] [3,5,0]\n[3,2,3] [0,5,3] [0,5,3]\n[6,2,0] [3,5,0]\n[6,0,2] [3,2,3]\n[1,5,2]\n[1,4,3]\n[4,4,0]\n</code></pre><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> deque</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WaterStatus</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, limit, water)</span>:</span></span><br><span class=\"line\">        self.limit = limit  <span class=\"comment\"># 最大容量</span></span><br><span class=\"line\">        self.water = water  <span class=\"comment\"># 装水容量</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">change_water</span><span class=\"params\">(src: WaterStatus, dst: WaterStatus)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> src.water == <span class=\"number\">0</span> <span class=\"keyword\">or</span> dst.water == dst.limit:</span><br><span class=\"line\">        water = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> src.water &gt;= dst.limit - dst.water:</span><br><span class=\"line\">        water = dst.limit - dst.water</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        water = src.water</span><br><span class=\"line\">    src.water -= water</span><br><span class=\"line\">    dst.water += water</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    a = WaterStatus(<span class=\"number\">8</span>, <span class=\"number\">8</span>)</span><br><span class=\"line\">    b = WaterStatus(<span class=\"number\">5</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    c = WaterStatus(<span class=\"number\">3</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    water_list = [a, b, c]</span><br><span class=\"line\">    <span class=\"comment\"># 队列</span></span><br><span class=\"line\">    water_queue = deque()</span><br><span class=\"line\">    water_queue.append([<span class=\"number\">8</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    cur_status = []</span><br><span class=\"line\">    cnt = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">        print(<span class=\"string\">'***第 %d 次循环***'</span> % cnt)</span><br><span class=\"line\">        cnt += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> [<span class=\"number\">4</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>] == cur_status:</span><br><span class=\"line\">            print(<span class=\"string\">'find it!'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> water1 <span class=\"keyword\">in</span> water_list:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> water2 <span class=\"keyword\">in</span> water_list:</span><br><span class=\"line\">                <span class=\"comment\"># 记录当前状态，深拷贝deepcopy，创建新的对象</span></span><br><span class=\"line\">                cur_status = list(water_queue[<span class=\"number\">-1</span>])</span><br><span class=\"line\">                water_list[<span class=\"number\">0</span>].water = cur_status[<span class=\"number\">0</span>]</span><br><span class=\"line\">                water_list[<span class=\"number\">1</span>].water = cur_status[<span class=\"number\">1</span>]</span><br><span class=\"line\">                water_list[<span class=\"number\">2</span>].water = cur_status[<span class=\"number\">2</span>]</span><br><span class=\"line\">                <span class=\"comment\"># print water_list[0].water, water_list[1].water, water_list[2].water</span></span><br><span class=\"line\">                <span class=\"comment\"># 计算一次迁移</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> water1.limit != water2.limit:</span><br><span class=\"line\">                    change_water(water1, water2)</span><br><span class=\"line\">                    next_status = [water_list[<span class=\"number\">0</span>].water, water_list[<span class=\"number\">1</span>].water, water_list[<span class=\"number\">2</span>].water]</span><br><span class=\"line\">                    <span class=\"comment\"># print 'next_status' , next_status</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> next_status <span class=\"keyword\">in</span> water_queue:</span><br><span class=\"line\">                        <span class=\"comment\"># print '迁移后的状态在记录中存在，将当前状态转到迁移之前的状态'</span></span><br><span class=\"line\">                        <span class=\"keyword\">pass</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                        <span class=\"comment\"># print '记录迁移后的状态,一定要用list()来新建一个对象'</span></span><br><span class=\"line\">                        cur_status = next_status</span><br><span class=\"line\">                        water_queue.append(list(next_status))</span><br><span class=\"line\">                    <span class=\"comment\"># print water1.limit , water2.limit, cur_status</span></span><br><span class=\"line\">                    print(<span class=\"string\">'---'</span>, water_queue)</span><br></pre></td></tr></table></figure>"},{"title":"爱因斯坦的思考题 下","_content":"\n穷举来源\n    \n    每个状态有 5 个类型\n    每个类型又要对 5 个值进行排列组合\n\n穷举实现\n    \n    根据状态分布，有3个类型是有值在固定位置的\n    则对于国籍需要对4个位置进行排列\n    对于颜色 由于5间房子排成一排\n    所以 蓝色固定在第二间房 \n    而 绿和白存在绑定关系 则对3个位置进行排列\n    对于饮料 住中间位置的人 喝牛奶\n    则需要对 4 个位置进行排列\n    \n    剪枝操作 --。感觉智商不够用\n\n\n使用Python语言实现 \n```python\nfrom itertools import permutations\nfrom copy import deepcopy\n\n#  房子      国籍     饮料     宠物     烟\n# 初始化5个组 用以代表5个人以及5个属性\nmap_info = [\n    [''] * 5 for _ in range(5)\n]\n\n# 根据线索9 得到\nmap_info[0][1] = '挪威'\n\n# 根据 房间排成一排 与线索14 得到\nmap_info[1][0] = '蓝色'\n\n# 根据 线索8 得到\nmap_info[2][2] = '牛奶'\n\n# 线索绑定 s4 得到 绿色白色为一体\n# 并且只能在2，3 或3，4位置，0开始\n# s1 = ['红色', '英国', '', '', '']\n# s2 = ['', '瑞典', '', '狗', '']\n# s3 = ['', '丹麦', '茶', '', '']\n# s5 = ['绿色', '', '咖啡', '', '']\n# s6 = ['', '', '', '鸟', 'PallMall']\n# s7 = ['黄色', '', '', '', 'Dunhill']\n# s12 = ['', '', '啤酒', '', 'BlueMaster']\n# s13 = ['', '德国', '', '', 'Prince']\n\n#    # s11 10, 15\n\n# 从颜色开始，绿白只能或3，4位置 绿房 喝 咖啡\n# 2位置已经固定为牛奶了 s5\nmap_info[3][0] = '绿色'\nmap_info[3][2] = '咖啡'\nmap_info[4][0] = '白色'\n\n# 结合国籍看 那么剩下颜色中间位置\nmap_info[2][0] = '红色'\nmap_info[2][1] = '英国'\nmap_info[0][0] = '黄色'\n# print(map_info)\n# todo ---以上 颜色排列完整\n\n# s7 绑定 Dunhill\nmap_info[0][4] = 'Dunhill'\n# s11 养马的人和抽 Dunhill 牌香烟的人相邻\nmap_info[1][3] = '马'\n# print(map_info)\n\n\n# 对剩下的7个线索做为消费数据对象\n# 对剩下的4个类型作为排列对象生产数据\n\n\n# 消费数据\ndef check(map_info_test):\n    for i in range(5):\n\n        if map_info_test[i][1] == '瑞典' and map_info_test[i][3] != '狗':\n            return False\n        if map_info_test[i][1] == '丹麦' and map_info_test[i][2] != '茶':\n            return False\n        if map_info_test[i][3] == '鸟' and map_info_test[i][4] != 'PallMall':\n            return False\n        if map_info_test[i][2] == '啤酒' and map_info_test[i][4] != 'BlueMaster':\n            return False\n        if map_info_test[i][1] == '德国' and map_info_test[i][4] != 'Prince':\n            return False\n        if map_info_test[i][4] == 'Blends':\n            status = False\n            try:\n                if map_info_test[i - 1][3] == '猫':\n                    status = True\n            except:\n                pass\n            try:\n                if map_info_test[i + 1][3] == '猫':\n                    status = True\n            except:\n                pass\n            if status is False:\n                return False\n\n        if map_info_test[i][4] == 'Blends':\n\n            status = False\n            try:\n                if map_info_test[i - 1][2] == '水':\n                    status = True\n            except:\n                pass\n            try:\n                if map_info_test[i + 1][2] == '水':\n                    status = True\n            except:\n                pass\n            if status is False:\n                return False\n    # 通过校验\n    return True\n\n\n# 生产数据\n\"\"\"\n1. 国籍 1，3，4 -- 丹麦、德国、瑞典\n2. 饮料 0，1，4 -- 水、茶、啤酒\n3. 宠物 0，2，3，4 -- 猫、鸟、鱼、狗\n4. 烟 1，2，3，4 -- Blends、PallMall、Prince、BlueMaster\n\"\"\"\n\nres = []\nfor g in permutations({'丹麦', '德国', '瑞典'}, 3):\n    map_info[1][1], map_info[3][1], map_info[4][1] = g\n    # print(map_info)\n\n    for yl in permutations({'水', '茶', ' 啤酒'}, 3):\n        map_info[0][2], map_info[1][2], map_info[4][2] = yl\n\n        for c in permutations({'猫', '鸟', '鱼', '狗'}, 4):\n            map_info[0][3], map_info[2][3], map_info[3][3], map_info[4][3] = c\n\n            for y in permutations({'Blends', 'PallMall', 'Prince', 'BlueMaster'}, 4):\n                map_info[1][4], map_info[2][4], map_info[3][4], map_info[4][4] = y\n\n                if check(map_info):\n                    res.append(deepcopy(map_info))\n\nfor r in res:\n    print(r)\n\n```","source":"_posts/穷举搜索法06.md","raw":"---\ntitle: 爱因斯坦的思考题 下\n---\n\n穷举来源\n    \n    每个状态有 5 个类型\n    每个类型又要对 5 个值进行排列组合\n\n穷举实现\n    \n    根据状态分布，有3个类型是有值在固定位置的\n    则对于国籍需要对4个位置进行排列\n    对于颜色 由于5间房子排成一排\n    所以 蓝色固定在第二间房 \n    而 绿和白存在绑定关系 则对3个位置进行排列\n    对于饮料 住中间位置的人 喝牛奶\n    则需要对 4 个位置进行排列\n    \n    剪枝操作 --。感觉智商不够用\n\n\n使用Python语言实现 \n```python\nfrom itertools import permutations\nfrom copy import deepcopy\n\n#  房子      国籍     饮料     宠物     烟\n# 初始化5个组 用以代表5个人以及5个属性\nmap_info = [\n    [''] * 5 for _ in range(5)\n]\n\n# 根据线索9 得到\nmap_info[0][1] = '挪威'\n\n# 根据 房间排成一排 与线索14 得到\nmap_info[1][0] = '蓝色'\n\n# 根据 线索8 得到\nmap_info[2][2] = '牛奶'\n\n# 线索绑定 s4 得到 绿色白色为一体\n# 并且只能在2，3 或3，4位置，0开始\n# s1 = ['红色', '英国', '', '', '']\n# s2 = ['', '瑞典', '', '狗', '']\n# s3 = ['', '丹麦', '茶', '', '']\n# s5 = ['绿色', '', '咖啡', '', '']\n# s6 = ['', '', '', '鸟', 'PallMall']\n# s7 = ['黄色', '', '', '', 'Dunhill']\n# s12 = ['', '', '啤酒', '', 'BlueMaster']\n# s13 = ['', '德国', '', '', 'Prince']\n\n#    # s11 10, 15\n\n# 从颜色开始，绿白只能或3，4位置 绿房 喝 咖啡\n# 2位置已经固定为牛奶了 s5\nmap_info[3][0] = '绿色'\nmap_info[3][2] = '咖啡'\nmap_info[4][0] = '白色'\n\n# 结合国籍看 那么剩下颜色中间位置\nmap_info[2][0] = '红色'\nmap_info[2][1] = '英国'\nmap_info[0][0] = '黄色'\n# print(map_info)\n# todo ---以上 颜色排列完整\n\n# s7 绑定 Dunhill\nmap_info[0][4] = 'Dunhill'\n# s11 养马的人和抽 Dunhill 牌香烟的人相邻\nmap_info[1][3] = '马'\n# print(map_info)\n\n\n# 对剩下的7个线索做为消费数据对象\n# 对剩下的4个类型作为排列对象生产数据\n\n\n# 消费数据\ndef check(map_info_test):\n    for i in range(5):\n\n        if map_info_test[i][1] == '瑞典' and map_info_test[i][3] != '狗':\n            return False\n        if map_info_test[i][1] == '丹麦' and map_info_test[i][2] != '茶':\n            return False\n        if map_info_test[i][3] == '鸟' and map_info_test[i][4] != 'PallMall':\n            return False\n        if map_info_test[i][2] == '啤酒' and map_info_test[i][4] != 'BlueMaster':\n            return False\n        if map_info_test[i][1] == '德国' and map_info_test[i][4] != 'Prince':\n            return False\n        if map_info_test[i][4] == 'Blends':\n            status = False\n            try:\n                if map_info_test[i - 1][3] == '猫':\n                    status = True\n            except:\n                pass\n            try:\n                if map_info_test[i + 1][3] == '猫':\n                    status = True\n            except:\n                pass\n            if status is False:\n                return False\n\n        if map_info_test[i][4] == 'Blends':\n\n            status = False\n            try:\n                if map_info_test[i - 1][2] == '水':\n                    status = True\n            except:\n                pass\n            try:\n                if map_info_test[i + 1][2] == '水':\n                    status = True\n            except:\n                pass\n            if status is False:\n                return False\n    # 通过校验\n    return True\n\n\n# 生产数据\n\"\"\"\n1. 国籍 1，3，4 -- 丹麦、德国、瑞典\n2. 饮料 0，1，4 -- 水、茶、啤酒\n3. 宠物 0，2，3，4 -- 猫、鸟、鱼、狗\n4. 烟 1，2，3，4 -- Blends、PallMall、Prince、BlueMaster\n\"\"\"\n\nres = []\nfor g in permutations({'丹麦', '德国', '瑞典'}, 3):\n    map_info[1][1], map_info[3][1], map_info[4][1] = g\n    # print(map_info)\n\n    for yl in permutations({'水', '茶', ' 啤酒'}, 3):\n        map_info[0][2], map_info[1][2], map_info[4][2] = yl\n\n        for c in permutations({'猫', '鸟', '鱼', '狗'}, 4):\n            map_info[0][3], map_info[2][3], map_info[3][3], map_info[4][3] = c\n\n            for y in permutations({'Blends', 'PallMall', 'Prince', 'BlueMaster'}, 4):\n                map_info[1][4], map_info[2][4], map_info[3][4], map_info[4][4] = y\n\n                if check(map_info):\n                    res.append(deepcopy(map_info))\n\nfor r in res:\n    print(r)\n\n```","slug":"穷举搜索法06","published":1,"date":"2019-04-08T16:45:49.390Z","updated":"2019-04-08T16:45:49.390Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw32rpdb000lvw72p2pwiuij","content":"<p>穷举来源</p>\n<pre><code>每个状态有 5 个类型\n每个类型又要对 5 个值进行排列组合\n</code></pre><p>穷举实现</p>\n<pre><code>根据状态分布，有3个类型是有值在固定位置的\n则对于国籍需要对4个位置进行排列\n对于颜色 由于5间房子排成一排\n所以 蓝色固定在第二间房 \n而 绿和白存在绑定关系 则对3个位置进行排列\n对于饮料 住中间位置的人 喝牛奶\n则需要对 4 个位置进行排列\n\n剪枝操作 --。感觉智商不够用\n</code></pre><p>使用Python语言实现<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> itertools <span class=\"keyword\">import</span> permutations</span><br><span class=\"line\"><span class=\"keyword\">from</span> copy <span class=\"keyword\">import</span> deepcopy</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#  房子      国籍     饮料     宠物     烟</span></span><br><span class=\"line\"><span class=\"comment\"># 初始化5个组 用以代表5个人以及5个属性</span></span><br><span class=\"line\">map_info = [</span><br><span class=\"line\">    [<span class=\"string\">''</span>] * <span class=\"number\">5</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>)</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 根据线索9 得到</span></span><br><span class=\"line\">map_info[<span class=\"number\">0</span>][<span class=\"number\">1</span>] = <span class=\"string\">'挪威'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 根据 房间排成一排 与线索14 得到</span></span><br><span class=\"line\">map_info[<span class=\"number\">1</span>][<span class=\"number\">0</span>] = <span class=\"string\">'蓝色'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 根据 线索8 得到</span></span><br><span class=\"line\">map_info[<span class=\"number\">2</span>][<span class=\"number\">2</span>] = <span class=\"string\">'牛奶'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 线索绑定 s4 得到 绿色白色为一体</span></span><br><span class=\"line\"><span class=\"comment\"># 并且只能在2，3 或3，4位置，0开始</span></span><br><span class=\"line\"><span class=\"comment\"># s1 = ['红色', '英国', '', '', '']</span></span><br><span class=\"line\"><span class=\"comment\"># s2 = ['', '瑞典', '', '狗', '']</span></span><br><span class=\"line\"><span class=\"comment\"># s3 = ['', '丹麦', '茶', '', '']</span></span><br><span class=\"line\"><span class=\"comment\"># s5 = ['绿色', '', '咖啡', '', '']</span></span><br><span class=\"line\"><span class=\"comment\"># s6 = ['', '', '', '鸟', 'PallMall']</span></span><br><span class=\"line\"><span class=\"comment\"># s7 = ['黄色', '', '', '', 'Dunhill']</span></span><br><span class=\"line\"><span class=\"comment\"># s12 = ['', '', '啤酒', '', 'BlueMaster']</span></span><br><span class=\"line\"><span class=\"comment\"># s13 = ['', '德国', '', '', 'Prince']</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#    # s11 10, 15</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从颜色开始，绿白只能或3，4位置 绿房 喝 咖啡</span></span><br><span class=\"line\"><span class=\"comment\"># 2位置已经固定为牛奶了 s5</span></span><br><span class=\"line\">map_info[<span class=\"number\">3</span>][<span class=\"number\">0</span>] = <span class=\"string\">'绿色'</span></span><br><span class=\"line\">map_info[<span class=\"number\">3</span>][<span class=\"number\">2</span>] = <span class=\"string\">'咖啡'</span></span><br><span class=\"line\">map_info[<span class=\"number\">4</span>][<span class=\"number\">0</span>] = <span class=\"string\">'白色'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 结合国籍看 那么剩下颜色中间位置</span></span><br><span class=\"line\">map_info[<span class=\"number\">2</span>][<span class=\"number\">0</span>] = <span class=\"string\">'红色'</span></span><br><span class=\"line\">map_info[<span class=\"number\">2</span>][<span class=\"number\">1</span>] = <span class=\"string\">'英国'</span></span><br><span class=\"line\">map_info[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"string\">'黄色'</span></span><br><span class=\"line\"><span class=\"comment\"># print(map_info)</span></span><br><span class=\"line\"><span class=\"comment\"># todo ---以上 颜色排列完整</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># s7 绑定 Dunhill</span></span><br><span class=\"line\">map_info[<span class=\"number\">0</span>][<span class=\"number\">4</span>] = <span class=\"string\">'Dunhill'</span></span><br><span class=\"line\"><span class=\"comment\"># s11 养马的人和抽 Dunhill 牌香烟的人相邻</span></span><br><span class=\"line\">map_info[<span class=\"number\">1</span>][<span class=\"number\">3</span>] = <span class=\"string\">'马'</span></span><br><span class=\"line\"><span class=\"comment\"># print(map_info)</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 对剩下的7个线索做为消费数据对象</span></span><br><span class=\"line\"><span class=\"comment\"># 对剩下的4个类型作为排列对象生产数据</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 消费数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check</span><span class=\"params\">(map_info_test)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>):</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> map_info_test[i][<span class=\"number\">1</span>] == <span class=\"string\">'瑞典'</span> <span class=\"keyword\">and</span> map_info_test[i][<span class=\"number\">3</span>] != <span class=\"string\">'狗'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> map_info_test[i][<span class=\"number\">1</span>] == <span class=\"string\">'丹麦'</span> <span class=\"keyword\">and</span> map_info_test[i][<span class=\"number\">2</span>] != <span class=\"string\">'茶'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> map_info_test[i][<span class=\"number\">3</span>] == <span class=\"string\">'鸟'</span> <span class=\"keyword\">and</span> map_info_test[i][<span class=\"number\">4</span>] != <span class=\"string\">'PallMall'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> map_info_test[i][<span class=\"number\">2</span>] == <span class=\"string\">'啤酒'</span> <span class=\"keyword\">and</span> map_info_test[i][<span class=\"number\">4</span>] != <span class=\"string\">'BlueMaster'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> map_info_test[i][<span class=\"number\">1</span>] == <span class=\"string\">'德国'</span> <span class=\"keyword\">and</span> map_info_test[i][<span class=\"number\">4</span>] != <span class=\"string\">'Prince'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> map_info_test[i][<span class=\"number\">4</span>] == <span class=\"string\">'Blends'</span>:</span><br><span class=\"line\">            status = <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> map_info_test[i - <span class=\"number\">1</span>][<span class=\"number\">3</span>] == <span class=\"string\">'猫'</span>:</span><br><span class=\"line\">                    status = <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"keyword\">except</span>:</span><br><span class=\"line\">                <span class=\"keyword\">pass</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> map_info_test[i + <span class=\"number\">1</span>][<span class=\"number\">3</span>] == <span class=\"string\">'猫'</span>:</span><br><span class=\"line\">                    status = <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"keyword\">except</span>:</span><br><span class=\"line\">                <span class=\"keyword\">pass</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> status <span class=\"keyword\">is</span> <span class=\"literal\">False</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> map_info_test[i][<span class=\"number\">4</span>] == <span class=\"string\">'Blends'</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">            status = <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> map_info_test[i - <span class=\"number\">1</span>][<span class=\"number\">2</span>] == <span class=\"string\">'水'</span>:</span><br><span class=\"line\">                    status = <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"keyword\">except</span>:</span><br><span class=\"line\">                <span class=\"keyword\">pass</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> map_info_test[i + <span class=\"number\">1</span>][<span class=\"number\">2</span>] == <span class=\"string\">'水'</span>:</span><br><span class=\"line\">                    status = <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"keyword\">except</span>:</span><br><span class=\"line\">                <span class=\"keyword\">pass</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> status <span class=\"keyword\">is</span> <span class=\"literal\">False</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"comment\"># 通过校验</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 生产数据</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">1. 国籍 1，3，4 -- 丹麦、德国、瑞典</span></span><br><span class=\"line\"><span class=\"string\">2. 饮料 0，1，4 -- 水、茶、啤酒</span></span><br><span class=\"line\"><span class=\"string\">3. 宠物 0，2，3，4 -- 猫、鸟、鱼、狗</span></span><br><span class=\"line\"><span class=\"string\">4. 烟 1，2，3，4 -- Blends、PallMall、Prince、BlueMaster</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">res = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> g <span class=\"keyword\">in</span> permutations(&#123;<span class=\"string\">'丹麦'</span>, <span class=\"string\">'德国'</span>, <span class=\"string\">'瑞典'</span>&#125;, <span class=\"number\">3</span>):</span><br><span class=\"line\">    map_info[<span class=\"number\">1</span>][<span class=\"number\">1</span>], map_info[<span class=\"number\">3</span>][<span class=\"number\">1</span>], map_info[<span class=\"number\">4</span>][<span class=\"number\">1</span>] = g</span><br><span class=\"line\">    <span class=\"comment\"># print(map_info)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> yl <span class=\"keyword\">in</span> permutations(&#123;<span class=\"string\">'水'</span>, <span class=\"string\">'茶'</span>, <span class=\"string\">' 啤酒'</span>&#125;, <span class=\"number\">3</span>):</span><br><span class=\"line\">        map_info[<span class=\"number\">0</span>][<span class=\"number\">2</span>], map_info[<span class=\"number\">1</span>][<span class=\"number\">2</span>], map_info[<span class=\"number\">4</span>][<span class=\"number\">2</span>] = yl</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> permutations(&#123;<span class=\"string\">'猫'</span>, <span class=\"string\">'鸟'</span>, <span class=\"string\">'鱼'</span>, <span class=\"string\">'狗'</span>&#125;, <span class=\"number\">4</span>):</span><br><span class=\"line\">            map_info[<span class=\"number\">0</span>][<span class=\"number\">3</span>], map_info[<span class=\"number\">2</span>][<span class=\"number\">3</span>], map_info[<span class=\"number\">3</span>][<span class=\"number\">3</span>], map_info[<span class=\"number\">4</span>][<span class=\"number\">3</span>] = c</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> permutations(&#123;<span class=\"string\">'Blends'</span>, <span class=\"string\">'PallMall'</span>, <span class=\"string\">'Prince'</span>, <span class=\"string\">'BlueMaster'</span>&#125;, <span class=\"number\">4</span>):</span><br><span class=\"line\">                map_info[<span class=\"number\">1</span>][<span class=\"number\">4</span>], map_info[<span class=\"number\">2</span>][<span class=\"number\">4</span>], map_info[<span class=\"number\">3</span>][<span class=\"number\">4</span>], map_info[<span class=\"number\">4</span>][<span class=\"number\">4</span>] = y</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> check(map_info):</span><br><span class=\"line\">                    res.append(deepcopy(map_info))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> r <span class=\"keyword\">in</span> res:</span><br><span class=\"line\">    print(r)</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>穷举来源</p>\n<pre><code>每个状态有 5 个类型\n每个类型又要对 5 个值进行排列组合\n</code></pre><p>穷举实现</p>\n<pre><code>根据状态分布，有3个类型是有值在固定位置的\n则对于国籍需要对4个位置进行排列\n对于颜色 由于5间房子排成一排\n所以 蓝色固定在第二间房 \n而 绿和白存在绑定关系 则对3个位置进行排列\n对于饮料 住中间位置的人 喝牛奶\n则需要对 4 个位置进行排列\n\n剪枝操作 --。感觉智商不够用\n</code></pre><p>使用Python语言实现<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> itertools <span class=\"keyword\">import</span> permutations</span><br><span class=\"line\"><span class=\"keyword\">from</span> copy <span class=\"keyword\">import</span> deepcopy</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#  房子      国籍     饮料     宠物     烟</span></span><br><span class=\"line\"><span class=\"comment\"># 初始化5个组 用以代表5个人以及5个属性</span></span><br><span class=\"line\">map_info = [</span><br><span class=\"line\">    [<span class=\"string\">''</span>] * <span class=\"number\">5</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>)</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 根据线索9 得到</span></span><br><span class=\"line\">map_info[<span class=\"number\">0</span>][<span class=\"number\">1</span>] = <span class=\"string\">'挪威'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 根据 房间排成一排 与线索14 得到</span></span><br><span class=\"line\">map_info[<span class=\"number\">1</span>][<span class=\"number\">0</span>] = <span class=\"string\">'蓝色'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 根据 线索8 得到</span></span><br><span class=\"line\">map_info[<span class=\"number\">2</span>][<span class=\"number\">2</span>] = <span class=\"string\">'牛奶'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 线索绑定 s4 得到 绿色白色为一体</span></span><br><span class=\"line\"><span class=\"comment\"># 并且只能在2，3 或3，4位置，0开始</span></span><br><span class=\"line\"><span class=\"comment\"># s1 = ['红色', '英国', '', '', '']</span></span><br><span class=\"line\"><span class=\"comment\"># s2 = ['', '瑞典', '', '狗', '']</span></span><br><span class=\"line\"><span class=\"comment\"># s3 = ['', '丹麦', '茶', '', '']</span></span><br><span class=\"line\"><span class=\"comment\"># s5 = ['绿色', '', '咖啡', '', '']</span></span><br><span class=\"line\"><span class=\"comment\"># s6 = ['', '', '', '鸟', 'PallMall']</span></span><br><span class=\"line\"><span class=\"comment\"># s7 = ['黄色', '', '', '', 'Dunhill']</span></span><br><span class=\"line\"><span class=\"comment\"># s12 = ['', '', '啤酒', '', 'BlueMaster']</span></span><br><span class=\"line\"><span class=\"comment\"># s13 = ['', '德国', '', '', 'Prince']</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#    # s11 10, 15</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从颜色开始，绿白只能或3，4位置 绿房 喝 咖啡</span></span><br><span class=\"line\"><span class=\"comment\"># 2位置已经固定为牛奶了 s5</span></span><br><span class=\"line\">map_info[<span class=\"number\">3</span>][<span class=\"number\">0</span>] = <span class=\"string\">'绿色'</span></span><br><span class=\"line\">map_info[<span class=\"number\">3</span>][<span class=\"number\">2</span>] = <span class=\"string\">'咖啡'</span></span><br><span class=\"line\">map_info[<span class=\"number\">4</span>][<span class=\"number\">0</span>] = <span class=\"string\">'白色'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 结合国籍看 那么剩下颜色中间位置</span></span><br><span class=\"line\">map_info[<span class=\"number\">2</span>][<span class=\"number\">0</span>] = <span class=\"string\">'红色'</span></span><br><span class=\"line\">map_info[<span class=\"number\">2</span>][<span class=\"number\">1</span>] = <span class=\"string\">'英国'</span></span><br><span class=\"line\">map_info[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"string\">'黄色'</span></span><br><span class=\"line\"><span class=\"comment\"># print(map_info)</span></span><br><span class=\"line\"><span class=\"comment\"># todo ---以上 颜色排列完整</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># s7 绑定 Dunhill</span></span><br><span class=\"line\">map_info[<span class=\"number\">0</span>][<span class=\"number\">4</span>] = <span class=\"string\">'Dunhill'</span></span><br><span class=\"line\"><span class=\"comment\"># s11 养马的人和抽 Dunhill 牌香烟的人相邻</span></span><br><span class=\"line\">map_info[<span class=\"number\">1</span>][<span class=\"number\">3</span>] = <span class=\"string\">'马'</span></span><br><span class=\"line\"><span class=\"comment\"># print(map_info)</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 对剩下的7个线索做为消费数据对象</span></span><br><span class=\"line\"><span class=\"comment\"># 对剩下的4个类型作为排列对象生产数据</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 消费数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check</span><span class=\"params\">(map_info_test)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>):</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> map_info_test[i][<span class=\"number\">1</span>] == <span class=\"string\">'瑞典'</span> <span class=\"keyword\">and</span> map_info_test[i][<span class=\"number\">3</span>] != <span class=\"string\">'狗'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> map_info_test[i][<span class=\"number\">1</span>] == <span class=\"string\">'丹麦'</span> <span class=\"keyword\">and</span> map_info_test[i][<span class=\"number\">2</span>] != <span class=\"string\">'茶'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> map_info_test[i][<span class=\"number\">3</span>] == <span class=\"string\">'鸟'</span> <span class=\"keyword\">and</span> map_info_test[i][<span class=\"number\">4</span>] != <span class=\"string\">'PallMall'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> map_info_test[i][<span class=\"number\">2</span>] == <span class=\"string\">'啤酒'</span> <span class=\"keyword\">and</span> map_info_test[i][<span class=\"number\">4</span>] != <span class=\"string\">'BlueMaster'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> map_info_test[i][<span class=\"number\">1</span>] == <span class=\"string\">'德国'</span> <span class=\"keyword\">and</span> map_info_test[i][<span class=\"number\">4</span>] != <span class=\"string\">'Prince'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> map_info_test[i][<span class=\"number\">4</span>] == <span class=\"string\">'Blends'</span>:</span><br><span class=\"line\">            status = <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> map_info_test[i - <span class=\"number\">1</span>][<span class=\"number\">3</span>] == <span class=\"string\">'猫'</span>:</span><br><span class=\"line\">                    status = <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"keyword\">except</span>:</span><br><span class=\"line\">                <span class=\"keyword\">pass</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> map_info_test[i + <span class=\"number\">1</span>][<span class=\"number\">3</span>] == <span class=\"string\">'猫'</span>:</span><br><span class=\"line\">                    status = <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"keyword\">except</span>:</span><br><span class=\"line\">                <span class=\"keyword\">pass</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> status <span class=\"keyword\">is</span> <span class=\"literal\">False</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> map_info_test[i][<span class=\"number\">4</span>] == <span class=\"string\">'Blends'</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">            status = <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> map_info_test[i - <span class=\"number\">1</span>][<span class=\"number\">2</span>] == <span class=\"string\">'水'</span>:</span><br><span class=\"line\">                    status = <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"keyword\">except</span>:</span><br><span class=\"line\">                <span class=\"keyword\">pass</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> map_info_test[i + <span class=\"number\">1</span>][<span class=\"number\">2</span>] == <span class=\"string\">'水'</span>:</span><br><span class=\"line\">                    status = <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"keyword\">except</span>:</span><br><span class=\"line\">                <span class=\"keyword\">pass</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> status <span class=\"keyword\">is</span> <span class=\"literal\">False</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"comment\"># 通过校验</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 生产数据</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">1. 国籍 1，3，4 -- 丹麦、德国、瑞典</span></span><br><span class=\"line\"><span class=\"string\">2. 饮料 0，1，4 -- 水、茶、啤酒</span></span><br><span class=\"line\"><span class=\"string\">3. 宠物 0，2，3，4 -- 猫、鸟、鱼、狗</span></span><br><span class=\"line\"><span class=\"string\">4. 烟 1，2，3，4 -- Blends、PallMall、Prince、BlueMaster</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">res = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> g <span class=\"keyword\">in</span> permutations(&#123;<span class=\"string\">'丹麦'</span>, <span class=\"string\">'德国'</span>, <span class=\"string\">'瑞典'</span>&#125;, <span class=\"number\">3</span>):</span><br><span class=\"line\">    map_info[<span class=\"number\">1</span>][<span class=\"number\">1</span>], map_info[<span class=\"number\">3</span>][<span class=\"number\">1</span>], map_info[<span class=\"number\">4</span>][<span class=\"number\">1</span>] = g</span><br><span class=\"line\">    <span class=\"comment\"># print(map_info)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> yl <span class=\"keyword\">in</span> permutations(&#123;<span class=\"string\">'水'</span>, <span class=\"string\">'茶'</span>, <span class=\"string\">' 啤酒'</span>&#125;, <span class=\"number\">3</span>):</span><br><span class=\"line\">        map_info[<span class=\"number\">0</span>][<span class=\"number\">2</span>], map_info[<span class=\"number\">1</span>][<span class=\"number\">2</span>], map_info[<span class=\"number\">4</span>][<span class=\"number\">2</span>] = yl</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> permutations(&#123;<span class=\"string\">'猫'</span>, <span class=\"string\">'鸟'</span>, <span class=\"string\">'鱼'</span>, <span class=\"string\">'狗'</span>&#125;, <span class=\"number\">4</span>):</span><br><span class=\"line\">            map_info[<span class=\"number\">0</span>][<span class=\"number\">3</span>], map_info[<span class=\"number\">2</span>][<span class=\"number\">3</span>], map_info[<span class=\"number\">3</span>][<span class=\"number\">3</span>], map_info[<span class=\"number\">4</span>][<span class=\"number\">3</span>] = c</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> permutations(&#123;<span class=\"string\">'Blends'</span>, <span class=\"string\">'PallMall'</span>, <span class=\"string\">'Prince'</span>, <span class=\"string\">'BlueMaster'</span>&#125;, <span class=\"number\">4</span>):</span><br><span class=\"line\">                map_info[<span class=\"number\">1</span>][<span class=\"number\">4</span>], map_info[<span class=\"number\">2</span>][<span class=\"number\">4</span>], map_info[<span class=\"number\">3</span>][<span class=\"number\">4</span>], map_info[<span class=\"number\">4</span>][<span class=\"number\">4</span>] = y</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> check(map_info):</span><br><span class=\"line\">                    res.append(deepcopy(map_info))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> r <span class=\"keyword\">in</span> res:</span><br><span class=\"line\">    print(r)</span><br></pre></td></tr></table></figure></p>\n"},{"title":"爱因斯坦的思考题 上","_content":"\n题目描述：\n    \n    据说有五个不同颜色的房间排成一排，\n    每个房间里分别住着一个不同国籍的人，\n    每个人都喝一种特定品牌的饮料，\n    抽一种特定品牌的烟，养一种宠物，\n    没有任意两个人抽相同品牌的香烟，\n    或喝相同品牌的饮料，或养相同的宠物，\n    问题是谁在养鱼作为宠物？\n    \n线索：\n\n    （1）英国人住在红色的房子里\n    （2）瑞典人养狗作为宠物\n    （3）丹麦人喝茶\n    （4）绿房子紧挨着白房子，在白房子的左边\n    （5）绿房子的主人喝咖啡\n    （6）抽 Pall Mall 牌香烟的人养鸟\n    （7）黄色房子里的人抽 Dunhill 牌香烟\n    （8）住在中间那个房子里的人喝牛奶\n    （9）挪威人住在第一个房子里面\n    （10）抽 Blends 牌香烟的人和养猫的人相邻\n    （11）养马的人和抽 Dunhill 牌香烟的人相邻\n    （12）抽 BlueMaster 牌香烟的人喝啤酒\n    （13）德国人抽 Prince 牌香烟\n    （14）挪威人和住在蓝房子的人相邻\n    （15）抽 Blends 牌香烟的人和喝矿泉水的人相邻\n\n状态描述[也是答案的一种]\n    \n    房子      国籍\t    饮料\t    宠物\t    烟\n    黄色      挪威\t    水\t    猫\t    Dunhill\n    蓝色      丹麦\t    茶\t    马\t    Blends\n    红色      英国\t    牛奶\t    鸟\t    PallMall\n    绿色      德国\t    咖啡\t    鱼\t    Prince\n    白色      瑞典\t    啤酒\t    狗\t    BlueMaster\n    \n根据线索得到的状态分布\n    \n    房子      国籍      饮料      宠物      烟\n    住蓝房邻   挪威\n    蓝色\n    红色      英国      \n             瑞典                狗\n             丹麦      茶\n    绿色               咖啡\n    白色\n                                鸟       PallMall\n    黄色                                 Dunhill\n                      啤酒               BlueMaster\n             德国                        Prince\n    中间              牛奶         \n                     邻矿泉水  和养猫的人相邻  Blends \n                                马        和Dunhill相邻\n                                \n分析\n\n    从状态分布来看，所提供的线索完整。并且可以固定部分位置\n    [0][1] = 挪威\n    [1][0] = 蓝色\n    [2][2] = 牛奶\n    多数线索提供 状态绑定关系。\n    Blends 无绑定关系，但相邻关系多，或许是个入手点。","source":"_posts/穷举搜索法05.md","raw":"---\ntitle: 爱因斯坦的思考题 上\n---\n\n题目描述：\n    \n    据说有五个不同颜色的房间排成一排，\n    每个房间里分别住着一个不同国籍的人，\n    每个人都喝一种特定品牌的饮料，\n    抽一种特定品牌的烟，养一种宠物，\n    没有任意两个人抽相同品牌的香烟，\n    或喝相同品牌的饮料，或养相同的宠物，\n    问题是谁在养鱼作为宠物？\n    \n线索：\n\n    （1）英国人住在红色的房子里\n    （2）瑞典人养狗作为宠物\n    （3）丹麦人喝茶\n    （4）绿房子紧挨着白房子，在白房子的左边\n    （5）绿房子的主人喝咖啡\n    （6）抽 Pall Mall 牌香烟的人养鸟\n    （7）黄色房子里的人抽 Dunhill 牌香烟\n    （8）住在中间那个房子里的人喝牛奶\n    （9）挪威人住在第一个房子里面\n    （10）抽 Blends 牌香烟的人和养猫的人相邻\n    （11）养马的人和抽 Dunhill 牌香烟的人相邻\n    （12）抽 BlueMaster 牌香烟的人喝啤酒\n    （13）德国人抽 Prince 牌香烟\n    （14）挪威人和住在蓝房子的人相邻\n    （15）抽 Blends 牌香烟的人和喝矿泉水的人相邻\n\n状态描述[也是答案的一种]\n    \n    房子      国籍\t    饮料\t    宠物\t    烟\n    黄色      挪威\t    水\t    猫\t    Dunhill\n    蓝色      丹麦\t    茶\t    马\t    Blends\n    红色      英国\t    牛奶\t    鸟\t    PallMall\n    绿色      德国\t    咖啡\t    鱼\t    Prince\n    白色      瑞典\t    啤酒\t    狗\t    BlueMaster\n    \n根据线索得到的状态分布\n    \n    房子      国籍      饮料      宠物      烟\n    住蓝房邻   挪威\n    蓝色\n    红色      英国      \n             瑞典                狗\n             丹麦      茶\n    绿色               咖啡\n    白色\n                                鸟       PallMall\n    黄色                                 Dunhill\n                      啤酒               BlueMaster\n             德国                        Prince\n    中间              牛奶         \n                     邻矿泉水  和养猫的人相邻  Blends \n                                马        和Dunhill相邻\n                                \n分析\n\n    从状态分布来看，所提供的线索完整。并且可以固定部分位置\n    [0][1] = 挪威\n    [1][0] = 蓝色\n    [2][2] = 牛奶\n    多数线索提供 状态绑定关系。\n    Blends 无绑定关系，但相邻关系多，或许是个入手点。","slug":"穷举搜索法05","published":1,"date":"2019-04-08T14:08:14.224Z","updated":"2019-04-08T14:08:14.224Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw32rpdc000mvw7293mk2f88","content":"<p>题目描述：</p>\n<pre><code>据说有五个不同颜色的房间排成一排，\n每个房间里分别住着一个不同国籍的人，\n每个人都喝一种特定品牌的饮料，\n抽一种特定品牌的烟，养一种宠物，\n没有任意两个人抽相同品牌的香烟，\n或喝相同品牌的饮料，或养相同的宠物，\n问题是谁在养鱼作为宠物？\n</code></pre><p>线索：</p>\n<pre><code>（1）英国人住在红色的房子里\n（2）瑞典人养狗作为宠物\n（3）丹麦人喝茶\n（4）绿房子紧挨着白房子，在白房子的左边\n（5）绿房子的主人喝咖啡\n（6）抽 Pall Mall 牌香烟的人养鸟\n（7）黄色房子里的人抽 Dunhill 牌香烟\n（8）住在中间那个房子里的人喝牛奶\n（9）挪威人住在第一个房子里面\n（10）抽 Blends 牌香烟的人和养猫的人相邻\n（11）养马的人和抽 Dunhill 牌香烟的人相邻\n（12）抽 BlueMaster 牌香烟的人喝啤酒\n（13）德国人抽 Prince 牌香烟\n（14）挪威人和住在蓝房子的人相邻\n（15）抽 Blends 牌香烟的人和喝矿泉水的人相邻\n</code></pre><p>状态描述[也是答案的一种]</p>\n<pre><code>房子      国籍        饮料        宠物        烟\n黄色      挪威        水        猫        Dunhill\n蓝色      丹麦        茶        马        Blends\n红色      英国        牛奶        鸟        PallMall\n绿色      德国        咖啡        鱼        Prince\n白色      瑞典        啤酒        狗        BlueMaster\n</code></pre><p>根据线索得到的状态分布</p>\n<pre><code>房子      国籍      饮料      宠物      烟\n住蓝房邻   挪威\n蓝色\n红色      英国      \n         瑞典                狗\n         丹麦      茶\n绿色               咖啡\n白色\n                            鸟       PallMall\n黄色                                 Dunhill\n                  啤酒               BlueMaster\n         德国                        Prince\n中间              牛奶         \n                 邻矿泉水  和养猫的人相邻  Blends \n                            马        和Dunhill相邻\n</code></pre><p>分析</p>\n<pre><code>从状态分布来看，所提供的线索完整。并且可以固定部分位置\n[0][1] = 挪威\n[1][0] = 蓝色\n[2][2] = 牛奶\n多数线索提供 状态绑定关系。\nBlends 无绑定关系，但相邻关系多，或许是个入手点。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>题目描述：</p>\n<pre><code>据说有五个不同颜色的房间排成一排，\n每个房间里分别住着一个不同国籍的人，\n每个人都喝一种特定品牌的饮料，\n抽一种特定品牌的烟，养一种宠物，\n没有任意两个人抽相同品牌的香烟，\n或喝相同品牌的饮料，或养相同的宠物，\n问题是谁在养鱼作为宠物？\n</code></pre><p>线索：</p>\n<pre><code>（1）英国人住在红色的房子里\n（2）瑞典人养狗作为宠物\n（3）丹麦人喝茶\n（4）绿房子紧挨着白房子，在白房子的左边\n（5）绿房子的主人喝咖啡\n（6）抽 Pall Mall 牌香烟的人养鸟\n（7）黄色房子里的人抽 Dunhill 牌香烟\n（8）住在中间那个房子里的人喝牛奶\n（9）挪威人住在第一个房子里面\n（10）抽 Blends 牌香烟的人和养猫的人相邻\n（11）养马的人和抽 Dunhill 牌香烟的人相邻\n（12）抽 BlueMaster 牌香烟的人喝啤酒\n（13）德国人抽 Prince 牌香烟\n（14）挪威人和住在蓝房子的人相邻\n（15）抽 Blends 牌香烟的人和喝矿泉水的人相邻\n</code></pre><p>状态描述[也是答案的一种]</p>\n<pre><code>房子      国籍        饮料        宠物        烟\n黄色      挪威        水        猫        Dunhill\n蓝色      丹麦        茶        马        Blends\n红色      英国        牛奶        鸟        PallMall\n绿色      德国        咖啡        鱼        Prince\n白色      瑞典        啤酒        狗        BlueMaster\n</code></pre><p>根据线索得到的状态分布</p>\n<pre><code>房子      国籍      饮料      宠物      烟\n住蓝房邻   挪威\n蓝色\n红色      英国      \n         瑞典                狗\n         丹麦      茶\n绿色               咖啡\n白色\n                            鸟       PallMall\n黄色                                 Dunhill\n                  啤酒               BlueMaster\n         德国                        Prince\n中间              牛奶         \n                 邻矿泉水  和养猫的人相邻  Blends \n                            马        和Dunhill相邻\n</code></pre><p>分析</p>\n<pre><code>从状态分布来看，所提供的线索完整。并且可以固定部分位置\n[0][1] = 挪威\n[1][0] = 蓝色\n[2][2] = 牛奶\n多数线索提供 状态绑定关系。\nBlends 无绑定关系，但相邻关系多，或许是个入手点。\n</code></pre>"},{"title":"如何设计递归函数","_content":"\n递归\n    \n    1. 确定递归子结构\n    2. 确定递归退出条件和退出处理\n    3. 递归的自我触发机制\n\n    基本原则是能不使用递归就不使用递归，\n    毕竟递归方法存在效率和栈的开销问题，\n    在搞不清楚问题规模的情况下，\n    很容易出现问题。\n\n\n二叉树的前序遍历\n    \n    根-->左-->右\n    \n    \n举个简单的例子\n```python\ndef fib(n):\n    \n    if n <= 1:\n        return 1\n    else:\n        return fib(n-1)+fib(n-2)\n\n```","source":"_posts/穷举搜索法08.md","raw":"---\ntitle: 如何设计递归函数\n---\n\n递归\n    \n    1. 确定递归子结构\n    2. 确定递归退出条件和退出处理\n    3. 递归的自我触发机制\n\n    基本原则是能不使用递归就不使用递归，\n    毕竟递归方法存在效率和栈的开销问题，\n    在搞不清楚问题规模的情况下，\n    很容易出现问题。\n\n\n二叉树的前序遍历\n    \n    根-->左-->右\n    \n    \n举个简单的例子\n```python\ndef fib(n):\n    \n    if n <= 1:\n        return 1\n    else:\n        return fib(n-1)+fib(n-2)\n\n```","slug":"穷举搜索法08","published":1,"date":"2019-04-09T15:05:30.183Z","updated":"2019-04-09T15:05:30.183Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw32rpdd000nvw72ttdd1190","content":"<p>递归</p>\n<pre><code>1. 确定递归子结构\n2. 确定递归退出条件和退出处理\n3. 递归的自我触发机制\n\n基本原则是能不使用递归就不使用递归，\n毕竟递归方法存在效率和栈的开销问题，\n在搞不清楚问题规模的情况下，\n很容易出现问题。\n</code></pre><p>二叉树的前序遍历</p>\n<pre><code>根--&gt;左--&gt;右\n</code></pre><p>举个简单的例子<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fib</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> n &lt;= <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fib(n<span class=\"number\">-1</span>)+fib(n<span class=\"number\">-2</span>)</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>递归</p>\n<pre><code>1. 确定递归子结构\n2. 确定递归退出条件和退出处理\n3. 递归的自我触发机制\n\n基本原则是能不使用递归就不使用递归，\n毕竟递归方法存在效率和栈的开销问题，\n在搞不清楚问题规模的情况下，\n很容易出现问题。\n</code></pre><p>二叉树的前序遍历</p>\n<pre><code>根--&gt;左--&gt;右\n</code></pre><p>举个简单的例子<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fib</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> n &lt;= <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fib(n<span class=\"number\">-1</span>)+fib(n<span class=\"number\">-2</span>)</span><br></pre></td></tr></table></figure></p>\n"},{"title":"多点共线问题","_content":"\n问题提出\n    \n    一个几何平面上有 N 个点，\n    根据欧氏（欧几里得）几何原理，\n    每两个点可以连成一条直线，\n    N 个点可以连成很多条直线。\n    当然，也会有多个点共线的情况出现，\n    现在我们的问题是，在这 N 个点中，\n    找出哪两个点组成的直线上包含最多的点，\n    也就是找出含有最多点的那条直线。\n    \n注意浮点数不要直接比较值相等\n    \n解题思路\n    \n    确定一个点为原点\n    其他点过原点的斜率计算\n    统计出斜率频次并取最大，并记录\n    依次遍历点作为原点，重复上面操作\n    从记录的频次列表中\n    求得最大的即为含有最多点的那条直线。\n    \n使用Python实现\n```python\nfrom collections import Counter\n\n\ndef get_most_count(spot_list):\n    res = set()\n    for j in range(len(spot_list)):\n        tmp = list()\n        for i, spot in enumerate(spot_list):\n\n            if j == i:\n                continue\n            x, y = spot\n            x0, y0 = spot_list[j]\n            # 注意x==x0时的情况为斜率不存在\n            if (x - x0) != 0:\n                tmp.append(format((y - y0) / (x - x0), '.8f'))\n            else:\n                tmp.append(float(\"inf\"))\n        res.add(max(Counter(tmp).values()))\n    return max(res) + 1\n```\n    ","source":"_posts/穷举搜索法07.md","raw":"---\ntitle: 多点共线问题\n---\n\n问题提出\n    \n    一个几何平面上有 N 个点，\n    根据欧氏（欧几里得）几何原理，\n    每两个点可以连成一条直线，\n    N 个点可以连成很多条直线。\n    当然，也会有多个点共线的情况出现，\n    现在我们的问题是，在这 N 个点中，\n    找出哪两个点组成的直线上包含最多的点，\n    也就是找出含有最多点的那条直线。\n    \n注意浮点数不要直接比较值相等\n    \n解题思路\n    \n    确定一个点为原点\n    其他点过原点的斜率计算\n    统计出斜率频次并取最大，并记录\n    依次遍历点作为原点，重复上面操作\n    从记录的频次列表中\n    求得最大的即为含有最多点的那条直线。\n    \n使用Python实现\n```python\nfrom collections import Counter\n\n\ndef get_most_count(spot_list):\n    res = set()\n    for j in range(len(spot_list)):\n        tmp = list()\n        for i, spot in enumerate(spot_list):\n\n            if j == i:\n                continue\n            x, y = spot\n            x0, y0 = spot_list[j]\n            # 注意x==x0时的情况为斜率不存在\n            if (x - x0) != 0:\n                tmp.append(format((y - y0) / (x - x0), '.8f'))\n            else:\n                tmp.append(float(\"inf\"))\n        res.add(max(Counter(tmp).values()))\n    return max(res) + 1\n```\n    ","slug":"穷举搜索法07","published":1,"date":"2019-04-09T13:54:18.913Z","updated":"2019-04-09T13:54:18.913Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw32rpdd000ovw728u4xa5pi","content":"<p>问题提出</p>\n<pre><code>一个几何平面上有 N 个点，\n根据欧氏（欧几里得）几何原理，\n每两个点可以连成一条直线，\nN 个点可以连成很多条直线。\n当然，也会有多个点共线的情况出现，\n现在我们的问题是，在这 N 个点中，\n找出哪两个点组成的直线上包含最多的点，\n也就是找出含有最多点的那条直线。\n</code></pre><p>注意浮点数不要直接比较值相等</p>\n<p>解题思路</p>\n<pre><code>确定一个点为原点\n其他点过原点的斜率计算\n统计出斜率频次并取最大，并记录\n依次遍历点作为原点，重复上面操作\n从记录的频次列表中\n求得最大的即为含有最多点的那条直线。\n</code></pre><p>使用Python实现<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_most_count</span><span class=\"params\">(spot_list)</span>:</span></span><br><span class=\"line\">    res = set()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(spot_list)):</span><br><span class=\"line\">        tmp = list()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, spot <span class=\"keyword\">in</span> enumerate(spot_list):</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> j == i:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            x, y = spot</span><br><span class=\"line\">            x0, y0 = spot_list[j]</span><br><span class=\"line\">            <span class=\"comment\"># 注意x==x0时的情况为斜率不存在</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x - x0) != <span class=\"number\">0</span>:</span><br><span class=\"line\">                tmp.append(format((y - y0) / (x - x0), <span class=\"string\">'.8f'</span>))</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                tmp.append(float(<span class=\"string\">\"inf\"</span>))</span><br><span class=\"line\">        res.add(max(Counter(tmp).values()))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(res) + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>问题提出</p>\n<pre><code>一个几何平面上有 N 个点，\n根据欧氏（欧几里得）几何原理，\n每两个点可以连成一条直线，\nN 个点可以连成很多条直线。\n当然，也会有多个点共线的情况出现，\n现在我们的问题是，在这 N 个点中，\n找出哪两个点组成的直线上包含最多的点，\n也就是找出含有最多点的那条直线。\n</code></pre><p>注意浮点数不要直接比较值相等</p>\n<p>解题思路</p>\n<pre><code>确定一个点为原点\n其他点过原点的斜率计算\n统计出斜率频次并取最大，并记录\n依次遍历点作为原点，重复上面操作\n从记录的频次列表中\n求得最大的即为含有最多点的那条直线。\n</code></pre><p>使用Python实现<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_most_count</span><span class=\"params\">(spot_list)</span>:</span></span><br><span class=\"line\">    res = set()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(spot_list)):</span><br><span class=\"line\">        tmp = list()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, spot <span class=\"keyword\">in</span> enumerate(spot_list):</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> j == i:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            x, y = spot</span><br><span class=\"line\">            x0, y0 = spot_list[j]</span><br><span class=\"line\">            <span class=\"comment\"># 注意x==x0时的情况为斜率不存在</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x - x0) != <span class=\"number\">0</span>:</span><br><span class=\"line\">                tmp.append(format((y - y0) / (x - x0), <span class=\"string\">'.8f'</span>))</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                tmp.append(float(<span class=\"string\">\"inf\"</span>))</span><br><span class=\"line\">        res.add(max(Counter(tmp).values()))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(res) + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure></p>\n"},{"title":"推箱子游戏","_content":"\nGET\n\n    偏移量数组 { { -1,0 }、{ 0,1 }、{ 1,0 }、{ 0,-1 } } \n    分别表示“上”、“右”、“下”和“左”四个方向的偏移，\n    对这个数组遍历一遍，即可完成对某个位置四周的四个小格子的遍历。\n\n[回顾](https://leetcode-cn.com/contest/weekly-contest-125/problems/available-captures-for-rook/)\n    \n    在一个 8 x 8 的棋盘上，\n    有一个白色车（rook）。\n    也可能有空方块，白色的象（bishop）\n    和黑色的卒（pawn）。\n    它们分别以字符 “R”，“.”，“B” 和 “p” 给出。\n    大写字符表示白棋，小写字符表示黑棋。\n\n    车按国际象棋中的规则移动：\n    它选择四个基本方向中的一个（北，东，西和南），\n    然后朝那个方向移动，直到它选择停止、\n    到达棋盘的边缘或移动到同一方格\n    来捕获该方格上颜色相反的卒。\n    另外，车不能与其他友方（白色）象进入同一个方格。\n    返回车能够在一次移动中捕获到的卒的数量。\n    \n    ","source":"_posts/穷举搜索法09.md","raw":"---\ntitle: 推箱子游戏\n---\n\nGET\n\n    偏移量数组 { { -1,0 }、{ 0,1 }、{ 1,0 }、{ 0,-1 } } \n    分别表示“上”、“右”、“下”和“左”四个方向的偏移，\n    对这个数组遍历一遍，即可完成对某个位置四周的四个小格子的遍历。\n\n[回顾](https://leetcode-cn.com/contest/weekly-contest-125/problems/available-captures-for-rook/)\n    \n    在一个 8 x 8 的棋盘上，\n    有一个白色车（rook）。\n    也可能有空方块，白色的象（bishop）\n    和黑色的卒（pawn）。\n    它们分别以字符 “R”，“.”，“B” 和 “p” 给出。\n    大写字符表示白棋，小写字符表示黑棋。\n\n    车按国际象棋中的规则移动：\n    它选择四个基本方向中的一个（北，东，西和南），\n    然后朝那个方向移动，直到它选择停止、\n    到达棋盘的边缘或移动到同一方格\n    来捕获该方格上颜色相反的卒。\n    另外，车不能与其他友方（白色）象进入同一个方格。\n    返回车能够在一次移动中捕获到的卒的数量。\n    \n    ","slug":"穷举搜索法09","published":1,"date":"2019-04-10T13:26:13.369Z","updated":"2019-04-10T13:26:13.369Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw32rpde000pvw72azagl696","content":"<p>GET</p>\n<pre><code>偏移量数组 { { -1,0 }、{ 0,1 }、{ 1,0 }、{ 0,-1 } } \n分别表示“上”、“右”、“下”和“左”四个方向的偏移，\n对这个数组遍历一遍，即可完成对某个位置四周的四个小格子的遍历。\n</code></pre><p><a href=\"https://leetcode-cn.com/contest/weekly-contest-125/problems/available-captures-for-rook/\" target=\"_blank\" rel=\"noopener\">回顾</a></p>\n<pre><code>在一个 8 x 8 的棋盘上，\n有一个白色车（rook）。\n也可能有空方块，白色的象（bishop）\n和黑色的卒（pawn）。\n它们分别以字符 “R”，“.”，“B” 和 “p” 给出。\n大写字符表示白棋，小写字符表示黑棋。\n\n车按国际象棋中的规则移动：\n它选择四个基本方向中的一个（北，东，西和南），\n然后朝那个方向移动，直到它选择停止、\n到达棋盘的边缘或移动到同一方格\n来捕获该方格上颜色相反的卒。\n另外，车不能与其他友方（白色）象进入同一个方格。\n返回车能够在一次移动中捕获到的卒的数量。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>GET</p>\n<pre><code>偏移量数组 { { -1,0 }、{ 0,1 }、{ 1,0 }、{ 0,-1 } } \n分别表示“上”、“右”、“下”和“左”四个方向的偏移，\n对这个数组遍历一遍，即可完成对某个位置四周的四个小格子的遍历。\n</code></pre><p><a href=\"https://leetcode-cn.com/contest/weekly-contest-125/problems/available-captures-for-rook/\" target=\"_blank\" rel=\"noopener\">回顾</a></p>\n<pre><code>在一个 8 x 8 的棋盘上，\n有一个白色车（rook）。\n也可能有空方块，白色的象（bishop）\n和黑色的卒（pawn）。\n它们分别以字符 “R”，“.”，“B” 和 “p” 给出。\n大写字符表示白棋，小写字符表示黑棋。\n\n车按国际象棋中的规则移动：\n它选择四个基本方向中的一个（北，东，西和南），\n然后朝那个方向移动，直到它选择停止、\n到达棋盘的边缘或移动到同一方格\n来捕获该方格上颜色相反的卒。\n另外，车不能与其他友方（白色）象进入同一个方格。\n返回车能够在一次移动中捕获到的卒的数量。\n</code></pre>"},{"title":"整数的范围","_content":"\n    8 位有符号整数能表示的范围是 −128 到 127，\n    无符号时能表示的范围是 0 ~ 255。\n    \n    16 位的有符号整数能表示的范围是 −32768 到 32767，\n    无符号时能表示的范围是 0 ~ 65535。\n    \n    32 位的有符号整数能表示的范围是\n     −2,147,483,648 到 2,147,483,647，\n    无符号时能表示的范围是 0 ~ 4,294,967,295。\n    \n    64 位的有符号整数能表示的范围是\n     −9,223,372,036,854,775,808 到 9,223,372,036,854,775,807，\n     无符号时能表示的范围是 0 ~ 18,446,744,073,709,551,615。\n     \n","source":"_posts/穷举搜索法10.md","raw":"---\ntitle: 整数的范围\n---\n\n    8 位有符号整数能表示的范围是 −128 到 127，\n    无符号时能表示的范围是 0 ~ 255。\n    \n    16 位的有符号整数能表示的范围是 −32768 到 32767，\n    无符号时能表示的范围是 0 ~ 65535。\n    \n    32 位的有符号整数能表示的范围是\n     −2,147,483,648 到 2,147,483,647，\n    无符号时能表示的范围是 0 ~ 4,294,967,295。\n    \n    64 位的有符号整数能表示的范围是\n     −9,223,372,036,854,775,808 到 9,223,372,036,854,775,807，\n     无符号时能表示的范围是 0 ~ 18,446,744,073,709,551,615。\n     \n","slug":"穷举搜索法10","published":1,"date":"2019-04-10T13:28:01.068Z","updated":"2019-04-10T13:28:01.068Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw32rpde000qvw72vo4kp8kn","content":"<pre><code>8 位有符号整数能表示的范围是 −128 到 127，\n无符号时能表示的范围是 0 ~ 255。\n\n16 位的有符号整数能表示的范围是 −32768 到 32767，\n无符号时能表示的范围是 0 ~ 65535。\n\n32 位的有符号整数能表示的范围是\n −2,147,483,648 到 2,147,483,647，\n无符号时能表示的范围是 0 ~ 4,294,967,295。\n\n64 位的有符号整数能表示的范围是\n −9,223,372,036,854,775,808 到 9,223,372,036,854,775,807，\n 无符号时能表示的范围是 0 ~ 18,446,744,073,709,551,615。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<pre><code>8 位有符号整数能表示的范围是 −128 到 127，\n无符号时能表示的范围是 0 ~ 255。\n\n16 位的有符号整数能表示的范围是 −32768 到 32767，\n无符号时能表示的范围是 0 ~ 65535。\n\n32 位的有符号整数能表示的范围是\n −2,147,483,648 到 2,147,483,647，\n无符号时能表示的范围是 0 ~ 4,294,967,295。\n\n64 位的有符号整数能表示的范围是\n −9,223,372,036,854,775,808 到 9,223,372,036,854,775,807，\n 无符号时能表示的范围是 0 ~ 18,446,744,073,709,551,615。\n</code></pre>"},{"title":"非线性方程与牛顿迭代法","_content":"\n求解一元非线性方程的常用方法\n\n    二分逼近法\n    牛顿迭代法\n    \n二分逼近法\n\n    数学原理：对于实数域的函数 f(x)f(x)，\n    如果存在实数 kk，使得 f(k) = 0f(k)=0，\n    则 x = kx=k 就是函数 f(x)f(x) 的零点。\n    如果函数 f(x)f(x) 是连续函数，\n    且在区间 [a,b] 上是单调函数，\n    只要 f(a)和 f(b)异号，\n    就说明在区间 [a,b] 内一定有零点。\n\n使用Python语言实现 二分逼近法 求解方程\n```python\n\ndef func(x):\n    return 2.0 * x * x + 3.2 * x - 1.8\n\n\ndef dichotomy_equation(a, b, f):\n    esp = 0.1 ** 6\n    mid = (a + b) / 2\n    while abs(b - a) > esp:\n\n        # 说明零点[方程解]存在于（a, mid）\n        if f(a) * f(mid) < 0:\n            b = mid\n        else:\n            a = mid\n        mid = (a + b) / 2\n    return mid\n\n\n# 求 2.0 * x * x + 3.2 * x - 1.8 在 (-1,2)上的解\nres = dichotomy_equation(-1, 2, func)\n# 0.4409674406051636\nprint(res)\n\n```\n\n牛顿迭代法\n\n\n使用Python实现 牛顿迭代法\n```python\ndef calc_derivative(func, x):\n    a = 0.000001\n    b = a*5\n    return (func(x+b) - func(x-b))/a\n    \ndef newton_raphson(func, x0, invalid_value):\n    \n    esp = 0.1**6\n    x1 = x0 - func(x0)/calc_derivative(func, x0)\n    while abs(x1 - x0) > esp:\n        if invalid_value == x1:\n            break\n        x0 = x1\n    return x1\n\n```    \n","source":"_posts/迭代递推卡01.md","raw":"---\ntitle: 非线性方程与牛顿迭代法\n---\n\n求解一元非线性方程的常用方法\n\n    二分逼近法\n    牛顿迭代法\n    \n二分逼近法\n\n    数学原理：对于实数域的函数 f(x)f(x)，\n    如果存在实数 kk，使得 f(k) = 0f(k)=0，\n    则 x = kx=k 就是函数 f(x)f(x) 的零点。\n    如果函数 f(x)f(x) 是连续函数，\n    且在区间 [a,b] 上是单调函数，\n    只要 f(a)和 f(b)异号，\n    就说明在区间 [a,b] 内一定有零点。\n\n使用Python语言实现 二分逼近法 求解方程\n```python\n\ndef func(x):\n    return 2.0 * x * x + 3.2 * x - 1.8\n\n\ndef dichotomy_equation(a, b, f):\n    esp = 0.1 ** 6\n    mid = (a + b) / 2\n    while abs(b - a) > esp:\n\n        # 说明零点[方程解]存在于（a, mid）\n        if f(a) * f(mid) < 0:\n            b = mid\n        else:\n            a = mid\n        mid = (a + b) / 2\n    return mid\n\n\n# 求 2.0 * x * x + 3.2 * x - 1.8 在 (-1,2)上的解\nres = dichotomy_equation(-1, 2, func)\n# 0.4409674406051636\nprint(res)\n\n```\n\n牛顿迭代法\n\n\n使用Python实现 牛顿迭代法\n```python\ndef calc_derivative(func, x):\n    a = 0.000001\n    b = a*5\n    return (func(x+b) - func(x-b))/a\n    \ndef newton_raphson(func, x0, invalid_value):\n    \n    esp = 0.1**6\n    x1 = x0 - func(x0)/calc_derivative(func, x0)\n    while abs(x1 - x0) > esp:\n        if invalid_value == x1:\n            break\n        x0 = x1\n    return x1\n\n```    \n","slug":"迭代递推卡01","published":1,"date":"2019-04-05T11:55:56.750Z","updated":"2019-04-05T11:55:56.750Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw32rpdf000rvw72q70eiqm6","content":"<p>求解一元非线性方程的常用方法</p>\n<pre><code>二分逼近法\n牛顿迭代法\n</code></pre><p>二分逼近法</p>\n<pre><code>数学原理：对于实数域的函数 f(x)f(x)，\n如果存在实数 kk，使得 f(k) = 0f(k)=0，\n则 x = kx=k 就是函数 f(x)f(x) 的零点。\n如果函数 f(x)f(x) 是连续函数，\n且在区间 [a,b] 上是单调函数，\n只要 f(a)和 f(b)异号，\n就说明在区间 [a,b] 内一定有零点。\n</code></pre><p>使用Python语言实现 二分逼近法 求解方程<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2.0</span> * x * x + <span class=\"number\">3.2</span> * x - <span class=\"number\">1.8</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dichotomy_equation</span><span class=\"params\">(a, b, f)</span>:</span></span><br><span class=\"line\">    esp = <span class=\"number\">0.1</span> ** <span class=\"number\">6</span></span><br><span class=\"line\">    mid = (a + b) / <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> abs(b - a) &gt; esp:</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 说明零点[方程解]存在于（a, mid）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> f(a) * f(mid) &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            b = mid</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            a = mid</span><br><span class=\"line\">        mid = (a + b) / <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> mid</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 求 2.0 * x * x + 3.2 * x - 1.8 在 (-1,2)上的解</span></span><br><span class=\"line\">res = dichotomy_equation(<span class=\"number\">-1</span>, <span class=\"number\">2</span>, func)</span><br><span class=\"line\"><span class=\"comment\"># 0.4409674406051636</span></span><br><span class=\"line\">print(res)</span><br></pre></td></tr></table></figure></p>\n<p>牛顿迭代法</p>\n<p>使用Python实现 牛顿迭代法</p>\n<pre><code class=\"python\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calc_derivative</span><span class=\"params\">(func, x)</span>:</span>\n    a = <span class=\"number\">0.000001</span>\n    b = a*<span class=\"number\">5</span>\n    <span class=\"keyword\">return</span> (func(x+b) - func(x-b))/a\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">newton_raphson</span><span class=\"params\">(func, x0, invalid_value)</span>:</span>\n\n    esp = <span class=\"number\">0.1</span>**<span class=\"number\">6</span>\n    x1 = x0 - func(x0)/calc_derivative(func, x0)\n    <span class=\"keyword\">while</span> abs(x1 - x0) &gt; esp:\n        <span class=\"keyword\">if</span> invalid_value == x1:\n            <span class=\"keyword\">break</span>\n        x0 = x1\n    <span class=\"keyword\">return</span> x1\n\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>求解一元非线性方程的常用方法</p>\n<pre><code>二分逼近法\n牛顿迭代法\n</code></pre><p>二分逼近法</p>\n<pre><code>数学原理：对于实数域的函数 f(x)f(x)，\n如果存在实数 kk，使得 f(k) = 0f(k)=0，\n则 x = kx=k 就是函数 f(x)f(x) 的零点。\n如果函数 f(x)f(x) 是连续函数，\n且在区间 [a,b] 上是单调函数，\n只要 f(a)和 f(b)异号，\n就说明在区间 [a,b] 内一定有零点。\n</code></pre><p>使用Python语言实现 二分逼近法 求解方程<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2.0</span> * x * x + <span class=\"number\">3.2</span> * x - <span class=\"number\">1.8</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dichotomy_equation</span><span class=\"params\">(a, b, f)</span>:</span></span><br><span class=\"line\">    esp = <span class=\"number\">0.1</span> ** <span class=\"number\">6</span></span><br><span class=\"line\">    mid = (a + b) / <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> abs(b - a) &gt; esp:</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 说明零点[方程解]存在于（a, mid）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> f(a) * f(mid) &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            b = mid</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            a = mid</span><br><span class=\"line\">        mid = (a + b) / <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> mid</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 求 2.0 * x * x + 3.2 * x - 1.8 在 (-1,2)上的解</span></span><br><span class=\"line\">res = dichotomy_equation(<span class=\"number\">-1</span>, <span class=\"number\">2</span>, func)</span><br><span class=\"line\"><span class=\"comment\"># 0.4409674406051636</span></span><br><span class=\"line\">print(res)</span><br></pre></td></tr></table></figure></p>\n<p>牛顿迭代法</p>\n<p>使用Python实现 牛顿迭代法</p>\n<pre><code class=\"python\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calc_derivative</span><span class=\"params\">(func, x)</span>:</span>\n    a = <span class=\"number\">0.000001</span>\n    b = a*<span class=\"number\">5</span>\n    <span class=\"keyword\">return</span> (func(x+b) - func(x-b))/a\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">newton_raphson</span><span class=\"params\">(func, x0, invalid_value)</span>:</span>\n\n    esp = <span class=\"number\">0.1</span>**<span class=\"number\">6</span>\n    x1 = x0 - func(x0)/calc_derivative(func, x0)\n    <span class=\"keyword\">while</span> abs(x1 - x0) &gt; esp:\n        <span class=\"keyword\">if</span> invalid_value == x1:\n            <span class=\"keyword\">break</span>\n        x0 = x1\n    <span class=\"keyword\">return</span> x1\n\n</code></pre>\n"},{"title":"迭代法计算定积分","_content":"\n计算数值积分的两种常用方法\n    \n    变步长梯形公式法\n    变步长辛普森公式法\n    \n![](../img/梯型公式法.png)\n\n![](../img/变长梯型公式法.png)\n\n![](../img/辛普森公式法.png)\n\n可变长辛普森公式法\n    \n    和梯形公式一样，\n    复合辛普森公式也可以改造为变步长辛普森公式法。\n    改造的方法就是使用迭代法的思想，\n    通过改变区间个数 n 使得步长 step 也跟着变化，\n    当迭代差值符合精度要求时即可停止迭代。\n    算法的迭代变量仍然是每次分割后的小区间上\n    使用辛普森公式计算的插值曲线面积之和，\n    迭代关系则非常简单，\n    就是用本迭代的迭代变量代替上个迭代的迭代自变量的值，\n    迭代终止条件就是两个迭代的迭代变量之差小于精度值。\n    迭代变量的初始值就是在区间 [a,b] 上\n    应用辛普森公式计算最大的区间面积。\n    用一个变量 n 表示当前迭代分割小梯形的个数，\n    n 的值每个迭代增加一倍。\n    而每次分割后的小区间面积和的计算\n    可由第 2-2 课中给出的\n    复合辛普森公式算法 simpson() 函数计算，\n    迭代算法的整体结构与变步长梯形法类似。\n\n\n\n","source":"_posts/迭代递推卡03.md","raw":"---\ntitle: 迭代法计算定积分\n---\n\n计算数值积分的两种常用方法\n    \n    变步长梯形公式法\n    变步长辛普森公式法\n    \n![](../img/梯型公式法.png)\n\n![](../img/变长梯型公式法.png)\n\n![](../img/辛普森公式法.png)\n\n可变长辛普森公式法\n    \n    和梯形公式一样，\n    复合辛普森公式也可以改造为变步长辛普森公式法。\n    改造的方法就是使用迭代法的思想，\n    通过改变区间个数 n 使得步长 step 也跟着变化，\n    当迭代差值符合精度要求时即可停止迭代。\n    算法的迭代变量仍然是每次分割后的小区间上\n    使用辛普森公式计算的插值曲线面积之和，\n    迭代关系则非常简单，\n    就是用本迭代的迭代变量代替上个迭代的迭代自变量的值，\n    迭代终止条件就是两个迭代的迭代变量之差小于精度值。\n    迭代变量的初始值就是在区间 [a,b] 上\n    应用辛普森公式计算最大的区间面积。\n    用一个变量 n 表示当前迭代分割小梯形的个数，\n    n 的值每个迭代增加一倍。\n    而每次分割后的小区间面积和的计算\n    可由第 2-2 课中给出的\n    复合辛普森公式算法 simpson() 函数计算，\n    迭代算法的整体结构与变步长梯形法类似。\n\n\n\n","slug":"迭代递推卡03","published":1,"date":"2019-04-05T12:40:14.491Z","updated":"2019-04-05T12:40:14.491Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw32rpdf000svw72gvloev2k","content":"<p>计算数值积分的两种常用方法</p>\n<pre><code>变步长梯形公式法\n变步长辛普森公式法\n</code></pre><p><img src=\"../img/梯型公式法.png\" alt></p>\n<p><img src=\"../img/变长梯型公式法.png\" alt></p>\n<p><img src=\"../img/辛普森公式法.png\" alt></p>\n<p>可变长辛普森公式法</p>\n<pre><code>和梯形公式一样，\n复合辛普森公式也可以改造为变步长辛普森公式法。\n改造的方法就是使用迭代法的思想，\n通过改变区间个数 n 使得步长 step 也跟着变化，\n当迭代差值符合精度要求时即可停止迭代。\n算法的迭代变量仍然是每次分割后的小区间上\n使用辛普森公式计算的插值曲线面积之和，\n迭代关系则非常简单，\n就是用本迭代的迭代变量代替上个迭代的迭代自变量的值，\n迭代终止条件就是两个迭代的迭代变量之差小于精度值。\n迭代变量的初始值就是在区间 [a,b] 上\n应用辛普森公式计算最大的区间面积。\n用一个变量 n 表示当前迭代分割小梯形的个数，\nn 的值每个迭代增加一倍。\n而每次分割后的小区间面积和的计算\n可由第 2-2 课中给出的\n复合辛普森公式算法 simpson() 函数计算，\n迭代算法的整体结构与变步长梯形法类似。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>计算数值积分的两种常用方法</p>\n<pre><code>变步长梯形公式法\n变步长辛普森公式法\n</code></pre><p><img src=\"../img/梯型公式法.png\" alt></p>\n<p><img src=\"../img/变长梯型公式法.png\" alt></p>\n<p><img src=\"../img/辛普森公式法.png\" alt></p>\n<p>可变长辛普森公式法</p>\n<pre><code>和梯形公式一样，\n复合辛普森公式也可以改造为变步长辛普森公式法。\n改造的方法就是使用迭代法的思想，\n通过改变区间个数 n 使得步长 step 也跟着变化，\n当迭代差值符合精度要求时即可停止迭代。\n算法的迭代变量仍然是每次分割后的小区间上\n使用辛普森公式计算的插值曲线面积之和，\n迭代关系则非常简单，\n就是用本迭代的迭代变量代替上个迭代的迭代自变量的值，\n迭代终止条件就是两个迭代的迭代变量之差小于精度值。\n迭代变量的初始值就是在区间 [a,b] 上\n应用辛普森公式计算最大的区间面积。\n用一个变量 n 表示当前迭代分割小梯形的个数，\nn 的值每个迭代增加一倍。\n而每次分割后的小区间面积和的计算\n可由第 2-2 课中给出的\n复合辛普森公式算法 simpson() 函数计算，\n迭代算法的整体结构与变步长梯形法类似。\n</code></pre>"},{"title":"线性代数方程组的求解","_content":"\n雅可比迭代法\n    \n    通过计算一次矩阵和向量的乘法，\n    且计算过程中原始矩阵 A 保持不变，\n    便于用多线程并行计算的方式优化效率。\n    对于 n 阶线性方程组 Ax=b，\n    假如其系数矩阵 A 是非奇异矩阵，\n    且对角线元素非 0，\n    就可以证明雅可比迭代过程是收敛的。\n    \n    雅可比迭代原理和算法实现都很简单，\n    但是雅可比迭代存在收敛速度慢的问题。\n    工程中一般不直接使用雅可比迭代法，\n    而是使用各种基于雅可比迭代法的改进方法。\n    \n    \n高斯-赛德尔迭代法\n    \n    雅可比迭代法每次迭代计算时，\n    将上一次的迭代变量整体带入到迭代关系式中，\n    计算新的迭代变量值，\n    也就是所谓的整体迭代。\n    在迭代收敛的前提下，\n    如果迭代变量中的每个分量 x 在计算出新的迭代值后，\n    直接带入迭代，\n    参与其他迭代分量的计算，\n    则能显著地提高迭代效果，\n    这种改进的方法就是高斯-赛德尔迭代法。\n    \n \n    ","source":"_posts/迭代递推卡02.md","raw":"---\ntitle: 线性代数方程组的求解 \n---\n\n雅可比迭代法\n    \n    通过计算一次矩阵和向量的乘法，\n    且计算过程中原始矩阵 A 保持不变，\n    便于用多线程并行计算的方式优化效率。\n    对于 n 阶线性方程组 Ax=b，\n    假如其系数矩阵 A 是非奇异矩阵，\n    且对角线元素非 0，\n    就可以证明雅可比迭代过程是收敛的。\n    \n    雅可比迭代原理和算法实现都很简单，\n    但是雅可比迭代存在收敛速度慢的问题。\n    工程中一般不直接使用雅可比迭代法，\n    而是使用各种基于雅可比迭代法的改进方法。\n    \n    \n高斯-赛德尔迭代法\n    \n    雅可比迭代法每次迭代计算时，\n    将上一次的迭代变量整体带入到迭代关系式中，\n    计算新的迭代变量值，\n    也就是所谓的整体迭代。\n    在迭代收敛的前提下，\n    如果迭代变量中的每个分量 x 在计算出新的迭代值后，\n    直接带入迭代，\n    参与其他迭代分量的计算，\n    则能显著地提高迭代效果，\n    这种改进的方法就是高斯-赛德尔迭代法。\n    \n \n    ","slug":"迭代递推卡02","published":1,"date":"2019-04-05T12:09:36.408Z","updated":"2019-04-05T12:09:36.409Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw32rpe5000tvw72xoamaeii","content":"<p>雅可比迭代法</p>\n<pre><code>通过计算一次矩阵和向量的乘法，\n且计算过程中原始矩阵 A 保持不变，\n便于用多线程并行计算的方式优化效率。\n对于 n 阶线性方程组 Ax=b，\n假如其系数矩阵 A 是非奇异矩阵，\n且对角线元素非 0，\n就可以证明雅可比迭代过程是收敛的。\n\n雅可比迭代原理和算法实现都很简单，\n但是雅可比迭代存在收敛速度慢的问题。\n工程中一般不直接使用雅可比迭代法，\n而是使用各种基于雅可比迭代法的改进方法。\n</code></pre><p>高斯-赛德尔迭代法</p>\n<pre><code>雅可比迭代法每次迭代计算时，\n将上一次的迭代变量整体带入到迭代关系式中，\n计算新的迭代变量值，\n也就是所谓的整体迭代。\n在迭代收敛的前提下，\n如果迭代变量中的每个分量 x 在计算出新的迭代值后，\n直接带入迭代，\n参与其他迭代分量的计算，\n则能显著地提高迭代效果，\n这种改进的方法就是高斯-赛德尔迭代法。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>雅可比迭代法</p>\n<pre><code>通过计算一次矩阵和向量的乘法，\n且计算过程中原始矩阵 A 保持不变，\n便于用多线程并行计算的方式优化效率。\n对于 n 阶线性方程组 Ax=b，\n假如其系数矩阵 A 是非奇异矩阵，\n且对角线元素非 0，\n就可以证明雅可比迭代过程是收敛的。\n\n雅可比迭代原理和算法实现都很简单，\n但是雅可比迭代存在收敛速度慢的问题。\n工程中一般不直接使用雅可比迭代法，\n而是使用各种基于雅可比迭代法的改进方法。\n</code></pre><p>高斯-赛德尔迭代法</p>\n<pre><code>雅可比迭代法每次迭代计算时，\n将上一次的迭代变量整体带入到迭代关系式中，\n计算新的迭代变量值，\n也就是所谓的整体迭代。\n在迭代收敛的前提下，\n如果迭代变量中的每个分量 x 在计算出新的迭代值后，\n直接带入迭代，\n参与其他迭代分量的计算，\n则能显著地提高迭代效果，\n这种改进的方法就是高斯-赛德尔迭代法。\n</code></pre>"},{"title":"start blog","_content":"1. 安装node\n2. 安装git\n3. 在GitHub上创建格式为 BlogName.github.io的项目\n4. 使用npm install hexo -g 安装hexo\n5. 切换到博客并使用命令 hexo init初始化项目\n6. npm install 安装所需组件\n7. hexo g 首次使用需要编译\n8. hexo s 开启服务\n9. 设置Git的user name和email\n    \n       git config --global user.name \"YourUserName\"\n       git config --global user.email \"YourEmail\"\n\n10. ssh环境准备\n    \n        cd ~/.ssh\n        ssh-keygen -t rsa -C \"YourUserName\"\n        eval \"$(ssh-agent -s)\"\n        ssh-add ~/.ssh/id_rsa\n\n11. 上GitHub配置 ssh key\n        \n        新建ssh key 并将本地 id_rsa.pub的文件内容复制进去\n        \n12. 在本地执行 ssh -T git@github.com，如果显示出用户名则成功， 否则需要重新配置ssh-key\n\n13. 在项目中找到_config.yml文件修改以下参数\n\n        deploy:\n              type: git\n              repository: 项目的ssh链接\n              branch: master\n\n14. 安装git扩展 npm install hexo-deployer-git --save\n15. hexo d -g 生成以及部署了","source":"_posts/安装步骤.md","raw":"---\ntitle: start blog\n---\n1. 安装node\n2. 安装git\n3. 在GitHub上创建格式为 BlogName.github.io的项目\n4. 使用npm install hexo -g 安装hexo\n5. 切换到博客并使用命令 hexo init初始化项目\n6. npm install 安装所需组件\n7. hexo g 首次使用需要编译\n8. hexo s 开启服务\n9. 设置Git的user name和email\n    \n       git config --global user.name \"YourUserName\"\n       git config --global user.email \"YourEmail\"\n\n10. ssh环境准备\n    \n        cd ~/.ssh\n        ssh-keygen -t rsa -C \"YourUserName\"\n        eval \"$(ssh-agent -s)\"\n        ssh-add ~/.ssh/id_rsa\n\n11. 上GitHub配置 ssh key\n        \n        新建ssh key 并将本地 id_rsa.pub的文件内容复制进去\n        \n12. 在本地执行 ssh -T git@github.com，如果显示出用户名则成功， 否则需要重新配置ssh-key\n\n13. 在项目中找到_config.yml文件修改以下参数\n\n        deploy:\n              type: git\n              repository: 项目的ssh链接\n              branch: master\n\n14. 安装git扩展 npm install hexo-deployer-git --save\n15. hexo d -g 生成以及部署了","slug":"安装步骤","published":1,"date":"2019-05-25T06:25:59.300Z","updated":"2019-05-25T06:25:59.300Z","_id":"cjw347hl800007o72z113o69q","comments":1,"layout":"post","photos":[],"link":"","content":"<ol>\n<li>安装node</li>\n<li>安装git</li>\n<li>在GitHub上创建格式为 BlogName.github.io的项目</li>\n<li>使用npm install hexo -g 安装hexo</li>\n<li>切换到博客并使用命令 hexo init初始化项目</li>\n<li>npm install 安装所需组件</li>\n<li>hexo g 首次使用需要编译</li>\n<li>hexo s 开启服务</li>\n<li><p>设置Git的user name和email</p>\n<pre><code>git config --global user.name &quot;YourUserName&quot;\ngit config --global user.email &quot;YourEmail&quot;\n</code></pre></li>\n<li><p>ssh环境准备</p>\n<pre><code>cd ~/.ssh\nssh-keygen -t rsa -C &quot;YourUserName&quot;\neval &quot;$(ssh-agent -s)&quot;\nssh-add ~/.ssh/id_rsa\n</code></pre></li>\n<li><p>上GitHub配置 ssh key</p>\n<pre><code>新建ssh key 并将本地 id_rsa.pub的文件内容复制进去\n</code></pre></li>\n<li><p>在本地执行 ssh -T <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>，如果显示出用户名则成功， 否则需要重新配置ssh-key</p>\n</li>\n<li><p>在项目中找到_config.yml文件修改以下参数</p>\n<pre><code>deploy:\n      type: git\n      repository: 项目的ssh链接\n      branch: master\n</code></pre></li>\n<li><p>安装git扩展 npm install hexo-deployer-git –save</p>\n</li>\n<li>hexo d -g 生成以及部署了</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>安装node</li>\n<li>安装git</li>\n<li>在GitHub上创建格式为 BlogName.github.io的项目</li>\n<li>使用npm install hexo -g 安装hexo</li>\n<li>切换到博客并使用命令 hexo init初始化项目</li>\n<li>npm install 安装所需组件</li>\n<li>hexo g 首次使用需要编译</li>\n<li>hexo s 开启服务</li>\n<li><p>设置Git的user name和email</p>\n<pre><code>git config --global user.name &quot;YourUserName&quot;\ngit config --global user.email &quot;YourEmail&quot;\n</code></pre></li>\n<li><p>ssh环境准备</p>\n<pre><code>cd ~/.ssh\nssh-keygen -t rsa -C &quot;YourUserName&quot;\neval &quot;$(ssh-agent -s)&quot;\nssh-add ~/.ssh/id_rsa\n</code></pre></li>\n<li><p>上GitHub配置 ssh key</p>\n<pre><code>新建ssh key 并将本地 id_rsa.pub的文件内容复制进去\n</code></pre></li>\n<li><p>在本地执行 ssh -T <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>，如果显示出用户名则成功， 否则需要重新配置ssh-key</p>\n</li>\n<li><p>在项目中找到_config.yml文件修改以下参数</p>\n<pre><code>deploy:\n      type: git\n      repository: 项目的ssh链接\n      branch: master\n</code></pre></li>\n<li><p>安装git扩展 npm install hexo-deployer-git –save</p>\n</li>\n<li>hexo d -g 生成以及部署了</li>\n</ol>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}