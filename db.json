{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/img/辛普森公式法.png","path":"img/辛普森公式法.png","modified":0,"renderable":0},{"_id":"source/img/梯型公式法.png","path":"img/梯型公式法.png","modified":0,"renderable":0},{"_id":"source/img/变长梯型公式法.png","path":"img/变长梯型公式法.png","modified":0,"renderable":0},{"_id":"themes/landscape/source/images/favicon-192x192.png","path":"images/favicon-192x192.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/images/apple-touch-icon.png","path":"images/apple-touch-icon.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/rtl.styl","path":"css/rtl.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Black.woff2","path":"lib/vazir-font/Vazir-Black.woff2","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Black.woff","path":"lib/vazir-font/Vazir-Black.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Bold.woff2","path":"lib/vazir-font/Vazir-Bold.woff2","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Bold.woff","path":"lib/vazir-font/Vazir-Bold.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Light.woff","path":"lib/vazir-font/Vazir-Light.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Light.woff2","path":"lib/vazir-font/Vazir-Light.woff2","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Medium.woff","path":"lib/vazir-font/Vazir-Medium.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Medium.woff2","path":"lib/vazir-font/Vazir-Medium.woff2","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Thin.woff","path":"lib/vazir-font/Vazir-Thin.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Thin.woff2","path":"lib/vazir-font/Vazir-Thin.woff2","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/font-face.css","path":"lib/vazir-font/font-face.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir.woff","path":"lib/vazir-font/Vazir.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir.woff2","path":"lib/vazir-font/Vazir.woff2","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/jquery/jquery.min.js","path":"lib/jquery/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Black.ttf","path":"lib/vazir-font/Vazir-Black.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Black.eot","path":"lib/vazir-font/Vazir-Black.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Bold.eot","path":"lib/vazir-font/Vazir-Bold.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Bold.ttf","path":"lib/vazir-font/Vazir-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Light.eot","path":"lib/vazir-font/Vazir-Light.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Light.ttf","path":"lib/vazir-font/Vazir-Light.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Medium.eot","path":"lib/vazir-font/Vazir-Medium.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Medium.ttf","path":"lib/vazir-font/Vazir-Medium.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Thin.eot","path":"lib/vazir-font/Vazir-Thin.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Thin.ttf","path":"lib/vazir-font/Vazir-Thin.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir.eot","path":"lib/vazir-font/Vazir.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/vazir-font/Vazir.ttf","path":"lib/vazir-font/Vazir.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/images/logo.png","path":"images/logo.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-regular-400.woff","path":"lib/font-awesome/webfonts/fa-regular-400.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-regular-400.eot","path":"lib/font-awesome/webfonts/fa-regular-400.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-regular-400.ttf","path":"lib/font-awesome/webfonts/fa-regular-400.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/justified-gallery/css/justifiedGallery.min.css","path":"lib/justified-gallery/css/justifiedGallery.min.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/justified-gallery/js/jquery.justifiedGallery.min.js","path":"lib/justified-gallery/js/jquery.justifiedGallery.min.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-brands-400.woff","path":"lib/font-awesome/webfonts/fa-brands-400.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-brands-400.ttf","path":"lib/font-awesome/webfonts/fa-brands-400.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-solid-900.woff","path":"lib/font-awesome/webfonts/fa-solid-900.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-brands-400.eot","path":"lib/font-awesome/webfonts/fa-brands-400.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-regular-400.svg","path":"lib/font-awesome/webfonts/fa-regular-400.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-solid-900.eot","path":"lib/font-awesome/webfonts/fa-solid-900.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGM-BoldItalic.ttf","path":"lib/meslo-LG/MesloLGM-BoldItalic.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGS-Italic.ttf","path":"lib/meslo-LG/MesloLGS-Italic.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGS-BoldItalic.ttf","path":"lib/meslo-LG/MesloLGS-BoldItalic.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGL-BoldItalic.ttf","path":"lib/meslo-LG/MesloLGL-BoldItalic.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGM-Italic.ttf","path":"lib/meslo-LG/MesloLGM-Italic.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGL-Italic.ttf","path":"lib/meslo-LG/MesloLGL-Italic.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGM-Bold.ttf","path":"lib/meslo-LG/MesloLGM-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-solid-900.ttf","path":"lib/font-awesome/webfonts/fa-solid-900.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGS-Bold.ttf","path":"lib/meslo-LG/MesloLGS-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGL-Bold.ttf","path":"lib/meslo-LG/MesloLGL-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGM-Regular.ttf","path":"lib/meslo-LG/MesloLGM-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGL-Regular.ttf","path":"lib/meslo-LG/MesloLGL-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGS-Regular.ttf","path":"lib/meslo-LG/MesloLGS-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-brands-400.svg","path":"lib/font-awesome/webfonts/fa-brands-400.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-solid-900.svg","path":"lib/font-awesome/webfonts/fa-solid-900.svg","modified":0,"renderable":1},{"_id":"source/img/pad.png","path":"img/pad.png","modified":0,"renderable":0},{"_id":"source/img/stride.png","path":"img/stride.png","modified":0,"renderable":0},{"_id":"source/img/常见激活函数.png","path":"img/常见激活函数.png","modified":0,"renderable":0},{"_id":"source/img/BatchNorm.png","path":"img/BatchNorm.png","modified":0,"renderable":0},{"_id":"source/img/BatchNorm层的优点.png","path":"img/BatchNorm层的优点.png","modified":0,"renderable":0},{"_id":"source/img/ReLU.png","path":"img/ReLU.png","modified":0,"renderable":0},{"_id":"source/img/池化.png","path":"img/池化.png","modified":0,"renderable":0},{"_id":"source/img/tensorflow使用BatchNorm层.png","path":"img/tensorflow使用BatchNorm层.png","modified":0,"renderable":0},{"_id":"source/img/190530解决携程房型拼接属性不兼容问题.jpg","path":"img/190530解决携程房型拼接属性不兼容问题.jpg","modified":0,"renderable":0},{"_id":"source/img/Python常用内置数据结构与算法.jpg","path":"img/Python常用内置数据结构与算法.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"themes/landscape/.gitignore","hash":"c5345a2c5fa6c136dbe2020a405e541b4755a259","modified":1554081277000},{"_id":"themes/landscape/.stylintrc","hash":"eb5f48e83657928cb0cbee031373b2cd36ca0083","modified":1554081277000},{"_id":"themes/landscape/.jshintrc","hash":"2548bd6ce44422edc7e6f9f68061ab47f26c4f57","modified":1554081277000},{"_id":"themes/landscape/LICENSE","hash":"346ece39a983b0e7858c11f785cd846cef9eb875","modified":1554081277000},{"_id":"themes/landscape/_config.yml","hash":"c986259b700208a4205f739fd89e74e7b6777c8e","modified":1554126582204},{"_id":"themes/landscape/README.md","hash":"859d11941c46be4f7b4a6d62297ccbeb4f732bc9","modified":1554081277000},{"_id":"themes/landscape/package.json","hash":"5bbdbc429e9d46acf97baf7ac5654edde0781064","modified":1554081277000},{"_id":"themes/landscape/gulpfile.js","hash":"2bae290993507026a509665ee5a5326b616f8d68","modified":1554081277000},{"_id":"source/_posts/动态规划05.md","hash":"64cc4da343731a4e7857a6d2f4e9e5b40e73168a","modified":1555311720837},{"_id":"source/_posts/动态规划法01.md","hash":"47c3340e73c21c2bdc60ed848e8880aad379d09e","modified":1554992096057},{"_id":"source/_posts/28天训练营课程表.md","hash":"572ce8a78986c23466692dc0e4c849d6e3062d52","modified":1554112789319},{"_id":"source/_posts/hello-world.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1554081324453},{"_id":"source/_posts/unpacking_tuple_of_lists.md","hash":"b9889c4867550424875abc30fe2f3fff04217b52","modified":1558764226792},{"_id":"source/_posts/基础卡01-贪婪法.md","hash":"d04f26d2b691ebb7617bb9e029cfc98b313aae9d","modified":1554266810040},{"_id":"source/_posts/基础卡02-分治法.md","hash":"8d6b0e8d65b5c9d3d1a7f50440f281a8b34e7254","modified":1554127979024},{"_id":"source/_posts/基础卡03-动态规划.md","hash":"8885bee18843096d6a789545349e7c0c67e8adf6","modified":1554275857311},{"_id":"source/_posts/基础卡04-穷举法.md","hash":"c324918126bd59517f1f79b5b729b484b293438e","modified":1554272156591},{"_id":"source/_posts/基础卡05-迭代法.md","hash":"94a14272caff73ed343b382fae33dc44546a1c53","modified":1554459120665},{"_id":"source/_posts/游戏算法卡01-A*算法.md","hash":"4bc0ce2a8556f871ec1d5d720c30174dd2f4d1f8","modified":1555649341314},{"_id":"source/_posts/基础卡06-基础开胃菜.md","hash":"b4939934aa6fd31a7e53590c73700c434912672c","modified":1554391424593},{"_id":"source/_posts/挂载硬盘的一些命令.md","hash":"be9f1701caf7f20056adcd73180c906038ec17d1","modified":1554356588786},{"_id":"source/_posts/热身卡01-开篇词：算法是程序的灵魂.md","hash":"eb4e6e6f6fca03f106bc16b57e0f7b153dc3bc98","modified":1554112789338},{"_id":"source/_posts/热身卡02-入门测试题.md","hash":"cccf8a298396f91a4ff4c58facf7c5195dcd53cd","modified":1554112789330},{"_id":"source/_posts/热身卡03-如何\"玩\"算法.md","hash":"55e7657d06c17567ebe1fdf35e3dfd8400f79086","modified":1554112789335},{"_id":"source/_posts/穷举搜索卡01.md","hash":"210233ac9951cf2d15d9fa0d3ad66bfef2561aa7","modified":1554555081328},{"_id":"source/_posts/开营仪式.md","hash":"baddb420d6ebbc321702b61b1e706d5c10c3a0a4","modified":1554127140284},{"_id":"source/_posts/穷举搜索卡03.md","hash":"69eb1be397251d14ae262d70d1fcf0014b6e18a1","modified":1554642815552},{"_id":"source/_posts/穷举搜索卡04.md","hash":"850e020f8e574f41bdc15816a230cbdb10e30385","modified":1554643509670},{"_id":"source/_posts/穷举搜索卡02.md","hash":"0a1b49996b5e505f56f74c621fcaa77f51c65853","modified":1554559752518},{"_id":"source/_posts/穷举搜索法05.md","hash":"d66e42b8e15e3556a94f510bf8a33c1a0cb866ac","modified":1554732494224},{"_id":"source/_posts/穷举搜索法06.md","hash":"3a8cf3c3a187e42df9d56ddf515c216ff498f2da","modified":1554741949390},{"_id":"source/_posts/穷举搜索法08.md","hash":"6e83a52d06624cf3af3d7c5f84e12b8d55a0839e","modified":1554822330183},{"_id":"source/_posts/穷举搜索法07.md","hash":"61fd2649d3effee2b78c61f7b26cb98747c7dfbc","modified":1554818058913},{"_id":"source/_posts/穷举搜索法09.md","hash":"114d3fd1a7dfecbf60f0e3decc42ff6eea642372","modified":1554902773369},{"_id":"source/_posts/穷举搜索法10.md","hash":"0fe0fe2bd186f9517f900ab703fb4fffa187c268","modified":1554902881068},{"_id":"source/_posts/迭代递推卡01.md","hash":"5fcdca9bb8f3be94ac352d674e87ea7aa875c94d","modified":1554465356750},{"_id":"source/_posts/迭代递推卡03.md","hash":"3f679fb0f6eb8b168c05a2165475143f0cf5fab1","modified":1554468014491},{"_id":"source/_posts/迭代递推卡02.md","hash":"815aa79d1a71591e6a8b3dce828af13b4f761f91","modified":1554466176409},{"_id":"themes/landscape/languages/ca.yml","hash":"b79dd2c21dc6697c635e92db1f661a4b8d5d2305","modified":1554081277000},{"_id":"source/img/辛普森公式法.png","hash":"bdfdc4ec6767f6b6f69d6fe321dfdf2a44319c84","modified":1554467817506},{"_id":"themes/landscape/languages/default.yml","hash":"ca5582329d9721d58fe8504725108769080e9993","modified":1554081277000},{"_id":"themes/landscape/languages/en.yml","hash":"ea91a271db1a49386f97955ed72b2a668e2aea5e","modified":1554081277000},{"_id":"themes/landscape/languages/default_old.yml","hash":"ea91a271db1a49386f97955ed72b2a668e2aea5e","modified":1554081277000},{"_id":"themes/landscape/languages/es.yml","hash":"2b1fc8b0d636123e9ee39017fa20053bd1913a5a","modified":1554081277000},{"_id":"themes/landscape/languages/fr.yml","hash":"4fea266d3c522903f3eee4fffee6e66c44775005","modified":1554081277000},{"_id":"themes/landscape/languages/it.yml","hash":"62800bcae1f2d2454f87f4bcf4d7593848424f61","modified":1554081277000},{"_id":"themes/landscape/languages/fa.yml","hash":"63f32e50953af1c4bd0308a4fca5862b5287c2cb","modified":1554081277000},{"_id":"themes/landscape/languages/ru.yml","hash":"81b57fcd1977ef534f4bf303dbc1b4710cc7f057","modified":1554081277000},{"_id":"themes/landscape/languages/nl.yml","hash":"ac0573352ad2c737a7686bcca498b985e7bd6447","modified":1554081277000},{"_id":"themes/landscape/languages/pt-br.yml","hash":"4859aba788a050c2d5d0b997693b0c8c24b349f7","modified":1554081277000},{"_id":"themes/landscape/languages/pl.yml","hash":"8a2d6dc874d86c38d42c2c861c39590647b5d536","modified":1554081277000},{"_id":"themes/landscape/layout/archive.ejs","hash":"53de8817e37be01b3ba8fa5ca31b9cafa2f3c011","modified":1554081277000},{"_id":"themes/landscape/languages/tr.yml","hash":"2702914007e6bade9d6861078c0e179ac05bf48c","modified":1554081277000},{"_id":"themes/landscape/languages/vi.yml","hash":"f84893c3ec3e45875c90069e14b17ed3016ed973","modified":1554081277000},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"2f4e050c9b35a67f4a7278cec3a949533c2ac16a","modified":1554081277000},{"_id":"themes/landscape/layout/index.ejs","hash":"c53484094a7c30ab82b0ea984404157ab9711e71","modified":1554081277000},{"_id":"themes/landscape/layout/page.ejs","hash":"c5465d5315a7544aa466b01fd8cfb62917a8bb1d","modified":1554081277000},{"_id":"themes/landscape/layout/layout.ejs","hash":"8504004f2ed78914f806c6699d9bd722318cbe56","modified":1554081277000},{"_id":"themes/landscape/scripts/meta.js","hash":"fa6055a39851c9953d033e70c1614547b94dce60","modified":1554081277000},{"_id":"themes/landscape/scripts/page_title.js","hash":"fa662dbdb82779af1b95e35ed7ccdf4866a53dee","modified":1554081277000},{"_id":"themes/landscape/scripts/thumbnail.js","hash":"df8829fd8c3119650037eba5ec11bdce06acff9d","modified":1554081277000},{"_id":"themes/landscape/scripts/merge-configs.js","hash":"2048c3415d96b17b9d84aa44bc0c25f1210525f8","modified":1554081277000},{"_id":"themes/landscape/layout/post.ejs","hash":"a7d164ce888a60cd3eddd9c04bc6762428fa66bb","modified":1554081277000},{"_id":"source/img/梯型公式法.png","hash":"8342a1d9226a276e3d033e1490fce6ddc16e5887","modified":1554467201498},{"_id":"source/img/变长梯型公式法.png","hash":"74d6534f051befad7fd9849099a9993ab6a4e5b2","modified":1554467657180},{"_id":"themes/landscape/layout/_partial/comments.ejs","hash":"4cf8d0059e5f8bc8ae1dd1a426293583fd398052","modified":1554081277000},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"c3a80e347cb11022baf5e65fb4d0209b8d205693","modified":1554081277000},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"753dcb513c6f21f6f46e673942c7261cf50da886","modified":1554081277000},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"9b2b7d6e9ab514107adf408c7ec8530fd612b3d5","modified":1554081277000},{"_id":"themes/landscape/layout/_partial/pagination.ejs","hash":"23bf862b3b8a3cd831850504d9b5a24d21b005e7","modified":1554081277000},{"_id":"themes/landscape/layout/_partial/scripts.ejs","hash":"78e3e290ab8bb6450a04b2a9c7c5b7b3da74abb8","modified":1554081277000},{"_id":"themes/landscape/layout/_partial/search.ejs","hash":"8b4bf9cf5db0ce762a31fc3baae0f2fc004bece4","modified":1554081277000},{"_id":"themes/landscape/layout/_partial/styles.ejs","hash":"be1b54388eb02176dd4722285dda19e3dce2e62e","modified":1554081277000},{"_id":"themes/landscape/source/images/favicon-192x192.png","hash":"96e6fcbbb13a5914a6131391e210eb7dfd13d692","modified":1554081277000},{"_id":"themes/landscape/source/images/apple-touch-icon.png","hash":"57e2def34682655f41a0be2d083f16765ba7858b","modified":1554081277000},{"_id":"themes/landscape/source/css/_fonts.styl","hash":"354809b5a64e8a47a66c66fd1a28ac597c1460a6","modified":1554081277000},{"_id":"themes/landscape/source/images/favicon.ico","hash":"189f9842bcb79a6f8f9e8445bc8bbd773443826b","modified":1554081277000},{"_id":"themes/landscape/source/css/_extend.styl","hash":"2c8751d132e62f5f068dc3a184d160670737ba1f","modified":1554081277000},{"_id":"themes/landscape/source/css/_mixins.styl","hash":"1a9e309523df9685e8d088dcff0a809c58e2c392","modified":1554081277000},{"_id":"themes/landscape/source/css/_util.styl","hash":"2bfeb2e2605dd5235693b00c71a212646d2e0410","modified":1554081277000},{"_id":"themes/landscape/source/css/style.styl","hash":"d9be82f7e7145cde78e04183afc8ff13d6a16059","modified":1554081277000},{"_id":"themes/landscape/source/css/rtl.styl","hash":"98355abe9ef3a398a5b4cb40d3d33bf86ac8d1d4","modified":1554081277000},{"_id":"themes/landscape/source/css/_variables.styl","hash":"02079fb71b7d1c01d15fa512a1948ad4cbb416b5","modified":1554081277000},{"_id":"themes/landscape/source/js/main.js","hash":"584c5a69ac81a483a1c4377a2e2cf326c2795e7b","modified":1554081277000},{"_id":"themes/landscape/source/js/search.js","hash":"a74d0c601f820160825a2e4ad13618074d714933","modified":1554081277000},{"_id":"themes/landscape/layout/_partial/post/actions_desktop.ejs","hash":"38aadd1ed890303dde582b722486138afee09b0a","modified":1554081277000},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6f2d1aa9562df343b797d25705f1945323c465fb","modified":1554081277000},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"b5bfa049f17868fb09d9d2a7e1d5279fa0381d37","modified":1554081277000},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"e08fae30da060f49c087f6c121868b08eb55c795","modified":1554081277000},{"_id":"themes/landscape/layout/_partial/post/actions_mobile.ejs","hash":"79b234ff3c264e66b2e71c819228e62bf92b48e4","modified":1554081277000},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"9aecd8908e8a684f33dc20c02497c0f1774137c7","modified":1554081277000},{"_id":"themes/landscape/layout/_partial/post/share.ejs","hash":"847a400e79b775246ca9067e40c3f104d571413d","modified":1554081277000},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"a060f1c6e3718494a6b1d0e1981ea0bf4e549828","modified":1554081277000},{"_id":"themes/landscape/source/css/_colors/classic.styl","hash":"0f0ec41a4165814ce69688425d5ac4d701b7cc70","modified":1554081277000},{"_id":"themes/landscape/source/css/_colors/light.styl","hash":"d09f781cb02394850737b3a9efc6693307d5bf09","modified":1554081277000},{"_id":"themes/landscape/source/css/_colors/white.styl","hash":"2b25ad24573bded8b42f9d80112eab9fadbed1a5","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/agate.styl","hash":"53027913ed8d4f75ac3e49e76aad824f0df62da3","modified":1554081277000},{"_id":"themes/landscape/source/css/_colors/dark.styl","hash":"9c9655b42b85f754b8a573a1d4634c23c680e1bf","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/arta.styl","hash":"b3e81e3e694ceb8deed178adb8b91013c5120e30","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/arduino-light.styl","hash":"15e8572585cd708221c513dea4bdd89d8fe56c10","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/androidstudio.styl","hash":"2af0861725f97f0ee2ded67c3d2d4548c62b2d16","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-cave-dark.styl","hash":"ce63dd8548688d88254405eedfa75b1d7c82449e","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/ascetic.styl","hash":"32cff3bef6fac3760fe78f203096477052a90552","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-cave-light.styl","hash":"a5be0744a7ecf4a08f600ade4cfd555afc67bc15","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-dune-light.styl","hash":"931435fbc6f974e8ce9e32722680035d248a9dc1","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-estuary-dark.styl","hash":"0bb16a4eff93688f40787abc2f9e56e7d5cc93e7","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-dune-dark.styl","hash":"c196ff0ee064af0e507823694ae39020addfc280","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-forest-light.styl","hash":"95228d9f2102fad425536aac44b80b2cba1f5950","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-estuary-light.styl","hash":"344276ca9b27e51d4c907f76afe5d13cf8e60bdf","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-heath-dark.styl","hash":"9a2e9a1d0a01bbdf158560c3ed1c134e098b2c68","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-forest-dark.styl","hash":"effbc5d75fa87203c847039869c22031b40d5b7d","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-lakeside-light.styl","hash":"2c54cb9bdb259ae3b5b29f63ac2469ed34b08578","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-plateau-dark.styl","hash":"84c80e6f67f62fce958d25817c277d2360272617","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-lakeside-dark.styl","hash":"10ee3882fca7b97a37bd309d2d35fce9868647bb","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-savanna-dark.styl","hash":"e32c1c70def8060fce5e790979a126da650ac642","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-heath-light.styl","hash":"8c8c2e445abef85273be966d59770e9ced6aac21","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-plateau-light.styl","hash":"d1a05fdd1ededc9063d181ab25bad55a164aeb4a","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-savanna-light.styl","hash":"f8244c93711c7cb59dd79d2df966806b30d171ea","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-seaside-dark.styl","hash":"2edf385215bbe1985b1a10106525d362667d28c2","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-seaside-light.styl","hash":"0597342da6e2d0c5bdcc7d42dabb07322b1a4177","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-sulphurpool-dark.styl","hash":"538a14321193cd8abf2ddc484306631e54149ffb","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/atelier-sulphurpool-light.styl","hash":"efa52713efc468abeeb2b9299704371583b857de","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/brown-paper.styl","hash":"c2326ba20a5020a66ca7895258d18833327d4334","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/codepen-embed.styl","hash":"8b7b34484f76a6c2c3b1a9e49abb9b382f439ae8","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/dark.styl","hash":"f5e6e75958de59e87fc6be3a1668e870e20bc836","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/color-brewer.styl","hash":"2a439d6214430e2f45dd4939b4dfe1fe1a20aa0f","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/darkula.styl","hash":"9717efa9194837ba3fb4d762997d33075dcf8bfa","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/far.styl","hash":"aaac3028f5e33123cd123a583cddc9290c45ec8e","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/docco.styl","hash":"b1c176378bb275f2e8caa759f36294e42d614bf1","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/github-gist.styl","hash":"48211a03d33e7f7ada0b261162bea06676155a71","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/github.styl","hash":"3336aeba324c6d34a6fd41fef9b47bc598f7064c","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/foundation.styl","hash":"bf8ddc94b4ad995b8b8805b5a4cf95004553fdac","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/grayscale.styl","hash":"bf37d8b8d1e602126c51526f0cc28807440228ed","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/googlecode.styl","hash":"bda816beee7b439814b514e6869dc678822be1bc","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/hopscotch.styl","hash":"1378a6bc67a32c0cbff72ab771268b53f9aa586d","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/highlightjs.styl","hash":"0e198b7a59191c7a39b641a4ddd22c948edb9358","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/index.styl","hash":"002d5596f6379cc87dbd43d9145bc764aa666be1","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/hybrid.styl","hash":"b8eb5c69d12f2ee5ebc50265ae271699d7f1a8d3","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/idea.styl","hash":"a02967cb51c16a34e0ee895d33ded2b823d35b21","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/gruvbox-dark.styl","hash":"76b744c14fd5600bea64731c05df97c2df75523f","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/kimbie.dark.styl","hash":"45dbb168f22d739d0109745d2decd66b5f94e786","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/ir-black.styl","hash":"53e5d74326a4527b92272bbd6946d4fec92720e8","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/kimbie.light.styl","hash":"61f8baed25be05288c8604d5070afbcd9f183f49","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/kimbie.styl","hash":"51b889ca7c6fe178cfbbe28d875a6ea427184441","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/magula.styl","hash":"16d323f989b1420a0f72ef989242ece9bf17a456","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/mono-blue.styl","hash":"4c89a6ae29de67c0700585af82a60607e85df928","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/monokai.styl","hash":"f87be027848ea6bee623a08ad1e17b2f5b7937ee","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/obsidian.styl","hash":"199e28326be8590883f0813ebbd54fcfaa4750fd","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/paraiso-light.styl","hash":"d224d1df0eb3395d9eea1344cee945c228af2911","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/paraiso.styl","hash":"75f181eece6b71d033ea0c8d6cf00ae7efb9e29b","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/paraiso-dark.styl","hash":"f1537bd868579fa018ecdbfd2eb922dcf3ba2cac","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/monokai-sublime.styl","hash":"c385b11345894be7e6ce3c5f08663e199933b8e4","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/rainbow.styl","hash":"c0cf97aae3e10fdcd10414547a711c9effbc39b8","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/pojoaque.styl","hash":"4e7b6b046b8575ac749f6aec4e953a62ada27a36","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/pojoaque.jpg","hash":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/solarized-dark.styl","hash":"90c9da5aa594383697e5b18892a7f95beb053f55","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/school-book.styl","hash":"d43560fe519a931ce6da7d57416d7aa148441b83","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/railscasts.styl","hash":"b6674db9210e0c4444e4835fff2d1361f3ebd64c","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/sunburst.styl","hash":"af3eec0fd56151e55bbd49c31b151f36717611d8","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/solarized-light.styl","hash":"aa0dd3fd25c464183b59c5575c9bee8756b397f2","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/tomorrow-night-bright.styl","hash":"7674fecb6d27350727dc0d2dc93bc018382ebbd0","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/tomorrow-night-eighties.styl","hash":"28d751075ebabf7d0327a36f725076fe82fdf626","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/tomorrow-night.styl","hash":"16ba09b2db501e4e3e2e7d62595d9bf935bf27c4","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/zenburn.styl","hash":"68ff9332ccc03f9389b15b713415cde016f8088f","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/tomorrow.styl","hash":"15779cf6846725c7c35fc56cac39047d7e0aec1c","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/tomorrow-night-blue.styl","hash":"f24c17d0ab815dcfaab3438cb9fe2ab4839f5e0d","modified":1554081277000},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"ef8fc52337c4c7b010cad7c427cb78009b30f9d8","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/vs.styl","hash":"959a746f4b37aacb5d1d6ff1d57e0c045289d75d","modified":1554081277000},{"_id":"themes/landscape/source/css/_partial/comments.styl","hash":"1e90f1fb9d4c155df518cacb5a537e9de9c042c1","modified":1554081277000},{"_id":"themes/landscape/source/css/_partial/categories.styl","hash":"a43f00e61b3507f130b8a3f8108a4eeca147c2a0","modified":1554081277000},{"_id":"themes/landscape/source/css/_partial/index.styl","hash":"59c99f4ea3a73bf47ce030df166c5e33d5de31fb","modified":1554081277000},{"_id":"themes/landscape/source/css/_highlight/xcode.styl","hash":"5e8532ae8366dcf6a4ef5e4813dc3d42ab3d0a50","modified":1554081277000},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"d9b13e402808175dc90761cc4fdfe3d4808034f8","modified":1554081277000},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"7ff5b6a28dc3f2cd4ebfc4f5351054a18800bf96","modified":1554081277000},{"_id":"themes/landscape/source/css/_partial/pagination.styl","hash":"950bf517bbe7adb9a9aa4eb5ddec74ffc7598787","modified":1554081277000},{"_id":"themes/landscape/source/css/_partial/search.styl","hash":"159be002780c62a77f46947cf854a7342fba24f4","modified":1554081277000},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"662667942cc9a2caf55caa84a0fc73617d0c3aa4","modified":1554081277000},{"_id":"themes/landscape/source/css/_partial/tags.styl","hash":"d571d5c7c960300d29c5f0ec3fe1140322ecd6b3","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Black.woff2","hash":"0a257c8b60e0f20802c1dc8daeed2d3cb0d44f17","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Black.woff","hash":"37443d0040f0d7af381c955e4c15919a15d0349e","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Bold.woff2","hash":"62447a951d48b21c4696ae72df4bc4adef636e26","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Bold.woff","hash":"df15fd1e74b6f4a50bea57e2b44d9627f38495b5","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Light.woff","hash":"32ae5c0d1d5943c8bb8e0f6ab07c3269c6f8b8a8","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Light.woff2","hash":"ef07a250766fea840c1049e67c0405d9216ee0a8","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Medium.woff","hash":"f5653059b2a5929516e4aab02329a978600b9b67","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Medium.woff2","hash":"668400ae92700965f03f2371faaee0ab8c8347c3","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Thin.woff","hash":"ad4d46a99a1daf6353c86c79ac3a2b030213859c","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Thin.woff2","hash":"c3be79b553ec394db71268d604b1d29183b867dc","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/font-face.css","hash":"8f2bf6b59ae1f2ed4c2fead6cea4b8314fcf62e5","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir.woff","hash":"bbee70033f0f5882e9869e417b69c6a38f56f187","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir.woff2","hash":"30ce165216db078951a690a6ad665b9b78f5dd81","modified":1554081277000},{"_id":"themes/landscape/source/lib/jquery/jquery.min.js","hash":"0dc32db4aa9c5f03f3b38c47d883dbd4fed13aae","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Black.ttf","hash":"594dc3344ad14903c247615427d1009709f0f5a4","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Black.eot","hash":"13d026ff857c853cbd0dc519b6e58669db309441","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Bold.eot","hash":"f76ec625e15522ff60d21f7a9a3b71c65bc27556","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Bold.ttf","hash":"2e6c9df9f775373fb1988ae8529aa8f05313dae6","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Light.eot","hash":"3edffd7bb61eee8cd46b57225f9f9e5264e3362b","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Light.ttf","hash":"9f1e2934098a6a4a7c5584c8f3fa24a707070da3","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Medium.eot","hash":"1f5a73db7947ef22c8a2bb19d6449b80496c03c4","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Medium.ttf","hash":"295f7e02c9b157e7ea63ad09613b00ceab85c5cd","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Thin.eot","hash":"08e1503d1181188690fd9c81860d6c890c1465f6","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir-Thin.ttf","hash":"a6aa450ee6e0f85786474ca6b04827ef97e81af4","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir.eot","hash":"31a9219c25fe1991fb745ec8dbbcf45c6094a702","modified":1554081277000},{"_id":"themes/landscape/source/lib/vazir-font/Vazir.ttf","hash":"f22b219824026e490a581ddb3b36b07997dff0e3","modified":1554081277000},{"_id":"themes/landscape/source/images/logo.png","hash":"0e3029251dfda26adee2761f71377297e8c26871","modified":1554081277000},{"_id":"themes/landscape/source/css/_partial/post/actions_mobile.styl","hash":"0d2966c1d870392476864af8ee3ba312ba30cb82","modified":1554081277000},{"_id":"themes/landscape/source/css/_partial/post/actions_desktop.styl","hash":"4ef72ea70f7c840b2843bf7717aaafae3b6fc241","modified":1554081277000},{"_id":"themes/landscape/source/lib/font-awesome/css/all.min.css","hash":"cf1a3fd771900af34f2af22142beecfb47367548","modified":1554081277000},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-regular-400.woff","hash":"7b3f44b4d3028f3c87ddf0f4bd62511c9bf4a87e","modified":1554081277000},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-regular-400.eot","hash":"42ff503f20e97503cef8e5b2ec10ae07699d7c01","modified":1554081277000},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"9784edb76f8a2ed595ea4bf74d46cda4eff3b303","modified":1554081277000},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-regular-400.ttf","hash":"c140085833a38abec6b7df99d4ccac93eb266031","modified":1554081277000},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"92da6e3c7121e21cdfde25ef08797a3937a683e1","modified":1554081277000},{"_id":"themes/landscape/source/lib/justified-gallery/css/justifiedGallery.min.css","hash":"92bb6e468a1db7fbd99ccb960e15e28572254263","modified":1554081277000},{"_id":"themes/landscape/source/lib/justified-gallery/js/jquery.justifiedGallery.min.js","hash":"82ab395176c927ffbb2f7c95132ee0a06cd5d64a","modified":1554081277000},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"d902f8db3e021155f177f698a252fb98d6e61768","modified":1554081277000},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-brands-400.woff","hash":"f9d835a0f9248b1bb33d66968e87c4a50103ed8d","modified":1554081277000},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-brands-400.ttf","hash":"19e302760e39e25a5f8d90d6cd0164ef6cd74f8c","modified":1554081277000},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-solid-900.woff","hash":"80d33a73cbb60e206ef6f5c898988641576c7dda","modified":1554081277000},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-brands-400.eot","hash":"644ece8263d2f96b087eebf7f6d4e309e5898eb5","modified":1554081277000},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-regular-400.svg","hash":"33e86c0ad6fb9c5c0c8c2af4cb2d790c6b14a8aa","modified":1554081277000},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-solid-900.eot","hash":"10740942ec6b3f4985529d343402d0bf32f9f847","modified":1554081277000},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGM-BoldItalic.ttf","hash":"b542b9591fbf33925d93f0695b6e123a9f0cfd43","modified":1554081277000},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGS-Italic.ttf","hash":"9d757cc9f928fc83b2133283dd639c12b11d94ad","modified":1554081277000},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGS-BoldItalic.ttf","hash":"926035f0156cccf1b0ca507347f39bf9c510f51e","modified":1554081277000},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGL-BoldItalic.ttf","hash":"b7d24ab1e4fad720f31a2b0cca1904ce1740d846","modified":1554081277000},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGM-Italic.ttf","hash":"93ebc5098cf57a32b7b8d297681f31692c09bdfa","modified":1554081277000},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGL-Italic.ttf","hash":"9a23c6898b0943bd3d96c04df9a0f66e919451d8","modified":1554081277000},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGM-Bold.ttf","hash":"58be4b7760e9a84daa81929d046f9a15c4fd1c1a","modified":1554081277000},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-solid-900.ttf","hash":"c445864a9646948e0d7ff44930ad732ee61427d8","modified":1554081277000},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGS-Bold.ttf","hash":"f9918fb93d6ab6850f5d38069a999c311af78816","modified":1554081277000},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGL-Bold.ttf","hash":"34f7db59f1d023294e69976aa20b7d52b86165a4","modified":1554081277000},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGM-Regular.ttf","hash":"20ce1fc7ae1254558ca044ae48283faaa58897e5","modified":1554081277000},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGL-Regular.ttf","hash":"6c090d6bff3928fbf8a5f4104e58ed7f421aea7c","modified":1554081277000},{"_id":"themes/landscape/source/lib/meslo-LG/MesloLGS-Regular.ttf","hash":"de559f8d70d5b1ab2810597bfd0b1b9506f3ef01","modified":1554081277000},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-brands-400.svg","hash":"b0bb9e6ac7709206b9510f1718516d89aead5b21","modified":1554081277000},{"_id":"themes/landscape/source/lib/font-awesome/webfonts/fa-solid-900.svg","hash":"ed6c1ed8f24df909f40fe5e5c652d7ff9570c821","modified":1554081277000},{"_id":"public/2019/04/19/游戏算法卡01-A*算法/index.html","hash":"3842123c1ef474ef7ec0ed09fece87f99eb6468f","modified":1558765569143},{"_id":"public/2019/04/15/动态规划05/index.html","hash":"42f9cfa25244a5600c605be5bbc48ebc4e1a5144","modified":1558763174829},{"_id":"public/2019/04/11/动态规划法01/index.html","hash":"9d8efc415c7f97867c52d424457d18e829445417","modified":1558763174829},{"_id":"public/2019/04/10/穷举搜索法10/index.html","hash":"bb8515e229e67beae5ffc59af8f1507fec87b7e7","modified":1558763174829},{"_id":"public/2019/04/10/穷举搜索法09/index.html","hash":"165a83d79a3b3b5980421ae04631844bdadcf526","modified":1558763174830},{"_id":"public/2019/04/09/穷举搜索法08/index.html","hash":"8ae0ec71581d50855cc5575f2718e599741ab30d","modified":1558763174830},{"_id":"public/2019/04/09/穷举搜索法07/index.html","hash":"177e419cc2fea6b9c32b82624291b46f809b6d32","modified":1558763174830},{"_id":"public/2019/04/08/穷举搜索法05/index.html","hash":"d51db647a4ca71f7d1fdd354f25412b6b48c1fe2","modified":1558765569144},{"_id":"public/2019/04/08/unpacking_tuple_of_lists/index.html","hash":"5ce7772b1909be4acd492d0d50b5aed89fd51727","modified":1558763174830},{"_id":"public/2019/04/07/穷举搜索卡04/index.html","hash":"a70befa44aa4708b62ba04ae3300e807cc473fa1","modified":1558765569173},{"_id":"public/2019/04/07/穷举搜索卡03/index.html","hash":"469652429c98dcb22e47ac0aee732d45a8469423","modified":1558763174830},{"_id":"public/2019/04/06/穷举搜索卡01/index.html","hash":"c4d4694569b7637caa33250e0ac65fff55baf0d1","modified":1558763174830},{"_id":"public/2019/04/05/迭代递推卡03/index.html","hash":"bb7ccece278ae650b91d7415f0edde9c8f7d33ac","modified":1558763174830},{"_id":"public/2019/04/05/迭代递推卡02/index.html","hash":"ace1129b556c1d72dae003d9de104cd5d1ea25b6","modified":1558763174830},{"_id":"public/2019/04/05/迭代递推卡01/index.html","hash":"6417c13e73e703c6d0339e3a3f7880246e892b93","modified":1558763174830},{"_id":"public/2019/04/04/基础卡06-基础开胃菜/index.html","hash":"81e8bb4d1af9746e515bf860c20a817a0490091a","modified":1558763174830},{"_id":"public/2019/04/04/挂载硬盘的一些命令/index.html","hash":"2041406828cf4ae86ae7d21719b0a3e605d5574e","modified":1559523788563},{"_id":"public/2019/04/01/开营仪式/index.html","hash":"60d661d6b649ee162a10cb197a2a6053002df4b1","modified":1558763174831},{"_id":"public/2019/04/01/热身卡01-开篇词：算法是程序的灵魂/index.html","hash":"5365cd2cb5cc87f5b44d1a96ff62b7687d89e88b","modified":1558763174831},{"_id":"public/2019/04/01/热身卡03-如何\"玩\"算法/index.html","hash":"14716c7babdf6b60d1d1d1a1b17fef4c2e3fed14","modified":1558763174831},{"_id":"public/2019/04/01/28天训练营课程表/index.html","hash":"c26eac356c83b417737471cf8e389dcd32b63add","modified":1558765569173},{"_id":"public/2019/04/01/hello-world/index.html","hash":"25163ac5467791b1fb6719a1915a8799db571c22","modified":1558763174831},{"_id":"public/archives/index.html","hash":"60079c5798681478eb48449bc17595b223b64b60","modified":1559624023998},{"_id":"public/archives/page/2/index.html","hash":"db1afc63772e43d3f3c7bf076f8ca23d76af80ab","modified":1559624023998},{"_id":"public/archives/page/3/index.html","hash":"a6a6f5b08c657a61fedef790ef3f44ce441d40e2","modified":1559624023998},{"_id":"public/archives/2019/index.html","hash":"54e7970ba104b31fcdf710a7494cf5b5e98d18fd","modified":1559624023999},{"_id":"public/archives/2019/page/2/index.html","hash":"b3037b7b02f15491316f082fdabaddc5485d1a75","modified":1559624023999},{"_id":"public/archives/2019/page/3/index.html","hash":"86c1fca5d89004dc30dbce76dd01ebfc276f63ea","modified":1559624023999},{"_id":"public/archives/2019/04/index.html","hash":"79a78b19071fc7898490d9d7c5140264277f1922","modified":1559523788570},{"_id":"public/archives/2019/04/page/2/index.html","hash":"67cc20665a7bf68052b7343e5b703f0b144d2ef4","modified":1559523788570},{"_id":"public/archives/2019/04/page/3/index.html","hash":"63ff85b9dc0fa123a33a504281f9326cf35981de","modified":1559523788570},{"_id":"public/index.html","hash":"89cfdbbff10a7a21472fd7c6b37d186230c9eb3d","modified":1559624023973},{"_id":"public/page/2/index.html","hash":"9de971f46676507e48a7c1a7ccdc72d08114eca9","modified":1559624023974},{"_id":"public/page/3/index.html","hash":"ba4b2d7b5e1ecf15d80af124d15b3eb2b1dba3b9","modified":1559624023997},{"_id":"public/2019/04/09/穷举搜索法06/index.html","hash":"6c1fc09ea611610eb7993c9aa4631cce6b5dbd18","modified":1558763174832},{"_id":"public/2019/04/06/穷举搜索卡02/index.html","hash":"944312374b373426266d0069cd0635bde8d7f91d","modified":1558763174832},{"_id":"public/2019/04/05/基础卡05-迭代法/index.html","hash":"d101ee37e5593f9c6be3bf78e74dddfd90d37a7c","modified":1558763174832},{"_id":"public/2019/04/03/基础卡03-动态规划/index.html","hash":"bcf02e32736e4923a42824f9d0d01621c62db1b5","modified":1558763174832},{"_id":"public/2019/04/03/基础卡04-穷举法/index.html","hash":"a8af4b3f01647d43216298674a8dde6820f47b45","modified":1558763174832},{"_id":"public/2019/04/03/基础卡01-贪婪法/index.html","hash":"8e0127d4be7e2cbfacca3bd194af9c7621e8541a","modified":1558763174832},{"_id":"public/2019/04/01/基础卡02-分治法/index.html","hash":"b8a458c45c4ee8cadff94079438e76254a1159f5","modified":1558763174832},{"_id":"public/2019/04/01/热身卡02-入门测试题/index.html","hash":"e85cfe49af3d5ac8870d017710022817f8d0408a","modified":1558767433044},{"_id":"public/images/apple-touch-icon.png","hash":"57e2def34682655f41a0be2d083f16765ba7858b","modified":1558763174843},{"_id":"public/images/favicon.ico","hash":"189f9842bcb79a6f8f9e8445bc8bbd773443826b","modified":1558763174843},{"_id":"public/lib/vazir-font/Vazir-Black.woff2","hash":"0a257c8b60e0f20802c1dc8daeed2d3cb0d44f17","modified":1558763174843},{"_id":"public/lib/vazir-font/Vazir-Bold.woff2","hash":"62447a951d48b21c4696ae72df4bc4adef636e26","modified":1558763174843},{"_id":"public/lib/vazir-font/Vazir-Bold.woff","hash":"df15fd1e74b6f4a50bea57e2b44d9627f38495b5","modified":1558763174843},{"_id":"public/lib/vazir-font/Vazir-Black.woff","hash":"37443d0040f0d7af381c955e4c15919a15d0349e","modified":1558763174843},{"_id":"public/lib/vazir-font/Vazir-Light.woff","hash":"32ae5c0d1d5943c8bb8e0f6ab07c3269c6f8b8a8","modified":1558763174843},{"_id":"public/lib/vazir-font/Vazir-Light.woff2","hash":"ef07a250766fea840c1049e67c0405d9216ee0a8","modified":1558763174844},{"_id":"public/lib/vazir-font/Vazir-Medium.woff","hash":"f5653059b2a5929516e4aab02329a978600b9b67","modified":1558763174844},{"_id":"public/lib/vazir-font/Vazir-Thin.woff","hash":"ad4d46a99a1daf6353c86c79ac3a2b030213859c","modified":1558763174844},{"_id":"public/lib/vazir-font/Vazir-Thin.woff2","hash":"c3be79b553ec394db71268d604b1d29183b867dc","modified":1558763174844},{"_id":"public/lib/vazir-font/Vazir-Medium.woff2","hash":"668400ae92700965f03f2371faaee0ab8c8347c3","modified":1558763174844},{"_id":"public/lib/vazir-font/Vazir.woff","hash":"bbee70033f0f5882e9869e417b69c6a38f56f187","modified":1558763174844},{"_id":"public/lib/vazir-font/Vazir.woff2","hash":"30ce165216db078951a690a6ad665b9b78f5dd81","modified":1558763174844},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff","hash":"7b3f44b4d3028f3c87ddf0f4bd62511c9bf4a87e","modified":1558763174844},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"9784edb76f8a2ed595ea4bf74d46cda4eff3b303","modified":1558763174844},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.eot","hash":"42ff503f20e97503cef8e5b2ec10ae07699d7c01","modified":1558763174844},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.ttf","hash":"c140085833a38abec6b7df99d4ccac93eb266031","modified":1558763174844},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"92da6e3c7121e21cdfde25ef08797a3937a683e1","modified":1558763174844},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"d902f8db3e021155f177f698a252fb98d6e61768","modified":1558763174845},{"_id":"public/img/辛普森公式法.png","hash":"bdfdc4ec6767f6b6f69d6fe321dfdf2a44319c84","modified":1558763175080},{"_id":"public/img/梯型公式法.png","hash":"8342a1d9226a276e3d033e1490fce6ddc16e5887","modified":1558763175080},{"_id":"public/img/变长梯型公式法.png","hash":"74d6534f051befad7fd9849099a9993ab6a4e5b2","modified":1558763175081},{"_id":"public/images/favicon-192x192.png","hash":"96e6fcbbb13a5914a6131391e210eb7dfd13d692","modified":1558763175081},{"_id":"public/lib/vazir-font/Vazir-Black.ttf","hash":"594dc3344ad14903c247615427d1009709f0f5a4","modified":1558763175081},{"_id":"public/lib/vazir-font/Vazir-Black.eot","hash":"13d026ff857c853cbd0dc519b6e58669db309441","modified":1558763175081},{"_id":"public/lib/vazir-font/Vazir-Bold.eot","hash":"f76ec625e15522ff60d21f7a9a3b71c65bc27556","modified":1558763175081},{"_id":"public/lib/vazir-font/Vazir-Bold.ttf","hash":"2e6c9df9f775373fb1988ae8529aa8f05313dae6","modified":1558763175081},{"_id":"public/lib/vazir-font/Vazir-Light.eot","hash":"3edffd7bb61eee8cd46b57225f9f9e5264e3362b","modified":1558763175081},{"_id":"public/lib/vazir-font/Vazir-Light.ttf","hash":"9f1e2934098a6a4a7c5584c8f3fa24a707070da3","modified":1558763175081},{"_id":"public/lib/vazir-font/Vazir-Medium.eot","hash":"1f5a73db7947ef22c8a2bb19d6449b80496c03c4","modified":1558763175082},{"_id":"public/lib/vazir-font/Vazir-Medium.ttf","hash":"295f7e02c9b157e7ea63ad09613b00ceab85c5cd","modified":1558763175082},{"_id":"public/lib/vazir-font/Vazir.eot","hash":"31a9219c25fe1991fb745ec8dbbcf45c6094a702","modified":1558763175082},{"_id":"public/lib/vazir-font/Vazir-Thin.eot","hash":"08e1503d1181188690fd9c81860d6c890c1465f6","modified":1558763175082},{"_id":"public/lib/vazir-font/Vazir.ttf","hash":"f22b219824026e490a581ddb3b36b07997dff0e3","modified":1558763175082},{"_id":"public/lib/vazir-font/Vazir-Thin.ttf","hash":"a6aa450ee6e0f85786474ca6b04827ef97e81af4","modified":1558763175082},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff","hash":"f9d835a0f9248b1bb33d66968e87c4a50103ed8d","modified":1558763175082},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.ttf","hash":"19e302760e39e25a5f8d90d6cd0164ef6cd74f8c","modified":1558763175082},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff","hash":"80d33a73cbb60e206ef6f5c898988641576c7dda","modified":1558763175082},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.eot","hash":"644ece8263d2f96b087eebf7f6d4e309e5898eb5","modified":1558763175083},{"_id":"public/css/rtl.css","hash":"c2c2bc4ce311b3129275e009e903088b45e7ed77","modified":1558763175088},{"_id":"public/js/main.js","hash":"584c5a69ac81a483a1c4377a2e2cf326c2795e7b","modified":1558763175088},{"_id":"public/js/search.js","hash":"a74d0c601f820160825a2e4ad13618074d714933","modified":1558763175088},{"_id":"public/lib/vazir-font/font-face.css","hash":"8f2bf6b59ae1f2ed4c2fead6cea4b8314fcf62e5","modified":1558763175088},{"_id":"public/lib/justified-gallery/css/justifiedGallery.min.css","hash":"92bb6e468a1db7fbd99ccb960e15e28572254263","modified":1558763175088},{"_id":"public/css/style.css","hash":"65a6371478e578f261dfabd29cc430ea48e8445e","modified":1558763175088},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.svg","hash":"33e86c0ad6fb9c5c0c8c2af4cb2d790c6b14a8aa","modified":1558763175094},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.ttf","hash":"c445864a9646948e0d7ff44930ad732ee61427d8","modified":1558763175094},{"_id":"public/lib/justified-gallery/js/jquery.justifiedGallery.min.js","hash":"82ab395176c927ffbb2f7c95132ee0a06cd5d64a","modified":1558763175098},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.eot","hash":"10740942ec6b3f4985529d343402d0bf32f9f847","modified":1558763175098},{"_id":"public/images/logo.png","hash":"0e3029251dfda26adee2761f71377297e8c26871","modified":1558763175103},{"_id":"public/lib/meslo-LG/MesloLGM-BoldItalic.ttf","hash":"b542b9591fbf33925d93f0695b6e123a9f0cfd43","modified":1558763175108},{"_id":"public/lib/meslo-LG/MesloLGS-BoldItalic.ttf","hash":"926035f0156cccf1b0ca507347f39bf9c510f51e","modified":1558763175108},{"_id":"public/lib/meslo-LG/MesloLGL-BoldItalic.ttf","hash":"b7d24ab1e4fad720f31a2b0cca1904ce1740d846","modified":1558763175108},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"cf1a3fd771900af34f2af22142beecfb47367548","modified":1558763175113},{"_id":"public/lib/meslo-LG/MesloLGL-Italic.ttf","hash":"9a23c6898b0943bd3d96c04df9a0f66e919451d8","modified":1558763175113},{"_id":"public/lib/meslo-LG/MesloLGM-Italic.ttf","hash":"93ebc5098cf57a32b7b8d297681f31692c09bdfa","modified":1558763175113},{"_id":"public/lib/meslo-LG/MesloLGS-Bold.ttf","hash":"f9918fb93d6ab6850f5d38069a999c311af78816","modified":1558763175118},{"_id":"public/lib/meslo-LG/MesloLGL-Regular.ttf","hash":"6c090d6bff3928fbf8a5f4104e58ed7f421aea7c","modified":1558763175118},{"_id":"public/lib/meslo-LG/MesloLGS-Regular.ttf","hash":"de559f8d70d5b1ab2810597bfd0b1b9506f3ef01","modified":1558763175119},{"_id":"public/lib/meslo-LG/MesloLGM-Regular.ttf","hash":"20ce1fc7ae1254558ca044ae48283faaa58897e5","modified":1558763175120},{"_id":"public/lib/meslo-LG/MesloLGS-Italic.ttf","hash":"9d757cc9f928fc83b2133283dd639c12b11d94ad","modified":1558763175126},{"_id":"public/lib/meslo-LG/MesloLGM-Bold.ttf","hash":"58be4b7760e9a84daa81929d046f9a15c4fd1c1a","modified":1558763175126},{"_id":"public/lib/meslo-LG/MesloLGL-Bold.ttf","hash":"34f7db59f1d023294e69976aa20b7d52b86165a4","modified":1558763175129},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.svg","hash":"ed6c1ed8f24df909f40fe5e5c652d7ff9570c821","modified":1558763175134},{"_id":"public/lib/jquery/jquery.min.js","hash":"0dc32db4aa9c5f03f3b38c47d883dbd4fed13aae","modified":1558763175135},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.svg","hash":"b0bb9e6ac7709206b9510f1718516d89aead5b21","modified":1558763175139},{"_id":"source/_posts/安装步骤.md","hash":"014939865334f9276b8e44ab74384cbf5544fe3b","modified":1558765559300},{"_id":"public/2019/05/25/安装步骤/index.html","hash":"cd918c4c1b07102b3167ff024ab749e58a2f98a7","modified":1558767433033},{"_id":"public/2019/05/25/unpacking_tuple_of_lists/index.html","hash":"2f0ddd1899200462437c9b603d298bb64d923b9d","modified":1559523788198},{"_id":"public/archives/2019/05/index.html","hash":"22a13395b3331ddbc8a9d62f5f5b75a3444144ea","modified":1559523788570},{"_id":"source/_posts/将26个小写字母与阿拉伯数字对应.md","hash":"cd4dd5e11ca83a8a5d615478f7f785eb05adcf6b","modified":1558780931179},{"_id":"public/2019/05/25/将26个小写字母与阿拉伯数字对应/index.html","hash":"af2f2d709d81a73348c172a8a611bc9b884865ea","modified":1559523788198},{"_id":"source/_posts/卷积中的重要参数.md","hash":"311366b508560f0c8a123f36b6fc0937e6d1f6c4","modified":1558860228991},{"_id":"source/img/pad.png","hash":"7c2c51394c0163d44be8182baf9fc4b42dd84cbc","modified":1558857057884},{"_id":"source/img/stride.png","hash":"eb95dd01016f11199ddf05a8fb6b2eb97c5001b0","modified":1558856821977},{"_id":"public/2019/05/26/卷积中的重要参数/index.html","hash":"404646d47296badd40bd7ba162eabf4b3fbef3f5","modified":1558860508971},{"_id":"public/page/4/index.html","hash":"8dd65a615fb1e7eefbfd4026ba03ca2be40e8e4b","modified":1559624023998},{"_id":"public/archives/page/4/index.html","hash":"142279ec3a6ecdc1404fc2ac261d5486395de3c0","modified":1559624023999},{"_id":"public/archives/2019/page/4/index.html","hash":"66ca2ce9f68020432247e4c5be35228fca4ebd87","modified":1559624023999},{"_id":"public/img/stride.png","hash":"eb95dd01016f11199ddf05a8fb6b2eb97c5001b0","modified":1558857417784},{"_id":"public/img/pad.png","hash":"7c2c51394c0163d44be8182baf9fc4b42dd84cbc","modified":1558857417786},{"_id":"source/_posts/BatchNorm层.md","hash":"a826fc3a85e47695044a92f4ec8a2395a074b017","modified":1558860451272},{"_id":"source/_posts/池化层.md","hash":"97dbe507b31eec80fa13afbc5a95e3f866c10fdd","modified":1558858037487},{"_id":"source/_posts/激活层.md","hash":"15d1eca9ccbd4696110bd6d88278a2a1315698fd","modified":1558859674446},{"_id":"source/img/常见激活函数.png","hash":"13ac9413c5da89e6bff9a5efa8b5ff40437c587c","modified":1558858329448},{"_id":"source/img/BatchNorm.png","hash":"e6083d642d9c9e81b1d4931d1f8b36d3466b5347","modified":1558859982001},{"_id":"source/img/BatchNorm层的优点.png","hash":"4bd722f49230daf8799474d4c8bc3e02cf7482e4","modified":1558860124075},{"_id":"source/img/ReLU.png","hash":"1d6e48e2764d293a595623a1cbf6d60f4d615c5b","modified":1558859639746},{"_id":"source/img/池化.png","hash":"331cd73a3de111542eb427519fc4eb0986e31370","modified":1558857739367},{"_id":"source/img/tensorflow使用BatchNorm层.png","hash":"03e54d09b6cc05668eadddb338593d3f1d3d7238","modified":1558860402166},{"_id":"public/2019/05/26/BatchNorm层/index.html","hash":"5638fa5e54304c69e81a0d1dcf61ae12cbca48cf","modified":1559126362269},{"_id":"public/2019/05/26/激活层/index.html","hash":"651e41d70dff63a0a2d173dcc6b9babef71a86ad","modified":1558860509005},{"_id":"public/2019/05/26/池化层/index.html","hash":"60719d4547d4e906a4147837c9e2dbb60dbda7f8","modified":1558860509005},{"_id":"public/img/常见激活函数.png","hash":"13ac9413c5da89e6bff9a5efa8b5ff40437c587c","modified":1558860509007},{"_id":"public/img/BatchNorm.png","hash":"e6083d642d9c9e81b1d4931d1f8b36d3466b5347","modified":1558860509012},{"_id":"public/img/BatchNorm层的优点.png","hash":"4bd722f49230daf8799474d4c8bc3e02cf7482e4","modified":1558860509012},{"_id":"public/img/ReLU.png","hash":"1d6e48e2764d293a595623a1cbf6d60f4d615c5b","modified":1558860509012},{"_id":"public/img/池化.png","hash":"331cd73a3de111542eb427519fc4eb0986e31370","modified":1558860509012},{"_id":"public/img/tensorflow使用BatchNorm层.png","hash":"03e54d09b6cc05668eadddb338593d3f1d3d7238","modified":1558860509015},{"_id":"source/_posts/work0528.md","hash":"5535aeef0b48ad85eb631791026342abaf93746b","modified":1559108564637},{"_id":"source/_posts/work0529.md","hash":"fedbf66145f239fb6494fe551f6f0bfb3f027b57","modified":1559182366134},{"_id":"public/2019/05/29/work0529/index.html","hash":"531042de5e5613287d698f1392959e5011334f41","modified":1559126362286},{"_id":"public/2019/05/29/work0528/index.html","hash":"3d5ae6aaabb519b898a524d830dcb416c7031ea4","modified":1559196128808},{"_id":"source/_posts/work0530.md","hash":"4be6a49e7720fe4d6bcd633ef134b1a252eb690d","modified":1559264994383},{"_id":"source/img/190530解决携程房型拼接属性不兼容问题.jpg","hash":"cea22ada86a390443420d47bec79ee650bbb1a92","modified":1559183431361},{"_id":"source/_posts/3编程概论.html","hash":"5a5e57a0b1139ede6a531273709f4db7163ec3a8","modified":1559196302909},{"_id":"public/2019/05/30/work0530/index.html","hash":"da03c8473d2869658676609d5fb4e1e94d4687ce","modified":1559196628421},{"_id":"public/2019/05/30/work0529/index.html","hash":"1ebd09d7dc6d8909fd999d5b0ce21585606f94a9","modified":1559278160970},{"_id":"public/archives/2019/05/page/2/index.html","hash":"cb42ae3309339ea974dc6d98e2530be111baf062","modified":1559368537130},{"_id":"public/2019/05/30/3编程概论/index.html","hash":"85abe1c52c0822a89eb4e9f3fbd45500e40a5059","modified":1559196307906},{"_id":"public/img/190530解决携程房型拼接属性不兼容问题.jpg","hash":"cea22ada86a390443420d47bec79ee650bbb1a92","modified":1559196128897},{"_id":"source/_posts/3_python_coding_introduction.html","hash":"5a5e57a0b1139ede6a531273709f4db7163ec3a8","modified":1559196302909},{"_id":"public/2019/05/30/3_python_coding_introduction/index.html","hash":"fffd61a43ef00800c6a0c3829ea8b81988b590b9","modified":1559278161003},{"_id":"source/_posts/4_function.html","hash":"cb9f9827a9da2b6b7e2a89251ee76edf17c7a3c3","modified":1559278106278},{"_id":"public/2019/05/31/work0530/index.html","hash":"e89aa3935613a9692753f659d589628ad033c6dd","modified":1559278161004},{"_id":"public/2019/05/31/4_function/index.html","hash":"13fb422eb653e73f448e7e58700edaec33602967","modified":1559281600393},{"_id":"source/_posts/python_asyncio_guidelines.html","hash":"e469c32a403f245024e30dd8e9a7881200eb1b97","modified":1559281660753},{"_id":"public/2019/05/31/python_asyncio_guidelines/index.html","hash":"18d6a64377481c8c990efd00a2872230ab0a152f","modified":1559281996428},{"_id":"source/_posts/python_coroutine.html","hash":"0e9677ac949990853b5e4aa4a84ec917f01dfabf","modified":1559281992548},{"_id":"public/archives/page/5/index.html","hash":"b347727f8684a2bad67e7cd7aef55f27a5c06c76","modified":1559624023999},{"_id":"public/archives/2019/page/5/index.html","hash":"329feae6a88dfa1e33c7618c071d433734d82241","modified":1559624023999},{"_id":"public/page/5/index.html","hash":"c320a4a37b4b8ba7cef9ff1fb792306769a25457","modified":1559624023998},{"_id":"public/2019/05/31/python_coroutine/index.html","hash":"1b4bc70ec3667341bd2ed4d7b9f6cb163bf9c6f7","modified":1559368537130},{"_id":"source/_posts/Python学习路线.md","hash":"c367d5fd8fc7ed868218a4040ef12c8ba6b40a47","modified":1559368770524},{"_id":"source/_posts/work_0531.md","hash":"b3e57c2d056726020bc605246b17d4c800c2b48f","modified":1559297992748},{"_id":"public/2019/05/31/work_0531/index.html","hash":"06a2b1ed1de281802323a13bdc2bb227e278f333","modified":1559368537131},{"_id":"public/archives/2019/06/index.html","hash":"fdd4a9793ddb2fb70134b2fb270822ab22cd67ec","modified":1559624023999},{"_id":"public/2019/06/01/Python学习路线/index.html","hash":"a7a73b454ea805a733d2d2715ab5f97e8a611721","modified":1559523788570},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1559369087436},{"_id":"source/_posts/test/1.md","hash":"aee9d44bd9068a1c71fc45d43ea1f56c4a57f2dd","modified":1559369187113},{"_id":"source/_posts/Python3_TensorFlow_WechatApplet/1.md","hash":"aee9d44bd9068a1c71fc45d43ea1f56c4a57f2dd","modified":1559369187113},{"_id":"source/_posts/Python3_TensorFlow_WechatApplet/BatchNorm层.md","hash":"81f3f481780125bdbccbc70052ec075b4665910a","modified":1559369527160},{"_id":"source/_posts/Python3_TensorFlow_WechatApplet/卷积中的重要参数.md","hash":"d99ffdba94b085424ab7bffd9f78348885560c70","modified":1559369527165},{"_id":"source/_posts/Python3_TensorFlow_WechatApplet/池化层.md","hash":"265d4a91d01fd0b69980ad8cbe652861aa4a1dbc","modified":1559369527157},{"_id":"source/_posts/Python3_TensorFlow_WechatApplet/激活层.md","hash":"c6c0a28e2b1788037b1d4919ec82f7aa458491b3","modified":1559369527167},{"_id":"source/_posts/Python无师自通/4_function.html","hash":"cb9f9827a9da2b6b7e2a89251ee76edf17c7a3c3","modified":1559278106278},{"_id":"source/_posts/gitchat/python_asyncio_guidelines.html","hash":"e469c32a403f245024e30dd8e9a7881200eb1b97","modified":1559281660753},{"_id":"source/_posts/gitchat/python_coroutine.html","hash":"0e9677ac949990853b5e4aa4a84ec917f01dfabf","modified":1559281992548},{"_id":"source/_posts/work_coding/work0528.md","hash":"5535aeef0b48ad85eb631791026342abaf93746b","modified":1559108564637},{"_id":"source/_posts/work_coding/work0529.md","hash":"fedbf66145f239fb6494fe551f6f0bfb3f027b57","modified":1559182366134},{"_id":"source/_posts/work_coding/work0530.md","hash":"67adbb4459af4e4596988dc883213ebf7a742516","modified":1559369527170},{"_id":"source/_posts/work_coding/work_0531.md","hash":"b3e57c2d056726020bc605246b17d4c800c2b48f","modified":1559297992748},{"_id":"source/_posts/训练营/动态规划05.md","hash":"64cc4da343731a4e7857a6d2f4e9e5b40e73168a","modified":1555311720837},{"_id":"source/_posts/训练营/动态规划法01.md","hash":"47c3340e73c21c2bdc60ed848e8880aad379d09e","modified":1554992096057},{"_id":"source/_posts/训练营/基础卡01-贪婪法.md","hash":"d04f26d2b691ebb7617bb9e029cfc98b313aae9d","modified":1554266810040},{"_id":"source/_posts/训练营/基础卡02-分治法.md","hash":"8d6b0e8d65b5c9d3d1a7f50440f281a8b34e7254","modified":1554127979024},{"_id":"source/_posts/训练营/基础卡03-动态规划.md","hash":"8885bee18843096d6a789545349e7c0c67e8adf6","modified":1554275857311},{"_id":"source/_posts/训练营/基础卡04-穷举法.md","hash":"c324918126bd59517f1f79b5b729b484b293438e","modified":1554272156591},{"_id":"source/_posts/训练营/基础卡05-迭代法.md","hash":"94a14272caff73ed343b382fae33dc44546a1c53","modified":1554459120665},{"_id":"source/_posts/训练营/基础卡06-基础开胃菜.md","hash":"b4939934aa6fd31a7e53590c73700c434912672c","modified":1554391424593},{"_id":"source/_posts/训练营/开营仪式.md","hash":"baddb420d6ebbc321702b61b1e706d5c10c3a0a4","modified":1554127140284},{"_id":"source/_posts/训练营/游戏算法卡01-A*算法.md","hash":"4bc0ce2a8556f871ec1d5d720c30174dd2f4d1f8","modified":1555649341314},{"_id":"source/_posts/训练营/热身卡01-开篇词：算法是程序的灵魂.md","hash":"eb4e6e6f6fca03f106bc16b57e0f7b153dc3bc98","modified":1554112789338},{"_id":"source/_posts/训练营/热身卡02-入门测试题.md","hash":"cccf8a298396f91a4ff4c58facf7c5195dcd53cd","modified":1554112789330},{"_id":"source/_posts/训练营/热身卡03-如何\"玩\"算法.md","hash":"55e7657d06c17567ebe1fdf35e3dfd8400f79086","modified":1554112789335},{"_id":"source/_posts/训练营/穷举搜索卡01.md","hash":"210233ac9951cf2d15d9fa0d3ad66bfef2561aa7","modified":1554555081328},{"_id":"source/_posts/训练营/穷举搜索卡02.md","hash":"0a1b49996b5e505f56f74c621fcaa77f51c65853","modified":1554559752518},{"_id":"source/_posts/训练营/穷举搜索卡03.md","hash":"69eb1be397251d14ae262d70d1fcf0014b6e18a1","modified":1554642815552},{"_id":"source/_posts/训练营/穷举搜索卡04.md","hash":"850e020f8e574f41bdc15816a230cbdb10e30385","modified":1554643509670},{"_id":"source/_posts/训练营/穷举搜索法05.md","hash":"d66e42b8e15e3556a94f510bf8a33c1a0cb866ac","modified":1554732494224},{"_id":"source/_posts/训练营/穷举搜索法06.md","hash":"3a8cf3c3a187e42df9d56ddf515c216ff498f2da","modified":1554741949390},{"_id":"source/_posts/训练营/穷举搜索法07.md","hash":"61fd2649d3effee2b78c61f7b26cb98747c7dfbc","modified":1554818058913},{"_id":"source/_posts/训练营/穷举搜索法08.md","hash":"6e83a52d06624cf3af3d7c5f84e12b8d55a0839e","modified":1554822330183},{"_id":"source/_posts/训练营/穷举搜索法09.md","hash":"114d3fd1a7dfecbf60f0e3decc42ff6eea642372","modified":1554902773369},{"_id":"source/_posts/训练营/穷举搜索法10.md","hash":"0fe0fe2bd186f9517f900ab703fb4fffa187c268","modified":1554902881068},{"_id":"source/_posts/训练营/迭代递推卡01.md","hash":"5fcdca9bb8f3be94ac352d674e87ea7aa875c94d","modified":1554465356750},{"_id":"source/_posts/训练营/迭代递推卡02.md","hash":"815aa79d1a71591e6a8b3dce828af13b4f761f91","modified":1554466176409},{"_id":"source/_posts/训练营/迭代递推卡03.md","hash":"30d38e0d626a811974fe4dfe8a5e6e65d1ec6d79","modified":1559369527162},{"_id":"source/_posts/Python无师自通/3_python_coding_introduction.html","hash":"5a5e57a0b1139ede6a531273709f4db7163ec3a8","modified":1559196302909},{"_id":"source/img/Python常用内置数据结构与算法.jpg","hash":"6ffb961baab2b1050bf72910b383a5f7e4bad13d","modified":1559472106549},{"_id":"source/_posts/Python3_TensorFlow_WechatApplet/全连接层.md","hash":"704fd1019bcb387c8d214a73cc36ec69e8170b50","modified":1559387916065},{"_id":"source/_posts/Python服务端面试/常考的内置结构与算法.md","hash":"bd87c346ba0bbe5163d8ebaa61cd6dbc42086ab1","modified":1559480874237},{"_id":"source/_posts/work_coding/work0602.md","hash":"926d28cb603abdf6e3ed9618cb4f3fd2ba1ba16a","modified":1559483259222},{"_id":"public/2019/06/02/work_coding/work0602/index.html","hash":"535fc9c88f283697cb1873e59870cbd342b50c9d","modified":1559534020281},{"_id":"public/2019/06/01/Python3_TensorFlow_WechatApplet/全连接层/index.html","hash":"b3b80b74fbe36f3046efea62fa06e64d20a7833a","modified":1559523788574},{"_id":"public/2019/06/01/work_coding/work0530/index.html","hash":"e0157b67017658a4754400bc4b3a8903cd7b54ed","modified":1559523788574},{"_id":"public/2019/06/01/Python3_TensorFlow_WechatApplet/激活层/index.html","hash":"a534f9ad7aefa7615fd427c1f118ca8d24397a61","modified":1559523788574},{"_id":"public/2019/06/01/Python3_TensorFlow_WechatApplet/卷积中的重要参数/index.html","hash":"54dcd3ea8f81fc0134fdbedb2ef90d52a5a9c843","modified":1559523788574},{"_id":"public/2019/06/01/训练营/迭代递推卡03/index.html","hash":"5aa519b5d03d989be4e7593d64cbf0df9585c6a1","modified":1559523788575},{"_id":"public/2019/06/01/Python3_TensorFlow_WechatApplet/BatchNorm层/index.html","hash":"b968e627bacc06e4fbb998de6f74a174c10ca6fd","modified":1559523788575},{"_id":"public/2019/06/01/Python3_TensorFlow_WechatApplet/池化层/index.html","hash":"3a4b7851a13ad4221d8e5d81d562dac4bb0363d4","modified":1559523788575},{"_id":"public/2019/05/31/work_coding/work_0531/index.html","hash":"b8d2b596b588ac529c0e88665ea89b4d5bfc2268","modified":1559523788575},{"_id":"public/2019/05/30/work_coding/work0529/index.html","hash":"681ca0d440f9bf26dd0c88a8b867f157aa607218","modified":1559523788575},{"_id":"public/2019/05/29/work_coding/work0528/index.html","hash":"4bc44080b50ca03cf151ed9da96f2f28c5ccb37d","modified":1559523788575},{"_id":"public/2019/04/19/训练营/游戏算法卡01-A*算法/index.html","hash":"e52dabb4f9deba99749dd5871752d6369d8880f5","modified":1559523788575},{"_id":"public/2019/04/15/训练营/动态规划05/index.html","hash":"5388e020a2e723994992ff22f9227071bff834b1","modified":1559523788575},{"_id":"public/2019/04/11/训练营/动态规划法01/index.html","hash":"48d9c7439deeb9dbd07ec9bb44bbeac2bf45f8a5","modified":1559523788575},{"_id":"public/2019/04/10/训练营/穷举搜索法10/index.html","hash":"aa73d0f1432474c6da0cf86bd9efe6beeef37ae5","modified":1559523788575},{"_id":"public/2019/04/10/训练营/穷举搜索法09/index.html","hash":"025dda16aeb0c7ba6f56def4844c0d248944c8f8","modified":1559523788575},{"_id":"public/2019/04/09/训练营/穷举搜索法08/index.html","hash":"f68f0d724745b3b76c6c48d35a299f39510146a8","modified":1559523788575},{"_id":"public/2019/04/09/训练营/穷举搜索法07/index.html","hash":"f08a4413492369846c89304a3c6589ac691dda82","modified":1559523788575},{"_id":"public/2019/04/08/训练营/穷举搜索法05/index.html","hash":"ec7fad56094ced57ad56958fef421dd0a310515e","modified":1559523788575},{"_id":"public/2019/04/07/训练营/穷举搜索卡04/index.html","hash":"7dc4a0954ce55817f837ce9e7e3fb201a4c338f0","modified":1559523788576},{"_id":"public/2019/04/07/训练营/穷举搜索卡03/index.html","hash":"b8939a53a1d27844853085a712035e5d38c6ae2e","modified":1559523788576},{"_id":"public/2019/04/06/训练营/穷举搜索卡01/index.html","hash":"f751e4e5a79729a22764765da1402b4e093f51ba","modified":1559523788576},{"_id":"public/2019/04/05/训练营/迭代递推卡02/index.html","hash":"3fb3097e0454635907fcc581e15e9e31e401fb3c","modified":1559523788576},{"_id":"public/2019/04/05/训练营/迭代递推卡01/index.html","hash":"ee8dad7627017f17cac97832160ebeba1b227f63","modified":1559523788576},{"_id":"public/2019/04/04/训练营/基础卡06-基础开胃菜/index.html","hash":"d024561f6429604a20cb163678cb77b7c873b98d","modified":1559523788576},{"_id":"public/2019/04/01/训练营/开营仪式/index.html","hash":"bc32bf6d02ae2a6a89ec25140a77d62325ea2cee","modified":1559523788576},{"_id":"public/2019/04/01/训练营/热身卡01-开篇词：算法是程序的灵魂/index.html","hash":"9f1019b4f70b2007c0607c2d84c1d8dd513336a6","modified":1559523788576},{"_id":"public/2019/04/01/训练营/热身卡03-如何\"玩\"算法/index.html","hash":"90f109d0be19f0c8e45d5b491f5d1d806d7de1d0","modified":1559523788576},{"_id":"public/2019/06/02/Python服务端面试/常考的内置结构与算法/index.html","hash":"a982361c77aa446af6744cfe53ce24986fe330af","modified":1559523788576},{"_id":"public/2019/05/31/gitchat/python_coroutine/index.html","hash":"d3907675b3e4f1b9a381433da018af3ce258ccb6","modified":1559523788576},{"_id":"public/2019/05/31/gitchat/python_asyncio_guidelines/index.html","hash":"ae6fda55000aa3bfb640b4c3dd310975688aa1ce","modified":1559523788576},{"_id":"public/2019/05/31/Python无师自通/4_function/index.html","hash":"99016a460ad3f4293ae7fe7548ae5cb85a8ef979","modified":1559523788576},{"_id":"public/2019/05/30/Python无师自通/3_python_coding_introduction/index.html","hash":"bf9565cdcc2e67a5349d9044fdeb75963de5f4f3","modified":1559523788576},{"_id":"public/2019/04/09/训练营/穷举搜索法06/index.html","hash":"d9edf04b583dbe99a52f34ad9bda97c2ce9fdbc6","modified":1559523788577},{"_id":"public/2019/04/06/训练营/穷举搜索卡02/index.html","hash":"4d3f7243c247710864bcfebcbd36d83e6738ceee","modified":1559523788577},{"_id":"public/2019/04/05/训练营/基础卡05-迭代法/index.html","hash":"6737be9f51bbb894c5973610da3c12493571299c","modified":1559523788577},{"_id":"public/2019/04/03/训练营/基础卡03-动态规划/index.html","hash":"07b9655ec58597715769ba2b0b15c5e5ec6f461d","modified":1559523788577},{"_id":"public/2019/04/03/训练营/基础卡04-穷举法/index.html","hash":"74506ed27c6b0b3ac097c72c83fda94573f83371","modified":1559523788577},{"_id":"public/2019/04/03/训练营/基础卡01-贪婪法/index.html","hash":"0d5918141d02abbcde4bfff5ecd1e6aa2e973d99","modified":1559523788577},{"_id":"public/2019/04/01/训练营/基础卡02-分治法/index.html","hash":"98c39bd1a50ad95ff687279f08239e1522da8570","modified":1559523788577},{"_id":"public/2019/04/01/训练营/热身卡02-入门测试题/index.html","hash":"b12a8883e978009c6a6ba6e2b8889e1969a1d36b","modified":1559523788577},{"_id":"public/img/Python常用内置数据结构与算法.jpg","hash":"6ffb961baab2b1050bf72910b383a5f7e4bad13d","modified":1559523788584},{"_id":"source/_posts/Python无师自通/5_container.html","hash":"6cc920a512b5b52a33af3fac5279b3dd21668429","modified":1559533984178},{"_id":"public/archives/2019/06/page/2/index.html","hash":"dc120fa644d680dad40078518e0e67355f6cced3","modified":1559624023999},{"_id":"public/2019/06/03/Python无师自通/5_container/index.html","hash":"1381cbd90a02c5f34e2bb693099f1a85d96a7bba","modified":1559624023999},{"_id":"source/_posts/Python无师自通/strings.html","hash":"75ccbd75c68bad718a35b57d3585ce753e19b034","modified":1559623997835},{"_id":"source/_posts/work_coding/work0603.md","hash":"30396b2b2cc1047c62a24cc633b68ba67c920e0c","modified":1559613948446},{"_id":"public/2019/06/04/work_coding/work0603/index.html","hash":"f8be4a8525adf20ab6b3520c972250a5f73e62e8","modified":1559624024001},{"_id":"public/2019/06/04/Python无师自通/strings/index.html","hash":"91fd2fac222a8640d06bb6a067b95fe47c463ca2","modified":1559624024001}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"unpacking tuple of list","_content":"\n[原文地址](https://www.geeksforgeeks.org/python-unpacking-tuple-of-lists/)\n\n第四种方法\n```python\ndef unpack_tuple(tups):\n    res = list()\n    for lst in tups:\n        res.extend(lst)\n    return res\n```","source":"_posts/unpacking_tuple_of_lists.md","raw":"---\ntitle: unpacking tuple of list\n---\n\n[原文地址](https://www.geeksforgeeks.org/python-unpacking-tuple-of-lists/)\n\n第四种方法\n```python\ndef unpack_tuple(tups):\n    res = list()\n    for lst in tups:\n        res.extend(lst)\n    return res\n```","slug":"unpacking_tuple_of_lists","published":1,"date":"2019-05-25T06:03:46.792Z","updated":"2019-05-25T06:03:46.792Z","_id":"cjw32rpcn0003vw72rz5rgdpb","comments":1,"layout":"post","photos":[],"link":"","content":"<p><a href=\"https://www.geeksforgeeks.org/python-unpacking-tuple-of-lists/\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n<p>第四种方法<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">unpack_tuple</span><span class=\"params\">(tups)</span>:</span></span><br><span class=\"line\">    res = list()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> lst <span class=\"keyword\">in</span> tups:</span><br><span class=\"line\">        res.extend(lst)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.geeksforgeeks.org/python-unpacking-tuple-of-lists/\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n<p>第四种方法<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">unpack_tuple</span><span class=\"params\">(tups)</span>:</span></span><br><span class=\"line\">    res = list()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> lst <span class=\"keyword\">in</span> tups:</span><br><span class=\"line\">        res.extend(lst)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure></p>\n"},{"_content":"查看硬盘分区列表\n\n    diskutil list\n    \n进行挂载\n    \n    diskutil mount 硬盘号","source":"_posts/挂载硬盘的一些命令.md","raw":"查看硬盘分区列表\n\n    diskutil list\n    \n进行挂载\n    \n    diskutil mount 硬盘号","slug":"挂载硬盘的一些命令","published":1,"date":"2019-04-04T05:43:08.785Z","updated":"2019-04-04T05:43:08.786Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjw32rpcy000cvw72sia0h04d","content":"<p>查看硬盘分区列表</p>\n<pre><code>diskutil list\n</code></pre><p>进行挂载</p>\n<pre><code>diskutil mount 硬盘号\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>查看硬盘分区列表</p>\n<pre><code>diskutil list\n</code></pre><p>进行挂载</p>\n<pre><code>diskutil mount 硬盘号\n</code></pre>"},{"title":"start blog","_content":"1. 安装node\n2. 安装git\n3. 在GitHub上创建格式为 BlogName.github.io的项目\n4. 使用npm install hexo -g 安装hexo\n5. 切换到博客并使用命令 hexo init初始化项目\n6. npm install 安装所需组件\n7. hexo g 首次使用需要编译\n8. hexo s 开启服务\n9. 设置Git的user name和email\n    \n       git config --global user.name \"YourUserName\"\n       git config --global user.email \"YourEmail\"\n\n10. ssh环境准备\n    \n        cd ~/.ssh\n        ssh-keygen -t rsa -C \"YourUserName\"\n        eval \"$(ssh-agent -s)\"\n        ssh-add ~/.ssh/id_rsa\n\n11. 上GitHub配置 ssh key\n        \n        新建ssh key 并将本地 id_rsa.pub的文件内容复制进去\n        \n12. 在本地执行 ssh -T git@github.com，如果显示出用户名则成功， 否则需要重新配置ssh-key\n\n13. 在项目中找到_config.yml文件修改以下参数\n\n        deploy:\n              type: git\n              repository: 项目的ssh链接\n              branch: master\n\n14. 安装git扩展 npm install hexo-deployer-git --save\n15. hexo d -g 生成以及部署了","source":"_posts/安装步骤.md","raw":"---\ntitle: start blog\n---\n1. 安装node\n2. 安装git\n3. 在GitHub上创建格式为 BlogName.github.io的项目\n4. 使用npm install hexo -g 安装hexo\n5. 切换到博客并使用命令 hexo init初始化项目\n6. npm install 安装所需组件\n7. hexo g 首次使用需要编译\n8. hexo s 开启服务\n9. 设置Git的user name和email\n    \n       git config --global user.name \"YourUserName\"\n       git config --global user.email \"YourEmail\"\n\n10. ssh环境准备\n    \n        cd ~/.ssh\n        ssh-keygen -t rsa -C \"YourUserName\"\n        eval \"$(ssh-agent -s)\"\n        ssh-add ~/.ssh/id_rsa\n\n11. 上GitHub配置 ssh key\n        \n        新建ssh key 并将本地 id_rsa.pub的文件内容复制进去\n        \n12. 在本地执行 ssh -T git@github.com，如果显示出用户名则成功， 否则需要重新配置ssh-key\n\n13. 在项目中找到_config.yml文件修改以下参数\n\n        deploy:\n              type: git\n              repository: 项目的ssh链接\n              branch: master\n\n14. 安装git扩展 npm install hexo-deployer-git --save\n15. hexo d -g 生成以及部署了","slug":"安装步骤","published":1,"date":"2019-05-25T06:25:59.300Z","updated":"2019-05-25T06:25:59.300Z","_id":"cjw347hl800007o72z113o69q","comments":1,"layout":"post","photos":[],"link":"","content":"<ol>\n<li>安装node</li>\n<li>安装git</li>\n<li>在GitHub上创建格式为 BlogName.github.io的项目</li>\n<li>使用npm install hexo -g 安装hexo</li>\n<li>切换到博客并使用命令 hexo init初始化项目</li>\n<li>npm install 安装所需组件</li>\n<li>hexo g 首次使用需要编译</li>\n<li>hexo s 开启服务</li>\n<li><p>设置Git的user name和email</p>\n<pre><code>git config --global user.name &quot;YourUserName&quot;\ngit config --global user.email &quot;YourEmail&quot;\n</code></pre></li>\n<li><p>ssh环境准备</p>\n<pre><code>cd ~/.ssh\nssh-keygen -t rsa -C &quot;YourUserName&quot;\neval &quot;$(ssh-agent -s)&quot;\nssh-add ~/.ssh/id_rsa\n</code></pre></li>\n<li><p>上GitHub配置 ssh key</p>\n<pre><code>新建ssh key 并将本地 id_rsa.pub的文件内容复制进去\n</code></pre></li>\n<li><p>在本地执行 ssh -T <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>，如果显示出用户名则成功， 否则需要重新配置ssh-key</p>\n</li>\n<li><p>在项目中找到_config.yml文件修改以下参数</p>\n<pre><code>deploy:\n      type: git\n      repository: 项目的ssh链接\n      branch: master\n</code></pre></li>\n<li><p>安装git扩展 npm install hexo-deployer-git –save</p>\n</li>\n<li>hexo d -g 生成以及部署了</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>安装node</li>\n<li>安装git</li>\n<li>在GitHub上创建格式为 BlogName.github.io的项目</li>\n<li>使用npm install hexo -g 安装hexo</li>\n<li>切换到博客并使用命令 hexo init初始化项目</li>\n<li>npm install 安装所需组件</li>\n<li>hexo g 首次使用需要编译</li>\n<li>hexo s 开启服务</li>\n<li><p>设置Git的user name和email</p>\n<pre><code>git config --global user.name &quot;YourUserName&quot;\ngit config --global user.email &quot;YourEmail&quot;\n</code></pre></li>\n<li><p>ssh环境准备</p>\n<pre><code>cd ~/.ssh\nssh-keygen -t rsa -C &quot;YourUserName&quot;\neval &quot;$(ssh-agent -s)&quot;\nssh-add ~/.ssh/id_rsa\n</code></pre></li>\n<li><p>上GitHub配置 ssh key</p>\n<pre><code>新建ssh key 并将本地 id_rsa.pub的文件内容复制进去\n</code></pre></li>\n<li><p>在本地执行 ssh -T <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>，如果显示出用户名则成功， 否则需要重新配置ssh-key</p>\n</li>\n<li><p>在项目中找到_config.yml文件修改以下参数</p>\n<pre><code>deploy:\n      type: git\n      repository: 项目的ssh链接\n      branch: master\n</code></pre></li>\n<li><p>安装git扩展 npm install hexo-deployer-git –save</p>\n</li>\n<li>hexo d -g 生成以及部署了</li>\n</ol>\n"},{"title":"week_1","_content":"\n#### 测试题\n将26个小写字母按顺序与数字1～26对应，以字典形式保存。\n```python\nres = {chr(v): i+1 for i, v in enumerate(range(97, 97+26))}\n```\n\n[推荐视频](https://www.icourse163.org/course/BIT-268001)","source":"_posts/将26个小写字母与阿拉伯数字对应.md","raw":"---\ntitle: week_1\n---\n\n#### 测试题\n将26个小写字母按顺序与数字1～26对应，以字典形式保存。\n```python\nres = {chr(v): i+1 for i, v in enumerate(range(97, 97+26))}\n```\n\n[推荐视频](https://www.icourse163.org/course/BIT-268001)","slug":"将26个小写字母与阿拉伯数字对应","published":1,"date":"2019-05-25T10:42:11.179Z","updated":"2019-05-25T10:42:11.179Z","_id":"cjw35vsb20000go72bwx87dx8","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"测试题\"><a href=\"#测试题\" class=\"headerlink\" title=\"测试题\"></a>测试题</h4><p>将26个小写字母按顺序与数字1～26对应，以字典形式保存。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res = &#123;chr(v): i+<span class=\"number\">1</span> <span class=\"keyword\">for</span> i, v <span class=\"keyword\">in</span> enumerate(range(<span class=\"number\">97</span>, <span class=\"number\">97</span>+<span class=\"number\">26</span>))&#125;</span><br></pre></td></tr></table></figure></p>\n<p><a href=\"https://www.icourse163.org/course/BIT-268001\" target=\"_blank\" rel=\"noopener\">推荐视频</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"测试题\"><a href=\"#测试题\" class=\"headerlink\" title=\"测试题\"></a>测试题</h4><p>将26个小写字母按顺序与数字1～26对应，以字典形式保存。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res = &#123;chr(v): i+<span class=\"number\">1</span> <span class=\"keyword\">for</span> i, v <span class=\"keyword\">in</span> enumerate(range(<span class=\"number\">97</span>, <span class=\"number\">97</span>+<span class=\"number\">26</span>))&#125;</span><br></pre></td></tr></table></figure></p>\n<p><a href=\"https://www.icourse163.org/course/BIT-268001\" target=\"_blank\" rel=\"noopener\">推荐视频</a></p>\n"},{"title":"Python学习路线","_content":"\n## 语法\n\n### 菜鸟教程 https://www.runoob.com/python3/python3-tutorial.html\n\n### 免费课程https://www.icourse163.org/course/BIT-268001\n\n### 推荐书籍《Python编程无师自通》\n\n## 必备\n\n### GitHub账号\n\n### git基本命令\n\n- clone\n- push\n- pull\n- status\n- checkout\n\n### Unix/Linux\n\n## 数据\n\n### MySQL\n\n### Redis\n\n### MongoDB\n\n### Numpy\n\n### Pandas\n\n### JSON\n\n### XML\n\n## 系统学习\n\n### 黑马程序员培训课程链接: https://pan.baidu.com/s/16rRmNF4qCL2UVDS_V0pFPA 提取码: t7t3 复制这段内容后打开百度网盘手机App，操作更方便哦\n\n## 项目开发工具\n\n### Pycharm\n\n### Docker\n\n## 进阶\n\n### 进程/线程/协程\n\n### 《数据结构与算法Python语言实现》\n\n### Python书籍《流畅的Python》\n\n### 推荐视频链接: https://pan.baidu.com/s/15W92DB2uq4DBvzzZWCHG7A 提取码: ijsc 复制这段内容后打开百度网盘手机App，操作更方便哦\n\n## 博客\n\n### 推荐使用GitHub托管并搭建免费的技术博客\n\n### 我的博客地址https://1005281342.github.io/\n","source":"_posts/Python学习路线.md","raw":"---\ntitle: Python学习路线\n---\n\n## 语法\n\n### 菜鸟教程 https://www.runoob.com/python3/python3-tutorial.html\n\n### 免费课程https://www.icourse163.org/course/BIT-268001\n\n### 推荐书籍《Python编程无师自通》\n\n## 必备\n\n### GitHub账号\n\n### git基本命令\n\n- clone\n- push\n- pull\n- status\n- checkout\n\n### Unix/Linux\n\n## 数据\n\n### MySQL\n\n### Redis\n\n### MongoDB\n\n### Numpy\n\n### Pandas\n\n### JSON\n\n### XML\n\n## 系统学习\n\n### 黑马程序员培训课程链接: https://pan.baidu.com/s/16rRmNF4qCL2UVDS_V0pFPA 提取码: t7t3 复制这段内容后打开百度网盘手机App，操作更方便哦\n\n## 项目开发工具\n\n### Pycharm\n\n### Docker\n\n## 进阶\n\n### 进程/线程/协程\n\n### 《数据结构与算法Python语言实现》\n\n### Python书籍《流畅的Python》\n\n### 推荐视频链接: https://pan.baidu.com/s/15W92DB2uq4DBvzzZWCHG7A 提取码: ijsc 复制这段内容后打开百度网盘手机App，操作更方便哦\n\n## 博客\n\n### 推荐使用GitHub托管并搭建免费的技术博客\n\n### 我的博客地址https://1005281342.github.io/\n","slug":"Python学习路线","published":1,"date":"2019-06-01T05:59:30.524Z","updated":"2019-06-01T05:59:30.524Z","_id":"cjwd3riv60000pr72d25jiwd2","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><h3 id=\"菜鸟教程-https-www-runoob-com-python3-python3-tutorial-html\"><a href=\"#菜鸟教程-https-www-runoob-com-python3-python3-tutorial-html\" class=\"headerlink\" title=\"菜鸟教程 https://www.runoob.com/python3/python3-tutorial.html\"></a>菜鸟教程 <a href=\"https://www.runoob.com/python3/python3-tutorial.html\" target=\"_blank\" rel=\"noopener\">https://www.runoob.com/python3/python3-tutorial.html</a></h3><h3 id=\"免费课程https-www-icourse163-org-course-BIT-268001\"><a href=\"#免费课程https-www-icourse163-org-course-BIT-268001\" class=\"headerlink\" title=\"免费课程https://www.icourse163.org/course/BIT-268001\"></a>免费课程<a href=\"https://www.icourse163.org/course/BIT-268001\" target=\"_blank\" rel=\"noopener\">https://www.icourse163.org/course/BIT-268001</a></h3><h3 id=\"推荐书籍《Python编程无师自通》\"><a href=\"#推荐书籍《Python编程无师自通》\" class=\"headerlink\" title=\"推荐书籍《Python编程无师自通》\"></a>推荐书籍《Python编程无师自通》</h3><h2 id=\"必备\"><a href=\"#必备\" class=\"headerlink\" title=\"必备\"></a>必备</h2><h3 id=\"GitHub账号\"><a href=\"#GitHub账号\" class=\"headerlink\" title=\"GitHub账号\"></a>GitHub账号</h3><h3 id=\"git基本命令\"><a href=\"#git基本命令\" class=\"headerlink\" title=\"git基本命令\"></a>git基本命令</h3><ul>\n<li>clone</li>\n<li>push</li>\n<li>pull</li>\n<li>status</li>\n<li>checkout</li>\n</ul>\n<h3 id=\"Unix-Linux\"><a href=\"#Unix-Linux\" class=\"headerlink\" title=\"Unix/Linux\"></a>Unix/Linux</h3><h2 id=\"数据\"><a href=\"#数据\" class=\"headerlink\" title=\"数据\"></a>数据</h2><h3 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h3><h3 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h3><h3 id=\"MongoDB\"><a href=\"#MongoDB\" class=\"headerlink\" title=\"MongoDB\"></a>MongoDB</h3><h3 id=\"Numpy\"><a href=\"#Numpy\" class=\"headerlink\" title=\"Numpy\"></a>Numpy</h3><h3 id=\"Pandas\"><a href=\"#Pandas\" class=\"headerlink\" title=\"Pandas\"></a>Pandas</h3><h3 id=\"JSON\"><a href=\"#JSON\" class=\"headerlink\" title=\"JSON\"></a>JSON</h3><h3 id=\"XML\"><a href=\"#XML\" class=\"headerlink\" title=\"XML\"></a>XML</h3><h2 id=\"系统学习\"><a href=\"#系统学习\" class=\"headerlink\" title=\"系统学习\"></a>系统学习</h2><h3 id=\"黑马程序员培训课程链接-https-pan-baidu-com-s-16rRmNF4qCL2UVDS-V0pFPA-提取码-t7t3-复制这段内容后打开百度网盘手机App，操作更方便哦\"><a href=\"#黑马程序员培训课程链接-https-pan-baidu-com-s-16rRmNF4qCL2UVDS-V0pFPA-提取码-t7t3-复制这段内容后打开百度网盘手机App，操作更方便哦\" class=\"headerlink\" title=\"黑马程序员培训课程链接: https://pan.baidu.com/s/16rRmNF4qCL2UVDS_V0pFPA 提取码: t7t3 复制这段内容后打开百度网盘手机App，操作更方便哦\"></a>黑马程序员培训课程链接: <a href=\"https://pan.baidu.com/s/16rRmNF4qCL2UVDS_V0pFPA\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/16rRmNF4qCL2UVDS_V0pFPA</a> 提取码: t7t3 复制这段内容后打开百度网盘手机App，操作更方便哦</h3><h2 id=\"项目开发工具\"><a href=\"#项目开发工具\" class=\"headerlink\" title=\"项目开发工具\"></a>项目开发工具</h2><h3 id=\"Pycharm\"><a href=\"#Pycharm\" class=\"headerlink\" title=\"Pycharm\"></a>Pycharm</h3><h3 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h3><h2 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h2><h3 id=\"进程-线程-协程\"><a href=\"#进程-线程-协程\" class=\"headerlink\" title=\"进程/线程/协程\"></a>进程/线程/协程</h3><h3 id=\"《数据结构与算法Python语言实现》\"><a href=\"#《数据结构与算法Python语言实现》\" class=\"headerlink\" title=\"《数据结构与算法Python语言实现》\"></a>《数据结构与算法Python语言实现》</h3><h3 id=\"Python书籍《流畅的Python》\"><a href=\"#Python书籍《流畅的Python》\" class=\"headerlink\" title=\"Python书籍《流畅的Python》\"></a>Python书籍《流畅的Python》</h3><h3 id=\"推荐视频链接-https-pan-baidu-com-s-15W92DB2uq4DBvzzZWCHG7A-提取码-ijsc-复制这段内容后打开百度网盘手机App，操作更方便哦\"><a href=\"#推荐视频链接-https-pan-baidu-com-s-15W92DB2uq4DBvzzZWCHG7A-提取码-ijsc-复制这段内容后打开百度网盘手机App，操作更方便哦\" class=\"headerlink\" title=\"推荐视频链接: https://pan.baidu.com/s/15W92DB2uq4DBvzzZWCHG7A 提取码: ijsc 复制这段内容后打开百度网盘手机App，操作更方便哦\"></a>推荐视频链接: <a href=\"https://pan.baidu.com/s/15W92DB2uq4DBvzzZWCHG7A\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/15W92DB2uq4DBvzzZWCHG7A</a> 提取码: ijsc 复制这段内容后打开百度网盘手机App，操作更方便哦</h3><h2 id=\"博客\"><a href=\"#博客\" class=\"headerlink\" title=\"博客\"></a>博客</h2><h3 id=\"推荐使用GitHub托管并搭建免费的技术博客\"><a href=\"#推荐使用GitHub托管并搭建免费的技术博客\" class=\"headerlink\" title=\"推荐使用GitHub托管并搭建免费的技术博客\"></a>推荐使用GitHub托管并搭建免费的技术博客</h3><h3 id=\"我的博客地址https-1005281342-github-io\"><a href=\"#我的博客地址https-1005281342-github-io\" class=\"headerlink\" title=\"我的博客地址https://1005281342.github.io/\"></a>我的博客地址<a href=\"https://1005281342.github.io/\" target=\"_blank\" rel=\"noopener\">https://1005281342.github.io/</a></h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><h3 id=\"菜鸟教程-https-www-runoob-com-python3-python3-tutorial-html\"><a href=\"#菜鸟教程-https-www-runoob-com-python3-python3-tutorial-html\" class=\"headerlink\" title=\"菜鸟教程 https://www.runoob.com/python3/python3-tutorial.html\"></a>菜鸟教程 <a href=\"https://www.runoob.com/python3/python3-tutorial.html\" target=\"_blank\" rel=\"noopener\">https://www.runoob.com/python3/python3-tutorial.html</a></h3><h3 id=\"免费课程https-www-icourse163-org-course-BIT-268001\"><a href=\"#免费课程https-www-icourse163-org-course-BIT-268001\" class=\"headerlink\" title=\"免费课程https://www.icourse163.org/course/BIT-268001\"></a>免费课程<a href=\"https://www.icourse163.org/course/BIT-268001\" target=\"_blank\" rel=\"noopener\">https://www.icourse163.org/course/BIT-268001</a></h3><h3 id=\"推荐书籍《Python编程无师自通》\"><a href=\"#推荐书籍《Python编程无师自通》\" class=\"headerlink\" title=\"推荐书籍《Python编程无师自通》\"></a>推荐书籍《Python编程无师自通》</h3><h2 id=\"必备\"><a href=\"#必备\" class=\"headerlink\" title=\"必备\"></a>必备</h2><h3 id=\"GitHub账号\"><a href=\"#GitHub账号\" class=\"headerlink\" title=\"GitHub账号\"></a>GitHub账号</h3><h3 id=\"git基本命令\"><a href=\"#git基本命令\" class=\"headerlink\" title=\"git基本命令\"></a>git基本命令</h3><ul>\n<li>clone</li>\n<li>push</li>\n<li>pull</li>\n<li>status</li>\n<li>checkout</li>\n</ul>\n<h3 id=\"Unix-Linux\"><a href=\"#Unix-Linux\" class=\"headerlink\" title=\"Unix/Linux\"></a>Unix/Linux</h3><h2 id=\"数据\"><a href=\"#数据\" class=\"headerlink\" title=\"数据\"></a>数据</h2><h3 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h3><h3 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h3><h3 id=\"MongoDB\"><a href=\"#MongoDB\" class=\"headerlink\" title=\"MongoDB\"></a>MongoDB</h3><h3 id=\"Numpy\"><a href=\"#Numpy\" class=\"headerlink\" title=\"Numpy\"></a>Numpy</h3><h3 id=\"Pandas\"><a href=\"#Pandas\" class=\"headerlink\" title=\"Pandas\"></a>Pandas</h3><h3 id=\"JSON\"><a href=\"#JSON\" class=\"headerlink\" title=\"JSON\"></a>JSON</h3><h3 id=\"XML\"><a href=\"#XML\" class=\"headerlink\" title=\"XML\"></a>XML</h3><h2 id=\"系统学习\"><a href=\"#系统学习\" class=\"headerlink\" title=\"系统学习\"></a>系统学习</h2><h3 id=\"黑马程序员培训课程链接-https-pan-baidu-com-s-16rRmNF4qCL2UVDS-V0pFPA-提取码-t7t3-复制这段内容后打开百度网盘手机App，操作更方便哦\"><a href=\"#黑马程序员培训课程链接-https-pan-baidu-com-s-16rRmNF4qCL2UVDS-V0pFPA-提取码-t7t3-复制这段内容后打开百度网盘手机App，操作更方便哦\" class=\"headerlink\" title=\"黑马程序员培训课程链接: https://pan.baidu.com/s/16rRmNF4qCL2UVDS_V0pFPA 提取码: t7t3 复制这段内容后打开百度网盘手机App，操作更方便哦\"></a>黑马程序员培训课程链接: <a href=\"https://pan.baidu.com/s/16rRmNF4qCL2UVDS_V0pFPA\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/16rRmNF4qCL2UVDS_V0pFPA</a> 提取码: t7t3 复制这段内容后打开百度网盘手机App，操作更方便哦</h3><h2 id=\"项目开发工具\"><a href=\"#项目开发工具\" class=\"headerlink\" title=\"项目开发工具\"></a>项目开发工具</h2><h3 id=\"Pycharm\"><a href=\"#Pycharm\" class=\"headerlink\" title=\"Pycharm\"></a>Pycharm</h3><h3 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h3><h2 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h2><h3 id=\"进程-线程-协程\"><a href=\"#进程-线程-协程\" class=\"headerlink\" title=\"进程/线程/协程\"></a>进程/线程/协程</h3><h3 id=\"《数据结构与算法Python语言实现》\"><a href=\"#《数据结构与算法Python语言实现》\" class=\"headerlink\" title=\"《数据结构与算法Python语言实现》\"></a>《数据结构与算法Python语言实现》</h3><h3 id=\"Python书籍《流畅的Python》\"><a href=\"#Python书籍《流畅的Python》\" class=\"headerlink\" title=\"Python书籍《流畅的Python》\"></a>Python书籍《流畅的Python》</h3><h3 id=\"推荐视频链接-https-pan-baidu-com-s-15W92DB2uq4DBvzzZWCHG7A-提取码-ijsc-复制这段内容后打开百度网盘手机App，操作更方便哦\"><a href=\"#推荐视频链接-https-pan-baidu-com-s-15W92DB2uq4DBvzzZWCHG7A-提取码-ijsc-复制这段内容后打开百度网盘手机App，操作更方便哦\" class=\"headerlink\" title=\"推荐视频链接: https://pan.baidu.com/s/15W92DB2uq4DBvzzZWCHG7A 提取码: ijsc 复制这段内容后打开百度网盘手机App，操作更方便哦\"></a>推荐视频链接: <a href=\"https://pan.baidu.com/s/15W92DB2uq4DBvzzZWCHG7A\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/15W92DB2uq4DBvzzZWCHG7A</a> 提取码: ijsc 复制这段内容后打开百度网盘手机App，操作更方便哦</h3><h2 id=\"博客\"><a href=\"#博客\" class=\"headerlink\" title=\"博客\"></a>博客</h2><h3 id=\"推荐使用GitHub托管并搭建免费的技术博客\"><a href=\"#推荐使用GitHub托管并搭建免费的技术博客\" class=\"headerlink\" title=\"推荐使用GitHub托管并搭建免费的技术博客\"></a>推荐使用GitHub托管并搭建免费的技术博客</h3><h3 id=\"我的博客地址https-1005281342-github-io\"><a href=\"#我的博客地址https-1005281342-github-io\" class=\"headerlink\" title=\"我的博客地址https://1005281342.github.io/\"></a>我的博客地址<a href=\"https://1005281342.github.io/\" target=\"_blank\" rel=\"noopener\">https://1005281342.github.io/</a></h3>"},{"title":"卷积中的重要参数","_content":"\n权值共享与局部连接\n\n    1. 卷积运算作用在局部, 因此在这个区域是权值共享的, 而上一级节点与下一级节点的连接关系则称为局部连接, 若下一级节点与上一级的所有节点都有连接关系则称为全连接。\n    2. Feature map使用同一个卷积核运算后得到一种特征。\n    3. 多种特征采用多个卷积核(channel), 具体为多少个卷积核取决于num_out。\n    \n\n卷积的参数量以及计算量\n    \n    1. 参数量： (k_w*k_h*in_channel+1)*Out_Channel, 其中+1项由偏置操作产生。\n    2. 计算量： in_w*in_h*(k_w*k_h*in_channel+1)*Out_Channel\n\n防止过拟合的策略\n\n    1. 正则化\n    2. 早停DorpOut\n    3. 增大数据集\n    4. 减少参数量\n    5. 增加BatchNorm层\n    \n步长stride, 不会影响卷积核的参数量, 但是会影响卷积计算的计算量\n![](../../img/stride.png)\n\n    1. 在pooling层下采样过程中会直接受stride参数影响\n    2. 在同一个卷积核的情况下，stride设置不同计算所得的Feature Map也会不同\n    3. stride越大计算量会小，一般设置为1或者2，设置为2时，长、宽下采样都会增大至2倍，整体下采样则增大至4倍\n    \n    Output size: (N-F)/stride+1\n    e.g. N=7, F=3\n    stride 1    =>  (7-3)/1 + 1 = 5\n    stride 2    =>  (7-3)/2 + 1 = 3\n    stride 3    =>  (7-3)/3 + 1 = 2.33\n\n    \npad 确保Feature Map整数倍变化，对尺度相关的任务非常重要\n![](../../img/pad.png)\n    ","source":"_posts/Python3_TensorFlow_WechatApplet/卷积中的重要参数.md","raw":"---\ntitle: 卷积中的重要参数\n---\n\n权值共享与局部连接\n\n    1. 卷积运算作用在局部, 因此在这个区域是权值共享的, 而上一级节点与下一级节点的连接关系则称为局部连接, 若下一级节点与上一级的所有节点都有连接关系则称为全连接。\n    2. Feature map使用同一个卷积核运算后得到一种特征。\n    3. 多种特征采用多个卷积核(channel), 具体为多少个卷积核取决于num_out。\n    \n\n卷积的参数量以及计算量\n    \n    1. 参数量： (k_w*k_h*in_channel+1)*Out_Channel, 其中+1项由偏置操作产生。\n    2. 计算量： in_w*in_h*(k_w*k_h*in_channel+1)*Out_Channel\n\n防止过拟合的策略\n\n    1. 正则化\n    2. 早停DorpOut\n    3. 增大数据集\n    4. 减少参数量\n    5. 增加BatchNorm层\n    \n步长stride, 不会影响卷积核的参数量, 但是会影响卷积计算的计算量\n![](../../img/stride.png)\n\n    1. 在pooling层下采样过程中会直接受stride参数影响\n    2. 在同一个卷积核的情况下，stride设置不同计算所得的Feature Map也会不同\n    3. stride越大计算量会小，一般设置为1或者2，设置为2时，长、宽下采样都会增大至2倍，整体下采样则增大至4倍\n    \n    Output size: (N-F)/stride+1\n    e.g. N=7, F=3\n    stride 1    =>  (7-3)/1 + 1 = 5\n    stride 2    =>  (7-3)/2 + 1 = 3\n    stride 3    =>  (7-3)/3 + 1 = 2.33\n\n    \npad 确保Feature Map整数倍变化，对尺度相关的任务非常重要\n![](../../img/pad.png)\n    ","slug":"Python3_TensorFlow_WechatApplet/卷积中的重要参数","published":1,"date":"2019-06-01T06:12:07.165Z","updated":"2019-06-01T06:12:07.165Z","_id":"cjwd48fwn0002sv72nhaxgt4u","comments":1,"layout":"post","photos":[],"link":"","content":"<p>权值共享与局部连接</p>\n<pre><code>1. 卷积运算作用在局部, 因此在这个区域是权值共享的, 而上一级节点与下一级节点的连接关系则称为局部连接, 若下一级节点与上一级的所有节点都有连接关系则称为全连接。\n2. Feature map使用同一个卷积核运算后得到一种特征。\n3. 多种特征采用多个卷积核(channel), 具体为多少个卷积核取决于num_out。\n</code></pre><p>卷积的参数量以及计算量</p>\n<pre><code>1. 参数量： (k_w*k_h*in_channel+1)*Out_Channel, 其中+1项由偏置操作产生。\n2. 计算量： in_w*in_h*(k_w*k_h*in_channel+1)*Out_Channel\n</code></pre><p>防止过拟合的策略</p>\n<pre><code>1. 正则化\n2. 早停DorpOut\n3. 增大数据集\n4. 减少参数量\n5. 增加BatchNorm层\n</code></pre><p>步长stride, 不会影响卷积核的参数量, 但是会影响卷积计算的计算量<br><img src=\"../../img/stride.png\" alt></p>\n<pre><code>1. 在pooling层下采样过程中会直接受stride参数影响\n2. 在同一个卷积核的情况下，stride设置不同计算所得的Feature Map也会不同\n3. stride越大计算量会小，一般设置为1或者2，设置为2时，长、宽下采样都会增大至2倍，整体下采样则增大至4倍\n\nOutput size: (N-F)/stride+1\ne.g. N=7, F=3\nstride 1    =&gt;  (7-3)/1 + 1 = 5\nstride 2    =&gt;  (7-3)/2 + 1 = 3\nstride 3    =&gt;  (7-3)/3 + 1 = 2.33\n</code></pre><p>pad 确保Feature Map整数倍变化，对尺度相关的任务非常重要<br><img src=\"../../img/pad.png\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<p>权值共享与局部连接</p>\n<pre><code>1. 卷积运算作用在局部, 因此在这个区域是权值共享的, 而上一级节点与下一级节点的连接关系则称为局部连接, 若下一级节点与上一级的所有节点都有连接关系则称为全连接。\n2. Feature map使用同一个卷积核运算后得到一种特征。\n3. 多种特征采用多个卷积核(channel), 具体为多少个卷积核取决于num_out。\n</code></pre><p>卷积的参数量以及计算量</p>\n<pre><code>1. 参数量： (k_w*k_h*in_channel+1)*Out_Channel, 其中+1项由偏置操作产生。\n2. 计算量： in_w*in_h*(k_w*k_h*in_channel+1)*Out_Channel\n</code></pre><p>防止过拟合的策略</p>\n<pre><code>1. 正则化\n2. 早停DorpOut\n3. 增大数据集\n4. 减少参数量\n5. 增加BatchNorm层\n</code></pre><p>步长stride, 不会影响卷积核的参数量, 但是会影响卷积计算的计算量<br><img src=\"../../img/stride.png\" alt></p>\n<pre><code>1. 在pooling层下采样过程中会直接受stride参数影响\n2. 在同一个卷积核的情况下，stride设置不同计算所得的Feature Map也会不同\n3. stride越大计算量会小，一般设置为1或者2，设置为2时，长、宽下采样都会增大至2倍，整体下采样则增大至4倍\n\nOutput size: (N-F)/stride+1\ne.g. N=7, F=3\nstride 1    =&gt;  (7-3)/1 + 1 = 5\nstride 2    =&gt;  (7-3)/2 + 1 = 3\nstride 3    =&gt;  (7-3)/3 + 1 = 2.33\n</code></pre><p>pad 确保Feature Map整数倍变化，对尺度相关的任务非常重要<br><img src=\"../../img/pad.png\" alt></p>\n"},{"title":"激活函数","_content":"\n作用\n    \n    增加网络的非线性，进而提升网络的表达能力\n    \n激活函数的特点\n    \n    非线性\n    单调性\n    可微性\n    取值范围\n\n常见的激活函数\n\n![](../../img/常见激活函数.png)\n\n    Sigmoid\n    Tanh\n    ReLU\n\n![](../../img/ReLU.png)","source":"_posts/Python3_TensorFlow_WechatApplet/激活层.md","raw":"---\ntitle: 激活函数\n---\n\n作用\n    \n    增加网络的非线性，进而提升网络的表达能力\n    \n激活函数的特点\n    \n    非线性\n    单调性\n    可微性\n    取值范围\n\n常见的激活函数\n\n![](../../img/常见激活函数.png)\n\n    Sigmoid\n    Tanh\n    ReLU\n\n![](../../img/ReLU.png)","slug":"Python3_TensorFlow_WechatApplet/激活层","published":1,"date":"2019-06-01T06:12:07.167Z","updated":"2019-06-01T06:12:07.167Z","_id":"cjwd48fwq0003sv72mqi1swzb","comments":1,"layout":"post","photos":[],"link":"","content":"<p>作用</p>\n<pre><code>增加网络的非线性，进而提升网络的表达能力\n</code></pre><p>激活函数的特点</p>\n<pre><code>非线性\n单调性\n可微性\n取值范围\n</code></pre><p>常见的激活函数</p>\n<p><img src=\"../../img/常见激活函数.png\" alt></p>\n<pre><code>Sigmoid\nTanh\nReLU\n</code></pre><p><img src=\"../../img/ReLU.png\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<p>作用</p>\n<pre><code>增加网络的非线性，进而提升网络的表达能力\n</code></pre><p>激活函数的特点</p>\n<pre><code>非线性\n单调性\n可微性\n取值范围\n</code></pre><p>常见的激活函数</p>\n<p><img src=\"../../img/常见激活函数.png\" alt></p>\n<pre><code>Sigmoid\nTanh\nReLU\n</code></pre><p><img src=\"../../img/ReLU.png\" alt></p>\n"},{"title":"池化层","_content":"\n基本概念\n\n    池化：对输入的特征图进行压缩\n    \n![](../../img/池化.png)\n\n池化作用\n    \n    使得特征图变小，简化网络计算复杂度\n    进行特征压缩，提取主要特征\n    增大感受野\n    \n常见池化策略\n\n    一般有最大池化、平均池化、随机池化\n    池化层是无参的，在BP过程中池化层是不会被参数优化的","source":"_posts/Python3_TensorFlow_WechatApplet/池化层.md","raw":"---\ntitle: 池化层\n---\n\n基本概念\n\n    池化：对输入的特征图进行压缩\n    \n![](../../img/池化.png)\n\n池化作用\n    \n    使得特征图变小，简化网络计算复杂度\n    进行特征压缩，提取主要特征\n    增大感受野\n    \n常见池化策略\n\n    一般有最大池化、平均池化、随机池化\n    池化层是无参的，在BP过程中池化层是不会被参数优化的","slug":"Python3_TensorFlow_WechatApplet/池化层","published":1,"date":"2019-06-01T06:12:07.157Z","updated":"2019-06-01T06:12:07.157Z","_id":"cjwd48fwr0004sv72i38evgq6","comments":1,"layout":"post","photos":[],"link":"","content":"<p>基本概念</p>\n<pre><code>池化：对输入的特征图进行压缩\n</code></pre><p><img src=\"../../img/池化.png\" alt></p>\n<p>池化作用</p>\n<pre><code>使得特征图变小，简化网络计算复杂度\n进行特征压缩，提取主要特征\n增大感受野\n</code></pre><p>常见池化策略</p>\n<pre><code>一般有最大池化、平均池化、随机池化\n池化层是无参的，在BP过程中池化层是不会被参数优化的\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>基本概念</p>\n<pre><code>池化：对输入的特征图进行压缩\n</code></pre><p><img src=\"../../img/池化.png\" alt></p>\n<p>池化作用</p>\n<pre><code>使得特征图变小，简化网络计算复杂度\n进行特征压缩，提取主要特征\n增大感受野\n</code></pre><p>常见池化策略</p>\n<pre><code>一般有最大池化、平均池化、随机池化\n池化层是无参的，在BP过程中池化层是不会被参数优化的\n</code></pre>"},{"title":"BatchNorm","_content":"\n基本概念\n    \n    通过一定的规范化手段，把每层神经网络任意神经元的输入值的分布强行拉回到均值为0方差为1的标准正态分布\n    \n![](../../img/BatchNorm.png)\n\nBatchNorm层的优点\n![](../../img/BatchNorm层的优点.png)\n\nBatchNorm层的使用\n![](../../img/tensorflow使用BatchNorm层.png)","source":"_posts/Python3_TensorFlow_WechatApplet/BatchNorm层.md","raw":"---\ntitle: BatchNorm\n---\n\n基本概念\n    \n    通过一定的规范化手段，把每层神经网络任意神经元的输入值的分布强行拉回到均值为0方差为1的标准正态分布\n    \n![](../../img/BatchNorm.png)\n\nBatchNorm层的优点\n![](../../img/BatchNorm层的优点.png)\n\nBatchNorm层的使用\n![](../../img/tensorflow使用BatchNorm层.png)","slug":"Python3_TensorFlow_WechatApplet/BatchNorm层","published":1,"date":"2019-06-01T06:12:07.160Z","updated":"2019-06-01T06:12:07.160Z","_id":"cjwd48fzl0005sv72l055vs4o","comments":1,"layout":"post","photos":[],"link":"","content":"<p>基本概念</p>\n<pre><code>通过一定的规范化手段，把每层神经网络任意神经元的输入值的分布强行拉回到均值为0方差为1的标准正态分布\n</code></pre><p><img src=\"../../img/BatchNorm.png\" alt></p>\n<p>BatchNorm层的优点<br><img src=\"../../img/BatchNorm层的优点.png\" alt></p>\n<p>BatchNorm层的使用<br><img src=\"../../img/tensorflow使用BatchNorm层.png\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<p>基本概念</p>\n<pre><code>通过一定的规范化手段，把每层神经网络任意神经元的输入值的分布强行拉回到均值为0方差为1的标准正态分布\n</code></pre><p><img src=\"../../img/BatchNorm.png\" alt></p>\n<p>BatchNorm层的优点<br><img src=\"../../img/BatchNorm层的优点.png\" alt></p>\n<p>BatchNorm层的使用<br><img src=\"../../img/tensorflow使用BatchNorm层.png\" alt></p>\n"},{"title":"编程概论","_content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>编程概论</title>\n</head>\n<body>\n<article id=\"articleDiv\"><div class=\"mazi-article-content dont-break-out\"><p></p><div class=\"toc\">\n<ul>\n<li><ul>\n<li><ul>\n<li><a href=\"#31\">3.1　示例</a></li>\n<li><a href=\"#32\">3.2　注释</a></li>\n<li><a href=\"#33\">3.3　打印</a></li>\n<li><a href=\"#34\">3.4　代码行</a></li>\n<li><a href=\"#35\">3.5　关键字</a></li>\n<li><a href=\"#36\">3.6　间距</a></li>\n<li><a href=\"#37\">3.7　数据类型</a></li>\n<li><a href=\"#38\">3.8　常量和变量</a></li>\n<li><a href=\"#39\">3.9　语法</a></li>\n<li><a href=\"#310\">3.10　错误与异常</a></li>\n<li><a href=\"#311\">3.11　算术操作符</a></li>\n<li><a href=\"#312\">3.12　比较操作符</a></li>\n<li><a href=\"#313\">3.13　逻辑操作符</a></li>\n<li><a href=\"#314\">3.14　条件语句</a></li>\n<li><a href=\"#315\">3.15　语句</a></li>\n<li><a href=\"#316\">3.16　术语表</a></li>\n<li><a href=\"#317\">3.17　挑战练习</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>\n<p></p>\n<blockquote>\n  <p><span style=\"font-family: Times New Roman,楷体_GB2312\">“这是我能想到的，唯一可以让我既当工程师又做艺术家的工作。它要求具备极其缜密的技术思维，因为你必须要完成精确的思考，这点我很喜欢。另一方面，它又鼓励你肆意挥洒自己的创意，只有你想不到没有你做不到的。”</span></p>\n  <p><span style=\"font-family: Times New Roman,楷体_GB2312\">——安迪 · 赫兹菲尔德（Andy Hertzfeld）</span></p>\n</blockquote>\n<p>我们的第一个程序打印出了 <code>Hello, World!</code>。接下来打印 100 次。在交互式 shell 中输入如下代码（print 需要缩进 4 个空格符）：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># http://tinyurl.com/h79ob7s</span>\n2\n3\n4  <strong><span class=\"hljs-keyword\">for</span></strong> i <strong><span class=\"hljs-keyword\">in</span></strong> range(100):\n5      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, World!\"</span>)</code></pre>\n<p>交互式 shell 应该会打印 <code>Hello, World!</code> 100 次。即使通常没有这样做的需要，但可以从这个例子中看出编程的强大。你能想到任何其他可以如此简单地做 100 遍的事情吗？我想不到。这就是编程的厉害之处。</p>\n<h3 id=\"31\">3.1　示例</h3>\n<p>从现在开始，代码示例会以如下形式出现：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h4qntgk</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-keyword\">for</span></strong> i <strong><span class=\"hljs-keyword\">in</span></strong> range(<span class=\"hljs-number\">100</span>):\n<span class=\"hljs-number\">5</span>      print(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> Hello, World!\n&gt;&gt; Hello, World!\n&gt;&gt; Hello, World!\n…</code></pre>\n<p>打开 http://tinyurl.com/h4qntqk 这个链接，就可以看到包含有示例代码的网页，这样如果无法让代码运行，你可以轻松地复制代码，并粘贴到 IDLE 的文本编辑器中。<code>&gt;&gt;</code> 的后面则是交互式 shell 的输出。全书的每一个编程示例中都会看到 <code>&gt;&gt;</code>，这代表了程序的输出结果（会在交互式 shell 中打印出来）。“...”表示“等等”。</p>\n<p>如果示例后没有 <code>&gt;&gt;</code>，就表示该程序没有输出，或者只是在解释概念，输出并不太重要。</p>\n<p>字体为 Courier New 的部分，都是某种形式的代码、代码输出或编程术语。例如，上个例子中提到的词 <code>for</code>，它就会是 Courier New 字体。</p>\n<p>Courier New 是一个固定宽度（不等比）的字体，常用来显示编程文本。每个字符的宽度都一致，因此代码对齐后可以很容易地发现缩进和其他特征。</p>\n<p>可以用交互式 shell 或 <code>.py</code> 文件来运行示例代码。但是要注意的是，正如之前提到的，交互式 shell 中的输出与文件运行的输出可能略有不同，因此如果没得到完全一致的输出，原因就在于此。如果有示例要打印输出，但是却没有 <code>print</code> 字样，表示应该直接在交互式 shell 中输入代码。如果示例中有 <code>print</code> 字样，则说明应该从 <code>.py</code> 文件运行代码。</p>\n<h3 id=\"32\">3.2　注释</h3>\n<p><strong>注释</strong>（comment）是用英文或其他自然语言写的一行（或一部分）代码，行首均有一个特殊标志告知编程语言忽略这行代码。Python 用井号（#）来创建注释。</p>\n<p>注释的目的是解释代码的功能。程序员通过注释，使得代码更易于阅读。在注释中，可以写下任何内容，只要保持为一行即可，示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hut6nwu</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>  <span class=\"hljs-comment\"># 这是一行注释</span>\n<span class=\"hljs-number\">4</span>  print(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> Hello, World!\n</code></pre>\n<p>只有在代码中执行特别操作，或者代码不清晰易懂的情况下，才需要写注释。尽量少写注释——不要每行代码都写注释，有特殊情况才需要。下面是一个注释多余的例子：</p>\n<pre><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># http://tinyurl.com/jpzlwqq</span>\n2\n3\n4  <span class=\"hljs-comment\"># 打印 Hello, World!</span>\n5  <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n</code></pre>\n<p>注释之所以多余，是因为这行代码的功能已经非常明确。下面是一个注释合理的例子：</p>\n<pre class=\"代码无行号\"><code class=\"hljs cpp\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/z52c8z8</span></span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  <strong><span class=\"hljs-keyword\">import</span></strong> math\n<span class=\"hljs-number\">05</span>\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>  # 对角线的长度\n<span class=\"hljs-number\">08</span>  l = <span class=\"hljs-number\">4</span>\n<span class=\"hljs-number\">09</span>  w = <span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">10</span>  d = math.<span class=\"hljs-built_in\">sqrt</span>(l**<span class=\"hljs-number\">2</span>+ w**<span class=\"hljs-number\">2</span>)</code></pre>\n<p>即使你完全理解了这段代码，也可能并不知道如何计算长方形的对角线长度，因此这里的注释就是有用的。</p>\n<h3 id=\"33\">3.3　打印</h3>\n<p>程序不止可以打印 <code>Hello, World!</code>，它可以打印任何内容，只要记得加上双引号。</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zh5g2a3</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  print(<span class=\"hljs-string\">\"Python\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> Python\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hhwqva2</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  print(<span class=\"hljs-string\">\"Hola!\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> Hola!\n</code></pre>\n<h3 id=\"34\">3.4　代码行</h3>\n<p>Python 程序是由一行一行的代码组成的。看下面这个程序：</p>\n<pre><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># http://tinyurl.com/jq2w5ro</span>\n2\n3\n4  <span class=\"hljs-comment\"># 第一行</span>\n5  <span class=\"hljs-comment\"># 第二行</span>\n6  <span class=\"hljs-comment\"># 第三行</span>\n</code></pre>\n<p>程序共有 3 行代码。我们通常用代码所在的行数区别代码。在 IDLE 中，可以打开“编辑”菜单，选择“前往行”按钮，即可跳转至程序的指定行。在交互式 shell 中，一次只能输入一行代码，无法复制粘贴多行代码。</p>\n<p>有时一段代码比较长，超过了一行，可以用三引号、圆括号、方括号或者大括号扩展至新一行，示例如下：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zcdx3yo</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  print(<span class=\"hljs-string\">\"\"\"This is a really really\n5        really really long line of\n6        code.\"\"\"</span>)\n</code></pre>\n<p>另外，还可以使用反斜杠 \\ 对代码进行换行：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hjcf2sa</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-keyword\">print</span>\\\n<span class=\"hljs-number\">5</span>  (<span class=\"hljs-string\">\"\"\"This is a really really\n6   really long line of code.\"\"\"</span>)\n</code></pre>\n<p>上述两个例子的输出结果是一样的。反斜杠可以让我们将 <code>(\"\"\"This is a really really really long line of code.\"\"\")</code> 和 <code>print</code> 放在不同的行，这种情况一般是不允许的。</p>\n<h3 id=\"35\">3.5　关键字</h3>\n<p>Python 等编程语言中有一些具备特殊意义的字，即<strong>关键字</strong>（keyword）。前面见过的 <code>for</code> 就是一个关键字，用来多次执行代码。本章中还会学习更多的关键字。</p>\n<h3 id=\"36\">3.6　间距</h3>\n<p>我们再来回顾一下那个打印 <code>Hello, World!</code> 100 次的程序：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># http://tinyurl.com/glp9xq6</span>\n2\n3\n4  <strong><span class=\"hljs-keyword\">for</span></strong> i <strong><span class=\"hljs-keyword\">in</span></strong> range(100):\n5      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, World!\"</span>)</code></pre>\n<p>前面已经提到，<code>print</code> 缩进了 4 个空格符。稍后会解释原因，缩进可以告诉 Python 解释器代码块的开始与结束。同时要注意，在本书示例中看到的缩进距离，都是 4 个空格符。如果代码间距不合理，程序将无法执行。</p>\n<p>其他编程语言没有类似的缩进要求；它们使用关键字或花括号来表示代码开始和结束。以下是用 JavaScript 编程语言编写的同一个程序：</p>\n<pre class=\"代码无行号\"><code class=\"hljs coffeescript\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hwa2zae</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  <span class=\"hljs-comment\"># 这是一个 JavaScript 程序</span>\n<span class=\"hljs-number\">05</span>  <span class=\"hljs-comment\"># 不过没法执行</span>\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>\n<span class=\"hljs-number\">08</span>  <strong><span class=\"hljs-keyword\">for</span></strong> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">100</span>; i++) {\n<span class=\"hljs-number\">09</span>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"Hello, World!\"</span>);\n<span class=\"hljs-number\">10</span>  }</code></pre>\n<p>Python 的支持者坚信使用必要的缩进可以让 Python 比其他语言更易读易写。正如上例所示，即使编程语言不强制使用空格，程序员为了让代码更便于阅读，也会倾向于使用空格来分隔代码。</p>\n<h3 id=\"37\">3.7　数据类型</h3>\n<p>Python 将数据划分成不同的类别，即<strong>数据类型</strong>（data type）。在 Python 中，每一个数据值，如 <code>2</code> 或 <code>\"Hello, World!\"</code>，被称为<strong>对象</strong>（object）。本书第二部分会详细介绍数据类型，现在可以把对象看作拥有 3 个属性的数据值：唯一标识（identity）、数据类型和值。对象的唯一标识，指的是其在计算机内存中的地址，该地址不会变化。对象的数据类型是对象所属的数据类别，这决定了对象的属性，也不会变化。对象的值是其表示的数据，例如数字 <code>2</code> 的值即为 2。</p>\n<p><code>\"Hello, World!\"</code> 这个对象的数据类型为<strong>字符串</strong>（str，string 的缩写），值为 <code>\"Hello, World!\"</code>。如果提及数据类型为 <code>str</code> 的对象，可以称其为字符串。字符串是由引号包括的一个或多个字符组成的序列。<strong>字符</strong>（character）是类似 <code>a</code> 或 <code>l</code> 这样的单个符号。可以使用单引号或双引号来表示字符串，但是前后的引号必须保持一致，示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hh5kjwp</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"Hello, World!\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'Hello, World!'</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/heaxhsh</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">'Hello, World!'</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'Hello, World!'</span>\n</code></pre>\n<p>字符串可用来表示文本，且有自己独特的属性。</p>\n<p>之前章节中用来计算的数字，也是对象，但不是字符串。整数（1，2，3，4 等）的数据类型为<strong>整型数据</strong>（<code>int</code>，全称为 integer）。与字符串一样，整型数据也有着独特的属性。例如，可以将两个整数相乘，但是不能相乘两个字符串。</p>\n<p>小数（带小数点的数字）的数据类型为 <code>float</code>。2.1、8.2 和 9.9999 都是数据类型为 <code>float</code> 的对象，我们称之为<strong>浮点数</strong>（floating-point number）。与其他所有数据类型一样，浮点数也有自己独有的属性，且一定程度上与整型数据类似。</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/guoc4gy</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2.2</span> + <span class=\"hljs-number\">2.2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">4.4</span>\n</code></pre>\n<p>数据类型为 <strong>bool</strong> 的对象被称为<strong>布尔值</strong>（boolean），仅有 <code>True</code> 和 <code>False</code> 两个值。</p>\n<pre><code class=\"hljs php\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jyllj2k</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-keyword\">True</span>\n\n&gt;&gt; <span class=\"hljs-keyword\">True</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jzgsxz4</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-keyword\">False</span>\n\n&gt;&gt; <span class=\"hljs-keyword\">False</span>\n</code></pre>\n<p>数据类型为 <strong>NoneType</strong> 的对象，其值永远为 <code>None</code>，用来表示数据缺失。</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/h8oqo5v</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  None\n</code></pre>\n<p>本章后续会介绍如何使用不同的数据类型。</p>\n<h3 id=\"38\">3.8　常量和变量</h3>\n<p>你可以把 Python 当成计算器来算术，做加、减、乘、除、幂等运算。在交互式 shell 中输入以下所有示例：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zs65dp8</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">4</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gs9nwrw</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> - <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">0</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hasegvj</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">4</span> / <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">2.0</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z8ok4q3</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> * <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">4</span>\n</code></pre>\n<p><strong>常量</strong>（constant）是一个永远不会改变的值。上面示例中的每一个数字，都是常量；数字 2 永远表示的值为 2。<strong>变量</strong>（variable）则相反，指的是会改变的值。变量由一个或多个字符组成的名称构成，并使用<strong>赋值符</strong>（assignment operator）等号赋予了这个名称一个值。</p>\n<p>有些编程语言要求程序员编写变量“声明”，明确说明变量的数据类型。例如，在 C 语言中可以这样创建变量：</p>\n<pre><code class=\"hljs cs\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># 不用执行</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>  <span class=\"hljs-keyword\">int</span> a;\n<span class=\"hljs-number\">8</span>  a = <span class=\"hljs-number\">144</span>;\n</code></pre>\n<p>Python 的做法更简单；可以直接用赋值符，将某个值赋给变量，即可创建：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hw64mrr</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  b = <span class=\"hljs-number\">100</span>\n<span class=\"hljs-number\">5</span>  b\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">100</span>\n</code></pre>\n<p>下面介绍如何改变变量的值：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hw97que</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  x = <span class=\"hljs-number\">100</span>\n<span class=\"hljs-number\">5</span>  x\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  x = <span class=\"hljs-number\">200</span>\n<span class=\"hljs-number\">9</span>  x\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">100</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">200</span>\n</code></pre>\n<p>还可以使用两个变量进行算术运算：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z8hv5j5</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  x = <span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">5</span>  y = <span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">6</span>  z = x + y\n<span class=\"hljs-number\">7</span>  z\n<span class=\"hljs-number\">8</span>  a = x - y\n<span class=\"hljs-number\">9</span>  a\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">20</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">0</span>\n</code></pre>\n<p>编程时经常需要<strong>增加</strong>（increment）或<strong>减小</strong>（decrement）某个变量的值。考虑到这个操作非常普遍，Python 提供了特殊语法进行增减变量的值。如需增加变量的值，可将该变量赋予给自身，然后在等号的另一侧将变量与希望增加的值相加：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zvzf786</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  x = <span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">5</span>  x = x + <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">6</span>  x\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">11</span>\n</code></pre>\n<p>如需减小变量的值，可以执行同样的操作，唯一的区别是要减去所希望的值：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gmuzdr9</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  x = <span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">5</span>  x = x - <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">6</span>  x\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">9</span>\n</code></pre>\n<p>这些示例都是完全有效的，不过还有一种更简便的方法，示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zdva5wq</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  x = <span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">5</span>  x += <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">6</span>  x\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">11</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jqw4m5r</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  x = <span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">5</span>  x -= <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">6</span>  x\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">9</span>\n</code></pre>\n<p>变量不仅仅用于保存整型数的值，还可以表示任何数据类型，示例如下：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/jsygqcy</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  hi = <span class=\"hljs-string\">\"Hello, World!\"</span>\n\n<span class=\"hljs-number\">1</span>  # http:<span class=\"hljs-comment\">//tinyurl.com/h47ty49</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  my_float = <span class=\"hljs-number\">2.2</span>\n\n<span class=\"hljs-number\">1</span>  # http:<span class=\"hljs-comment\">//tinyurl.com/hx9xluq</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  my_boolean = True\n</code></pre>\n<p>只要遵守以下 4 条原则，可以随意命名变量。</p>\n<p>1．变量名不能包含空格符。如果想在变量名中使用两个单子，可以在中间加入下划线，如 <code>my_variable = \"A string!\"</code>。</p>\n<p>2．变量名只能使用特定的字母、数字和下划线。</p>\n<p>3．变量名不能以数字开头。虽然可以使用下划线开头，但是这种命名方式有着特殊的意义，后面内容会提到。因此在此之前尽量避免这种情况。</p>\n<p>4．不能使用 Python 关键字作为变量名。可在网页 http://theselftaughtprogrammer.io/keywords 中查看所有关键字。</p>\n<h3 id=\"39\">3.9　语法</h3>\n<p><strong>语法（syntax）</strong>指的是规范一门语言中句子结构，尤其是字词顺序的一整套规则及流程。英语有语法，Python 也有。</p>\n<p>在 Python 中，字符串永远被包括在引号内。这就是 Python 的一个语法示例。下面是一个有效的 Python 程序：</p>\n<pre><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># http://tinyurl.com/j7c2npf</span>\n2\n3\n4  <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n</code></pre>\n<p>程序之所以有效，是因为遵守了 Python 的语法，在定义字符串时用引号包括了文本。如果只是在文本的一侧使用引号，就违背了 Python 的语法，代码将无法运行。</p>\n<h3 id=\"310\">3.10　错误与异常</h3>\n<p>如果在编写 Python 程序时无视其语法，那么在运行时将出现错误。Python 解释器将告知代码无法执行，并给出有关该错误的信息。如果只用一个引号定义字符串，看看会发生什么情况，示例如下：</p>\n<pre><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># http://tinyurl.com/hp2plhs</span>\n2\n3\n4  <span class=\"hljs-comment\"># 该代码有一个错误</span>\n5\n6\n7  my_string = <span class=\"hljs-string\">\"Hello World.\n\n&gt;&gt; File \"</span>/Users/coryalthoff/PycharmProjects/se.py<span class=\"hljs-string\">\", line 1 my_string = 'd ^ SyntaxError: EOL while scanning string literal\n</span></code></pre>\n<p>这段信息表示程序中有一个语法错误。语法错误是致命的，将导致程序无法运行。如果强制执行，Python 会报错。错误信息会告诉你错误位于哪个文件，出现在哪一行，以及属于什么类型。尽管这个错误看上去很吓人，但却是很常见的。</p>\n<p>如果代码中有错误，首先要找到出错的那行代码，找到出错的地方。在本例中，你应该去找代码的第一行，观察一段时间后，会注意到里面只有一个引号。只要在字符串结尾再加上一个引号，即可解决该错误，然后可以重新运行。从这里开始，本书将这样表示错误输出：</p>\n<pre><code class=\"hljs cpp\">&gt;&gt; SyntaxError: EOL <span class=\"hljs-keyword\">while</span> scanning <span class=\"hljs-built_in\">string</span> literal\n</code></pre>\n<p>为了方便阅读，书中只显示错误信息的最后一行。</p>\n<p>Python 有两种错误：语法错误和异常。不属于语法错误的错误，就是<strong>异常</strong>（exception）。如果用 0 作为分母，则会出现“ZeroDivisionError”异常。</p>\n<p>与语法错误不同的是，异常并不一定是致命的（有办法让程序在即使出现异常时仍继续运行，这会在下一章学到）。出现异常时，Python 程序员会说“Python（或程序）报了一个异常”。下面是一个异常的示例：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jxpztcx</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-comment\"># 该代码有一个错误</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>  <span class=\"hljs-number\">10</span> / <span class=\"hljs-number\">0</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-symbol\">ZeroDivisionError:</span> division by zero\n</code></pre>\n<p>如果代码缩进不正确，程序会报“IdentationError”：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gtp6amr</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-comment\"># 该代码有一个错误</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>  y = <span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">8</span>          x =<span class=\"hljs-number\">1</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-symbol\">IndentationError:</span> unexpected indent\n</code></pre>\n<p>在学习编程的过程中，你会经常碰到语法错误和异常（包括书中没有讲到过的），但是出错的情况会逐渐减少。要记住，在碰到语法错误或异常时，先找到出现问题的那行代码，然后仔细检查并找到解决办法（如果没有头绪可以在网上搜索错误或异常提示信息）。</p>\n<h3 id=\"311\">3.11　算术操作符</h3>\n<p>之前，我们用 Python 做了简单的算术计算，如 4/2。这些示例中所使用到的符号被称为<strong>操作符</strong>（operator）。Python 将操作符分为多个类型，目前所见到的是<strong>算术操作符</strong>（arithmetic operator）。下面是 Python 中常用的一些算术操作符，见表 3-1。</p>\n<p>表3-1</p>\n<table>\n<thead>\n<tr>\n<th>操作符</th>\n<th>含　　义</th>\n<th>示例</th>\n<th>运算结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>**</td>\n<td>指数运算</td>\n<td>2 ** 2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>%</td>\n<td>取模运算</td>\n<td>14 % 4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>//</td>\n<td>整除/地板除运算</td>\n<td>13 // 8</td>\n<td>1</td>\n</tr>\n<tr>\n<td>/</td>\n<td>除法运算</td>\n<td>13 / 8</td>\n<td>1.625</td>\n</tr>\n<tr>\n<td>*</td>\n<td>乘法运算</td>\n<td>8 * 2</td>\n<td>16</td>\n</tr>\n<tr>\n<td>−</td>\n<td>减法运算</td>\n<td>7 − 1</td>\n<td>6</td>\n</tr>\n<tr>\n<td>+</td>\n<td>加法运算</td>\n<td>2 + 2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>\n<p>两个数相除时，会有一个商和一个余数。商就是除法运算的结果，余数即剩下的值。取模操作符返回的就是余数。例如，13 除以 5 的结果就是商 2 余 3，示例如下：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/qrdc195</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">13</span> <span class=\"hljs-comment\">// 5</span>\n\n&gt;&gt; <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/zsqwukd</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">13</span> % <span class=\"hljs-number\">5</span>\n\n&gt;&gt; <span class=\"hljs-number\">3</span>\n</code></pre>\n<p>对两个数取模时，如果没有余数（返回 0），则被取模的数字为另一个数字的倍数。如果有余数，则不是其倍数。因此取模运算被用于检验数字的奇偶性，示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jerpe6u</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-comment\"># 偶数</span>\n<span class=\"hljs-number\">5</span>  <span class=\"hljs-number\">12</span> % <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">0</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gkudhcr</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-comment\"># 奇数</span>\n<span class=\"hljs-number\">5</span>  <span class=\"hljs-number\">11</span> % <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">1</span>\n</code></pre>\n<p>有两个操作符用于除法运算。第一个是 // ，返回值为商：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/hh9fqzy</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">14</span> <span class=\"hljs-comment\">// 3</span>\n\n&gt; <span class=\"hljs-number\">4</span>\n</code></pre>\n<p>第二个是 / ，返回值为两个数相除的浮点数结果：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/zlkjjdp</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">14</span> / <span class=\"hljs-number\">3</span>\n\n&gt; <span class=\"hljs-number\">4.666666666666667</span>\n</code></pre>\n<p>还可以使用指数运算符求幂：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h8vuwd4</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>  <span class=\"hljs-number\">2</span> ** <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">4</span>\n</code></pre>\n<p>操作符两侧的值（以上示例中就是数字）被称为<strong>操作数</strong>（operand）。两个操作数和一个操作符共同构成一个<strong>表达式</strong>（expression）。程序运行时，Python 会对每个表达式求值，并返回一个值作为结果。如果在交互式 shell 中输入表达式 2 + 2，则返回结果 4。</p>\n<p><strong>运算顺序</strong>（order of operation），指的是数学计算中对表达式求值的一套规则。可使用 PEMDAS 方法，帮助记忆数学公式的运算顺序：括号（parentheses）、指数（exponents）、乘法（multiplication）、除法（division）、加法（addition）和减法（subtraction）。括号的优先级大于指数符号，后者又优先于乘法和除法，最后才是加法和减法。如果操作符的优先级相同，如 15 / 3 * 2，则按照从左到右的顺序求值。上述表达式中将 15 先除以 3，然后再乘以 2。Python 对数学表达式求值时，遵循的是同一套运算顺序：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hgjyj7o</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">2</span> * <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">6</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hsq7rcz</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  (<span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">2</span>) * <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">8</span>\n</code></pre>\n<p>在第一个示例中，2 * 2 先进行求值，因为乘法的优先级大于加法。</p>\n<p>在第二个示例中，(2 + 2) 先求值，因为 Python 总是先对括号内的表达式求值。</p>\n<h3 id=\"312\">3.12　比较操作符</h3>\n<p><strong>比较操作符</strong>（comparison operator）是 Python 中的另一种操作符。与算术操作符类似，比较操作符可用于表达式任意一侧的操作数；不同的是，带有比较操作符的表达式最后求值的结果不是 <code>True</code> 就是 <code>False</code>。详情见表 3-2。</p>\n<p>表 3-2　　</p>\n<table>\n<thead>\n<tr>\n<th>操作符</th>\n<th>含　　义</th>\n<th>示　　例</th>\n<th>运算结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&gt;</td>\n<td>大于</td>\n<td>100 &gt; 10</td>\n<td>True</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>小于</td>\n<td>100 &lt; 10</td>\n<td>False</td>\n</tr>\n<tr>\n<td>&gt;=</td>\n<td>大于或等于</td>\n<td>2 &gt;= 2</td>\n<td>True</td>\n</tr>\n<tr>\n<td>&lt;=</td>\n<td>小于或等于</td>\n<td>1 &lt;= 4</td>\n<td>True</td>\n</tr>\n<tr>\n<td>==</td>\n<td>等于</td>\n<td>6 == 9</td>\n<td>False</td>\n</tr>\n<tr>\n<td>!=</td>\n<td>不等于</td>\n<td>3 != 2</td>\n<td>True</td>\n</tr>\n</tbody>\n</table>\n<p>在含有 &gt; 操作符的表达式中，如果左侧的数字大于右侧的数字，则表达式的值为 <code>True</code>，否则即为 <code>False</code>：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jm7cxzp</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">100</span> &gt; <span class=\"hljs-number\">10</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True\n</code></pre>\n<p>在含有 &lt; 操作符的表达式中，如果左侧的数字小于右侧的数字，则表达式的值为 <code>True</code>，否则即为 <code>False</code>：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gsdhr8q</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>  <span class=\"hljs-number\">100</span> &lt; <span class=\"hljs-number\">10</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False\n</code></pre>\n<p>在含有 &gt;= 操作符的表达式中，如果左侧的大于或等于右侧的数字，则表达式的值为 <code>True</code>，否则即为 <code>False</code>：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jy2oefs</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>  <span class=\"hljs-number\">2</span> &gt;= <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True\n</code></pre>\n<p>在含有 &lt;= 操作符的表达式中，如果左侧的数字小于或等于右侧的数字，则表达式的值为 <code>True</code>，否则即为 <code>False</code>：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jk599re</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> &gt;= <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True\n</code></pre>\n<p>在含有 == 操作符的表达式中，如果左侧的数字等于右侧的数字，则表达式的值为 <code>True</code>，否则即为 <code>False</code>：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/j2tsz9u</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/j5mr2q2</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False\n</code></pre>\n<p>在含有 != 操作符的表达式中，如果左侧的数字不等于右侧的数字，则表达式的值为 <code>True</code>，否则即为 <code>False</code>：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gsw3zoe</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> != <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z7pffk3</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> != <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False\n</code></pre>\n<p>此前，如果使用 = 将数字赋值给了变量，如 x = 100。可能会将其理解为“x 等于 100”，但这是错误的。前面看到，= 是用来给变量赋值的，而不是检查相等性的操作符。因此 x = 100 应理解为“x 的值为 100”。比较操作符 == 是用于检查两侧是否相等的，因此如果看到 x == 100，含义即为“x 等于 100”。</p>\n<h3 id=\"313\">3.13　逻辑操作符</h3>\n<p><strong>逻辑操作符</strong>（logical operator）也是 Python 中的一类操作符。与比较操作符类似，逻辑操作符的求值结果也是 <code>True</code> 或 <code>False</code>。详情见表 3-3。</p>\n<p>表 3-3　　</p>\n<table>\n<thead>\n<tr>\n<th>操　作　符</th>\n<th>含　　义</th>\n<th>示　　例</th>\n<th>运算结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>and</td>\n<td>与</td>\n<td>True and True</td>\n<td>True</td>\n</tr>\n<tr>\n<td>or</td>\n<td>或</td>\n<td>True or False</td>\n<td>True</td>\n</tr>\n<tr>\n<td>not</td>\n<td>非</td>\n<td>not True</td>\n<td>False</td>\n</tr>\n</tbody>\n</table>\n<p>Python 关键字 and 可以连接两个表达式，如果二者均求值为 <code>True</code>，则返回 <code>True</code>。如果任意一个的值为 <code>False</code>，即返回 <code>False</code>：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zdqghb2</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">1</span> <strong><span class=\"hljs-keyword\">and</span></strong> <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zkp2jzy</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">2</span> <strong><span class=\"hljs-keyword\">and</span></strong> <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/honkev6</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">2</span> <strong><span class=\"hljs-keyword\">and</span></strong> <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">1</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zjrxxrc</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">1</span> <strong><span class=\"hljs-keyword\">and</span></strong> <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">1</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False</code></pre>\n<p>可以在一个语句中多次使用 <code>and</code> 关键字：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zpvk56u</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">1</span> <strong><span class=\"hljs-keyword\">and</span></strong> <span class=\"hljs-number\">10</span> != <span class=\"hljs-number\">2</span> <strong><span class=\"hljs-keyword\">and</span></strong> <span class=\"hljs-number\">2</span> &lt; <span class=\"hljs-number\">10</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<p>关键字 <code>or</code> 可连接两个或多个表达式，如果任意一个表达式的值为 <code>True</code>，即返回 <code>True</code>：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hosuh7c</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">1</span> <strong><span class=\"hljs-keyword\">or</span></strong> <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zj6q8h9</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">1</span> <strong><span class=\"hljs-keyword\">or</span></strong> <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/j8ngufo</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">2</span> <strong><span class=\"hljs-keyword\">or</span></strong> <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">1</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z728zxz</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">1</span> <strong><span class=\"hljs-keyword\">or</span></strong> <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False</code></pre>\n<p>类似地，也可以在一个语句中多次使用 <code>or</code> 关键字：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/ja9mech</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">1</span> <strong><span class=\"hljs-keyword\">or</span></strong> <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">2</span> <strong><span class=\"hljs-keyword\">or</span></strong> <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">3</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<p>该表达式的值为 <code>True</code>，因为 1 == 1 的值为 <code>True</code>，即使表达式其余的部分求值为 <code>False</code>，最终的值仍为 <code>True</code>。</p>\n<p>将关键字 <code>not</code> 放置在表达式的前面，将改变表达式的求值结果，逆转为原本结果的对立值。如果表达式原本的求值结果为 <code>True</code>，则加上 <code>not</code> 之后结果会变为 <code>False</code>：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h45eq6v</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-keyword\">not</span></strong> <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">1</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gsqj6og</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-keyword\">not</span></strong> <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<h3 id=\"314\">3.14　条件语句</h3>\n<p>关键字 <code>if</code>、<code>elif</code> 和 <code>else</code> 用于<strong>条件语句</strong>（conditional statement）。条件语句是一种<strong>控制结构</strong>（control structure）：通过分析变量的值从而做出对应决定的代码块。条件语句是可根据条件执行额外代码的代码。为了方便理解，仔细看以下这个伪代码（pseudocode）示例（伪代码是用于解释说明示例代码的标记方法）：</p>\n<pre><code class=\"hljs php\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># 不要执行</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-keyword\">If</span> (expression) Then\n<span class=\"hljs-number\">5</span>              (code_area1)\n<span class=\"hljs-number\">6</span>  <span class=\"hljs-keyword\">Else</span>\n<span class=\"hljs-number\">7</span>              (code_area2)\n</code></pre>\n<p>上述伪代码显示，可以定义两个条件语句。如果第一个条件语句中定义的表达式为 <code>True</code>，则执行 <code>code_area1</code>；否则执行 <code>code_area2</code>。示例中的第一部分被称为 <code>if</code> 语句，第二部分为 <code>else</code> 语句。两者共同组成一个 <code>if-else</code> 语句：程序员用来表达“如果出现这种情况，则这样做，否则那样做”的方法。下面是 Python 中的 <code>if-else</code> 语句示例：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># http://tinyurl.com/htvy6g3</span>\n2\n3\n4  home = <span class=\"hljs-string\">\"America\"</span>\n5  <strong><span class=\"hljs-keyword\">if</span></strong> home == <span class=\"hljs-string\">\"America\"</span>:\n6      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, America!\"</span>)\n7  <strong><span class=\"hljs-keyword\">else</span></strong>:\n8      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n\n&gt;&gt; Hello, America!</code></pre>\n<p>第 5 行和第 6 行共同组成了 <code>if</code> 语句。一个 <code>if</code> 语句中，包括一行以 <code>if</code> 关键字开头的代码行，<code>if</code> 关键字之后是一个表达式，还有冒号、缩进，以及一行或多行如果表达式为 <code>True</code> 的情况下将执行的代码。第 7 行和第 8 行共同组成了 <code>else</code> 语句。一个 <code>else</code> 语句的开头是 <code>else</code> 关键字，然后是冒号、缩进，以及一行或多行如果 <code>if</code> 语句中表达式为 <code>False</code> 时将执行的代码。</p>\n<p>二者共同组成了一个 <code>if-else</code> 语句。本例的打印输出结果为 <code>Hello, America!</code>，因为 <code>if</code> 语句中的表达式结果为 <code>True</code>。如果将变量 <code>home</code> 的值修改为 <code>Canada</code>，则 <code>if</code> 语句中的表达式结果为 <code>False</code>，将会执行 <code>else</code> 语句中的代码，程序会打印出 <code>Hello, World!</code>。</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># http://tinyurl.com/jytyg5x</span>\n2\n3\n4  home = <span class=\"hljs-string\">\"Canada\"</span>\n5  <strong><span class=\"hljs-keyword\">if</span></strong> home ==<strong> </strong><span class=\"hljs-string\">\"America\"</span>:\n6      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, America!\"</span>)\n7  <strong><span class=\"hljs-keyword\">else</span></strong>:\n8      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n\n&gt;&gt; Hello, World!</code></pre>\n<p>可以单独使用一个 <code>if</code> 语句：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jyg7dd2</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  home = <span class=\"hljs-string\">\"America\"</span>\n<span class=\"hljs-number\">5</span>  <strong><span class=\"hljs-keyword\">if</span></strong> home == <span class=\"hljs-string\">\"America\"</span>:\n<span class=\"hljs-number\">6</span>      print(<span class=\"hljs-string\">\"Hello, America!\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> Hello, America!</code></pre>\n<p>也可以连续使用多个 <code>if</code> 语句：</p>\n<pre class=\"代码无行号\"><code class=\"hljs coffeescript\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z24ckye</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  x = <span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">05</span>  <strong><span class=\"hljs-keyword\">if</span></strong> x == <span class=\"hljs-number\">2</span>:\n<span class=\"hljs-number\">06</span>      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"The number is 2.\"</span>)\n<span class=\"hljs-number\">07</span>  <strong><span class=\"hljs-keyword\">if</span></strong> x % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>:\n<span class=\"hljs-number\">08</span>      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"The number is even.\"</span>)\n<span class=\"hljs-number\">09</span>  <strong><span class=\"hljs-keyword\">if</span></strong> x % <span class=\"hljs-number\">2</span> != <span class=\"hljs-number\">0</span>:\n<span class=\"hljs-number\">10</span>      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"The number is odd.\"</span>)\n\n&gt;&gt; The number <span class=\"hljs-keyword\">is</span> <span class=\"hljs-number\">2.</span>\n&gt;&gt; The number <span class=\"hljs-keyword\">is</span> even.</code></pre>\n<p>每个 <code>if</code> 语句只有在其表达式求值为 <code>True</code> 时，才会执行所有的代码。在本例中，前两个表达式的求值结果为 <code>True</code>，因此各自的代码都执行了，但是第 3 个表达式的结果为 <code>False</code>，所以没有执行。</p>\n<p>如果愿意，甚至还可以在 <code>if</code> 语句中再加入一个 <code>if</code> 语句（通常称之为嵌套）：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zrodgne</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  x = <span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">05</span>  y = <span class=\"hljs-number\">11</span>\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>\n08  <strong><span class=\"hljs-keyword\">if</span></strong> x == <span class=\"hljs-number\">10</span>:\n09      <strong><span class=\"hljs-keyword\">if</span></strong> y == <span class=\"hljs-number\">11</span>:\n<span class=\"hljs-number\">10</span>          print(x + y)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">21</span></code></pre>\n<p>在本例中，只有在两个 <code>if</code> 语句的结果均为 <code>True</code> 时，才会打印 <code>x + y</code>。<code>else</code> 语句无法被单独使用，只能用在 <code>if-else</code> 语句的最后一部分。</p>\n<p>也可以使用 <code>elif</code> 关键字创建 <code>elif</code> 语句。<code>elif</code> 表示另外如果，该语句可无限添加到 <code>if-else</code> 语句中，使其支持更多的决策。</p>\n<p>如果一个 <code>if-else</code> 语句中包含有 <code>elif</code> 语句，则首先判断 <code>if</code> 语句。如果该语句中的表达式为 <code>True</code>，则只执行其中的代码。但是，如果其值为 <code>False</code>，每个之后的 <code>elif</code> 语句都将进行求值。只要有一个 <code>elif</code> 语句中的表达式结果为 <code>True</code>，则执行其中的代码并退出。如果没有任何一个 <code>elif</code> 语句的结果为 <code>True</code>，则执行 <code>else</code> 语句中的代码。下面是一个包含有 <code>elif</code> 语句的 <code>if-else</code> 语句示例：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">01  <span class=\"hljs-comment\"># http://tinyurl.com/jpr265j</span>\n02\n03\n04  home = <span class=\"hljs-string\">\"Thailand\"</span>\n05  <strong><span class=\"hljs-keyword\">if</span></strong> home == <span class=\"hljs-string\">\"Japan\"</span>:\n06      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"Hello, Japan!\"</span>)\n07  <strong><span class=\"hljs-keyword\">elif</span></strong> home == <span class=\"hljs-string\">\"Thailand\"</span>:\n08      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"Hello, Thailand!\"</span>)\n09  <strong><span class=\"hljs-keyword\">elif</span></strong> home == <span class=\"hljs-string\">\"India\"</span>:\n10      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, India!\"</span>)\n11  <strong><span class=\"hljs-keyword\">elif</span></strong> home == <span class=\"hljs-string\">\"China\"</span>:\n12      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, China!\"</span>)\n13  <strong><span class=\"hljs-keyword\">else</span></strong>:\n14      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n\n&gt;&gt; Hello, Thailand!</code></pre>\n<p>下面这个示例中，所有的 <code>elif</code> 语句求值结果均不为 <code>True</code>，最后执行的是 <code>else</code> 语句中的代码。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">01  <span class=\"hljs-comment\"># http://tinyurl.com/zdvuuhs</span>\n02\n03  home = <span class=\"hljs-string\">\"Mars\"</span>\n04  <strong><span class=\"hljs-keyword\">if</span></strong> home == <span class=\"hljs-string\">\"America\"</span>:\n05      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"Hello, America!\"</span>)\n06  <strong><span class=\"hljs-keyword\">elif</span></strong> home == <span class=\"hljs-string\">\"Canada\"</span>:\n07      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"Hello, Canada!\"</span>)\n08  <strong><span class=\"hljs-keyword\">elif</span></strong> home == <span class=\"hljs-string\">\"Thailand\"</span>:\n09      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, Thailand!\"</span>)\n10  <strong><span class=\"hljs-keyword\">elif</span></strong> home == <span class=\"hljs-string\">\"Mexico\"</span>:\n11      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, Mexico!\"</span>)\n12  <strong><span class=\"hljs-keyword\">else</span></strong>:\n13      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n\n&gt;&gt; Hello, World! </code></pre>\n<p>最后，可以连续使用多个 <code>if</code> 语句和 <code>elif</code> 语句：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">01  <span class=\"hljs-comment\"># http://tinyurl.com/hzyxgf4</span>\n02\n03\n04  x = 100\n05  <strong><span class=\"hljs-keyword\">if</span></strong> x == 10:\n06      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"10!\"</span>)\n07  <strong><span class=\"hljs-keyword\">elif</span></strong> x == 20:\n08      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"20!\"</span>)\n09  <strong><span class=\"hljs-keyword\">else</span></strong>:\n10      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"I don't know!\"</span>)\n11\n12\n13  <strong><span class=\"hljs-keyword\">if</span></strong> x == 100:\n14      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"x is 100!\"</span>)\n15\n16\n17  <strong><span class=\"hljs-keyword\">if</span></strong> x % 2 == 0:\n18      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"x is even!\"</span>)\n19<strong>  <span class=\"hljs-keyword\">else</span></strong>:\n20      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"x is odd!\"</span>)\n\n&gt;&gt; I don<span class=\"hljs-string\">'t know!\n&gt;&gt; x is 100!\n&gt;&gt; x is even!</span></code></pre>\n<h3 id=\"315\">3.15　语句</h3>\n<p><strong>语句</strong>（statement）这个术语可用来描述 Python 语言的多种构成部分。可以将一个 Python 语句视作一个命令或计算。本节将详细介绍语句的语法。如果感觉部分内容初次学起来很难懂，也不用太担心，随着练习 Python 的时间变长，你就会慢慢理解。</p>\n<p>Python 中有两类语句：<strong>简单语句</strong>（simple statement）和<strong>复合语句</strong>（compound statement）。简单语句一般就是一行代码，而复合语句通常包括多行代码。下面是一些简单语句的示例：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jrowero</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  print(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> Hello, World!\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h2y549y</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">4</span>\n</code></pre>\n<p><code>if</code> 语句和 <code>if-else</code> 语句，以及本章编写的第一个程序（打印 <code>Hello, World!</code> 100 次）都是复合语句。</p>\n<p>复合语句由一个或多个<strong>从句</strong>（clause）组成。从句包括两行或多行代码：<strong>代码头</strong>（header）及紧随其后的<strong>配套代码</strong>（suite）。代码头指的是从句中包含关键字的那行代码，之后是一个冒号和一行或多行带缩进的代码。缩进之后，是一个或多个配套代码。配套代码就是从句中一行普通的代码。代码头控制配套代码的执行。打印 <code>Hello, World!</code> 100 次的程序，就是由一个复合语句组成。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zfz3eel</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>  <strong><span class=\"hljs-keyword\">for</span></strong> i <strong><span class=\"hljs-keyword\">in</span></strong> range(<span class=\"hljs-number\">100</span>):\n<span class=\"hljs-number\">4</span>      print(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> Hello, World!\n&gt;&gt; Hello, World!\n&gt;&gt; Hello, World!\n…</code></pre>\n<p>程序的第一行是代码头，包括关键字 <code>for</code>，之后是冒号。缩进之后是配套代码 <code>print(\"Hello, World!\")</code>。在上述示例中，代码头通过配套代码打印 <code>Hello, World!</code> 100 次，这是一个循环，将在第 7 章详细介绍。上述代码只有一个从句。</p>\n<p>复合语句可以由多个从句构成，你前面看到的 <code>if-else</code> 语句就是复合语句。<code>if</code> 语句之后如果带有一个 <code>else</code> 语句，就构成了一个由多个从句组成的复合语句。在包含多个从句的复合语句中，代码头从句共同控制代码执行。对于 <code>if-else</code> 语句，当 <code>if</code> 语句的值为 <code>True</code> 时，则执行 <code>if</code> 语句的配套代码，<code>else</code> 语句的配套代码不执行；当 <code>if</code> 语句的值为 <code>False</code> 时，则不执行 <code>if</code> 语句的配套代码，转而执行 <code>else</code> 语句的配套代码。上一节中的最后一个示例包含了 3 个复合语句：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">01  <span class=\"hljs-comment\"># http://tinyurl.com/hpwkdo4</span>\n02\n03\n04  x = 100\n05  <strong><span class=\"hljs-keyword\">if</span></strong> x == 10:\n06      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"10!\"</span>)\n07  <strong><span class=\"hljs-keyword\">elif</span></strong> x == 20:\n08      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"20!\"</span>)\n09  <strong><span class=\"hljs-keyword\">else</span></strong>:\n10      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"I don't know!\"</span>)\n11\n12\n13  <strong><span class=\"hljs-keyword\">if</span></strong> x == 100:\n14      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"x is 100!\"</span>)\n15\n16\n17  <strong><span class=\"hljs-keyword\">if</span></strong> x % 2 == 0:\n18      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"x is even!\"</span>)\n19  <strong><span class=\"hljs-keyword\">else</span></strong>:\n20      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"x is odd!\"</span>)\n\n&gt;&gt; I don<span class=\"hljs-string\">'t know!\n&gt;&gt; x is 100!\n&gt;&gt; x is even!</span></code></pre>\n<p>第一个复合语句中有 3 个从句，第二个里有一个从句，最后一个则有两个从句。</p>\n<p>关于语句还有一点要注意，语句之间是可以有空格的，这不会影响代码的执行。空格有时被用来提高代码的可读性。</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zlgcwoc</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  print(<span class=\"hljs-string\">\"Michael\"</span>)\n<span class=\"hljs-number\">05</span>\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>\n08\n09\n<span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">11</span>  print(<span class=\"hljs-string\">\"Jordan\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> Michael\n<span class=\"hljs-meta\">&gt;&gt;</span> Jordan\n</code></pre>\n<h3 id=\"316\">3.16　术语表</h3>\n<p><strong>注释</strong>：用英文或其他自然语言写的一行（或一部分）代码，行首均有一个特殊标志告知编程语言忽略这行代码。</p>\n<p><strong>关键字</strong>：编程语言中具有特殊意义的词。可在 http://theselftaughtprogrammer.io/keywords 网页中查看所有 Python 的关键字。</p>\n<p><strong>数据类型</strong>：数据所属的类别。</p>\n<p><strong>对象</strong>：Python 中具有 3 个属性的数据值——唯一标识、数据类型和值。</p>\n<p><strong>Str</strong>：字符串的数据类型。</p>\n<p><strong>字符</strong>：a 或 l 等单个符号。</p>\n<p><strong>Int</strong>：整数的数据类型。</p>\n<p><strong>整型数据</strong>：数据类型为 int 的对象，其值为一个整数。</p>\n<p><strong>Float</strong>：小数的数据类型。</p>\n<p><strong>浮点数</strong>：数据类型为 <code>float</code> 的对象，其值为一个小数。</p>\n<p><strong>Bool</strong>：布尔对象的数据类型。</p>\n<p><strong>布尔值</strong>：数据类型为 <code>bool</code> 的对象，其值为 <code>True</code> 或 <code>False</code>。</p>\n<p><strong>NoneType</strong>：<code>None</code> 对象的数据类型。</p>\n<p><strong>None</strong>：数据类型为 <code>NoneType</code> 的对象，其值永远为 <code>None</code>。</p>\n<p><strong>常量</strong>：不会改变的值。</p>\n<p><strong>变量</strong>：使用赋值操作符赋予了一个值的名称。</p>\n<p><strong>赋值操作符</strong>：Python 中的 <code>=</code> 符号。</p>\n<p><strong>增加</strong>：增加一个变量的值。</p>\n<p><strong>减少</strong>：减少一个变量的值。</p>\n<p><strong>语法</strong>：规范一门语言中句子结构，尤其是字词顺序的一整套规则及流程。</p>\n<p><strong>语法错误</strong>：违反编程语言的语法，所导致的致命编程错误。</p>\n<p><strong>异常</strong>：非致命的编程错误。</p>\n<p><strong>操作符</strong>：在表达式中与操作符一起使用的符号。</p>\n<p><strong>算术操作符</strong>：数学表达式中使用的一类操作符。</p>\n<p><strong>操作数</strong>：操作符两侧的值。</p>\n<p><strong>表达式</strong>：操作符及两个操作数构成的代码。</p>\n<p><strong>运算顺序</strong>：数学计算中用来对表达式求值的一组规则。</p>\n<p><strong>比较操作符</strong>：表达式中用到的一类操作符，求值结果为 <code>True</code> 或 <code>False</code>。</p>\n<p><strong>逻辑操作符</strong>：对两个表达式求值的一类操作符，求值结果为 <code>True</code> 或 <code>False</code>。</p>\n<p><strong>条件语句</strong>：根据条件执行不同代码的代码。</p>\n<p><strong>控制结构</strong>：通过分析变量的值，来决定代码如何执行的代码块。</p>\n<p><strong>伪代码</strong>：用来演示逻辑的标记方法，与代码类似。</p>\n<p><strong>if-else 语句</strong>：程序员用来表达“如果出现这种情况，则这样做，否则那样做”的方法。</p>\n<p><strong>if 语句</strong>：<code>if-else</code> 语句的第一部分。</p>\n<p><strong>else 语句</strong>：<code>if-else</code> 语句的第二部分。</p>\n<p><strong>语句</strong>：一个命令或计算。</p>\n<p><strong>简单语句</strong>：可用一行代码表述的语句。</p>\n<p><strong>复合语句</strong>：通常包括多行代码的语句。</p>\n<p><strong>从句</strong>：复合语句的组成部分；一个从句由两行或多行代码构成，包括代码头及配套代码。</p>\n<p><strong>代码头</strong>：从句中包含关键字的那行代码，之后是一个冒号和一行或多行带缩进的代码。</p>\n<p><strong>配套代码</strong>：从句中由代码头控制的代码。</p>\n<h3 id=\"317\">3.17　挑战练习</h3>\n<p>1．请打印 3 个不同的字符串。</p>\n<p>2．编写程序：如果变量的值小于 10，打印一条消息；如果大于或等于 10，则打印不同的消息。</p>\n<p>3．编写程序：如果变量的值小于或等于 10，打印一条消息；如果大于 10 且小于或等于 25，则打印一条不同的消息；如果大于 25，则打印另一条不同的消息。</p>\n<p>4．编写一个将两个变量相除，并打印余数的程序。</p>\n<p>5．编写一个将两个变量相除，并打印商的程序。</p>\n<p>6．编写程序：为变量 age 赋予一个整数值，根据不同的数值打印不同的字符串说明。</p>\n<p>答案可从异步社区（www.epubit.com）本书详情页的配套资源中下载。</p></div></article>\n</body>\n</html>","source":"_posts/Python无师自通/3_python_coding_introduction.html","raw":"---\ntitle: 编程概论\n---\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>编程概论</title>\n</head>\n<body>\n<article id=\"articleDiv\"><div class=\"mazi-article-content dont-break-out\"><p></p><div class=\"toc\">\n<ul>\n<li><ul>\n<li><ul>\n<li><a href=\"#31\">3.1　示例</a></li>\n<li><a href=\"#32\">3.2　注释</a></li>\n<li><a href=\"#33\">3.3　打印</a></li>\n<li><a href=\"#34\">3.4　代码行</a></li>\n<li><a href=\"#35\">3.5　关键字</a></li>\n<li><a href=\"#36\">3.6　间距</a></li>\n<li><a href=\"#37\">3.7　数据类型</a></li>\n<li><a href=\"#38\">3.8　常量和变量</a></li>\n<li><a href=\"#39\">3.9　语法</a></li>\n<li><a href=\"#310\">3.10　错误与异常</a></li>\n<li><a href=\"#311\">3.11　算术操作符</a></li>\n<li><a href=\"#312\">3.12　比较操作符</a></li>\n<li><a href=\"#313\">3.13　逻辑操作符</a></li>\n<li><a href=\"#314\">3.14　条件语句</a></li>\n<li><a href=\"#315\">3.15　语句</a></li>\n<li><a href=\"#316\">3.16　术语表</a></li>\n<li><a href=\"#317\">3.17　挑战练习</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>\n<p></p>\n<blockquote>\n  <p><span style=\"font-family: Times New Roman,楷体_GB2312\">“这是我能想到的，唯一可以让我既当工程师又做艺术家的工作。它要求具备极其缜密的技术思维，因为你必须要完成精确的思考，这点我很喜欢。另一方面，它又鼓励你肆意挥洒自己的创意，只有你想不到没有你做不到的。”</span></p>\n  <p><span style=\"font-family: Times New Roman,楷体_GB2312\">——安迪 · 赫兹菲尔德（Andy Hertzfeld）</span></p>\n</blockquote>\n<p>我们的第一个程序打印出了 <code>Hello, World!</code>。接下来打印 100 次。在交互式 shell 中输入如下代码（print 需要缩进 4 个空格符）：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># http://tinyurl.com/h79ob7s</span>\n2\n3\n4  <strong><span class=\"hljs-keyword\">for</span></strong> i <strong><span class=\"hljs-keyword\">in</span></strong> range(100):\n5      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, World!\"</span>)</code></pre>\n<p>交互式 shell 应该会打印 <code>Hello, World!</code> 100 次。即使通常没有这样做的需要，但可以从这个例子中看出编程的强大。你能想到任何其他可以如此简单地做 100 遍的事情吗？我想不到。这就是编程的厉害之处。</p>\n<h3 id=\"31\">3.1　示例</h3>\n<p>从现在开始，代码示例会以如下形式出现：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h4qntgk</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-keyword\">for</span></strong> i <strong><span class=\"hljs-keyword\">in</span></strong> range(<span class=\"hljs-number\">100</span>):\n<span class=\"hljs-number\">5</span>      print(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> Hello, World!\n&gt;&gt; Hello, World!\n&gt;&gt; Hello, World!\n…</code></pre>\n<p>打开 http://tinyurl.com/h4qntqk 这个链接，就可以看到包含有示例代码的网页，这样如果无法让代码运行，你可以轻松地复制代码，并粘贴到 IDLE 的文本编辑器中。<code>&gt;&gt;</code> 的后面则是交互式 shell 的输出。全书的每一个编程示例中都会看到 <code>&gt;&gt;</code>，这代表了程序的输出结果（会在交互式 shell 中打印出来）。“...”表示“等等”。</p>\n<p>如果示例后没有 <code>&gt;&gt;</code>，就表示该程序没有输出，或者只是在解释概念，输出并不太重要。</p>\n<p>字体为 Courier New 的部分，都是某种形式的代码、代码输出或编程术语。例如，上个例子中提到的词 <code>for</code>，它就会是 Courier New 字体。</p>\n<p>Courier New 是一个固定宽度（不等比）的字体，常用来显示编程文本。每个字符的宽度都一致，因此代码对齐后可以很容易地发现缩进和其他特征。</p>\n<p>可以用交互式 shell 或 <code>.py</code> 文件来运行示例代码。但是要注意的是，正如之前提到的，交互式 shell 中的输出与文件运行的输出可能略有不同，因此如果没得到完全一致的输出，原因就在于此。如果有示例要打印输出，但是却没有 <code>print</code> 字样，表示应该直接在交互式 shell 中输入代码。如果示例中有 <code>print</code> 字样，则说明应该从 <code>.py</code> 文件运行代码。</p>\n<h3 id=\"32\">3.2　注释</h3>\n<p><strong>注释</strong>（comment）是用英文或其他自然语言写的一行（或一部分）代码，行首均有一个特殊标志告知编程语言忽略这行代码。Python 用井号（#）来创建注释。</p>\n<p>注释的目的是解释代码的功能。程序员通过注释，使得代码更易于阅读。在注释中，可以写下任何内容，只要保持为一行即可，示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hut6nwu</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>  <span class=\"hljs-comment\"># 这是一行注释</span>\n<span class=\"hljs-number\">4</span>  print(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> Hello, World!\n</code></pre>\n<p>只有在代码中执行特别操作，或者代码不清晰易懂的情况下，才需要写注释。尽量少写注释——不要每行代码都写注释，有特殊情况才需要。下面是一个注释多余的例子：</p>\n<pre><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># http://tinyurl.com/jpzlwqq</span>\n2\n3\n4  <span class=\"hljs-comment\"># 打印 Hello, World!</span>\n5  <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n</code></pre>\n<p>注释之所以多余，是因为这行代码的功能已经非常明确。下面是一个注释合理的例子：</p>\n<pre class=\"代码无行号\"><code class=\"hljs cpp\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/z52c8z8</span></span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  <strong><span class=\"hljs-keyword\">import</span></strong> math\n<span class=\"hljs-number\">05</span>\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>  # 对角线的长度\n<span class=\"hljs-number\">08</span>  l = <span class=\"hljs-number\">4</span>\n<span class=\"hljs-number\">09</span>  w = <span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">10</span>  d = math.<span class=\"hljs-built_in\">sqrt</span>(l**<span class=\"hljs-number\">2</span>+ w**<span class=\"hljs-number\">2</span>)</code></pre>\n<p>即使你完全理解了这段代码，也可能并不知道如何计算长方形的对角线长度，因此这里的注释就是有用的。</p>\n<h3 id=\"33\">3.3　打印</h3>\n<p>程序不止可以打印 <code>Hello, World!</code>，它可以打印任何内容，只要记得加上双引号。</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zh5g2a3</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  print(<span class=\"hljs-string\">\"Python\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> Python\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hhwqva2</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  print(<span class=\"hljs-string\">\"Hola!\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> Hola!\n</code></pre>\n<h3 id=\"34\">3.4　代码行</h3>\n<p>Python 程序是由一行一行的代码组成的。看下面这个程序：</p>\n<pre><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># http://tinyurl.com/jq2w5ro</span>\n2\n3\n4  <span class=\"hljs-comment\"># 第一行</span>\n5  <span class=\"hljs-comment\"># 第二行</span>\n6  <span class=\"hljs-comment\"># 第三行</span>\n</code></pre>\n<p>程序共有 3 行代码。我们通常用代码所在的行数区别代码。在 IDLE 中，可以打开“编辑”菜单，选择“前往行”按钮，即可跳转至程序的指定行。在交互式 shell 中，一次只能输入一行代码，无法复制粘贴多行代码。</p>\n<p>有时一段代码比较长，超过了一行，可以用三引号、圆括号、方括号或者大括号扩展至新一行，示例如下：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zcdx3yo</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  print(<span class=\"hljs-string\">\"\"\"This is a really really\n5        really really long line of\n6        code.\"\"\"</span>)\n</code></pre>\n<p>另外，还可以使用反斜杠 \\ 对代码进行换行：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hjcf2sa</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-keyword\">print</span>\\\n<span class=\"hljs-number\">5</span>  (<span class=\"hljs-string\">\"\"\"This is a really really\n6   really long line of code.\"\"\"</span>)\n</code></pre>\n<p>上述两个例子的输出结果是一样的。反斜杠可以让我们将 <code>(\"\"\"This is a really really really long line of code.\"\"\")</code> 和 <code>print</code> 放在不同的行，这种情况一般是不允许的。</p>\n<h3 id=\"35\">3.5　关键字</h3>\n<p>Python 等编程语言中有一些具备特殊意义的字，即<strong>关键字</strong>（keyword）。前面见过的 <code>for</code> 就是一个关键字，用来多次执行代码。本章中还会学习更多的关键字。</p>\n<h3 id=\"36\">3.6　间距</h3>\n<p>我们再来回顾一下那个打印 <code>Hello, World!</code> 100 次的程序：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># http://tinyurl.com/glp9xq6</span>\n2\n3\n4  <strong><span class=\"hljs-keyword\">for</span></strong> i <strong><span class=\"hljs-keyword\">in</span></strong> range(100):\n5      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, World!\"</span>)</code></pre>\n<p>前面已经提到，<code>print</code> 缩进了 4 个空格符。稍后会解释原因，缩进可以告诉 Python 解释器代码块的开始与结束。同时要注意，在本书示例中看到的缩进距离，都是 4 个空格符。如果代码间距不合理，程序将无法执行。</p>\n<p>其他编程语言没有类似的缩进要求；它们使用关键字或花括号来表示代码开始和结束。以下是用 JavaScript 编程语言编写的同一个程序：</p>\n<pre class=\"代码无行号\"><code class=\"hljs coffeescript\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hwa2zae</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  <span class=\"hljs-comment\"># 这是一个 JavaScript 程序</span>\n<span class=\"hljs-number\">05</span>  <span class=\"hljs-comment\"># 不过没法执行</span>\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>\n<span class=\"hljs-number\">08</span>  <strong><span class=\"hljs-keyword\">for</span></strong> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">100</span>; i++) {\n<span class=\"hljs-number\">09</span>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"Hello, World!\"</span>);\n<span class=\"hljs-number\">10</span>  }</code></pre>\n<p>Python 的支持者坚信使用必要的缩进可以让 Python 比其他语言更易读易写。正如上例所示，即使编程语言不强制使用空格，程序员为了让代码更便于阅读，也会倾向于使用空格来分隔代码。</p>\n<h3 id=\"37\">3.7　数据类型</h3>\n<p>Python 将数据划分成不同的类别，即<strong>数据类型</strong>（data type）。在 Python 中，每一个数据值，如 <code>2</code> 或 <code>\"Hello, World!\"</code>，被称为<strong>对象</strong>（object）。本书第二部分会详细介绍数据类型，现在可以把对象看作拥有 3 个属性的数据值：唯一标识（identity）、数据类型和值。对象的唯一标识，指的是其在计算机内存中的地址，该地址不会变化。对象的数据类型是对象所属的数据类别，这决定了对象的属性，也不会变化。对象的值是其表示的数据，例如数字 <code>2</code> 的值即为 2。</p>\n<p><code>\"Hello, World!\"</code> 这个对象的数据类型为<strong>字符串</strong>（str，string 的缩写），值为 <code>\"Hello, World!\"</code>。如果提及数据类型为 <code>str</code> 的对象，可以称其为字符串。字符串是由引号包括的一个或多个字符组成的序列。<strong>字符</strong>（character）是类似 <code>a</code> 或 <code>l</code> 这样的单个符号。可以使用单引号或双引号来表示字符串，但是前后的引号必须保持一致，示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hh5kjwp</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"Hello, World!\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'Hello, World!'</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/heaxhsh</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">'Hello, World!'</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'Hello, World!'</span>\n</code></pre>\n<p>字符串可用来表示文本，且有自己独特的属性。</p>\n<p>之前章节中用来计算的数字，也是对象，但不是字符串。整数（1，2，3，4 等）的数据类型为<strong>整型数据</strong>（<code>int</code>，全称为 integer）。与字符串一样，整型数据也有着独特的属性。例如，可以将两个整数相乘，但是不能相乘两个字符串。</p>\n<p>小数（带小数点的数字）的数据类型为 <code>float</code>。2.1、8.2 和 9.9999 都是数据类型为 <code>float</code> 的对象，我们称之为<strong>浮点数</strong>（floating-point number）。与其他所有数据类型一样，浮点数也有自己独有的属性，且一定程度上与整型数据类似。</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/guoc4gy</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2.2</span> + <span class=\"hljs-number\">2.2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">4.4</span>\n</code></pre>\n<p>数据类型为 <strong>bool</strong> 的对象被称为<strong>布尔值</strong>（boolean），仅有 <code>True</code> 和 <code>False</code> 两个值。</p>\n<pre><code class=\"hljs php\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jyllj2k</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-keyword\">True</span>\n\n&gt;&gt; <span class=\"hljs-keyword\">True</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jzgsxz4</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-keyword\">False</span>\n\n&gt;&gt; <span class=\"hljs-keyword\">False</span>\n</code></pre>\n<p>数据类型为 <strong>NoneType</strong> 的对象，其值永远为 <code>None</code>，用来表示数据缺失。</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/h8oqo5v</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  None\n</code></pre>\n<p>本章后续会介绍如何使用不同的数据类型。</p>\n<h3 id=\"38\">3.8　常量和变量</h3>\n<p>你可以把 Python 当成计算器来算术，做加、减、乘、除、幂等运算。在交互式 shell 中输入以下所有示例：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zs65dp8</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">4</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gs9nwrw</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> - <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">0</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hasegvj</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">4</span> / <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">2.0</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z8ok4q3</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> * <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">4</span>\n</code></pre>\n<p><strong>常量</strong>（constant）是一个永远不会改变的值。上面示例中的每一个数字，都是常量；数字 2 永远表示的值为 2。<strong>变量</strong>（variable）则相反，指的是会改变的值。变量由一个或多个字符组成的名称构成，并使用<strong>赋值符</strong>（assignment operator）等号赋予了这个名称一个值。</p>\n<p>有些编程语言要求程序员编写变量“声明”，明确说明变量的数据类型。例如，在 C 语言中可以这样创建变量：</p>\n<pre><code class=\"hljs cs\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># 不用执行</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>  <span class=\"hljs-keyword\">int</span> a;\n<span class=\"hljs-number\">8</span>  a = <span class=\"hljs-number\">144</span>;\n</code></pre>\n<p>Python 的做法更简单；可以直接用赋值符，将某个值赋给变量，即可创建：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hw64mrr</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  b = <span class=\"hljs-number\">100</span>\n<span class=\"hljs-number\">5</span>  b\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">100</span>\n</code></pre>\n<p>下面介绍如何改变变量的值：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hw97que</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  x = <span class=\"hljs-number\">100</span>\n<span class=\"hljs-number\">5</span>  x\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  x = <span class=\"hljs-number\">200</span>\n<span class=\"hljs-number\">9</span>  x\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">100</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">200</span>\n</code></pre>\n<p>还可以使用两个变量进行算术运算：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z8hv5j5</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  x = <span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">5</span>  y = <span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">6</span>  z = x + y\n<span class=\"hljs-number\">7</span>  z\n<span class=\"hljs-number\">8</span>  a = x - y\n<span class=\"hljs-number\">9</span>  a\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">20</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">0</span>\n</code></pre>\n<p>编程时经常需要<strong>增加</strong>（increment）或<strong>减小</strong>（decrement）某个变量的值。考虑到这个操作非常普遍，Python 提供了特殊语法进行增减变量的值。如需增加变量的值，可将该变量赋予给自身，然后在等号的另一侧将变量与希望增加的值相加：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zvzf786</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  x = <span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">5</span>  x = x + <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">6</span>  x\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">11</span>\n</code></pre>\n<p>如需减小变量的值，可以执行同样的操作，唯一的区别是要减去所希望的值：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gmuzdr9</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  x = <span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">5</span>  x = x - <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">6</span>  x\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">9</span>\n</code></pre>\n<p>这些示例都是完全有效的，不过还有一种更简便的方法，示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zdva5wq</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  x = <span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">5</span>  x += <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">6</span>  x\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">11</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jqw4m5r</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  x = <span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">5</span>  x -= <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">6</span>  x\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">9</span>\n</code></pre>\n<p>变量不仅仅用于保存整型数的值，还可以表示任何数据类型，示例如下：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/jsygqcy</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  hi = <span class=\"hljs-string\">\"Hello, World!\"</span>\n\n<span class=\"hljs-number\">1</span>  # http:<span class=\"hljs-comment\">//tinyurl.com/h47ty49</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  my_float = <span class=\"hljs-number\">2.2</span>\n\n<span class=\"hljs-number\">1</span>  # http:<span class=\"hljs-comment\">//tinyurl.com/hx9xluq</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  my_boolean = True\n</code></pre>\n<p>只要遵守以下 4 条原则，可以随意命名变量。</p>\n<p>1．变量名不能包含空格符。如果想在变量名中使用两个单子，可以在中间加入下划线，如 <code>my_variable = \"A string!\"</code>。</p>\n<p>2．变量名只能使用特定的字母、数字和下划线。</p>\n<p>3．变量名不能以数字开头。虽然可以使用下划线开头，但是这种命名方式有着特殊的意义，后面内容会提到。因此在此之前尽量避免这种情况。</p>\n<p>4．不能使用 Python 关键字作为变量名。可在网页 http://theselftaughtprogrammer.io/keywords 中查看所有关键字。</p>\n<h3 id=\"39\">3.9　语法</h3>\n<p><strong>语法（syntax）</strong>指的是规范一门语言中句子结构，尤其是字词顺序的一整套规则及流程。英语有语法，Python 也有。</p>\n<p>在 Python 中，字符串永远被包括在引号内。这就是 Python 的一个语法示例。下面是一个有效的 Python 程序：</p>\n<pre><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># http://tinyurl.com/j7c2npf</span>\n2\n3\n4  <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n</code></pre>\n<p>程序之所以有效，是因为遵守了 Python 的语法，在定义字符串时用引号包括了文本。如果只是在文本的一侧使用引号，就违背了 Python 的语法，代码将无法运行。</p>\n<h3 id=\"310\">3.10　错误与异常</h3>\n<p>如果在编写 Python 程序时无视其语法，那么在运行时将出现错误。Python 解释器将告知代码无法执行，并给出有关该错误的信息。如果只用一个引号定义字符串，看看会发生什么情况，示例如下：</p>\n<pre><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># http://tinyurl.com/hp2plhs</span>\n2\n3\n4  <span class=\"hljs-comment\"># 该代码有一个错误</span>\n5\n6\n7  my_string = <span class=\"hljs-string\">\"Hello World.\n\n&gt;&gt; File \"</span>/Users/coryalthoff/PycharmProjects/se.py<span class=\"hljs-string\">\", line 1 my_string = 'd ^ SyntaxError: EOL while scanning string literal\n</span></code></pre>\n<p>这段信息表示程序中有一个语法错误。语法错误是致命的，将导致程序无法运行。如果强制执行，Python 会报错。错误信息会告诉你错误位于哪个文件，出现在哪一行，以及属于什么类型。尽管这个错误看上去很吓人，但却是很常见的。</p>\n<p>如果代码中有错误，首先要找到出错的那行代码，找到出错的地方。在本例中，你应该去找代码的第一行，观察一段时间后，会注意到里面只有一个引号。只要在字符串结尾再加上一个引号，即可解决该错误，然后可以重新运行。从这里开始，本书将这样表示错误输出：</p>\n<pre><code class=\"hljs cpp\">&gt;&gt; SyntaxError: EOL <span class=\"hljs-keyword\">while</span> scanning <span class=\"hljs-built_in\">string</span> literal\n</code></pre>\n<p>为了方便阅读，书中只显示错误信息的最后一行。</p>\n<p>Python 有两种错误：语法错误和异常。不属于语法错误的错误，就是<strong>异常</strong>（exception）。如果用 0 作为分母，则会出现“ZeroDivisionError”异常。</p>\n<p>与语法错误不同的是，异常并不一定是致命的（有办法让程序在即使出现异常时仍继续运行，这会在下一章学到）。出现异常时，Python 程序员会说“Python（或程序）报了一个异常”。下面是一个异常的示例：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jxpztcx</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-comment\"># 该代码有一个错误</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>  <span class=\"hljs-number\">10</span> / <span class=\"hljs-number\">0</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-symbol\">ZeroDivisionError:</span> division by zero\n</code></pre>\n<p>如果代码缩进不正确，程序会报“IdentationError”：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gtp6amr</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-comment\"># 该代码有一个错误</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>  y = <span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">8</span>          x =<span class=\"hljs-number\">1</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-symbol\">IndentationError:</span> unexpected indent\n</code></pre>\n<p>在学习编程的过程中，你会经常碰到语法错误和异常（包括书中没有讲到过的），但是出错的情况会逐渐减少。要记住，在碰到语法错误或异常时，先找到出现问题的那行代码，然后仔细检查并找到解决办法（如果没有头绪可以在网上搜索错误或异常提示信息）。</p>\n<h3 id=\"311\">3.11　算术操作符</h3>\n<p>之前，我们用 Python 做了简单的算术计算，如 4/2。这些示例中所使用到的符号被称为<strong>操作符</strong>（operator）。Python 将操作符分为多个类型，目前所见到的是<strong>算术操作符</strong>（arithmetic operator）。下面是 Python 中常用的一些算术操作符，见表 3-1。</p>\n<p>表3-1</p>\n<table>\n<thead>\n<tr>\n<th>操作符</th>\n<th>含　　义</th>\n<th>示例</th>\n<th>运算结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>**</td>\n<td>指数运算</td>\n<td>2 ** 2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>%</td>\n<td>取模运算</td>\n<td>14 % 4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>//</td>\n<td>整除/地板除运算</td>\n<td>13 // 8</td>\n<td>1</td>\n</tr>\n<tr>\n<td>/</td>\n<td>除法运算</td>\n<td>13 / 8</td>\n<td>1.625</td>\n</tr>\n<tr>\n<td>*</td>\n<td>乘法运算</td>\n<td>8 * 2</td>\n<td>16</td>\n</tr>\n<tr>\n<td>−</td>\n<td>减法运算</td>\n<td>7 − 1</td>\n<td>6</td>\n</tr>\n<tr>\n<td>+</td>\n<td>加法运算</td>\n<td>2 + 2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>\n<p>两个数相除时，会有一个商和一个余数。商就是除法运算的结果，余数即剩下的值。取模操作符返回的就是余数。例如，13 除以 5 的结果就是商 2 余 3，示例如下：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/qrdc195</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">13</span> <span class=\"hljs-comment\">// 5</span>\n\n&gt;&gt; <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/zsqwukd</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">13</span> % <span class=\"hljs-number\">5</span>\n\n&gt;&gt; <span class=\"hljs-number\">3</span>\n</code></pre>\n<p>对两个数取模时，如果没有余数（返回 0），则被取模的数字为另一个数字的倍数。如果有余数，则不是其倍数。因此取模运算被用于检验数字的奇偶性，示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jerpe6u</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-comment\"># 偶数</span>\n<span class=\"hljs-number\">5</span>  <span class=\"hljs-number\">12</span> % <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">0</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gkudhcr</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-comment\"># 奇数</span>\n<span class=\"hljs-number\">5</span>  <span class=\"hljs-number\">11</span> % <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">1</span>\n</code></pre>\n<p>有两个操作符用于除法运算。第一个是 // ，返回值为商：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/hh9fqzy</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">14</span> <span class=\"hljs-comment\">// 3</span>\n\n&gt; <span class=\"hljs-number\">4</span>\n</code></pre>\n<p>第二个是 / ，返回值为两个数相除的浮点数结果：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/zlkjjdp</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">14</span> / <span class=\"hljs-number\">3</span>\n\n&gt; <span class=\"hljs-number\">4.666666666666667</span>\n</code></pre>\n<p>还可以使用指数运算符求幂：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h8vuwd4</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>  <span class=\"hljs-number\">2</span> ** <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">4</span>\n</code></pre>\n<p>操作符两侧的值（以上示例中就是数字）被称为<strong>操作数</strong>（operand）。两个操作数和一个操作符共同构成一个<strong>表达式</strong>（expression）。程序运行时，Python 会对每个表达式求值，并返回一个值作为结果。如果在交互式 shell 中输入表达式 2 + 2，则返回结果 4。</p>\n<p><strong>运算顺序</strong>（order of operation），指的是数学计算中对表达式求值的一套规则。可使用 PEMDAS 方法，帮助记忆数学公式的运算顺序：括号（parentheses）、指数（exponents）、乘法（multiplication）、除法（division）、加法（addition）和减法（subtraction）。括号的优先级大于指数符号，后者又优先于乘法和除法，最后才是加法和减法。如果操作符的优先级相同，如 15 / 3 * 2，则按照从左到右的顺序求值。上述表达式中将 15 先除以 3，然后再乘以 2。Python 对数学表达式求值时，遵循的是同一套运算顺序：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hgjyj7o</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">2</span> * <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">6</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hsq7rcz</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  (<span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">2</span>) * <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">8</span>\n</code></pre>\n<p>在第一个示例中，2 * 2 先进行求值，因为乘法的优先级大于加法。</p>\n<p>在第二个示例中，(2 + 2) 先求值，因为 Python 总是先对括号内的表达式求值。</p>\n<h3 id=\"312\">3.12　比较操作符</h3>\n<p><strong>比较操作符</strong>（comparison operator）是 Python 中的另一种操作符。与算术操作符类似，比较操作符可用于表达式任意一侧的操作数；不同的是，带有比较操作符的表达式最后求值的结果不是 <code>True</code> 就是 <code>False</code>。详情见表 3-2。</p>\n<p>表 3-2　　</p>\n<table>\n<thead>\n<tr>\n<th>操作符</th>\n<th>含　　义</th>\n<th>示　　例</th>\n<th>运算结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&gt;</td>\n<td>大于</td>\n<td>100 &gt; 10</td>\n<td>True</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>小于</td>\n<td>100 &lt; 10</td>\n<td>False</td>\n</tr>\n<tr>\n<td>&gt;=</td>\n<td>大于或等于</td>\n<td>2 &gt;= 2</td>\n<td>True</td>\n</tr>\n<tr>\n<td>&lt;=</td>\n<td>小于或等于</td>\n<td>1 &lt;= 4</td>\n<td>True</td>\n</tr>\n<tr>\n<td>==</td>\n<td>等于</td>\n<td>6 == 9</td>\n<td>False</td>\n</tr>\n<tr>\n<td>!=</td>\n<td>不等于</td>\n<td>3 != 2</td>\n<td>True</td>\n</tr>\n</tbody>\n</table>\n<p>在含有 &gt; 操作符的表达式中，如果左侧的数字大于右侧的数字，则表达式的值为 <code>True</code>，否则即为 <code>False</code>：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jm7cxzp</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">100</span> &gt; <span class=\"hljs-number\">10</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True\n</code></pre>\n<p>在含有 &lt; 操作符的表达式中，如果左侧的数字小于右侧的数字，则表达式的值为 <code>True</code>，否则即为 <code>False</code>：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gsdhr8q</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>  <span class=\"hljs-number\">100</span> &lt; <span class=\"hljs-number\">10</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False\n</code></pre>\n<p>在含有 &gt;= 操作符的表达式中，如果左侧的大于或等于右侧的数字，则表达式的值为 <code>True</code>，否则即为 <code>False</code>：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jy2oefs</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>  <span class=\"hljs-number\">2</span> &gt;= <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True\n</code></pre>\n<p>在含有 &lt;= 操作符的表达式中，如果左侧的数字小于或等于右侧的数字，则表达式的值为 <code>True</code>，否则即为 <code>False</code>：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jk599re</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> &gt;= <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True\n</code></pre>\n<p>在含有 == 操作符的表达式中，如果左侧的数字等于右侧的数字，则表达式的值为 <code>True</code>，否则即为 <code>False</code>：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/j2tsz9u</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/j5mr2q2</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False\n</code></pre>\n<p>在含有 != 操作符的表达式中，如果左侧的数字不等于右侧的数字，则表达式的值为 <code>True</code>，否则即为 <code>False</code>：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gsw3zoe</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> != <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z7pffk3</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> != <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False\n</code></pre>\n<p>此前，如果使用 = 将数字赋值给了变量，如 x = 100。可能会将其理解为“x 等于 100”，但这是错误的。前面看到，= 是用来给变量赋值的，而不是检查相等性的操作符。因此 x = 100 应理解为“x 的值为 100”。比较操作符 == 是用于检查两侧是否相等的，因此如果看到 x == 100，含义即为“x 等于 100”。</p>\n<h3 id=\"313\">3.13　逻辑操作符</h3>\n<p><strong>逻辑操作符</strong>（logical operator）也是 Python 中的一类操作符。与比较操作符类似，逻辑操作符的求值结果也是 <code>True</code> 或 <code>False</code>。详情见表 3-3。</p>\n<p>表 3-3　　</p>\n<table>\n<thead>\n<tr>\n<th>操　作　符</th>\n<th>含　　义</th>\n<th>示　　例</th>\n<th>运算结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>and</td>\n<td>与</td>\n<td>True and True</td>\n<td>True</td>\n</tr>\n<tr>\n<td>or</td>\n<td>或</td>\n<td>True or False</td>\n<td>True</td>\n</tr>\n<tr>\n<td>not</td>\n<td>非</td>\n<td>not True</td>\n<td>False</td>\n</tr>\n</tbody>\n</table>\n<p>Python 关键字 and 可以连接两个表达式，如果二者均求值为 <code>True</code>，则返回 <code>True</code>。如果任意一个的值为 <code>False</code>，即返回 <code>False</code>：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zdqghb2</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">1</span> <strong><span class=\"hljs-keyword\">and</span></strong> <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zkp2jzy</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">2</span> <strong><span class=\"hljs-keyword\">and</span></strong> <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/honkev6</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">2</span> <strong><span class=\"hljs-keyword\">and</span></strong> <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">1</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zjrxxrc</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">1</span> <strong><span class=\"hljs-keyword\">and</span></strong> <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">1</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False</code></pre>\n<p>可以在一个语句中多次使用 <code>and</code> 关键字：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zpvk56u</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">1</span> <strong><span class=\"hljs-keyword\">and</span></strong> <span class=\"hljs-number\">10</span> != <span class=\"hljs-number\">2</span> <strong><span class=\"hljs-keyword\">and</span></strong> <span class=\"hljs-number\">2</span> &lt; <span class=\"hljs-number\">10</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<p>关键字 <code>or</code> 可连接两个或多个表达式，如果任意一个表达式的值为 <code>True</code>，即返回 <code>True</code>：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hosuh7c</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">1</span> <strong><span class=\"hljs-keyword\">or</span></strong> <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zj6q8h9</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">1</span> <strong><span class=\"hljs-keyword\">or</span></strong> <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/j8ngufo</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">2</span> <strong><span class=\"hljs-keyword\">or</span></strong> <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">1</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z728zxz</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">1</span> <strong><span class=\"hljs-keyword\">or</span></strong> <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False</code></pre>\n<p>类似地，也可以在一个语句中多次使用 <code>or</code> 关键字：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/ja9mech</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">1</span> <strong><span class=\"hljs-keyword\">or</span></strong> <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">2</span> <strong><span class=\"hljs-keyword\">or</span></strong> <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">3</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<p>该表达式的值为 <code>True</code>，因为 1 == 1 的值为 <code>True</code>，即使表达式其余的部分求值为 <code>False</code>，最终的值仍为 <code>True</code>。</p>\n<p>将关键字 <code>not</code> 放置在表达式的前面，将改变表达式的求值结果，逆转为原本结果的对立值。如果表达式原本的求值结果为 <code>True</code>，则加上 <code>not</code> 之后结果会变为 <code>False</code>：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h45eq6v</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-keyword\">not</span></strong> <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">1</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gsqj6og</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-keyword\">not</span></strong> <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<h3 id=\"314\">3.14　条件语句</h3>\n<p>关键字 <code>if</code>、<code>elif</code> 和 <code>else</code> 用于<strong>条件语句</strong>（conditional statement）。条件语句是一种<strong>控制结构</strong>（control structure）：通过分析变量的值从而做出对应决定的代码块。条件语句是可根据条件执行额外代码的代码。为了方便理解，仔细看以下这个伪代码（pseudocode）示例（伪代码是用于解释说明示例代码的标记方法）：</p>\n<pre><code class=\"hljs php\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># 不要执行</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-keyword\">If</span> (expression) Then\n<span class=\"hljs-number\">5</span>              (code_area1)\n<span class=\"hljs-number\">6</span>  <span class=\"hljs-keyword\">Else</span>\n<span class=\"hljs-number\">7</span>              (code_area2)\n</code></pre>\n<p>上述伪代码显示，可以定义两个条件语句。如果第一个条件语句中定义的表达式为 <code>True</code>，则执行 <code>code_area1</code>；否则执行 <code>code_area2</code>。示例中的第一部分被称为 <code>if</code> 语句，第二部分为 <code>else</code> 语句。两者共同组成一个 <code>if-else</code> 语句：程序员用来表达“如果出现这种情况，则这样做，否则那样做”的方法。下面是 Python 中的 <code>if-else</code> 语句示例：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># http://tinyurl.com/htvy6g3</span>\n2\n3\n4  home = <span class=\"hljs-string\">\"America\"</span>\n5  <strong><span class=\"hljs-keyword\">if</span></strong> home == <span class=\"hljs-string\">\"America\"</span>:\n6      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, America!\"</span>)\n7  <strong><span class=\"hljs-keyword\">else</span></strong>:\n8      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n\n&gt;&gt; Hello, America!</code></pre>\n<p>第 5 行和第 6 行共同组成了 <code>if</code> 语句。一个 <code>if</code> 语句中，包括一行以 <code>if</code> 关键字开头的代码行，<code>if</code> 关键字之后是一个表达式，还有冒号、缩进，以及一行或多行如果表达式为 <code>True</code> 的情况下将执行的代码。第 7 行和第 8 行共同组成了 <code>else</code> 语句。一个 <code>else</code> 语句的开头是 <code>else</code> 关键字，然后是冒号、缩进，以及一行或多行如果 <code>if</code> 语句中表达式为 <code>False</code> 时将执行的代码。</p>\n<p>二者共同组成了一个 <code>if-else</code> 语句。本例的打印输出结果为 <code>Hello, America!</code>，因为 <code>if</code> 语句中的表达式结果为 <code>True</code>。如果将变量 <code>home</code> 的值修改为 <code>Canada</code>，则 <code>if</code> 语句中的表达式结果为 <code>False</code>，将会执行 <code>else</code> 语句中的代码，程序会打印出 <code>Hello, World!</code>。</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># http://tinyurl.com/jytyg5x</span>\n2\n3\n4  home = <span class=\"hljs-string\">\"Canada\"</span>\n5  <strong><span class=\"hljs-keyword\">if</span></strong> home ==<strong> </strong><span class=\"hljs-string\">\"America\"</span>:\n6      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, America!\"</span>)\n7  <strong><span class=\"hljs-keyword\">else</span></strong>:\n8      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n\n&gt;&gt; Hello, World!</code></pre>\n<p>可以单独使用一个 <code>if</code> 语句：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jyg7dd2</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  home = <span class=\"hljs-string\">\"America\"</span>\n<span class=\"hljs-number\">5</span>  <strong><span class=\"hljs-keyword\">if</span></strong> home == <span class=\"hljs-string\">\"America\"</span>:\n<span class=\"hljs-number\">6</span>      print(<span class=\"hljs-string\">\"Hello, America!\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> Hello, America!</code></pre>\n<p>也可以连续使用多个 <code>if</code> 语句：</p>\n<pre class=\"代码无行号\"><code class=\"hljs coffeescript\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z24ckye</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  x = <span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">05</span>  <strong><span class=\"hljs-keyword\">if</span></strong> x == <span class=\"hljs-number\">2</span>:\n<span class=\"hljs-number\">06</span>      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"The number is 2.\"</span>)\n<span class=\"hljs-number\">07</span>  <strong><span class=\"hljs-keyword\">if</span></strong> x % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>:\n<span class=\"hljs-number\">08</span>      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"The number is even.\"</span>)\n<span class=\"hljs-number\">09</span>  <strong><span class=\"hljs-keyword\">if</span></strong> x % <span class=\"hljs-number\">2</span> != <span class=\"hljs-number\">0</span>:\n<span class=\"hljs-number\">10</span>      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"The number is odd.\"</span>)\n\n&gt;&gt; The number <span class=\"hljs-keyword\">is</span> <span class=\"hljs-number\">2.</span>\n&gt;&gt; The number <span class=\"hljs-keyword\">is</span> even.</code></pre>\n<p>每个 <code>if</code> 语句只有在其表达式求值为 <code>True</code> 时，才会执行所有的代码。在本例中，前两个表达式的求值结果为 <code>True</code>，因此各自的代码都执行了，但是第 3 个表达式的结果为 <code>False</code>，所以没有执行。</p>\n<p>如果愿意，甚至还可以在 <code>if</code> 语句中再加入一个 <code>if</code> 语句（通常称之为嵌套）：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zrodgne</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  x = <span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">05</span>  y = <span class=\"hljs-number\">11</span>\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>\n08  <strong><span class=\"hljs-keyword\">if</span></strong> x == <span class=\"hljs-number\">10</span>:\n09      <strong><span class=\"hljs-keyword\">if</span></strong> y == <span class=\"hljs-number\">11</span>:\n<span class=\"hljs-number\">10</span>          print(x + y)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">21</span></code></pre>\n<p>在本例中，只有在两个 <code>if</code> 语句的结果均为 <code>True</code> 时，才会打印 <code>x + y</code>。<code>else</code> 语句无法被单独使用，只能用在 <code>if-else</code> 语句的最后一部分。</p>\n<p>也可以使用 <code>elif</code> 关键字创建 <code>elif</code> 语句。<code>elif</code> 表示另外如果，该语句可无限添加到 <code>if-else</code> 语句中，使其支持更多的决策。</p>\n<p>如果一个 <code>if-else</code> 语句中包含有 <code>elif</code> 语句，则首先判断 <code>if</code> 语句。如果该语句中的表达式为 <code>True</code>，则只执行其中的代码。但是，如果其值为 <code>False</code>，每个之后的 <code>elif</code> 语句都将进行求值。只要有一个 <code>elif</code> 语句中的表达式结果为 <code>True</code>，则执行其中的代码并退出。如果没有任何一个 <code>elif</code> 语句的结果为 <code>True</code>，则执行 <code>else</code> 语句中的代码。下面是一个包含有 <code>elif</code> 语句的 <code>if-else</code> 语句示例：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">01  <span class=\"hljs-comment\"># http://tinyurl.com/jpr265j</span>\n02\n03\n04  home = <span class=\"hljs-string\">\"Thailand\"</span>\n05  <strong><span class=\"hljs-keyword\">if</span></strong> home == <span class=\"hljs-string\">\"Japan\"</span>:\n06      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"Hello, Japan!\"</span>)\n07  <strong><span class=\"hljs-keyword\">elif</span></strong> home == <span class=\"hljs-string\">\"Thailand\"</span>:\n08      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"Hello, Thailand!\"</span>)\n09  <strong><span class=\"hljs-keyword\">elif</span></strong> home == <span class=\"hljs-string\">\"India\"</span>:\n10      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, India!\"</span>)\n11  <strong><span class=\"hljs-keyword\">elif</span></strong> home == <span class=\"hljs-string\">\"China\"</span>:\n12      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, China!\"</span>)\n13  <strong><span class=\"hljs-keyword\">else</span></strong>:\n14      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n\n&gt;&gt; Hello, Thailand!</code></pre>\n<p>下面这个示例中，所有的 <code>elif</code> 语句求值结果均不为 <code>True</code>，最后执行的是 <code>else</code> 语句中的代码。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">01  <span class=\"hljs-comment\"># http://tinyurl.com/zdvuuhs</span>\n02\n03  home = <span class=\"hljs-string\">\"Mars\"</span>\n04  <strong><span class=\"hljs-keyword\">if</span></strong> home == <span class=\"hljs-string\">\"America\"</span>:\n05      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"Hello, America!\"</span>)\n06  <strong><span class=\"hljs-keyword\">elif</span></strong> home == <span class=\"hljs-string\">\"Canada\"</span>:\n07      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"Hello, Canada!\"</span>)\n08  <strong><span class=\"hljs-keyword\">elif</span></strong> home == <span class=\"hljs-string\">\"Thailand\"</span>:\n09      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, Thailand!\"</span>)\n10  <strong><span class=\"hljs-keyword\">elif</span></strong> home == <span class=\"hljs-string\">\"Mexico\"</span>:\n11      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, Mexico!\"</span>)\n12  <strong><span class=\"hljs-keyword\">else</span></strong>:\n13      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n\n&gt;&gt; Hello, World! </code></pre>\n<p>最后，可以连续使用多个 <code>if</code> 语句和 <code>elif</code> 语句：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">01  <span class=\"hljs-comment\"># http://tinyurl.com/hzyxgf4</span>\n02\n03\n04  x = 100\n05  <strong><span class=\"hljs-keyword\">if</span></strong> x == 10:\n06      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"10!\"</span>)\n07  <strong><span class=\"hljs-keyword\">elif</span></strong> x == 20:\n08      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"20!\"</span>)\n09  <strong><span class=\"hljs-keyword\">else</span></strong>:\n10      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"I don't know!\"</span>)\n11\n12\n13  <strong><span class=\"hljs-keyword\">if</span></strong> x == 100:\n14      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"x is 100!\"</span>)\n15\n16\n17  <strong><span class=\"hljs-keyword\">if</span></strong> x % 2 == 0:\n18      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"x is even!\"</span>)\n19<strong>  <span class=\"hljs-keyword\">else</span></strong>:\n20      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"x is odd!\"</span>)\n\n&gt;&gt; I don<span class=\"hljs-string\">'t know!\n&gt;&gt; x is 100!\n&gt;&gt; x is even!</span></code></pre>\n<h3 id=\"315\">3.15　语句</h3>\n<p><strong>语句</strong>（statement）这个术语可用来描述 Python 语言的多种构成部分。可以将一个 Python 语句视作一个命令或计算。本节将详细介绍语句的语法。如果感觉部分内容初次学起来很难懂，也不用太担心，随着练习 Python 的时间变长，你就会慢慢理解。</p>\n<p>Python 中有两类语句：<strong>简单语句</strong>（simple statement）和<strong>复合语句</strong>（compound statement）。简单语句一般就是一行代码，而复合语句通常包括多行代码。下面是一些简单语句的示例：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jrowero</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  print(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> Hello, World!\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h2y549y</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">4</span>\n</code></pre>\n<p><code>if</code> 语句和 <code>if-else</code> 语句，以及本章编写的第一个程序（打印 <code>Hello, World!</code> 100 次）都是复合语句。</p>\n<p>复合语句由一个或多个<strong>从句</strong>（clause）组成。从句包括两行或多行代码：<strong>代码头</strong>（header）及紧随其后的<strong>配套代码</strong>（suite）。代码头指的是从句中包含关键字的那行代码，之后是一个冒号和一行或多行带缩进的代码。缩进之后，是一个或多个配套代码。配套代码就是从句中一行普通的代码。代码头控制配套代码的执行。打印 <code>Hello, World!</code> 100 次的程序，就是由一个复合语句组成。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zfz3eel</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>  <strong><span class=\"hljs-keyword\">for</span></strong> i <strong><span class=\"hljs-keyword\">in</span></strong> range(<span class=\"hljs-number\">100</span>):\n<span class=\"hljs-number\">4</span>      print(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> Hello, World!\n&gt;&gt; Hello, World!\n&gt;&gt; Hello, World!\n…</code></pre>\n<p>程序的第一行是代码头，包括关键字 <code>for</code>，之后是冒号。缩进之后是配套代码 <code>print(\"Hello, World!\")</code>。在上述示例中，代码头通过配套代码打印 <code>Hello, World!</code> 100 次，这是一个循环，将在第 7 章详细介绍。上述代码只有一个从句。</p>\n<p>复合语句可以由多个从句构成，你前面看到的 <code>if-else</code> 语句就是复合语句。<code>if</code> 语句之后如果带有一个 <code>else</code> 语句，就构成了一个由多个从句组成的复合语句。在包含多个从句的复合语句中，代码头从句共同控制代码执行。对于 <code>if-else</code> 语句，当 <code>if</code> 语句的值为 <code>True</code> 时，则执行 <code>if</code> 语句的配套代码，<code>else</code> 语句的配套代码不执行；当 <code>if</code> 语句的值为 <code>False</code> 时，则不执行 <code>if</code> 语句的配套代码，转而执行 <code>else</code> 语句的配套代码。上一节中的最后一个示例包含了 3 个复合语句：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">01  <span class=\"hljs-comment\"># http://tinyurl.com/hpwkdo4</span>\n02\n03\n04  x = 100\n05  <strong><span class=\"hljs-keyword\">if</span></strong> x == 10:\n06      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"10!\"</span>)\n07  <strong><span class=\"hljs-keyword\">elif</span></strong> x == 20:\n08      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"20!\"</span>)\n09  <strong><span class=\"hljs-keyword\">else</span></strong>:\n10      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"I don't know!\"</span>)\n11\n12\n13  <strong><span class=\"hljs-keyword\">if</span></strong> x == 100:\n14      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"x is 100!\"</span>)\n15\n16\n17  <strong><span class=\"hljs-keyword\">if</span></strong> x % 2 == 0:\n18      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"x is even!\"</span>)\n19  <strong><span class=\"hljs-keyword\">else</span></strong>:\n20      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"x is odd!\"</span>)\n\n&gt;&gt; I don<span class=\"hljs-string\">'t know!\n&gt;&gt; x is 100!\n&gt;&gt; x is even!</span></code></pre>\n<p>第一个复合语句中有 3 个从句，第二个里有一个从句，最后一个则有两个从句。</p>\n<p>关于语句还有一点要注意，语句之间是可以有空格的，这不会影响代码的执行。空格有时被用来提高代码的可读性。</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zlgcwoc</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  print(<span class=\"hljs-string\">\"Michael\"</span>)\n<span class=\"hljs-number\">05</span>\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>\n08\n09\n<span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">11</span>  print(<span class=\"hljs-string\">\"Jordan\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> Michael\n<span class=\"hljs-meta\">&gt;&gt;</span> Jordan\n</code></pre>\n<h3 id=\"316\">3.16　术语表</h3>\n<p><strong>注释</strong>：用英文或其他自然语言写的一行（或一部分）代码，行首均有一个特殊标志告知编程语言忽略这行代码。</p>\n<p><strong>关键字</strong>：编程语言中具有特殊意义的词。可在 http://theselftaughtprogrammer.io/keywords 网页中查看所有 Python 的关键字。</p>\n<p><strong>数据类型</strong>：数据所属的类别。</p>\n<p><strong>对象</strong>：Python 中具有 3 个属性的数据值——唯一标识、数据类型和值。</p>\n<p><strong>Str</strong>：字符串的数据类型。</p>\n<p><strong>字符</strong>：a 或 l 等单个符号。</p>\n<p><strong>Int</strong>：整数的数据类型。</p>\n<p><strong>整型数据</strong>：数据类型为 int 的对象，其值为一个整数。</p>\n<p><strong>Float</strong>：小数的数据类型。</p>\n<p><strong>浮点数</strong>：数据类型为 <code>float</code> 的对象，其值为一个小数。</p>\n<p><strong>Bool</strong>：布尔对象的数据类型。</p>\n<p><strong>布尔值</strong>：数据类型为 <code>bool</code> 的对象，其值为 <code>True</code> 或 <code>False</code>。</p>\n<p><strong>NoneType</strong>：<code>None</code> 对象的数据类型。</p>\n<p><strong>None</strong>：数据类型为 <code>NoneType</code> 的对象，其值永远为 <code>None</code>。</p>\n<p><strong>常量</strong>：不会改变的值。</p>\n<p><strong>变量</strong>：使用赋值操作符赋予了一个值的名称。</p>\n<p><strong>赋值操作符</strong>：Python 中的 <code>=</code> 符号。</p>\n<p><strong>增加</strong>：增加一个变量的值。</p>\n<p><strong>减少</strong>：减少一个变量的值。</p>\n<p><strong>语法</strong>：规范一门语言中句子结构，尤其是字词顺序的一整套规则及流程。</p>\n<p><strong>语法错误</strong>：违反编程语言的语法，所导致的致命编程错误。</p>\n<p><strong>异常</strong>：非致命的编程错误。</p>\n<p><strong>操作符</strong>：在表达式中与操作符一起使用的符号。</p>\n<p><strong>算术操作符</strong>：数学表达式中使用的一类操作符。</p>\n<p><strong>操作数</strong>：操作符两侧的值。</p>\n<p><strong>表达式</strong>：操作符及两个操作数构成的代码。</p>\n<p><strong>运算顺序</strong>：数学计算中用来对表达式求值的一组规则。</p>\n<p><strong>比较操作符</strong>：表达式中用到的一类操作符，求值结果为 <code>True</code> 或 <code>False</code>。</p>\n<p><strong>逻辑操作符</strong>：对两个表达式求值的一类操作符，求值结果为 <code>True</code> 或 <code>False</code>。</p>\n<p><strong>条件语句</strong>：根据条件执行不同代码的代码。</p>\n<p><strong>控制结构</strong>：通过分析变量的值，来决定代码如何执行的代码块。</p>\n<p><strong>伪代码</strong>：用来演示逻辑的标记方法，与代码类似。</p>\n<p><strong>if-else 语句</strong>：程序员用来表达“如果出现这种情况，则这样做，否则那样做”的方法。</p>\n<p><strong>if 语句</strong>：<code>if-else</code> 语句的第一部分。</p>\n<p><strong>else 语句</strong>：<code>if-else</code> 语句的第二部分。</p>\n<p><strong>语句</strong>：一个命令或计算。</p>\n<p><strong>简单语句</strong>：可用一行代码表述的语句。</p>\n<p><strong>复合语句</strong>：通常包括多行代码的语句。</p>\n<p><strong>从句</strong>：复合语句的组成部分；一个从句由两行或多行代码构成，包括代码头及配套代码。</p>\n<p><strong>代码头</strong>：从句中包含关键字的那行代码，之后是一个冒号和一行或多行带缩进的代码。</p>\n<p><strong>配套代码</strong>：从句中由代码头控制的代码。</p>\n<h3 id=\"317\">3.17　挑战练习</h3>\n<p>1．请打印 3 个不同的字符串。</p>\n<p>2．编写程序：如果变量的值小于 10，打印一条消息；如果大于或等于 10，则打印不同的消息。</p>\n<p>3．编写程序：如果变量的值小于或等于 10，打印一条消息；如果大于 10 且小于或等于 25，则打印一条不同的消息；如果大于 25，则打印另一条不同的消息。</p>\n<p>4．编写一个将两个变量相除，并打印余数的程序。</p>\n<p>5．编写一个将两个变量相除，并打印商的程序。</p>\n<p>6．编写程序：为变量 age 赋予一个整数值，根据不同的数值打印不同的字符串说明。</p>\n<p>答案可从异步社区（www.epubit.com）本书详情页的配套资源中下载。</p></div></article>\n</body>\n</html>","slug":"Python无师自通/3_python_coding_introduction","published":1,"date":"2019-05-30T06:05:02.909Z","updated":"2019-05-30T06:05:02.909Z","_id":"cjwd49mca0006sv726spht06p","comments":1,"layout":"post","photos":[],"link":"","content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head><meta name=\"generator\" content=\"Hexo 3.8.0\">\n    <meta charset=\"UTF-8\">\n    <title>编程概论</title>\n</head>\n<body>\n<article id=\"articleDiv\"><div class=\"mazi-article-content dont-break-out\"><p></p><div class=\"toc\">\n<ul>\n<li><ul>\n<li><ul>\n<li><a href=\"#31\">3.1　示例</a></li>\n<li><a href=\"#32\">3.2　注释</a></li>\n<li><a href=\"#33\">3.3　打印</a></li>\n<li><a href=\"#34\">3.4　代码行</a></li>\n<li><a href=\"#35\">3.5　关键字</a></li>\n<li><a href=\"#36\">3.6　间距</a></li>\n<li><a href=\"#37\">3.7　数据类型</a></li>\n<li><a href=\"#38\">3.8　常量和变量</a></li>\n<li><a href=\"#39\">3.9　语法</a></li>\n<li><a href=\"#310\">3.10　错误与异常</a></li>\n<li><a href=\"#311\">3.11　算术操作符</a></li>\n<li><a href=\"#312\">3.12　比较操作符</a></li>\n<li><a href=\"#313\">3.13　逻辑操作符</a></li>\n<li><a href=\"#314\">3.14　条件语句</a></li>\n<li><a href=\"#315\">3.15　语句</a></li>\n<li><a href=\"#316\">3.16　术语表</a></li>\n<li><a href=\"#317\">3.17　挑战练习</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>\n<p></p>\n<blockquote>\n  <p><span style=\"font-family: Times New Roman,楷体_GB2312\">“这是我能想到的，唯一可以让我既当工程师又做艺术家的工作。它要求具备极其缜密的技术思维，因为你必须要完成精确的思考，这点我很喜欢。另一方面，它又鼓励你肆意挥洒自己的创意，只有你想不到没有你做不到的。”</span></p>\n  <p><span style=\"font-family: Times New Roman,楷体_GB2312\">——安迪 · 赫兹菲尔德（Andy Hertzfeld）</span></p>\n</blockquote>\n<p>我们的第一个程序打印出了 <code>Hello, World!</code>。接下来打印 100 次。在交互式 shell 中输入如下代码（print 需要缩进 4 个空格符）：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># http://tinyurl.com/h79ob7s</span>\n2\n3\n4  <strong><span class=\"hljs-keyword\">for</span></strong> i <strong><span class=\"hljs-keyword\">in</span></strong> range(100):\n5      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, World!\"</span>)</code></pre>\n<p>交互式 shell 应该会打印 <code>Hello, World!</code> 100 次。即使通常没有这样做的需要，但可以从这个例子中看出编程的强大。你能想到任何其他可以如此简单地做 100 遍的事情吗？我想不到。这就是编程的厉害之处。</p>\n<h3 id=\"31\">3.1　示例</h3>\n<p>从现在开始，代码示例会以如下形式出现：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h4qntgk</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-keyword\">for</span></strong> i <strong><span class=\"hljs-keyword\">in</span></strong> range(<span class=\"hljs-number\">100</span>):\n<span class=\"hljs-number\">5</span>      print(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> Hello, World!\n&gt;&gt; Hello, World!\n&gt;&gt; Hello, World!\n…</code></pre>\n<p>打开 http://tinyurl.com/h4qntqk 这个链接，就可以看到包含有示例代码的网页，这样如果无法让代码运行，你可以轻松地复制代码，并粘贴到 IDLE 的文本编辑器中。<code>&gt;&gt;</code> 的后面则是交互式 shell 的输出。全书的每一个编程示例中都会看到 <code>&gt;&gt;</code>，这代表了程序的输出结果（会在交互式 shell 中打印出来）。“...”表示“等等”。</p>\n<p>如果示例后没有 <code>&gt;&gt;</code>，就表示该程序没有输出，或者只是在解释概念，输出并不太重要。</p>\n<p>字体为 Courier New 的部分，都是某种形式的代码、代码输出或编程术语。例如，上个例子中提到的词 <code>for</code>，它就会是 Courier New 字体。</p>\n<p>Courier New 是一个固定宽度（不等比）的字体，常用来显示编程文本。每个字符的宽度都一致，因此代码对齐后可以很容易地发现缩进和其他特征。</p>\n<p>可以用交互式 shell 或 <code>.py</code> 文件来运行示例代码。但是要注意的是，正如之前提到的，交互式 shell 中的输出与文件运行的输出可能略有不同，因此如果没得到完全一致的输出，原因就在于此。如果有示例要打印输出，但是却没有 <code>print</code> 字样，表示应该直接在交互式 shell 中输入代码。如果示例中有 <code>print</code> 字样，则说明应该从 <code>.py</code> 文件运行代码。</p>\n<h3 id=\"32\">3.2　注释</h3>\n<p><strong>注释</strong>（comment）是用英文或其他自然语言写的一行（或一部分）代码，行首均有一个特殊标志告知编程语言忽略这行代码。Python 用井号（#）来创建注释。</p>\n<p>注释的目的是解释代码的功能。程序员通过注释，使得代码更易于阅读。在注释中，可以写下任何内容，只要保持为一行即可，示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hut6nwu</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>  <span class=\"hljs-comment\"># 这是一行注释</span>\n<span class=\"hljs-number\">4</span>  print(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> Hello, World!\n</code></pre>\n<p>只有在代码中执行特别操作，或者代码不清晰易懂的情况下，才需要写注释。尽量少写注释——不要每行代码都写注释，有特殊情况才需要。下面是一个注释多余的例子：</p>\n<pre><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># http://tinyurl.com/jpzlwqq</span>\n2\n3\n4  <span class=\"hljs-comment\"># 打印 Hello, World!</span>\n5  <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n</code></pre>\n<p>注释之所以多余，是因为这行代码的功能已经非常明确。下面是一个注释合理的例子：</p>\n<pre class=\"代码无行号\"><code class=\"hljs cpp\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/z52c8z8</span></span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  <strong><span class=\"hljs-keyword\">import</span></strong> math\n<span class=\"hljs-number\">05</span>\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>  # 对角线的长度\n<span class=\"hljs-number\">08</span>  l = <span class=\"hljs-number\">4</span>\n<span class=\"hljs-number\">09</span>  w = <span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">10</span>  d = math.<span class=\"hljs-built_in\">sqrt</span>(l**<span class=\"hljs-number\">2</span>+ w**<span class=\"hljs-number\">2</span>)</code></pre>\n<p>即使你完全理解了这段代码，也可能并不知道如何计算长方形的对角线长度，因此这里的注释就是有用的。</p>\n<h3 id=\"33\">3.3　打印</h3>\n<p>程序不止可以打印 <code>Hello, World!</code>，它可以打印任何内容，只要记得加上双引号。</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zh5g2a3</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  print(<span class=\"hljs-string\">\"Python\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> Python\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hhwqva2</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  print(<span class=\"hljs-string\">\"Hola!\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> Hola!\n</code></pre>\n<h3 id=\"34\">3.4　代码行</h3>\n<p>Python 程序是由一行一行的代码组成的。看下面这个程序：</p>\n<pre><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># http://tinyurl.com/jq2w5ro</span>\n2\n3\n4  <span class=\"hljs-comment\"># 第一行</span>\n5  <span class=\"hljs-comment\"># 第二行</span>\n6  <span class=\"hljs-comment\"># 第三行</span>\n</code></pre>\n<p>程序共有 3 行代码。我们通常用代码所在的行数区别代码。在 IDLE 中，可以打开“编辑”菜单，选择“前往行”按钮，即可跳转至程序的指定行。在交互式 shell 中，一次只能输入一行代码，无法复制粘贴多行代码。</p>\n<p>有时一段代码比较长，超过了一行，可以用三引号、圆括号、方括号或者大括号扩展至新一行，示例如下：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zcdx3yo</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  print(<span class=\"hljs-string\">\"\"\"This is a really really\n5        really really long line of\n6        code.\"\"\"</span>)\n</code></pre>\n<p>另外，还可以使用反斜杠 \\ 对代码进行换行：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hjcf2sa</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-keyword\">print</span>\\\n<span class=\"hljs-number\">5</span>  (<span class=\"hljs-string\">\"\"\"This is a really really\n6   really long line of code.\"\"\"</span>)\n</code></pre>\n<p>上述两个例子的输出结果是一样的。反斜杠可以让我们将 <code>(\"\"\"This is a really really really long line of code.\"\"\")</code> 和 <code>print</code> 放在不同的行，这种情况一般是不允许的。</p>\n<h3 id=\"35\">3.5　关键字</h3>\n<p>Python 等编程语言中有一些具备特殊意义的字，即<strong>关键字</strong>（keyword）。前面见过的 <code>for</code> 就是一个关键字，用来多次执行代码。本章中还会学习更多的关键字。</p>\n<h3 id=\"36\">3.6　间距</h3>\n<p>我们再来回顾一下那个打印 <code>Hello, World!</code> 100 次的程序：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># http://tinyurl.com/glp9xq6</span>\n2\n3\n4  <strong><span class=\"hljs-keyword\">for</span></strong> i <strong><span class=\"hljs-keyword\">in</span></strong> range(100):\n5      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, World!\"</span>)</code></pre>\n<p>前面已经提到，<code>print</code> 缩进了 4 个空格符。稍后会解释原因，缩进可以告诉 Python 解释器代码块的开始与结束。同时要注意，在本书示例中看到的缩进距离，都是 4 个空格符。如果代码间距不合理，程序将无法执行。</p>\n<p>其他编程语言没有类似的缩进要求；它们使用关键字或花括号来表示代码开始和结束。以下是用 JavaScript 编程语言编写的同一个程序：</p>\n<pre class=\"代码无行号\"><code class=\"hljs coffeescript\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hwa2zae</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  <span class=\"hljs-comment\"># 这是一个 JavaScript 程序</span>\n<span class=\"hljs-number\">05</span>  <span class=\"hljs-comment\"># 不过没法执行</span>\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>\n<span class=\"hljs-number\">08</span>  <strong><span class=\"hljs-keyword\">for</span></strong> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">100</span>; i++) {\n<span class=\"hljs-number\">09</span>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"Hello, World!\"</span>);\n<span class=\"hljs-number\">10</span>  }</code></pre>\n<p>Python 的支持者坚信使用必要的缩进可以让 Python 比其他语言更易读易写。正如上例所示，即使编程语言不强制使用空格，程序员为了让代码更便于阅读，也会倾向于使用空格来分隔代码。</p>\n<h3 id=\"37\">3.7　数据类型</h3>\n<p>Python 将数据划分成不同的类别，即<strong>数据类型</strong>（data type）。在 Python 中，每一个数据值，如 <code>2</code> 或 <code>\"Hello, World!\"</code>，被称为<strong>对象</strong>（object）。本书第二部分会详细介绍数据类型，现在可以把对象看作拥有 3 个属性的数据值：唯一标识（identity）、数据类型和值。对象的唯一标识，指的是其在计算机内存中的地址，该地址不会变化。对象的数据类型是对象所属的数据类别，这决定了对象的属性，也不会变化。对象的值是其表示的数据，例如数字 <code>2</code> 的值即为 2。</p>\n<p><code>\"Hello, World!\"</code> 这个对象的数据类型为<strong>字符串</strong>（str，string 的缩写），值为 <code>\"Hello, World!\"</code>。如果提及数据类型为 <code>str</code> 的对象，可以称其为字符串。字符串是由引号包括的一个或多个字符组成的序列。<strong>字符</strong>（character）是类似 <code>a</code> 或 <code>l</code> 这样的单个符号。可以使用单引号或双引号来表示字符串，但是前后的引号必须保持一致，示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hh5kjwp</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"Hello, World!\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'Hello, World!'</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/heaxhsh</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">'Hello, World!'</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'Hello, World!'</span>\n</code></pre>\n<p>字符串可用来表示文本，且有自己独特的属性。</p>\n<p>之前章节中用来计算的数字，也是对象，但不是字符串。整数（1，2，3，4 等）的数据类型为<strong>整型数据</strong>（<code>int</code>，全称为 integer）。与字符串一样，整型数据也有着独特的属性。例如，可以将两个整数相乘，但是不能相乘两个字符串。</p>\n<p>小数（带小数点的数字）的数据类型为 <code>float</code>。2.1、8.2 和 9.9999 都是数据类型为 <code>float</code> 的对象，我们称之为<strong>浮点数</strong>（floating-point number）。与其他所有数据类型一样，浮点数也有自己独有的属性，且一定程度上与整型数据类似。</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/guoc4gy</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2.2</span> + <span class=\"hljs-number\">2.2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">4.4</span>\n</code></pre>\n<p>数据类型为 <strong>bool</strong> 的对象被称为<strong>布尔值</strong>（boolean），仅有 <code>True</code> 和 <code>False</code> 两个值。</p>\n<pre><code class=\"hljs php\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jyllj2k</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-keyword\">True</span>\n\n&gt;&gt; <span class=\"hljs-keyword\">True</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jzgsxz4</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-keyword\">False</span>\n\n&gt;&gt; <span class=\"hljs-keyword\">False</span>\n</code></pre>\n<p>数据类型为 <strong>NoneType</strong> 的对象，其值永远为 <code>None</code>，用来表示数据缺失。</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/h8oqo5v</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  None\n</code></pre>\n<p>本章后续会介绍如何使用不同的数据类型。</p>\n<h3 id=\"38\">3.8　常量和变量</h3>\n<p>你可以把 Python 当成计算器来算术，做加、减、乘、除、幂等运算。在交互式 shell 中输入以下所有示例：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zs65dp8</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">4</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gs9nwrw</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> - <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">0</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hasegvj</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">4</span> / <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">2.0</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z8ok4q3</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> * <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">4</span>\n</code></pre>\n<p><strong>常量</strong>（constant）是一个永远不会改变的值。上面示例中的每一个数字，都是常量；数字 2 永远表示的值为 2。<strong>变量</strong>（variable）则相反，指的是会改变的值。变量由一个或多个字符组成的名称构成，并使用<strong>赋值符</strong>（assignment operator）等号赋予了这个名称一个值。</p>\n<p>有些编程语言要求程序员编写变量“声明”，明确说明变量的数据类型。例如，在 C 语言中可以这样创建变量：</p>\n<pre><code class=\"hljs cs\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># 不用执行</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>  <span class=\"hljs-keyword\">int</span> a;\n<span class=\"hljs-number\">8</span>  a = <span class=\"hljs-number\">144</span>;\n</code></pre>\n<p>Python 的做法更简单；可以直接用赋值符，将某个值赋给变量，即可创建：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hw64mrr</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  b = <span class=\"hljs-number\">100</span>\n<span class=\"hljs-number\">5</span>  b\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">100</span>\n</code></pre>\n<p>下面介绍如何改变变量的值：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hw97que</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  x = <span class=\"hljs-number\">100</span>\n<span class=\"hljs-number\">5</span>  x\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  x = <span class=\"hljs-number\">200</span>\n<span class=\"hljs-number\">9</span>  x\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">100</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">200</span>\n</code></pre>\n<p>还可以使用两个变量进行算术运算：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z8hv5j5</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  x = <span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">5</span>  y = <span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">6</span>  z = x + y\n<span class=\"hljs-number\">7</span>  z\n<span class=\"hljs-number\">8</span>  a = x - y\n<span class=\"hljs-number\">9</span>  a\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">20</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">0</span>\n</code></pre>\n<p>编程时经常需要<strong>增加</strong>（increment）或<strong>减小</strong>（decrement）某个变量的值。考虑到这个操作非常普遍，Python 提供了特殊语法进行增减变量的值。如需增加变量的值，可将该变量赋予给自身，然后在等号的另一侧将变量与希望增加的值相加：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zvzf786</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  x = <span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">5</span>  x = x + <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">6</span>  x\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">11</span>\n</code></pre>\n<p>如需减小变量的值，可以执行同样的操作，唯一的区别是要减去所希望的值：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gmuzdr9</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  x = <span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">5</span>  x = x - <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">6</span>  x\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">9</span>\n</code></pre>\n<p>这些示例都是完全有效的，不过还有一种更简便的方法，示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zdva5wq</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  x = <span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">5</span>  x += <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">6</span>  x\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">11</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jqw4m5r</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  x = <span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">5</span>  x -= <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">6</span>  x\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">9</span>\n</code></pre>\n<p>变量不仅仅用于保存整型数的值，还可以表示任何数据类型，示例如下：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/jsygqcy</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  hi = <span class=\"hljs-string\">\"Hello, World!\"</span>\n\n<span class=\"hljs-number\">1</span>  # http:<span class=\"hljs-comment\">//tinyurl.com/h47ty49</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  my_float = <span class=\"hljs-number\">2.2</span>\n\n<span class=\"hljs-number\">1</span>  # http:<span class=\"hljs-comment\">//tinyurl.com/hx9xluq</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  my_boolean = True\n</code></pre>\n<p>只要遵守以下 4 条原则，可以随意命名变量。</p>\n<p>1．变量名不能包含空格符。如果想在变量名中使用两个单子，可以在中间加入下划线，如 <code>my_variable = \"A string!\"</code>。</p>\n<p>2．变量名只能使用特定的字母、数字和下划线。</p>\n<p>3．变量名不能以数字开头。虽然可以使用下划线开头，但是这种命名方式有着特殊的意义，后面内容会提到。因此在此之前尽量避免这种情况。</p>\n<p>4．不能使用 Python 关键字作为变量名。可在网页 http://theselftaughtprogrammer.io/keywords 中查看所有关键字。</p>\n<h3 id=\"39\">3.9　语法</h3>\n<p><strong>语法（syntax）</strong>指的是规范一门语言中句子结构，尤其是字词顺序的一整套规则及流程。英语有语法，Python 也有。</p>\n<p>在 Python 中，字符串永远被包括在引号内。这就是 Python 的一个语法示例。下面是一个有效的 Python 程序：</p>\n<pre><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># http://tinyurl.com/j7c2npf</span>\n2\n3\n4  <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n</code></pre>\n<p>程序之所以有效，是因为遵守了 Python 的语法，在定义字符串时用引号包括了文本。如果只是在文本的一侧使用引号，就违背了 Python 的语法，代码将无法运行。</p>\n<h3 id=\"310\">3.10　错误与异常</h3>\n<p>如果在编写 Python 程序时无视其语法，那么在运行时将出现错误。Python 解释器将告知代码无法执行，并给出有关该错误的信息。如果只用一个引号定义字符串，看看会发生什么情况，示例如下：</p>\n<pre><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># http://tinyurl.com/hp2plhs</span>\n2\n3\n4  <span class=\"hljs-comment\"># 该代码有一个错误</span>\n5\n6\n7  my_string = <span class=\"hljs-string\">\"Hello World.\n\n&gt;&gt; File \"</span>/Users/coryalthoff/PycharmProjects/se.py<span class=\"hljs-string\">\", line 1 my_string = 'd ^ SyntaxError: EOL while scanning string literal\n</span></code></pre>\n<p>这段信息表示程序中有一个语法错误。语法错误是致命的，将导致程序无法运行。如果强制执行，Python 会报错。错误信息会告诉你错误位于哪个文件，出现在哪一行，以及属于什么类型。尽管这个错误看上去很吓人，但却是很常见的。</p>\n<p>如果代码中有错误，首先要找到出错的那行代码，找到出错的地方。在本例中，你应该去找代码的第一行，观察一段时间后，会注意到里面只有一个引号。只要在字符串结尾再加上一个引号，即可解决该错误，然后可以重新运行。从这里开始，本书将这样表示错误输出：</p>\n<pre><code class=\"hljs cpp\">&gt;&gt; SyntaxError: EOL <span class=\"hljs-keyword\">while</span> scanning <span class=\"hljs-built_in\">string</span> literal\n</code></pre>\n<p>为了方便阅读，书中只显示错误信息的最后一行。</p>\n<p>Python 有两种错误：语法错误和异常。不属于语法错误的错误，就是<strong>异常</strong>（exception）。如果用 0 作为分母，则会出现“ZeroDivisionError”异常。</p>\n<p>与语法错误不同的是，异常并不一定是致命的（有办法让程序在即使出现异常时仍继续运行，这会在下一章学到）。出现异常时，Python 程序员会说“Python（或程序）报了一个异常”。下面是一个异常的示例：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jxpztcx</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-comment\"># 该代码有一个错误</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>  <span class=\"hljs-number\">10</span> / <span class=\"hljs-number\">0</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-symbol\">ZeroDivisionError:</span> division by zero\n</code></pre>\n<p>如果代码缩进不正确，程序会报“IdentationError”：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gtp6amr</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-comment\"># 该代码有一个错误</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>  y = <span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">8</span>          x =<span class=\"hljs-number\">1</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-symbol\">IndentationError:</span> unexpected indent\n</code></pre>\n<p>在学习编程的过程中，你会经常碰到语法错误和异常（包括书中没有讲到过的），但是出错的情况会逐渐减少。要记住，在碰到语法错误或异常时，先找到出现问题的那行代码，然后仔细检查并找到解决办法（如果没有头绪可以在网上搜索错误或异常提示信息）。</p>\n<h3 id=\"311\">3.11　算术操作符</h3>\n<p>之前，我们用 Python 做了简单的算术计算，如 4/2。这些示例中所使用到的符号被称为<strong>操作符</strong>（operator）。Python 将操作符分为多个类型，目前所见到的是<strong>算术操作符</strong>（arithmetic operator）。下面是 Python 中常用的一些算术操作符，见表 3-1。</p>\n<p>表3-1</p>\n<table>\n<thead>\n<tr>\n<th>操作符</th>\n<th>含　　义</th>\n<th>示例</th>\n<th>运算结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>**</td>\n<td>指数运算</td>\n<td>2 ** 2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>%</td>\n<td>取模运算</td>\n<td>14 % 4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>//</td>\n<td>整除/地板除运算</td>\n<td>13 // 8</td>\n<td>1</td>\n</tr>\n<tr>\n<td>/</td>\n<td>除法运算</td>\n<td>13 / 8</td>\n<td>1.625</td>\n</tr>\n<tr>\n<td>*</td>\n<td>乘法运算</td>\n<td>8 * 2</td>\n<td>16</td>\n</tr>\n<tr>\n<td>−</td>\n<td>减法运算</td>\n<td>7 − 1</td>\n<td>6</td>\n</tr>\n<tr>\n<td>+</td>\n<td>加法运算</td>\n<td>2 + 2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>\n<p>两个数相除时，会有一个商和一个余数。商就是除法运算的结果，余数即剩下的值。取模操作符返回的就是余数。例如，13 除以 5 的结果就是商 2 余 3，示例如下：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/qrdc195</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">13</span> <span class=\"hljs-comment\">// 5</span>\n\n&gt;&gt; <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/zsqwukd</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">13</span> % <span class=\"hljs-number\">5</span>\n\n&gt;&gt; <span class=\"hljs-number\">3</span>\n</code></pre>\n<p>对两个数取模时，如果没有余数（返回 0），则被取模的数字为另一个数字的倍数。如果有余数，则不是其倍数。因此取模运算被用于检验数字的奇偶性，示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jerpe6u</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-comment\"># 偶数</span>\n<span class=\"hljs-number\">5</span>  <span class=\"hljs-number\">12</span> % <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">0</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gkudhcr</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-comment\"># 奇数</span>\n<span class=\"hljs-number\">5</span>  <span class=\"hljs-number\">11</span> % <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">1</span>\n</code></pre>\n<p>有两个操作符用于除法运算。第一个是 // ，返回值为商：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/hh9fqzy</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">14</span> <span class=\"hljs-comment\">// 3</span>\n\n&gt; <span class=\"hljs-number\">4</span>\n</code></pre>\n<p>第二个是 / ，返回值为两个数相除的浮点数结果：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/zlkjjdp</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">14</span> / <span class=\"hljs-number\">3</span>\n\n&gt; <span class=\"hljs-number\">4.666666666666667</span>\n</code></pre>\n<p>还可以使用指数运算符求幂：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h8vuwd4</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>  <span class=\"hljs-number\">2</span> ** <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">4</span>\n</code></pre>\n<p>操作符两侧的值（以上示例中就是数字）被称为<strong>操作数</strong>（operand）。两个操作数和一个操作符共同构成一个<strong>表达式</strong>（expression）。程序运行时，Python 会对每个表达式求值，并返回一个值作为结果。如果在交互式 shell 中输入表达式 2 + 2，则返回结果 4。</p>\n<p><strong>运算顺序</strong>（order of operation），指的是数学计算中对表达式求值的一套规则。可使用 PEMDAS 方法，帮助记忆数学公式的运算顺序：括号（parentheses）、指数（exponents）、乘法（multiplication）、除法（division）、加法（addition）和减法（subtraction）。括号的优先级大于指数符号，后者又优先于乘法和除法，最后才是加法和减法。如果操作符的优先级相同，如 15 / 3 * 2，则按照从左到右的顺序求值。上述表达式中将 15 先除以 3，然后再乘以 2。Python 对数学表达式求值时，遵循的是同一套运算顺序：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hgjyj7o</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">2</span> * <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">6</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hsq7rcz</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  (<span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">2</span>) * <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">8</span>\n</code></pre>\n<p>在第一个示例中，2 * 2 先进行求值，因为乘法的优先级大于加法。</p>\n<p>在第二个示例中，(2 + 2) 先求值，因为 Python 总是先对括号内的表达式求值。</p>\n<h3 id=\"312\">3.12　比较操作符</h3>\n<p><strong>比较操作符</strong>（comparison operator）是 Python 中的另一种操作符。与算术操作符类似，比较操作符可用于表达式任意一侧的操作数；不同的是，带有比较操作符的表达式最后求值的结果不是 <code>True</code> 就是 <code>False</code>。详情见表 3-2。</p>\n<p>表 3-2　　</p>\n<table>\n<thead>\n<tr>\n<th>操作符</th>\n<th>含　　义</th>\n<th>示　　例</th>\n<th>运算结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&gt;</td>\n<td>大于</td>\n<td>100 &gt; 10</td>\n<td>True</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>小于</td>\n<td>100 &lt; 10</td>\n<td>False</td>\n</tr>\n<tr>\n<td>&gt;=</td>\n<td>大于或等于</td>\n<td>2 &gt;= 2</td>\n<td>True</td>\n</tr>\n<tr>\n<td>&lt;=</td>\n<td>小于或等于</td>\n<td>1 &lt;= 4</td>\n<td>True</td>\n</tr>\n<tr>\n<td>==</td>\n<td>等于</td>\n<td>6 == 9</td>\n<td>False</td>\n</tr>\n<tr>\n<td>!=</td>\n<td>不等于</td>\n<td>3 != 2</td>\n<td>True</td>\n</tr>\n</tbody>\n</table>\n<p>在含有 &gt; 操作符的表达式中，如果左侧的数字大于右侧的数字，则表达式的值为 <code>True</code>，否则即为 <code>False</code>：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jm7cxzp</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">100</span> &gt; <span class=\"hljs-number\">10</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True\n</code></pre>\n<p>在含有 &lt; 操作符的表达式中，如果左侧的数字小于右侧的数字，则表达式的值为 <code>True</code>，否则即为 <code>False</code>：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gsdhr8q</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>  <span class=\"hljs-number\">100</span> &lt; <span class=\"hljs-number\">10</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False\n</code></pre>\n<p>在含有 &gt;= 操作符的表达式中，如果左侧的大于或等于右侧的数字，则表达式的值为 <code>True</code>，否则即为 <code>False</code>：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jy2oefs</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>  <span class=\"hljs-number\">2</span> &gt;= <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True\n</code></pre>\n<p>在含有 &lt;= 操作符的表达式中，如果左侧的数字小于或等于右侧的数字，则表达式的值为 <code>True</code>，否则即为 <code>False</code>：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jk599re</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> &gt;= <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True\n</code></pre>\n<p>在含有 == 操作符的表达式中，如果左侧的数字等于右侧的数字，则表达式的值为 <code>True</code>，否则即为 <code>False</code>：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/j2tsz9u</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/j5mr2q2</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False\n</code></pre>\n<p>在含有 != 操作符的表达式中，如果左侧的数字不等于右侧的数字，则表达式的值为 <code>True</code>，否则即为 <code>False</code>：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gsw3zoe</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> != <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z7pffk3</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> != <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False\n</code></pre>\n<p>此前，如果使用 = 将数字赋值给了变量，如 x = 100。可能会将其理解为“x 等于 100”，但这是错误的。前面看到，= 是用来给变量赋值的，而不是检查相等性的操作符。因此 x = 100 应理解为“x 的值为 100”。比较操作符 == 是用于检查两侧是否相等的，因此如果看到 x == 100，含义即为“x 等于 100”。</p>\n<h3 id=\"313\">3.13　逻辑操作符</h3>\n<p><strong>逻辑操作符</strong>（logical operator）也是 Python 中的一类操作符。与比较操作符类似，逻辑操作符的求值结果也是 <code>True</code> 或 <code>False</code>。详情见表 3-3。</p>\n<p>表 3-3　　</p>\n<table>\n<thead>\n<tr>\n<th>操　作　符</th>\n<th>含　　义</th>\n<th>示　　例</th>\n<th>运算结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>and</td>\n<td>与</td>\n<td>True and True</td>\n<td>True</td>\n</tr>\n<tr>\n<td>or</td>\n<td>或</td>\n<td>True or False</td>\n<td>True</td>\n</tr>\n<tr>\n<td>not</td>\n<td>非</td>\n<td>not True</td>\n<td>False</td>\n</tr>\n</tbody>\n</table>\n<p>Python 关键字 and 可以连接两个表达式，如果二者均求值为 <code>True</code>，则返回 <code>True</code>。如果任意一个的值为 <code>False</code>，即返回 <code>False</code>：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zdqghb2</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">1</span> <strong><span class=\"hljs-keyword\">and</span></strong> <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zkp2jzy</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">2</span> <strong><span class=\"hljs-keyword\">and</span></strong> <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/honkev6</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">2</span> <strong><span class=\"hljs-keyword\">and</span></strong> <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">1</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zjrxxrc</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">1</span> <strong><span class=\"hljs-keyword\">and</span></strong> <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">1</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False</code></pre>\n<p>可以在一个语句中多次使用 <code>and</code> 关键字：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zpvk56u</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">1</span> <strong><span class=\"hljs-keyword\">and</span></strong> <span class=\"hljs-number\">10</span> != <span class=\"hljs-number\">2</span> <strong><span class=\"hljs-keyword\">and</span></strong> <span class=\"hljs-number\">2</span> &lt; <span class=\"hljs-number\">10</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<p>关键字 <code>or</code> 可连接两个或多个表达式，如果任意一个表达式的值为 <code>True</code>，即返回 <code>True</code>：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hosuh7c</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">1</span> <strong><span class=\"hljs-keyword\">or</span></strong> <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zj6q8h9</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">1</span> <strong><span class=\"hljs-keyword\">or</span></strong> <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/j8ngufo</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">2</span> <strong><span class=\"hljs-keyword\">or</span></strong> <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">1</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z728zxz</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">1</span> <strong><span class=\"hljs-keyword\">or</span></strong> <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False</code></pre>\n<p>类似地，也可以在一个语句中多次使用 <code>or</code> 关键字：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/ja9mech</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">1</span> <strong><span class=\"hljs-keyword\">or</span></strong> <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">2</span> <strong><span class=\"hljs-keyword\">or</span></strong> <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">3</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<p>该表达式的值为 <code>True</code>，因为 1 == 1 的值为 <code>True</code>，即使表达式其余的部分求值为 <code>False</code>，最终的值仍为 <code>True</code>。</p>\n<p>将关键字 <code>not</code> 放置在表达式的前面，将改变表达式的求值结果，逆转为原本结果的对立值。如果表达式原本的求值结果为 <code>True</code>，则加上 <code>not</code> 之后结果会变为 <code>False</code>：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h45eq6v</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-keyword\">not</span></strong> <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">1</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gsqj6og</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-keyword\">not</span></strong> <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<h3 id=\"314\">3.14　条件语句</h3>\n<p>关键字 <code>if</code>、<code>elif</code> 和 <code>else</code> 用于<strong>条件语句</strong>（conditional statement）。条件语句是一种<strong>控制结构</strong>（control structure）：通过分析变量的值从而做出对应决定的代码块。条件语句是可根据条件执行额外代码的代码。为了方便理解，仔细看以下这个伪代码（pseudocode）示例（伪代码是用于解释说明示例代码的标记方法）：</p>\n<pre><code class=\"hljs php\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># 不要执行</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-keyword\">If</span> (expression) Then\n<span class=\"hljs-number\">5</span>              (code_area1)\n<span class=\"hljs-number\">6</span>  <span class=\"hljs-keyword\">Else</span>\n<span class=\"hljs-number\">7</span>              (code_area2)\n</code></pre>\n<p>上述伪代码显示，可以定义两个条件语句。如果第一个条件语句中定义的表达式为 <code>True</code>，则执行 <code>code_area1</code>；否则执行 <code>code_area2</code>。示例中的第一部分被称为 <code>if</code> 语句，第二部分为 <code>else</code> 语句。两者共同组成一个 <code>if-else</code> 语句：程序员用来表达“如果出现这种情况，则这样做，否则那样做”的方法。下面是 Python 中的 <code>if-else</code> 语句示例：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># http://tinyurl.com/htvy6g3</span>\n2\n3\n4  home = <span class=\"hljs-string\">\"America\"</span>\n5  <strong><span class=\"hljs-keyword\">if</span></strong> home == <span class=\"hljs-string\">\"America\"</span>:\n6      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, America!\"</span>)\n7  <strong><span class=\"hljs-keyword\">else</span></strong>:\n8      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n\n&gt;&gt; Hello, America!</code></pre>\n<p>第 5 行和第 6 行共同组成了 <code>if</code> 语句。一个 <code>if</code> 语句中，包括一行以 <code>if</code> 关键字开头的代码行，<code>if</code> 关键字之后是一个表达式，还有冒号、缩进，以及一行或多行如果表达式为 <code>True</code> 的情况下将执行的代码。第 7 行和第 8 行共同组成了 <code>else</code> 语句。一个 <code>else</code> 语句的开头是 <code>else</code> 关键字，然后是冒号、缩进，以及一行或多行如果 <code>if</code> 语句中表达式为 <code>False</code> 时将执行的代码。</p>\n<p>二者共同组成了一个 <code>if-else</code> 语句。本例的打印输出结果为 <code>Hello, America!</code>，因为 <code>if</code> 语句中的表达式结果为 <code>True</code>。如果将变量 <code>home</code> 的值修改为 <code>Canada</code>，则 <code>if</code> 语句中的表达式结果为 <code>False</code>，将会执行 <code>else</code> 语句中的代码，程序会打印出 <code>Hello, World!</code>。</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># http://tinyurl.com/jytyg5x</span>\n2\n3\n4  home = <span class=\"hljs-string\">\"Canada\"</span>\n5  <strong><span class=\"hljs-keyword\">if</span></strong> home ==<strong> </strong><span class=\"hljs-string\">\"America\"</span>:\n6      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, America!\"</span>)\n7  <strong><span class=\"hljs-keyword\">else</span></strong>:\n8      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n\n&gt;&gt; Hello, World!</code></pre>\n<p>可以单独使用一个 <code>if</code> 语句：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jyg7dd2</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  home = <span class=\"hljs-string\">\"America\"</span>\n<span class=\"hljs-number\">5</span>  <strong><span class=\"hljs-keyword\">if</span></strong> home == <span class=\"hljs-string\">\"America\"</span>:\n<span class=\"hljs-number\">6</span>      print(<span class=\"hljs-string\">\"Hello, America!\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> Hello, America!</code></pre>\n<p>也可以连续使用多个 <code>if</code> 语句：</p>\n<pre class=\"代码无行号\"><code class=\"hljs coffeescript\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z24ckye</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  x = <span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">05</span>  <strong><span class=\"hljs-keyword\">if</span></strong> x == <span class=\"hljs-number\">2</span>:\n<span class=\"hljs-number\">06</span>      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"The number is 2.\"</span>)\n<span class=\"hljs-number\">07</span>  <strong><span class=\"hljs-keyword\">if</span></strong> x % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>:\n<span class=\"hljs-number\">08</span>      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"The number is even.\"</span>)\n<span class=\"hljs-number\">09</span>  <strong><span class=\"hljs-keyword\">if</span></strong> x % <span class=\"hljs-number\">2</span> != <span class=\"hljs-number\">0</span>:\n<span class=\"hljs-number\">10</span>      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"The number is odd.\"</span>)\n\n&gt;&gt; The number <span class=\"hljs-keyword\">is</span> <span class=\"hljs-number\">2.</span>\n&gt;&gt; The number <span class=\"hljs-keyword\">is</span> even.</code></pre>\n<p>每个 <code>if</code> 语句只有在其表达式求值为 <code>True</code> 时，才会执行所有的代码。在本例中，前两个表达式的求值结果为 <code>True</code>，因此各自的代码都执行了，但是第 3 个表达式的结果为 <code>False</code>，所以没有执行。</p>\n<p>如果愿意，甚至还可以在 <code>if</code> 语句中再加入一个 <code>if</code> 语句（通常称之为嵌套）：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zrodgne</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  x = <span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">05</span>  y = <span class=\"hljs-number\">11</span>\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>\n08  <strong><span class=\"hljs-keyword\">if</span></strong> x == <span class=\"hljs-number\">10</span>:\n09      <strong><span class=\"hljs-keyword\">if</span></strong> y == <span class=\"hljs-number\">11</span>:\n<span class=\"hljs-number\">10</span>          print(x + y)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">21</span></code></pre>\n<p>在本例中，只有在两个 <code>if</code> 语句的结果均为 <code>True</code> 时，才会打印 <code>x + y</code>。<code>else</code> 语句无法被单独使用，只能用在 <code>if-else</code> 语句的最后一部分。</p>\n<p>也可以使用 <code>elif</code> 关键字创建 <code>elif</code> 语句。<code>elif</code> 表示另外如果，该语句可无限添加到 <code>if-else</code> 语句中，使其支持更多的决策。</p>\n<p>如果一个 <code>if-else</code> 语句中包含有 <code>elif</code> 语句，则首先判断 <code>if</code> 语句。如果该语句中的表达式为 <code>True</code>，则只执行其中的代码。但是，如果其值为 <code>False</code>，每个之后的 <code>elif</code> 语句都将进行求值。只要有一个 <code>elif</code> 语句中的表达式结果为 <code>True</code>，则执行其中的代码并退出。如果没有任何一个 <code>elif</code> 语句的结果为 <code>True</code>，则执行 <code>else</code> 语句中的代码。下面是一个包含有 <code>elif</code> 语句的 <code>if-else</code> 语句示例：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">01  <span class=\"hljs-comment\"># http://tinyurl.com/jpr265j</span>\n02\n03\n04  home = <span class=\"hljs-string\">\"Thailand\"</span>\n05  <strong><span class=\"hljs-keyword\">if</span></strong> home == <span class=\"hljs-string\">\"Japan\"</span>:\n06      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"Hello, Japan!\"</span>)\n07  <strong><span class=\"hljs-keyword\">elif</span></strong> home == <span class=\"hljs-string\">\"Thailand\"</span>:\n08      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"Hello, Thailand!\"</span>)\n09  <strong><span class=\"hljs-keyword\">elif</span></strong> home == <span class=\"hljs-string\">\"India\"</span>:\n10      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, India!\"</span>)\n11  <strong><span class=\"hljs-keyword\">elif</span></strong> home == <span class=\"hljs-string\">\"China\"</span>:\n12      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, China!\"</span>)\n13  <strong><span class=\"hljs-keyword\">else</span></strong>:\n14      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n\n&gt;&gt; Hello, Thailand!</code></pre>\n<p>下面这个示例中，所有的 <code>elif</code> 语句求值结果均不为 <code>True</code>，最后执行的是 <code>else</code> 语句中的代码。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">01  <span class=\"hljs-comment\"># http://tinyurl.com/zdvuuhs</span>\n02\n03  home = <span class=\"hljs-string\">\"Mars\"</span>\n04  <strong><span class=\"hljs-keyword\">if</span></strong> home == <span class=\"hljs-string\">\"America\"</span>:\n05      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"Hello, America!\"</span>)\n06  <strong><span class=\"hljs-keyword\">elif</span></strong> home == <span class=\"hljs-string\">\"Canada\"</span>:\n07      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"Hello, Canada!\"</span>)\n08  <strong><span class=\"hljs-keyword\">elif</span></strong> home == <span class=\"hljs-string\">\"Thailand\"</span>:\n09      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, Thailand!\"</span>)\n10  <strong><span class=\"hljs-keyword\">elif</span></strong> home == <span class=\"hljs-string\">\"Mexico\"</span>:\n11      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, Mexico!\"</span>)\n12  <strong><span class=\"hljs-keyword\">else</span></strong>:\n13      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n\n&gt;&gt; Hello, World! </code></pre>\n<p>最后，可以连续使用多个 <code>if</code> 语句和 <code>elif</code> 语句：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">01  <span class=\"hljs-comment\"># http://tinyurl.com/hzyxgf4</span>\n02\n03\n04  x = 100\n05  <strong><span class=\"hljs-keyword\">if</span></strong> x == 10:\n06      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"10!\"</span>)\n07  <strong><span class=\"hljs-keyword\">elif</span></strong> x == 20:\n08      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"20!\"</span>)\n09  <strong><span class=\"hljs-keyword\">else</span></strong>:\n10      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"I don't know!\"</span>)\n11\n12\n13  <strong><span class=\"hljs-keyword\">if</span></strong> x == 100:\n14      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"x is 100!\"</span>)\n15\n16\n17  <strong><span class=\"hljs-keyword\">if</span></strong> x % 2 == 0:\n18      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"x is even!\"</span>)\n19<strong>  <span class=\"hljs-keyword\">else</span></strong>:\n20      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"x is odd!\"</span>)\n\n&gt;&gt; I don<span class=\"hljs-string\">'t know!\n&gt;&gt; x is 100!\n&gt;&gt; x is even!</span></code></pre>\n<h3 id=\"315\">3.15　语句</h3>\n<p><strong>语句</strong>（statement）这个术语可用来描述 Python 语言的多种构成部分。可以将一个 Python 语句视作一个命令或计算。本节将详细介绍语句的语法。如果感觉部分内容初次学起来很难懂，也不用太担心，随着练习 Python 的时间变长，你就会慢慢理解。</p>\n<p>Python 中有两类语句：<strong>简单语句</strong>（simple statement）和<strong>复合语句</strong>（compound statement）。简单语句一般就是一行代码，而复合语句通常包括多行代码。下面是一些简单语句的示例：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jrowero</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  print(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> Hello, World!\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h2y549y</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">4</span>\n</code></pre>\n<p><code>if</code> 语句和 <code>if-else</code> 语句，以及本章编写的第一个程序（打印 <code>Hello, World!</code> 100 次）都是复合语句。</p>\n<p>复合语句由一个或多个<strong>从句</strong>（clause）组成。从句包括两行或多行代码：<strong>代码头</strong>（header）及紧随其后的<strong>配套代码</strong>（suite）。代码头指的是从句中包含关键字的那行代码，之后是一个冒号和一行或多行带缩进的代码。缩进之后，是一个或多个配套代码。配套代码就是从句中一行普通的代码。代码头控制配套代码的执行。打印 <code>Hello, World!</code> 100 次的程序，就是由一个复合语句组成。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zfz3eel</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>  <strong><span class=\"hljs-keyword\">for</span></strong> i <strong><span class=\"hljs-keyword\">in</span></strong> range(<span class=\"hljs-number\">100</span>):\n<span class=\"hljs-number\">4</span>      print(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> Hello, World!\n&gt;&gt; Hello, World!\n&gt;&gt; Hello, World!\n…</code></pre>\n<p>程序的第一行是代码头，包括关键字 <code>for</code>，之后是冒号。缩进之后是配套代码 <code>print(\"Hello, World!\")</code>。在上述示例中，代码头通过配套代码打印 <code>Hello, World!</code> 100 次，这是一个循环，将在第 7 章详细介绍。上述代码只有一个从句。</p>\n<p>复合语句可以由多个从句构成，你前面看到的 <code>if-else</code> 语句就是复合语句。<code>if</code> 语句之后如果带有一个 <code>else</code> 语句，就构成了一个由多个从句组成的复合语句。在包含多个从句的复合语句中，代码头从句共同控制代码执行。对于 <code>if-else</code> 语句，当 <code>if</code> 语句的值为 <code>True</code> 时，则执行 <code>if</code> 语句的配套代码，<code>else</code> 语句的配套代码不执行；当 <code>if</code> 语句的值为 <code>False</code> 时，则不执行 <code>if</code> 语句的配套代码，转而执行 <code>else</code> 语句的配套代码。上一节中的最后一个示例包含了 3 个复合语句：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">01  <span class=\"hljs-comment\"># http://tinyurl.com/hpwkdo4</span>\n02\n03\n04  x = 100\n05  <strong><span class=\"hljs-keyword\">if</span></strong> x == 10:\n06      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"10!\"</span>)\n07  <strong><span class=\"hljs-keyword\">elif</span></strong> x == 20:\n08      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"20!\"</span>)\n09  <strong><span class=\"hljs-keyword\">else</span></strong>:\n10      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"I don't know!\"</span>)\n11\n12\n13  <strong><span class=\"hljs-keyword\">if</span></strong> x == 100:\n14      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"x is 100!\"</span>)\n15\n16\n17  <strong><span class=\"hljs-keyword\">if</span></strong> x % 2 == 0:\n18      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"x is even!\"</span>)\n19  <strong><span class=\"hljs-keyword\">else</span></strong>:\n20      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"x is odd!\"</span>)\n\n&gt;&gt; I don<span class=\"hljs-string\">'t know!\n&gt;&gt; x is 100!\n&gt;&gt; x is even!</span></code></pre>\n<p>第一个复合语句中有 3 个从句，第二个里有一个从句，最后一个则有两个从句。</p>\n<p>关于语句还有一点要注意，语句之间是可以有空格的，这不会影响代码的执行。空格有时被用来提高代码的可读性。</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zlgcwoc</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  print(<span class=\"hljs-string\">\"Michael\"</span>)\n<span class=\"hljs-number\">05</span>\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>\n08\n09\n<span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">11</span>  print(<span class=\"hljs-string\">\"Jordan\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> Michael\n<span class=\"hljs-meta\">&gt;&gt;</span> Jordan\n</code></pre>\n<h3 id=\"316\">3.16　术语表</h3>\n<p><strong>注释</strong>：用英文或其他自然语言写的一行（或一部分）代码，行首均有一个特殊标志告知编程语言忽略这行代码。</p>\n<p><strong>关键字</strong>：编程语言中具有特殊意义的词。可在 http://theselftaughtprogrammer.io/keywords 网页中查看所有 Python 的关键字。</p>\n<p><strong>数据类型</strong>：数据所属的类别。</p>\n<p><strong>对象</strong>：Python 中具有 3 个属性的数据值——唯一标识、数据类型和值。</p>\n<p><strong>Str</strong>：字符串的数据类型。</p>\n<p><strong>字符</strong>：a 或 l 等单个符号。</p>\n<p><strong>Int</strong>：整数的数据类型。</p>\n<p><strong>整型数据</strong>：数据类型为 int 的对象，其值为一个整数。</p>\n<p><strong>Float</strong>：小数的数据类型。</p>\n<p><strong>浮点数</strong>：数据类型为 <code>float</code> 的对象，其值为一个小数。</p>\n<p><strong>Bool</strong>：布尔对象的数据类型。</p>\n<p><strong>布尔值</strong>：数据类型为 <code>bool</code> 的对象，其值为 <code>True</code> 或 <code>False</code>。</p>\n<p><strong>NoneType</strong>：<code>None</code> 对象的数据类型。</p>\n<p><strong>None</strong>：数据类型为 <code>NoneType</code> 的对象，其值永远为 <code>None</code>。</p>\n<p><strong>常量</strong>：不会改变的值。</p>\n<p><strong>变量</strong>：使用赋值操作符赋予了一个值的名称。</p>\n<p><strong>赋值操作符</strong>：Python 中的 <code>=</code> 符号。</p>\n<p><strong>增加</strong>：增加一个变量的值。</p>\n<p><strong>减少</strong>：减少一个变量的值。</p>\n<p><strong>语法</strong>：规范一门语言中句子结构，尤其是字词顺序的一整套规则及流程。</p>\n<p><strong>语法错误</strong>：违反编程语言的语法，所导致的致命编程错误。</p>\n<p><strong>异常</strong>：非致命的编程错误。</p>\n<p><strong>操作符</strong>：在表达式中与操作符一起使用的符号。</p>\n<p><strong>算术操作符</strong>：数学表达式中使用的一类操作符。</p>\n<p><strong>操作数</strong>：操作符两侧的值。</p>\n<p><strong>表达式</strong>：操作符及两个操作数构成的代码。</p>\n<p><strong>运算顺序</strong>：数学计算中用来对表达式求值的一组规则。</p>\n<p><strong>比较操作符</strong>：表达式中用到的一类操作符，求值结果为 <code>True</code> 或 <code>False</code>。</p>\n<p><strong>逻辑操作符</strong>：对两个表达式求值的一类操作符，求值结果为 <code>True</code> 或 <code>False</code>。</p>\n<p><strong>条件语句</strong>：根据条件执行不同代码的代码。</p>\n<p><strong>控制结构</strong>：通过分析变量的值，来决定代码如何执行的代码块。</p>\n<p><strong>伪代码</strong>：用来演示逻辑的标记方法，与代码类似。</p>\n<p><strong>if-else 语句</strong>：程序员用来表达“如果出现这种情况，则这样做，否则那样做”的方法。</p>\n<p><strong>if 语句</strong>：<code>if-else</code> 语句的第一部分。</p>\n<p><strong>else 语句</strong>：<code>if-else</code> 语句的第二部分。</p>\n<p><strong>语句</strong>：一个命令或计算。</p>\n<p><strong>简单语句</strong>：可用一行代码表述的语句。</p>\n<p><strong>复合语句</strong>：通常包括多行代码的语句。</p>\n<p><strong>从句</strong>：复合语句的组成部分；一个从句由两行或多行代码构成，包括代码头及配套代码。</p>\n<p><strong>代码头</strong>：从句中包含关键字的那行代码，之后是一个冒号和一行或多行带缩进的代码。</p>\n<p><strong>配套代码</strong>：从句中由代码头控制的代码。</p>\n<h3 id=\"317\">3.17　挑战练习</h3>\n<p>1．请打印 3 个不同的字符串。</p>\n<p>2．编写程序：如果变量的值小于 10，打印一条消息；如果大于或等于 10，则打印不同的消息。</p>\n<p>3．编写程序：如果变量的值小于或等于 10，打印一条消息；如果大于 10 且小于或等于 25，则打印一条不同的消息；如果大于 25，则打印另一条不同的消息。</p>\n<p>4．编写一个将两个变量相除，并打印余数的程序。</p>\n<p>5．编写一个将两个变量相除，并打印商的程序。</p>\n<p>6．编写程序：为变量 age 赋予一个整数值，根据不同的数值打印不同的字符串说明。</p>\n<p>答案可从异步社区（www.epubit.com）本书详情页的配套资源中下载。</p></div></article>\n</body>\n</html>","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE html>\n<html lang=\"en\">\n<head><meta name=\"generator\" content=\"Hexo 3.8.0\">\n    <meta charset=\"UTF-8\">\n    <title>编程概论</title>\n</head>\n<body>\n<article id=\"articleDiv\"><div class=\"mazi-article-content dont-break-out\"><p></p><div class=\"toc\">\n<ul>\n<li><ul>\n<li><ul>\n<li><a href=\"#31\">3.1　示例</a></li>\n<li><a href=\"#32\">3.2　注释</a></li>\n<li><a href=\"#33\">3.3　打印</a></li>\n<li><a href=\"#34\">3.4　代码行</a></li>\n<li><a href=\"#35\">3.5　关键字</a></li>\n<li><a href=\"#36\">3.6　间距</a></li>\n<li><a href=\"#37\">3.7　数据类型</a></li>\n<li><a href=\"#38\">3.8　常量和变量</a></li>\n<li><a href=\"#39\">3.9　语法</a></li>\n<li><a href=\"#310\">3.10　错误与异常</a></li>\n<li><a href=\"#311\">3.11　算术操作符</a></li>\n<li><a href=\"#312\">3.12　比较操作符</a></li>\n<li><a href=\"#313\">3.13　逻辑操作符</a></li>\n<li><a href=\"#314\">3.14　条件语句</a></li>\n<li><a href=\"#315\">3.15　语句</a></li>\n<li><a href=\"#316\">3.16　术语表</a></li>\n<li><a href=\"#317\">3.17　挑战练习</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>\n<p></p>\n<blockquote>\n  <p><span style=\"font-family: Times New Roman,楷体_GB2312\">“这是我能想到的，唯一可以让我既当工程师又做艺术家的工作。它要求具备极其缜密的技术思维，因为你必须要完成精确的思考，这点我很喜欢。另一方面，它又鼓励你肆意挥洒自己的创意，只有你想不到没有你做不到的。”</span></p>\n  <p><span style=\"font-family: Times New Roman,楷体_GB2312\">——安迪 · 赫兹菲尔德（Andy Hertzfeld）</span></p>\n</blockquote>\n<p>我们的第一个程序打印出了 <code>Hello, World!</code>。接下来打印 100 次。在交互式 shell 中输入如下代码（print 需要缩进 4 个空格符）：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># http://tinyurl.com/h79ob7s</span>\n2\n3\n4  <strong><span class=\"hljs-keyword\">for</span></strong> i <strong><span class=\"hljs-keyword\">in</span></strong> range(100):\n5      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, World!\"</span>)</code></pre>\n<p>交互式 shell 应该会打印 <code>Hello, World!</code> 100 次。即使通常没有这样做的需要，但可以从这个例子中看出编程的强大。你能想到任何其他可以如此简单地做 100 遍的事情吗？我想不到。这就是编程的厉害之处。</p>\n<h3 id=\"31\">3.1　示例</h3>\n<p>从现在开始，代码示例会以如下形式出现：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h4qntgk</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-keyword\">for</span></strong> i <strong><span class=\"hljs-keyword\">in</span></strong> range(<span class=\"hljs-number\">100</span>):\n<span class=\"hljs-number\">5</span>      print(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> Hello, World!\n&gt;&gt; Hello, World!\n&gt;&gt; Hello, World!\n…</code></pre>\n<p>打开 http://tinyurl.com/h4qntqk 这个链接，就可以看到包含有示例代码的网页，这样如果无法让代码运行，你可以轻松地复制代码，并粘贴到 IDLE 的文本编辑器中。<code>&gt;&gt;</code> 的后面则是交互式 shell 的输出。全书的每一个编程示例中都会看到 <code>&gt;&gt;</code>，这代表了程序的输出结果（会在交互式 shell 中打印出来）。“...”表示“等等”。</p>\n<p>如果示例后没有 <code>&gt;&gt;</code>，就表示该程序没有输出，或者只是在解释概念，输出并不太重要。</p>\n<p>字体为 Courier New 的部分，都是某种形式的代码、代码输出或编程术语。例如，上个例子中提到的词 <code>for</code>，它就会是 Courier New 字体。</p>\n<p>Courier New 是一个固定宽度（不等比）的字体，常用来显示编程文本。每个字符的宽度都一致，因此代码对齐后可以很容易地发现缩进和其他特征。</p>\n<p>可以用交互式 shell 或 <code>.py</code> 文件来运行示例代码。但是要注意的是，正如之前提到的，交互式 shell 中的输出与文件运行的输出可能略有不同，因此如果没得到完全一致的输出，原因就在于此。如果有示例要打印输出，但是却没有 <code>print</code> 字样，表示应该直接在交互式 shell 中输入代码。如果示例中有 <code>print</code> 字样，则说明应该从 <code>.py</code> 文件运行代码。</p>\n<h3 id=\"32\">3.2　注释</h3>\n<p><strong>注释</strong>（comment）是用英文或其他自然语言写的一行（或一部分）代码，行首均有一个特殊标志告知编程语言忽略这行代码。Python 用井号（#）来创建注释。</p>\n<p>注释的目的是解释代码的功能。程序员通过注释，使得代码更易于阅读。在注释中，可以写下任何内容，只要保持为一行即可，示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hut6nwu</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>  <span class=\"hljs-comment\"># 这是一行注释</span>\n<span class=\"hljs-number\">4</span>  print(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> Hello, World!\n</code></pre>\n<p>只有在代码中执行特别操作，或者代码不清晰易懂的情况下，才需要写注释。尽量少写注释——不要每行代码都写注释，有特殊情况才需要。下面是一个注释多余的例子：</p>\n<pre><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># http://tinyurl.com/jpzlwqq</span>\n2\n3\n4  <span class=\"hljs-comment\"># 打印 Hello, World!</span>\n5  <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n</code></pre>\n<p>注释之所以多余，是因为这行代码的功能已经非常明确。下面是一个注释合理的例子：</p>\n<pre class=\"代码无行号\"><code class=\"hljs cpp\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/z52c8z8</span></span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  <strong><span class=\"hljs-keyword\">import</span></strong> math\n<span class=\"hljs-number\">05</span>\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>  # 对角线的长度\n<span class=\"hljs-number\">08</span>  l = <span class=\"hljs-number\">4</span>\n<span class=\"hljs-number\">09</span>  w = <span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">10</span>  d = math.<span class=\"hljs-built_in\">sqrt</span>(l**<span class=\"hljs-number\">2</span>+ w**<span class=\"hljs-number\">2</span>)</code></pre>\n<p>即使你完全理解了这段代码，也可能并不知道如何计算长方形的对角线长度，因此这里的注释就是有用的。</p>\n<h3 id=\"33\">3.3　打印</h3>\n<p>程序不止可以打印 <code>Hello, World!</code>，它可以打印任何内容，只要记得加上双引号。</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zh5g2a3</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  print(<span class=\"hljs-string\">\"Python\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> Python\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hhwqva2</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  print(<span class=\"hljs-string\">\"Hola!\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> Hola!\n</code></pre>\n<h3 id=\"34\">3.4　代码行</h3>\n<p>Python 程序是由一行一行的代码组成的。看下面这个程序：</p>\n<pre><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># http://tinyurl.com/jq2w5ro</span>\n2\n3\n4  <span class=\"hljs-comment\"># 第一行</span>\n5  <span class=\"hljs-comment\"># 第二行</span>\n6  <span class=\"hljs-comment\"># 第三行</span>\n</code></pre>\n<p>程序共有 3 行代码。我们通常用代码所在的行数区别代码。在 IDLE 中，可以打开“编辑”菜单，选择“前往行”按钮，即可跳转至程序的指定行。在交互式 shell 中，一次只能输入一行代码，无法复制粘贴多行代码。</p>\n<p>有时一段代码比较长，超过了一行，可以用三引号、圆括号、方括号或者大括号扩展至新一行，示例如下：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zcdx3yo</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  print(<span class=\"hljs-string\">\"\"\"This is a really really\n5        really really long line of\n6        code.\"\"\"</span>)\n</code></pre>\n<p>另外，还可以使用反斜杠 \\ 对代码进行换行：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hjcf2sa</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-keyword\">print</span>\\\n<span class=\"hljs-number\">5</span>  (<span class=\"hljs-string\">\"\"\"This is a really really\n6   really long line of code.\"\"\"</span>)\n</code></pre>\n<p>上述两个例子的输出结果是一样的。反斜杠可以让我们将 <code>(\"\"\"This is a really really really long line of code.\"\"\")</code> 和 <code>print</code> 放在不同的行，这种情况一般是不允许的。</p>\n<h3 id=\"35\">3.5　关键字</h3>\n<p>Python 等编程语言中有一些具备特殊意义的字，即<strong>关键字</strong>（keyword）。前面见过的 <code>for</code> 就是一个关键字，用来多次执行代码。本章中还会学习更多的关键字。</p>\n<h3 id=\"36\">3.6　间距</h3>\n<p>我们再来回顾一下那个打印 <code>Hello, World!</code> 100 次的程序：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># http://tinyurl.com/glp9xq6</span>\n2\n3\n4  <strong><span class=\"hljs-keyword\">for</span></strong> i <strong><span class=\"hljs-keyword\">in</span></strong> range(100):\n5      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, World!\"</span>)</code></pre>\n<p>前面已经提到，<code>print</code> 缩进了 4 个空格符。稍后会解释原因，缩进可以告诉 Python 解释器代码块的开始与结束。同时要注意，在本书示例中看到的缩进距离，都是 4 个空格符。如果代码间距不合理，程序将无法执行。</p>\n<p>其他编程语言没有类似的缩进要求；它们使用关键字或花括号来表示代码开始和结束。以下是用 JavaScript 编程语言编写的同一个程序：</p>\n<pre class=\"代码无行号\"><code class=\"hljs coffeescript\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hwa2zae</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  <span class=\"hljs-comment\"># 这是一个 JavaScript 程序</span>\n<span class=\"hljs-number\">05</span>  <span class=\"hljs-comment\"># 不过没法执行</span>\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>\n<span class=\"hljs-number\">08</span>  <strong><span class=\"hljs-keyword\">for</span></strong> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">100</span>; i++) {\n<span class=\"hljs-number\">09</span>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"Hello, World!\"</span>);\n<span class=\"hljs-number\">10</span>  }</code></pre>\n<p>Python 的支持者坚信使用必要的缩进可以让 Python 比其他语言更易读易写。正如上例所示，即使编程语言不强制使用空格，程序员为了让代码更便于阅读，也会倾向于使用空格来分隔代码。</p>\n<h3 id=\"37\">3.7　数据类型</h3>\n<p>Python 将数据划分成不同的类别，即<strong>数据类型</strong>（data type）。在 Python 中，每一个数据值，如 <code>2</code> 或 <code>\"Hello, World!\"</code>，被称为<strong>对象</strong>（object）。本书第二部分会详细介绍数据类型，现在可以把对象看作拥有 3 个属性的数据值：唯一标识（identity）、数据类型和值。对象的唯一标识，指的是其在计算机内存中的地址，该地址不会变化。对象的数据类型是对象所属的数据类别，这决定了对象的属性，也不会变化。对象的值是其表示的数据，例如数字 <code>2</code> 的值即为 2。</p>\n<p><code>\"Hello, World!\"</code> 这个对象的数据类型为<strong>字符串</strong>（str，string 的缩写），值为 <code>\"Hello, World!\"</code>。如果提及数据类型为 <code>str</code> 的对象，可以称其为字符串。字符串是由引号包括的一个或多个字符组成的序列。<strong>字符</strong>（character）是类似 <code>a</code> 或 <code>l</code> 这样的单个符号。可以使用单引号或双引号来表示字符串，但是前后的引号必须保持一致，示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hh5kjwp</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"Hello, World!\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'Hello, World!'</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/heaxhsh</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">'Hello, World!'</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'Hello, World!'</span>\n</code></pre>\n<p>字符串可用来表示文本，且有自己独特的属性。</p>\n<p>之前章节中用来计算的数字，也是对象，但不是字符串。整数（1，2，3，4 等）的数据类型为<strong>整型数据</strong>（<code>int</code>，全称为 integer）。与字符串一样，整型数据也有着独特的属性。例如，可以将两个整数相乘，但是不能相乘两个字符串。</p>\n<p>小数（带小数点的数字）的数据类型为 <code>float</code>。2.1、8.2 和 9.9999 都是数据类型为 <code>float</code> 的对象，我们称之为<strong>浮点数</strong>（floating-point number）。与其他所有数据类型一样，浮点数也有自己独有的属性，且一定程度上与整型数据类似。</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/guoc4gy</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2.2</span> + <span class=\"hljs-number\">2.2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">4.4</span>\n</code></pre>\n<p>数据类型为 <strong>bool</strong> 的对象被称为<strong>布尔值</strong>（boolean），仅有 <code>True</code> 和 <code>False</code> 两个值。</p>\n<pre><code class=\"hljs php\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jyllj2k</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-keyword\">True</span>\n\n&gt;&gt; <span class=\"hljs-keyword\">True</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jzgsxz4</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-keyword\">False</span>\n\n&gt;&gt; <span class=\"hljs-keyword\">False</span>\n</code></pre>\n<p>数据类型为 <strong>NoneType</strong> 的对象，其值永远为 <code>None</code>，用来表示数据缺失。</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/h8oqo5v</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  None\n</code></pre>\n<p>本章后续会介绍如何使用不同的数据类型。</p>\n<h3 id=\"38\">3.8　常量和变量</h3>\n<p>你可以把 Python 当成计算器来算术，做加、减、乘、除、幂等运算。在交互式 shell 中输入以下所有示例：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zs65dp8</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">4</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gs9nwrw</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> - <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">0</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hasegvj</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">4</span> / <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">2.0</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z8ok4q3</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> * <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">4</span>\n</code></pre>\n<p><strong>常量</strong>（constant）是一个永远不会改变的值。上面示例中的每一个数字，都是常量；数字 2 永远表示的值为 2。<strong>变量</strong>（variable）则相反，指的是会改变的值。变量由一个或多个字符组成的名称构成，并使用<strong>赋值符</strong>（assignment operator）等号赋予了这个名称一个值。</p>\n<p>有些编程语言要求程序员编写变量“声明”，明确说明变量的数据类型。例如，在 C 语言中可以这样创建变量：</p>\n<pre><code class=\"hljs cs\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># 不用执行</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>  <span class=\"hljs-keyword\">int</span> a;\n<span class=\"hljs-number\">8</span>  a = <span class=\"hljs-number\">144</span>;\n</code></pre>\n<p>Python 的做法更简单；可以直接用赋值符，将某个值赋给变量，即可创建：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hw64mrr</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  b = <span class=\"hljs-number\">100</span>\n<span class=\"hljs-number\">5</span>  b\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">100</span>\n</code></pre>\n<p>下面介绍如何改变变量的值：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hw97que</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  x = <span class=\"hljs-number\">100</span>\n<span class=\"hljs-number\">5</span>  x\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  x = <span class=\"hljs-number\">200</span>\n<span class=\"hljs-number\">9</span>  x\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">100</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">200</span>\n</code></pre>\n<p>还可以使用两个变量进行算术运算：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z8hv5j5</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  x = <span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">5</span>  y = <span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">6</span>  z = x + y\n<span class=\"hljs-number\">7</span>  z\n<span class=\"hljs-number\">8</span>  a = x - y\n<span class=\"hljs-number\">9</span>  a\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">20</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">0</span>\n</code></pre>\n<p>编程时经常需要<strong>增加</strong>（increment）或<strong>减小</strong>（decrement）某个变量的值。考虑到这个操作非常普遍，Python 提供了特殊语法进行增减变量的值。如需增加变量的值，可将该变量赋予给自身，然后在等号的另一侧将变量与希望增加的值相加：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zvzf786</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  x = <span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">5</span>  x = x + <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">6</span>  x\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">11</span>\n</code></pre>\n<p>如需减小变量的值，可以执行同样的操作，唯一的区别是要减去所希望的值：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gmuzdr9</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  x = <span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">5</span>  x = x - <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">6</span>  x\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">9</span>\n</code></pre>\n<p>这些示例都是完全有效的，不过还有一种更简便的方法，示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zdva5wq</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  x = <span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">5</span>  x += <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">6</span>  x\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">11</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jqw4m5r</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  x = <span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">5</span>  x -= <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">6</span>  x\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">9</span>\n</code></pre>\n<p>变量不仅仅用于保存整型数的值，还可以表示任何数据类型，示例如下：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/jsygqcy</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  hi = <span class=\"hljs-string\">\"Hello, World!\"</span>\n\n<span class=\"hljs-number\">1</span>  # http:<span class=\"hljs-comment\">//tinyurl.com/h47ty49</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  my_float = <span class=\"hljs-number\">2.2</span>\n\n<span class=\"hljs-number\">1</span>  # http:<span class=\"hljs-comment\">//tinyurl.com/hx9xluq</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  my_boolean = True\n</code></pre>\n<p>只要遵守以下 4 条原则，可以随意命名变量。</p>\n<p>1．变量名不能包含空格符。如果想在变量名中使用两个单子，可以在中间加入下划线，如 <code>my_variable = \"A string!\"</code>。</p>\n<p>2．变量名只能使用特定的字母、数字和下划线。</p>\n<p>3．变量名不能以数字开头。虽然可以使用下划线开头，但是这种命名方式有着特殊的意义，后面内容会提到。因此在此之前尽量避免这种情况。</p>\n<p>4．不能使用 Python 关键字作为变量名。可在网页 http://theselftaughtprogrammer.io/keywords 中查看所有关键字。</p>\n<h3 id=\"39\">3.9　语法</h3>\n<p><strong>语法（syntax）</strong>指的是规范一门语言中句子结构，尤其是字词顺序的一整套规则及流程。英语有语法，Python 也有。</p>\n<p>在 Python 中，字符串永远被包括在引号内。这就是 Python 的一个语法示例。下面是一个有效的 Python 程序：</p>\n<pre><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># http://tinyurl.com/j7c2npf</span>\n2\n3\n4  <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n</code></pre>\n<p>程序之所以有效，是因为遵守了 Python 的语法，在定义字符串时用引号包括了文本。如果只是在文本的一侧使用引号，就违背了 Python 的语法，代码将无法运行。</p>\n<h3 id=\"310\">3.10　错误与异常</h3>\n<p>如果在编写 Python 程序时无视其语法，那么在运行时将出现错误。Python 解释器将告知代码无法执行，并给出有关该错误的信息。如果只用一个引号定义字符串，看看会发生什么情况，示例如下：</p>\n<pre><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># http://tinyurl.com/hp2plhs</span>\n2\n3\n4  <span class=\"hljs-comment\"># 该代码有一个错误</span>\n5\n6\n7  my_string = <span class=\"hljs-string\">\"Hello World.\n\n&gt;&gt; File \"</span>/Users/coryalthoff/PycharmProjects/se.py<span class=\"hljs-string\">\", line 1 my_string = 'd ^ SyntaxError: EOL while scanning string literal\n</span></code></pre>\n<p>这段信息表示程序中有一个语法错误。语法错误是致命的，将导致程序无法运行。如果强制执行，Python 会报错。错误信息会告诉你错误位于哪个文件，出现在哪一行，以及属于什么类型。尽管这个错误看上去很吓人，但却是很常见的。</p>\n<p>如果代码中有错误，首先要找到出错的那行代码，找到出错的地方。在本例中，你应该去找代码的第一行，观察一段时间后，会注意到里面只有一个引号。只要在字符串结尾再加上一个引号，即可解决该错误，然后可以重新运行。从这里开始，本书将这样表示错误输出：</p>\n<pre><code class=\"hljs cpp\">&gt;&gt; SyntaxError: EOL <span class=\"hljs-keyword\">while</span> scanning <span class=\"hljs-built_in\">string</span> literal\n</code></pre>\n<p>为了方便阅读，书中只显示错误信息的最后一行。</p>\n<p>Python 有两种错误：语法错误和异常。不属于语法错误的错误，就是<strong>异常</strong>（exception）。如果用 0 作为分母，则会出现“ZeroDivisionError”异常。</p>\n<p>与语法错误不同的是，异常并不一定是致命的（有办法让程序在即使出现异常时仍继续运行，这会在下一章学到）。出现异常时，Python 程序员会说“Python（或程序）报了一个异常”。下面是一个异常的示例：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jxpztcx</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-comment\"># 该代码有一个错误</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>  <span class=\"hljs-number\">10</span> / <span class=\"hljs-number\">0</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-symbol\">ZeroDivisionError:</span> division by zero\n</code></pre>\n<p>如果代码缩进不正确，程序会报“IdentationError”：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gtp6amr</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-comment\"># 该代码有一个错误</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>  y = <span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">8</span>          x =<span class=\"hljs-number\">1</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-symbol\">IndentationError:</span> unexpected indent\n</code></pre>\n<p>在学习编程的过程中，你会经常碰到语法错误和异常（包括书中没有讲到过的），但是出错的情况会逐渐减少。要记住，在碰到语法错误或异常时，先找到出现问题的那行代码，然后仔细检查并找到解决办法（如果没有头绪可以在网上搜索错误或异常提示信息）。</p>\n<h3 id=\"311\">3.11　算术操作符</h3>\n<p>之前，我们用 Python 做了简单的算术计算，如 4/2。这些示例中所使用到的符号被称为<strong>操作符</strong>（operator）。Python 将操作符分为多个类型，目前所见到的是<strong>算术操作符</strong>（arithmetic operator）。下面是 Python 中常用的一些算术操作符，见表 3-1。</p>\n<p>表3-1</p>\n<table>\n<thead>\n<tr>\n<th>操作符</th>\n<th>含　　义</th>\n<th>示例</th>\n<th>运算结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>**</td>\n<td>指数运算</td>\n<td>2 ** 2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>%</td>\n<td>取模运算</td>\n<td>14 % 4</td>\n<td>2</td>\n</tr>\n<tr>\n<td>//</td>\n<td>整除/地板除运算</td>\n<td>13 // 8</td>\n<td>1</td>\n</tr>\n<tr>\n<td>/</td>\n<td>除法运算</td>\n<td>13 / 8</td>\n<td>1.625</td>\n</tr>\n<tr>\n<td>*</td>\n<td>乘法运算</td>\n<td>8 * 2</td>\n<td>16</td>\n</tr>\n<tr>\n<td>−</td>\n<td>减法运算</td>\n<td>7 − 1</td>\n<td>6</td>\n</tr>\n<tr>\n<td>+</td>\n<td>加法运算</td>\n<td>2 + 2</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>\n<p>两个数相除时，会有一个商和一个余数。商就是除法运算的结果，余数即剩下的值。取模操作符返回的就是余数。例如，13 除以 5 的结果就是商 2 余 3，示例如下：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/qrdc195</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">13</span> <span class=\"hljs-comment\">// 5</span>\n\n&gt;&gt; <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/zsqwukd</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">13</span> % <span class=\"hljs-number\">5</span>\n\n&gt;&gt; <span class=\"hljs-number\">3</span>\n</code></pre>\n<p>对两个数取模时，如果没有余数（返回 0），则被取模的数字为另一个数字的倍数。如果有余数，则不是其倍数。因此取模运算被用于检验数字的奇偶性，示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jerpe6u</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-comment\"># 偶数</span>\n<span class=\"hljs-number\">5</span>  <span class=\"hljs-number\">12</span> % <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">0</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gkudhcr</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-comment\"># 奇数</span>\n<span class=\"hljs-number\">5</span>  <span class=\"hljs-number\">11</span> % <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">1</span>\n</code></pre>\n<p>有两个操作符用于除法运算。第一个是 // ，返回值为商：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/hh9fqzy</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">14</span> <span class=\"hljs-comment\">// 3</span>\n\n&gt; <span class=\"hljs-number\">4</span>\n</code></pre>\n<p>第二个是 / ，返回值为两个数相除的浮点数结果：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/zlkjjdp</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">14</span> / <span class=\"hljs-number\">3</span>\n\n&gt; <span class=\"hljs-number\">4.666666666666667</span>\n</code></pre>\n<p>还可以使用指数运算符求幂：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h8vuwd4</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>  <span class=\"hljs-number\">2</span> ** <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">4</span>\n</code></pre>\n<p>操作符两侧的值（以上示例中就是数字）被称为<strong>操作数</strong>（operand）。两个操作数和一个操作符共同构成一个<strong>表达式</strong>（expression）。程序运行时，Python 会对每个表达式求值，并返回一个值作为结果。如果在交互式 shell 中输入表达式 2 + 2，则返回结果 4。</p>\n<p><strong>运算顺序</strong>（order of operation），指的是数学计算中对表达式求值的一套规则。可使用 PEMDAS 方法，帮助记忆数学公式的运算顺序：括号（parentheses）、指数（exponents）、乘法（multiplication）、除法（division）、加法（addition）和减法（subtraction）。括号的优先级大于指数符号，后者又优先于乘法和除法，最后才是加法和减法。如果操作符的优先级相同，如 15 / 3 * 2，则按照从左到右的顺序求值。上述表达式中将 15 先除以 3，然后再乘以 2。Python 对数学表达式求值时，遵循的是同一套运算顺序：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hgjyj7o</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">2</span> * <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">6</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hsq7rcz</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  (<span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">2</span>) * <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">8</span>\n</code></pre>\n<p>在第一个示例中，2 * 2 先进行求值，因为乘法的优先级大于加法。</p>\n<p>在第二个示例中，(2 + 2) 先求值，因为 Python 总是先对括号内的表达式求值。</p>\n<h3 id=\"312\">3.12　比较操作符</h3>\n<p><strong>比较操作符</strong>（comparison operator）是 Python 中的另一种操作符。与算术操作符类似，比较操作符可用于表达式任意一侧的操作数；不同的是，带有比较操作符的表达式最后求值的结果不是 <code>True</code> 就是 <code>False</code>。详情见表 3-2。</p>\n<p>表 3-2　　</p>\n<table>\n<thead>\n<tr>\n<th>操作符</th>\n<th>含　　义</th>\n<th>示　　例</th>\n<th>运算结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&gt;</td>\n<td>大于</td>\n<td>100 &gt; 10</td>\n<td>True</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>小于</td>\n<td>100 &lt; 10</td>\n<td>False</td>\n</tr>\n<tr>\n<td>&gt;=</td>\n<td>大于或等于</td>\n<td>2 &gt;= 2</td>\n<td>True</td>\n</tr>\n<tr>\n<td>&lt;=</td>\n<td>小于或等于</td>\n<td>1 &lt;= 4</td>\n<td>True</td>\n</tr>\n<tr>\n<td>==</td>\n<td>等于</td>\n<td>6 == 9</td>\n<td>False</td>\n</tr>\n<tr>\n<td>!=</td>\n<td>不等于</td>\n<td>3 != 2</td>\n<td>True</td>\n</tr>\n</tbody>\n</table>\n<p>在含有 &gt; 操作符的表达式中，如果左侧的数字大于右侧的数字，则表达式的值为 <code>True</code>，否则即为 <code>False</code>：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jm7cxzp</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">100</span> &gt; <span class=\"hljs-number\">10</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True\n</code></pre>\n<p>在含有 &lt; 操作符的表达式中，如果左侧的数字小于右侧的数字，则表达式的值为 <code>True</code>，否则即为 <code>False</code>：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gsdhr8q</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>  <span class=\"hljs-number\">100</span> &lt; <span class=\"hljs-number\">10</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False\n</code></pre>\n<p>在含有 &gt;= 操作符的表达式中，如果左侧的大于或等于右侧的数字，则表达式的值为 <code>True</code>，否则即为 <code>False</code>：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jy2oefs</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>  <span class=\"hljs-number\">2</span> &gt;= <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True\n</code></pre>\n<p>在含有 &lt;= 操作符的表达式中，如果左侧的数字小于或等于右侧的数字，则表达式的值为 <code>True</code>，否则即为 <code>False</code>：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jk599re</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> &gt;= <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True\n</code></pre>\n<p>在含有 == 操作符的表达式中，如果左侧的数字等于右侧的数字，则表达式的值为 <code>True</code>，否则即为 <code>False</code>：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/j2tsz9u</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/j5mr2q2</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False\n</code></pre>\n<p>在含有 != 操作符的表达式中，如果左侧的数字不等于右侧的数字，则表达式的值为 <code>True</code>，否则即为 <code>False</code>：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gsw3zoe</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> != <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z7pffk3</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> != <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False\n</code></pre>\n<p>此前，如果使用 = 将数字赋值给了变量，如 x = 100。可能会将其理解为“x 等于 100”，但这是错误的。前面看到，= 是用来给变量赋值的，而不是检查相等性的操作符。因此 x = 100 应理解为“x 的值为 100”。比较操作符 == 是用于检查两侧是否相等的，因此如果看到 x == 100，含义即为“x 等于 100”。</p>\n<h3 id=\"313\">3.13　逻辑操作符</h3>\n<p><strong>逻辑操作符</strong>（logical operator）也是 Python 中的一类操作符。与比较操作符类似，逻辑操作符的求值结果也是 <code>True</code> 或 <code>False</code>。详情见表 3-3。</p>\n<p>表 3-3　　</p>\n<table>\n<thead>\n<tr>\n<th>操　作　符</th>\n<th>含　　义</th>\n<th>示　　例</th>\n<th>运算结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>and</td>\n<td>与</td>\n<td>True and True</td>\n<td>True</td>\n</tr>\n<tr>\n<td>or</td>\n<td>或</td>\n<td>True or False</td>\n<td>True</td>\n</tr>\n<tr>\n<td>not</td>\n<td>非</td>\n<td>not True</td>\n<td>False</td>\n</tr>\n</tbody>\n</table>\n<p>Python 关键字 and 可以连接两个表达式，如果二者均求值为 <code>True</code>，则返回 <code>True</code>。如果任意一个的值为 <code>False</code>，即返回 <code>False</code>：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zdqghb2</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">1</span> <strong><span class=\"hljs-keyword\">and</span></strong> <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zkp2jzy</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">2</span> <strong><span class=\"hljs-keyword\">and</span></strong> <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/honkev6</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">2</span> <strong><span class=\"hljs-keyword\">and</span></strong> <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">1</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zjrxxrc</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">1</span> <strong><span class=\"hljs-keyword\">and</span></strong> <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">1</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False</code></pre>\n<p>可以在一个语句中多次使用 <code>and</code> 关键字：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zpvk56u</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">1</span> <strong><span class=\"hljs-keyword\">and</span></strong> <span class=\"hljs-number\">10</span> != <span class=\"hljs-number\">2</span> <strong><span class=\"hljs-keyword\">and</span></strong> <span class=\"hljs-number\">2</span> &lt; <span class=\"hljs-number\">10</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<p>关键字 <code>or</code> 可连接两个或多个表达式，如果任意一个表达式的值为 <code>True</code>，即返回 <code>True</code>：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hosuh7c</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">1</span> <strong><span class=\"hljs-keyword\">or</span></strong> <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zj6q8h9</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">1</span> <strong><span class=\"hljs-keyword\">or</span></strong> <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/j8ngufo</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">2</span> <strong><span class=\"hljs-keyword\">or</span></strong> <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">1</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z728zxz</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">1</span> <strong><span class=\"hljs-keyword\">or</span></strong> <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False</code></pre>\n<p>类似地，也可以在一个语句中多次使用 <code>or</code> 关键字：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/ja9mech</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">1</span> <strong><span class=\"hljs-keyword\">or</span></strong> <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">2</span> <strong><span class=\"hljs-keyword\">or</span></strong> <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">3</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<p>该表达式的值为 <code>True</code>，因为 1 == 1 的值为 <code>True</code>，即使表达式其余的部分求值为 <code>False</code>，最终的值仍为 <code>True</code>。</p>\n<p>将关键字 <code>not</code> 放置在表达式的前面，将改变表达式的求值结果，逆转为原本结果的对立值。如果表达式原本的求值结果为 <code>True</code>，则加上 <code>not</code> 之后结果会变为 <code>False</code>：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h45eq6v</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-keyword\">not</span></strong> <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">1</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gsqj6og</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-keyword\">not</span></strong> <span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<h3 id=\"314\">3.14　条件语句</h3>\n<p>关键字 <code>if</code>、<code>elif</code> 和 <code>else</code> 用于<strong>条件语句</strong>（conditional statement）。条件语句是一种<strong>控制结构</strong>（control structure）：通过分析变量的值从而做出对应决定的代码块。条件语句是可根据条件执行额外代码的代码。为了方便理解，仔细看以下这个伪代码（pseudocode）示例（伪代码是用于解释说明示例代码的标记方法）：</p>\n<pre><code class=\"hljs php\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># 不要执行</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-keyword\">If</span> (expression) Then\n<span class=\"hljs-number\">5</span>              (code_area1)\n<span class=\"hljs-number\">6</span>  <span class=\"hljs-keyword\">Else</span>\n<span class=\"hljs-number\">7</span>              (code_area2)\n</code></pre>\n<p>上述伪代码显示，可以定义两个条件语句。如果第一个条件语句中定义的表达式为 <code>True</code>，则执行 <code>code_area1</code>；否则执行 <code>code_area2</code>。示例中的第一部分被称为 <code>if</code> 语句，第二部分为 <code>else</code> 语句。两者共同组成一个 <code>if-else</code> 语句：程序员用来表达“如果出现这种情况，则这样做，否则那样做”的方法。下面是 Python 中的 <code>if-else</code> 语句示例：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># http://tinyurl.com/htvy6g3</span>\n2\n3\n4  home = <span class=\"hljs-string\">\"America\"</span>\n5  <strong><span class=\"hljs-keyword\">if</span></strong> home == <span class=\"hljs-string\">\"America\"</span>:\n6      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, America!\"</span>)\n7  <strong><span class=\"hljs-keyword\">else</span></strong>:\n8      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n\n&gt;&gt; Hello, America!</code></pre>\n<p>第 5 行和第 6 行共同组成了 <code>if</code> 语句。一个 <code>if</code> 语句中，包括一行以 <code>if</code> 关键字开头的代码行，<code>if</code> 关键字之后是一个表达式，还有冒号、缩进，以及一行或多行如果表达式为 <code>True</code> 的情况下将执行的代码。第 7 行和第 8 行共同组成了 <code>else</code> 语句。一个 <code>else</code> 语句的开头是 <code>else</code> 关键字，然后是冒号、缩进，以及一行或多行如果 <code>if</code> 语句中表达式为 <code>False</code> 时将执行的代码。</p>\n<p>二者共同组成了一个 <code>if-else</code> 语句。本例的打印输出结果为 <code>Hello, America!</code>，因为 <code>if</code> 语句中的表达式结果为 <code>True</code>。如果将变量 <code>home</code> 的值修改为 <code>Canada</code>，则 <code>if</code> 语句中的表达式结果为 <code>False</code>，将会执行 <code>else</code> 语句中的代码，程序会打印出 <code>Hello, World!</code>。</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># http://tinyurl.com/jytyg5x</span>\n2\n3\n4  home = <span class=\"hljs-string\">\"Canada\"</span>\n5  <strong><span class=\"hljs-keyword\">if</span></strong> home ==<strong> </strong><span class=\"hljs-string\">\"America\"</span>:\n6      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, America!\"</span>)\n7  <strong><span class=\"hljs-keyword\">else</span></strong>:\n8      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n\n&gt;&gt; Hello, World!</code></pre>\n<p>可以单独使用一个 <code>if</code> 语句：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jyg7dd2</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  home = <span class=\"hljs-string\">\"America\"</span>\n<span class=\"hljs-number\">5</span>  <strong><span class=\"hljs-keyword\">if</span></strong> home == <span class=\"hljs-string\">\"America\"</span>:\n<span class=\"hljs-number\">6</span>      print(<span class=\"hljs-string\">\"Hello, America!\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> Hello, America!</code></pre>\n<p>也可以连续使用多个 <code>if</code> 语句：</p>\n<pre class=\"代码无行号\"><code class=\"hljs coffeescript\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z24ckye</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  x = <span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">05</span>  <strong><span class=\"hljs-keyword\">if</span></strong> x == <span class=\"hljs-number\">2</span>:\n<span class=\"hljs-number\">06</span>      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"The number is 2.\"</span>)\n<span class=\"hljs-number\">07</span>  <strong><span class=\"hljs-keyword\">if</span></strong> x % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>:\n<span class=\"hljs-number\">08</span>      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"The number is even.\"</span>)\n<span class=\"hljs-number\">09</span>  <strong><span class=\"hljs-keyword\">if</span></strong> x % <span class=\"hljs-number\">2</span> != <span class=\"hljs-number\">0</span>:\n<span class=\"hljs-number\">10</span>      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"The number is odd.\"</span>)\n\n&gt;&gt; The number <span class=\"hljs-keyword\">is</span> <span class=\"hljs-number\">2.</span>\n&gt;&gt; The number <span class=\"hljs-keyword\">is</span> even.</code></pre>\n<p>每个 <code>if</code> 语句只有在其表达式求值为 <code>True</code> 时，才会执行所有的代码。在本例中，前两个表达式的求值结果为 <code>True</code>，因此各自的代码都执行了，但是第 3 个表达式的结果为 <code>False</code>，所以没有执行。</p>\n<p>如果愿意，甚至还可以在 <code>if</code> 语句中再加入一个 <code>if</code> 语句（通常称之为嵌套）：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zrodgne</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  x = <span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">05</span>  y = <span class=\"hljs-number\">11</span>\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>\n08  <strong><span class=\"hljs-keyword\">if</span></strong> x == <span class=\"hljs-number\">10</span>:\n09      <strong><span class=\"hljs-keyword\">if</span></strong> y == <span class=\"hljs-number\">11</span>:\n<span class=\"hljs-number\">10</span>          print(x + y)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">21</span></code></pre>\n<p>在本例中，只有在两个 <code>if</code> 语句的结果均为 <code>True</code> 时，才会打印 <code>x + y</code>。<code>else</code> 语句无法被单独使用，只能用在 <code>if-else</code> 语句的最后一部分。</p>\n<p>也可以使用 <code>elif</code> 关键字创建 <code>elif</code> 语句。<code>elif</code> 表示另外如果，该语句可无限添加到 <code>if-else</code> 语句中，使其支持更多的决策。</p>\n<p>如果一个 <code>if-else</code> 语句中包含有 <code>elif</code> 语句，则首先判断 <code>if</code> 语句。如果该语句中的表达式为 <code>True</code>，则只执行其中的代码。但是，如果其值为 <code>False</code>，每个之后的 <code>elif</code> 语句都将进行求值。只要有一个 <code>elif</code> 语句中的表达式结果为 <code>True</code>，则执行其中的代码并退出。如果没有任何一个 <code>elif</code> 语句的结果为 <code>True</code>，则执行 <code>else</code> 语句中的代码。下面是一个包含有 <code>elif</code> 语句的 <code>if-else</code> 语句示例：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">01  <span class=\"hljs-comment\"># http://tinyurl.com/jpr265j</span>\n02\n03\n04  home = <span class=\"hljs-string\">\"Thailand\"</span>\n05  <strong><span class=\"hljs-keyword\">if</span></strong> home == <span class=\"hljs-string\">\"Japan\"</span>:\n06      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"Hello, Japan!\"</span>)\n07  <strong><span class=\"hljs-keyword\">elif</span></strong> home == <span class=\"hljs-string\">\"Thailand\"</span>:\n08      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"Hello, Thailand!\"</span>)\n09  <strong><span class=\"hljs-keyword\">elif</span></strong> home == <span class=\"hljs-string\">\"India\"</span>:\n10      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, India!\"</span>)\n11  <strong><span class=\"hljs-keyword\">elif</span></strong> home == <span class=\"hljs-string\">\"China\"</span>:\n12      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, China!\"</span>)\n13  <strong><span class=\"hljs-keyword\">else</span></strong>:\n14      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n\n&gt;&gt; Hello, Thailand!</code></pre>\n<p>下面这个示例中，所有的 <code>elif</code> 语句求值结果均不为 <code>True</code>，最后执行的是 <code>else</code> 语句中的代码。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">01  <span class=\"hljs-comment\"># http://tinyurl.com/zdvuuhs</span>\n02\n03  home = <span class=\"hljs-string\">\"Mars\"</span>\n04  <strong><span class=\"hljs-keyword\">if</span></strong> home == <span class=\"hljs-string\">\"America\"</span>:\n05      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"Hello, America!\"</span>)\n06  <strong><span class=\"hljs-keyword\">elif</span></strong> home == <span class=\"hljs-string\">\"Canada\"</span>:\n07      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"Hello, Canada!\"</span>)\n08  <strong><span class=\"hljs-keyword\">elif</span></strong> home == <span class=\"hljs-string\">\"Thailand\"</span>:\n09      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, Thailand!\"</span>)\n10  <strong><span class=\"hljs-keyword\">elif</span></strong> home == <span class=\"hljs-string\">\"Mexico\"</span>:\n11      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, Mexico!\"</span>)\n12  <strong><span class=\"hljs-keyword\">else</span></strong>:\n13      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n\n&gt;&gt; Hello, World! </code></pre>\n<p>最后，可以连续使用多个 <code>if</code> 语句和 <code>elif</code> 语句：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">01  <span class=\"hljs-comment\"># http://tinyurl.com/hzyxgf4</span>\n02\n03\n04  x = 100\n05  <strong><span class=\"hljs-keyword\">if</span></strong> x == 10:\n06      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"10!\"</span>)\n07  <strong><span class=\"hljs-keyword\">elif</span></strong> x == 20:\n08      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"20!\"</span>)\n09  <strong><span class=\"hljs-keyword\">else</span></strong>:\n10      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"I don't know!\"</span>)\n11\n12\n13  <strong><span class=\"hljs-keyword\">if</span></strong> x == 100:\n14      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"x is 100!\"</span>)\n15\n16\n17  <strong><span class=\"hljs-keyword\">if</span></strong> x % 2 == 0:\n18      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"x is even!\"</span>)\n19<strong>  <span class=\"hljs-keyword\">else</span></strong>:\n20      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"x is odd!\"</span>)\n\n&gt;&gt; I don<span class=\"hljs-string\">'t know!\n&gt;&gt; x is 100!\n&gt;&gt; x is even!</span></code></pre>\n<h3 id=\"315\">3.15　语句</h3>\n<p><strong>语句</strong>（statement）这个术语可用来描述 Python 语言的多种构成部分。可以将一个 Python 语句视作一个命令或计算。本节将详细介绍语句的语法。如果感觉部分内容初次学起来很难懂，也不用太担心，随着练习 Python 的时间变长，你就会慢慢理解。</p>\n<p>Python 中有两类语句：<strong>简单语句</strong>（simple statement）和<strong>复合语句</strong>（compound statement）。简单语句一般就是一行代码，而复合语句通常包括多行代码。下面是一些简单语句的示例：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jrowero</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  print(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> Hello, World!\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h2y549y</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">4</span>\n</code></pre>\n<p><code>if</code> 语句和 <code>if-else</code> 语句，以及本章编写的第一个程序（打印 <code>Hello, World!</code> 100 次）都是复合语句。</p>\n<p>复合语句由一个或多个<strong>从句</strong>（clause）组成。从句包括两行或多行代码：<strong>代码头</strong>（header）及紧随其后的<strong>配套代码</strong>（suite）。代码头指的是从句中包含关键字的那行代码，之后是一个冒号和一行或多行带缩进的代码。缩进之后，是一个或多个配套代码。配套代码就是从句中一行普通的代码。代码头控制配套代码的执行。打印 <code>Hello, World!</code> 100 次的程序，就是由一个复合语句组成。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zfz3eel</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>  <strong><span class=\"hljs-keyword\">for</span></strong> i <strong><span class=\"hljs-keyword\">in</span></strong> range(<span class=\"hljs-number\">100</span>):\n<span class=\"hljs-number\">4</span>      print(<span class=\"hljs-string\">\"Hello, World!\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> Hello, World!\n&gt;&gt; Hello, World!\n&gt;&gt; Hello, World!\n…</code></pre>\n<p>程序的第一行是代码头，包括关键字 <code>for</code>，之后是冒号。缩进之后是配套代码 <code>print(\"Hello, World!\")</code>。在上述示例中，代码头通过配套代码打印 <code>Hello, World!</code> 100 次，这是一个循环，将在第 7 章详细介绍。上述代码只有一个从句。</p>\n<p>复合语句可以由多个从句构成，你前面看到的 <code>if-else</code> 语句就是复合语句。<code>if</code> 语句之后如果带有一个 <code>else</code> 语句，就构成了一个由多个从句组成的复合语句。在包含多个从句的复合语句中，代码头从句共同控制代码执行。对于 <code>if-else</code> 语句，当 <code>if</code> 语句的值为 <code>True</code> 时，则执行 <code>if</code> 语句的配套代码，<code>else</code> 语句的配套代码不执行；当 <code>if</code> 语句的值为 <code>False</code> 时，则不执行 <code>if</code> 语句的配套代码，转而执行 <code>else</code> 语句的配套代码。上一节中的最后一个示例包含了 3 个复合语句：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">01  <span class=\"hljs-comment\"># http://tinyurl.com/hpwkdo4</span>\n02\n03\n04  x = 100\n05  <strong><span class=\"hljs-keyword\">if</span></strong> x == 10:\n06      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"10!\"</span>)\n07  <strong><span class=\"hljs-keyword\">elif</span></strong> x == 20:\n08      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"20!\"</span>)\n09  <strong><span class=\"hljs-keyword\">else</span></strong>:\n10      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"I don't know!\"</span>)\n11\n12\n13  <strong><span class=\"hljs-keyword\">if</span></strong> x == 100:\n14      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"x is 100!\"</span>)\n15\n16\n17  <strong><span class=\"hljs-keyword\">if</span></strong> x % 2 == 0:\n18      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"x is even!\"</span>)\n19  <strong><span class=\"hljs-keyword\">else</span></strong>:\n20      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"x is odd!\"</span>)\n\n&gt;&gt; I don<span class=\"hljs-string\">'t know!\n&gt;&gt; x is 100!\n&gt;&gt; x is even!</span></code></pre>\n<p>第一个复合语句中有 3 个从句，第二个里有一个从句，最后一个则有两个从句。</p>\n<p>关于语句还有一点要注意，语句之间是可以有空格的，这不会影响代码的执行。空格有时被用来提高代码的可读性。</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zlgcwoc</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  print(<span class=\"hljs-string\">\"Michael\"</span>)\n<span class=\"hljs-number\">05</span>\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>\n08\n09\n<span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">11</span>  print(<span class=\"hljs-string\">\"Jordan\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> Michael\n<span class=\"hljs-meta\">&gt;&gt;</span> Jordan\n</code></pre>\n<h3 id=\"316\">3.16　术语表</h3>\n<p><strong>注释</strong>：用英文或其他自然语言写的一行（或一部分）代码，行首均有一个特殊标志告知编程语言忽略这行代码。</p>\n<p><strong>关键字</strong>：编程语言中具有特殊意义的词。可在 http://theselftaughtprogrammer.io/keywords 网页中查看所有 Python 的关键字。</p>\n<p><strong>数据类型</strong>：数据所属的类别。</p>\n<p><strong>对象</strong>：Python 中具有 3 个属性的数据值——唯一标识、数据类型和值。</p>\n<p><strong>Str</strong>：字符串的数据类型。</p>\n<p><strong>字符</strong>：a 或 l 等单个符号。</p>\n<p><strong>Int</strong>：整数的数据类型。</p>\n<p><strong>整型数据</strong>：数据类型为 int 的对象，其值为一个整数。</p>\n<p><strong>Float</strong>：小数的数据类型。</p>\n<p><strong>浮点数</strong>：数据类型为 <code>float</code> 的对象，其值为一个小数。</p>\n<p><strong>Bool</strong>：布尔对象的数据类型。</p>\n<p><strong>布尔值</strong>：数据类型为 <code>bool</code> 的对象，其值为 <code>True</code> 或 <code>False</code>。</p>\n<p><strong>NoneType</strong>：<code>None</code> 对象的数据类型。</p>\n<p><strong>None</strong>：数据类型为 <code>NoneType</code> 的对象，其值永远为 <code>None</code>。</p>\n<p><strong>常量</strong>：不会改变的值。</p>\n<p><strong>变量</strong>：使用赋值操作符赋予了一个值的名称。</p>\n<p><strong>赋值操作符</strong>：Python 中的 <code>=</code> 符号。</p>\n<p><strong>增加</strong>：增加一个变量的值。</p>\n<p><strong>减少</strong>：减少一个变量的值。</p>\n<p><strong>语法</strong>：规范一门语言中句子结构，尤其是字词顺序的一整套规则及流程。</p>\n<p><strong>语法错误</strong>：违反编程语言的语法，所导致的致命编程错误。</p>\n<p><strong>异常</strong>：非致命的编程错误。</p>\n<p><strong>操作符</strong>：在表达式中与操作符一起使用的符号。</p>\n<p><strong>算术操作符</strong>：数学表达式中使用的一类操作符。</p>\n<p><strong>操作数</strong>：操作符两侧的值。</p>\n<p><strong>表达式</strong>：操作符及两个操作数构成的代码。</p>\n<p><strong>运算顺序</strong>：数学计算中用来对表达式求值的一组规则。</p>\n<p><strong>比较操作符</strong>：表达式中用到的一类操作符，求值结果为 <code>True</code> 或 <code>False</code>。</p>\n<p><strong>逻辑操作符</strong>：对两个表达式求值的一类操作符，求值结果为 <code>True</code> 或 <code>False</code>。</p>\n<p><strong>条件语句</strong>：根据条件执行不同代码的代码。</p>\n<p><strong>控制结构</strong>：通过分析变量的值，来决定代码如何执行的代码块。</p>\n<p><strong>伪代码</strong>：用来演示逻辑的标记方法，与代码类似。</p>\n<p><strong>if-else 语句</strong>：程序员用来表达“如果出现这种情况，则这样做，否则那样做”的方法。</p>\n<p><strong>if 语句</strong>：<code>if-else</code> 语句的第一部分。</p>\n<p><strong>else 语句</strong>：<code>if-else</code> 语句的第二部分。</p>\n<p><strong>语句</strong>：一个命令或计算。</p>\n<p><strong>简单语句</strong>：可用一行代码表述的语句。</p>\n<p><strong>复合语句</strong>：通常包括多行代码的语句。</p>\n<p><strong>从句</strong>：复合语句的组成部分；一个从句由两行或多行代码构成，包括代码头及配套代码。</p>\n<p><strong>代码头</strong>：从句中包含关键字的那行代码，之后是一个冒号和一行或多行带缩进的代码。</p>\n<p><strong>配套代码</strong>：从句中由代码头控制的代码。</p>\n<h3 id=\"317\">3.17　挑战练习</h3>\n<p>1．请打印 3 个不同的字符串。</p>\n<p>2．编写程序：如果变量的值小于 10，打印一条消息；如果大于或等于 10，则打印不同的消息。</p>\n<p>3．编写程序：如果变量的值小于或等于 10，打印一条消息；如果大于 10 且小于或等于 25，则打印一条不同的消息；如果大于 25，则打印另一条不同的消息。</p>\n<p>4．编写一个将两个变量相除，并打印余数的程序。</p>\n<p>5．编写一个将两个变量相除，并打印商的程序。</p>\n<p>6．编写程序：为变量 age 赋予一个整数值，根据不同的数值打印不同的字符串说明。</p>\n<p>答案可从异步社区（www.epubit.com）本书详情页的配套资源中下载。</p></div></article>\n</body>\n</html>"},{"title":"函数","_content":"\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>函数</title>\n</head>\n<body>\n<article id=\"articleDiv\"><div class=\"mazi-article-content dont-break-out\"><p></p><div class=\"toc\">\n<ul>\n<li><ul>\n<li><ul>\n<li><a href=\"#41\">4.1　表达概念</a></li>\n<li><a href=\"#42\">4.2　函数</a></li>\n<li><a href=\"#43\">4.3　定义函数</a></li>\n<li><a href=\"#44\">4.4　内置函数</a></li>\n<li><a href=\"#45\">4.5　复用函数</a></li>\n<li><a href=\"#46\">4.6　必选及可选参数</a></li>\n<li><a href=\"#47\">4.7　作用域</a></li>\n<li><a href=\"#48\">4.8　异常处理</a></li>\n<li><a href=\"#49\">4.9　文档字符串</a></li>\n<li><a href=\"#410\">4.10　有需要才使用变量</a></li>\n<li><a href=\"#411\">4.11　术语表</a></li>\n<li><a href=\"#412\">4.12　挑战练习</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>\n<p></p>\n<blockquote>\n  <p><span style=\"font-family: Times New Roman,楷体_GB2312\">“函数应该做一件事。做好这件事。只能做这一件事。”</span></p>\n  <p><span style=\"font-family: Times New Roman,楷体_GB2312\">——罗伯特 · C. 马丁（Robert C.Martin）</span></p>\n</blockquote>\n<p>本章将介绍<strong>函数（function）</strong>：可接受输入，执行指令并返回输出的复合语句。通过函数，我们可以在程序中定义功能，并重复使用。其示例如图 4-1 所示。</p>\n<p><img src=\"https://images.gitbook.cn/8f24fa40-6fc0-11e9-9e1b-5b6158413fa5\" alt=\"enter image description here\"></p>\n<p>图 4-1　函数</p>\n<h3 id=\"41\">4.1　表达概念</h3>\n<p>从此处开始，本书将在解释编程概念时使用一种新<strong>约定</strong>（convention）（一种共同认同的方式）。例如，通过 <code>print(\"[想打印的内容]\")</code> 来介绍如何使用 print 函数。</p>\n<p>新约定中结合使用了 Python 代码和方括号，方括号中的描述用来解释编程概念。当给出类似示例时，除了方括号及其中的内容之外，其他所有都是有效的 Python 代码。方括号中的内容隐含了你应该使用何种代码进行替换。Python 语法中也有使用方括号，因此在代码中本该应用方括号的处置将使用两个方括号体现。</p>\n<h3 id=\"42\">4.2　函数</h3>\n<p><strong>调用</strong>（call）一个函数，意味着为函数提供执行指令并返回输出所需的输入。函数的每一个输入就是一个<strong>参数</strong>（parameter）。当你为函数提供参数时，则被称为“函数传参”。</p>\n<p>Python 中的函数类似于数学函数。如果忘记了代数中的函数，请看下面这个示例：</p>\n<pre><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># 请不要运行代码</span>\n2\n3\n4\n5  f(x) = x * 2\n</code></pre>\n<p>上面代码中语句左侧定义了一个函数 <code>f</code>，接受一个参数 <code>x</code>。语句右侧是函数的具体定义，利用 <code>(x)</code> 中传递的参数进行计算并返回结果（输出）。本例中，函数的值被定义为函数的参数乘以 2。</p>\n<p>Python 和代数均使用如下语法调用函数：<code>[函数名]([逗号分隔的参数])</code>。在函数名后加上圆括号即可进行调用，参数放置在圆括号中，以逗号分隔。对于 <code>f(x) = x * 2</code> 这个数学函数，<code>f(2)</code> 的值是 4，<code>f(10)</code> 的值是 20。</p>\n<h3 id=\"43\">4.3　定义函数</h3>\n<p>在 Python 中创建一个函数，需要选择函数名，并定义其参数、行为和返回值。下面是定义函数的语法：</p>\n<pre class=\"代码无行号\"><code class=\"hljs markdown\">1  # 请不要执行代码\n2\n3\n4\n5  <strong>def</strong> [<span class=\"hljs-string\">函数名</span>](<span class=\"hljs-link\">[参数]</span>):\n6      [函数定义]</code></pre>\n<p>数学函数 f(x) = x * 2 在 Python 中应该表示如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/j9dctwl</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(x)</span>:</span>\n<span class=\"hljs-number\">5</span>      <strong><span class=\"hljs-keyword\">return</span></strong> x * <span class=\"hljs-number\">2</span></code></pre>\n<p>关键字 <code>def</code> 告诉 Python 操作者正在定义一个函数。在 <code>def</code> 关键字后面，指定函数的名称，名称选择遵循与变量名相同的规则。按惯例，函数名不应使用大写字母，单词用下划线分隔：<code>like_this</code>。</p>\n<p>命名函数之后，在名称后加上一对圆括号，圆括号中则是希望函数接受的参数。</p>\n<p>在圆括号之后加入冒号，然后换行并缩进 4 个空格符（和其他复合语句一样）。冒号之后所有缩进 4 个空格符的代码，就是函数的定义。本例中，函数的定义仅有一行，即 <code>return x * 2</code>。关键字 <code>return</code> 指定了调用函数时输出的值，我们称之为函数的返回值。</p>\n<p>在 Python 中，可以使用语法“<code>[函数名]([逗号分隔的参数])</code>”来调用一个函数。以下就是以 2 作为参数调用上述示例中函数 <code>f</code> 的示例：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># http://tinyurl.com/zheas3d</span>\n2\n3\n4  <span class=\"hljs-comment\"># 接上一个示例</span>\n5\n6\n7\n8  f(2)</code></pre>\n<p>控制台没有打印任何输出。你可以将函数的输出保存在一个变量中，然后将其传给 <code>print</code> 函数。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gspjcgj</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-comment\"># 接上一个示例</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  result = f(<span class=\"hljs-number\">2</span>)\n<span class=\"hljs-number\">9</span>  print(result)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">4</span></code></pre>\n<p>如果后面在程序中有需要使用函数返回值的地方，建议将函数的返回值保存到一个变量中。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs python\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/znqp8fk</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(x)</span>:</span>\n<span class=\"hljs-number\">05</span>      <strong><span class=\"hljs-keyword\">return</span></strong> x + <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>\n<span class=\"hljs-number\">08</span>  z = f(<span class=\"hljs-number\">4</span>)\n<span class=\"hljs-number\">09</span>\n<span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">11</span>  <strong><span class=\"hljs-keyword\">if</span></strong> z == <span class=\"hljs-number\">5</span>:\n<span class=\"hljs-number\">12</span>      <strong>print</strong>(<span class=\"hljs-string\">\"z is 5\"</span>)\n<span class=\"hljs-number\">13</span>  <strong><span class=\"hljs-keyword\">else</span></strong>:\n<span class=\"hljs-number\">14</span>      print(<span class=\"hljs-string\">\"z is not 5\"</span>)\n\n&gt;&gt; z <span class=\"hljs-keyword\">is</span> <span class=\"hljs-number\">5</span></code></pre>\n<p>函数可以有一个或多个参数，也可以不接受任何参数。如要定义不需要参数的函数，只需要在定义函数时把圆括号内置为空即可：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/htk7tr6</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span></span>:\n<span class=\"hljs-number\">5</span>      <strong><span class=\"hljs-keyword\">return</span></strong> <span class=\"hljs-number\">1</span> + <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  result = f()\n<span class=\"hljs-number\">9</span>  print(result)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">2</span></code></pre>\n<p>如要函数要接受多个参数，则必须将圆括号中的参数以逗号相隔：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gqmkft7</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(x, y, z)</span></span>:\n<span class=\"hljs-number\">5</span>      <strong><span class=\"hljs-keyword\">return</span></strong> x + y + z\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  result = f(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>)\n<span class=\"hljs-number\">9</span>  print(result)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">6</span></code></pre>\n<p>最后，函数必须包含 <code>return</code> 语句。如果函数没有 <code>return</code> 语句，则会返回 <code>None</code>。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/j8qyqov</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span>:</span>\n<span class=\"hljs-number\">5</span>      z = <span class=\"hljs-number\">1</span> + <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  result = f()\n<span class=\"hljs-number\">9</span>  print(result)\n\n&gt;&gt; <span class=\"hljs-keyword\">None</span></code></pre>\n<h3 id=\"44\">4.4　内置函数</h3>\n<p>Python 编程语言中自带了一个被称为<strong>内置函数</strong>（builtin function）的函数库，它可执行各式各样的计算和任务，而不需任何额外的工作。在前面已经看到过一个内置函数的例子：我们编写的第一个程序就使用了 <code>print</code> 函数打印 <code>\"Hello, World!\"</code>。</p>\n<p>len 也是一个内置函数，表示返回对象的长度，如字符串的长度（字符的数量）。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zfkzqw6</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  len(<span class=\"hljs-string\">\"Monty\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">5</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h75c3cf</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  len(<span class=\"hljs-string\">\"Python\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">6</span>\n</code></pre>\n<p>内置函数 <code>str</code> 接受一个对象作为参数，并返回一个数据类型为 <code>str</code> 的新对象。例如，可使用 <code>str</code> 将一个整型数据转换成一个字符串。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/juzxg2z</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  str(<span class=\"hljs-number\">100</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'100'</span>\n</code></pre>\n<p><code>int</code> 函数可接受一个对象作为参数，并返回一个整型对象。示例如下：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/j42qhkf</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-keyword\">int</span>(<span class=\"hljs-string\">\"1\"</span>)\n\n&gt;&gt; <span class=\"hljs-number\">1</span>\n</code></pre>\n<p><code>float</code> 函数可接受一个对象作为参数，并返回一个浮点数对象。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hnk8gh2</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  fload(<span class=\"hljs-number\">100</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">100.0</span>\n</code></pre>\n<p>传给 <code>str</code>、<code>int</code> 或 <code>float</code> 函数的参数，必须要能够转换为字符串、整数或浮点数。<code>str</code> 函数可接受大部分对象作为参数，但是 <code>int</code> 函数只能接受内容为数字的字符串或浮点数对象。<code>float</code> 函数只能接受内容为数字的字符串或整型对象。具体示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jcchmlx</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  int(<span class=\"hljs-string\">\"110\"</span>)\n<span class=\"hljs-number\">5</span>  int(<span class=\"hljs-number\">20.54</span>)\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  float(<span class=\"hljs-string\">\"16.4\"</span>)\n<span class=\"hljs-number\">9</span>  float(<span class=\"hljs-number\">99</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">100</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">20</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">16.4</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">99.0</span>\n</code></pre>\n<p>如果向 <code>int</code> 或 <code>float</code> 函数中传递的是无法转换为整数或浮点数的参数，Python 将会报出异常错误如下：</p>\n<pre><code class=\"hljs perl\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zseo21s</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-keyword\">int</span>(<span class=\"hljs-string\">\"Prince\"</span>)\n\n&gt;&gt; ValueError: invalid literal <span class=\"hljs-keyword\">for</span> <span class=\"hljs-keyword\">int</span>() with base <span class=\"hljs-number\">10</span>: <span class=\"hljs-string\">'Prince'</span>\n</code></pre>\n<p>使用内置函数 <code>input</code> 收集用户的信息的示例代码如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs perl\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zynprpg</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  age = input(<span class=\"hljs-string\">\"Enter your age:\"</span>)\n<span class=\"hljs-number\">5</span>  int_age = <span class=\"hljs-keyword\">int</span>(age)\n<span class=\"hljs-number\">6</span>  <strong><span class=\"hljs-keyword\">if</span></strong> int_age &lt; <span class=\"hljs-number\">21</span>:\n<span class=\"hljs-number\">7</span>      <span class=\"hljs-keyword\">print</span>(<span class=\"hljs-string\">\"You are young!\"</span>)\n<span class=\"hljs-number\">8</span>  <strong><span class=\"hljs-keyword\">else</span></strong>:\n<span class=\"hljs-number\">9</span>      <span class=\"hljs-keyword\">print</span>(<span class=\"hljs-string\">\"Wow, you are old!\"</span>)\n\n&gt;&gt; Enter your age:</code></pre>\n<p><code>input</code> 函数接受一个字符串作为参数，并将其展示给使用该程序的用户。用户在 shell 中输入回答，程序将回答保存在变量 <code>age</code> 中。</p>\n<p>接下来，使用 <code>int</code> 函数将 <code>age</code> 变量的值从字符串转换为整数。<code>input</code> 函数从用户收集数据以作为 <code>str</code>，但是需要将变量设为 <code>int</code> 才能与其他整数进行比较。转换为整数后，<code>if-else</code> 语句根据用户的输入决定为用户打印什么信息。如果用户输入的数字小于 21，则打印“<code>You are young!”</code>。如果用户输入的数字大于 21，则打印“<code>Wow, you are old!”</code>。</p>\n<h3 id=\"45\">4.5　复用函数</h3>\n<p>函数不仅可用于计算并返回值，还可以封装我们希望复用的功能。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zhy8y4m</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">even_odd</span><span class=\"hljs-params\">(x)</span></span>:\n<span class=\"hljs-number\">05</span>      <strong><span class=\"hljs-keyword\">if</span></strong> x % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>:\n<span class=\"hljs-number\">06</span>          print(<span class=\"hljs-string\">\"even\"</span>)\n<span class=\"hljs-number\">07</span>      <strong><span class=\"hljs-symbol\">else</span></strong><span class=\"hljs-symbol\">:</span>\n08          print(<span class=\"hljs-string\">\"odd\"</span>)\n09\n<span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">11</span>  even_odd(<span class=\"hljs-number\">2</span>)\n<span class=\"hljs-number\">12</span>  even_odd(<span class=\"hljs-number\">3</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> even\n<span class=\"hljs-meta\">&gt;&gt;</span> odd</code></pre>\n<p>这里虽然没有定义函数的返回值，但是该函数还是有用的：它检测 <code>x % 2 == 0</code> 是否为真，并打印 <code>x</code> 是奇数还是偶数。</p>\n<p>因为可以对函数进行复用，所以利用函数可以减少代码量。一个未使用函数的示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs perl\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jk8lugl</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  n = input(<span class=\"hljs-string\">\"type a number:\"</span>)\n<span class=\"hljs-number\">05</span>  n = <span class=\"hljs-keyword\">int</span>(n)\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>\n08  <strong><span class=\"hljs-keyword\">if</span></strong> n % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>:\n09      <span class=\"hljs-keyword\">print</span>(<span class=\"hljs-string\">\"n is even.\"</span>)\n<span class=\"hljs-number\">10</span>  <strong><span class=\"hljs-keyword\">else</span></strong>:\n<span class=\"hljs-number\">11</span>      <strong><span class=\"hljs-keyword\">print</span></strong>(<span class=\"hljs-string\">\"n is odd.\"</span>)\n<span class=\"hljs-number\">12</span>\n<span class=\"hljs-number\">13</span>\n<span class=\"hljs-number\">14</span>  n = input(<span class=\"hljs-string\">\"type a number:\"</span>)\n<span class=\"hljs-number\">15</span>  n = <span class=\"hljs-keyword\">int</span>(n)\n<span class=\"hljs-number\">16</span>  <strong><span class=\"hljs-keyword\">if</span></strong> n % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>:\n<span class=\"hljs-number\">17</span>      <span class=\"hljs-keyword\">print</span>(<span class=\"hljs-string\">\"n is even.\"</span>)\n<span class=\"hljs-number\">18</span>  <strong><span class=\"hljs-keyword\">else</span></strong>:\n<span class=\"hljs-number\">19</span>      <span class=\"hljs-keyword\">print</span>(<span class=\"hljs-string\">\"n is odd.\"</span>)\n<span class=\"hljs-number\">20</span>\n<span class=\"hljs-number\">21</span>\n<span class=\"hljs-number\">22</span>  n = input(<span class=\"hljs-string\">\"type a number:\"</span>)\n<span class=\"hljs-number\">23</span>  n = <span class=\"hljs-keyword\">int</span>(n)\n<span class=\"hljs-number\">24</span>  <strong><span class=\"hljs-keyword\">if</span></strong> n % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>:\n<span class=\"hljs-number\">25</span>      <span class=\"hljs-keyword\">print</span>(<span class=\"hljs-string\">\"n is even.\"</span>)\n<span class=\"hljs-number\">26</span>  <strong><span class=\"hljs-keyword\">else</span></strong>:\n<span class=\"hljs-number\">27</span>      <span class=\"hljs-keyword\">print</span>(<span class=\"hljs-string\">\"n is odd.\"</span>)\n\n&gt;&gt; type a number:</code></pre>\n<p>上面这个程序让用户 3 次输入数字，然后通过 <code>if-else</code> 语句检查数字是否为偶数。如果为偶数，则打印“<code>n is even.”</code>，否则打印“<code>n is odd.”</code>。</p>\n<p>这个程序的问题在于相同的代码重复了 3 次。如果将功能封装在函数中，再调用函数 3 次，则可以大幅减少程序的代码量，并提高可读性。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs python\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zzn22mz</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">even_odd</span><span class=\"hljs-params\">()</span>:</span>\n<span class=\"hljs-number\">05</span>      n = input(<span class=\"hljs-string\">\"type a number:\"</span>)\n<span class=\"hljs-number\">06</span>      n = int(n)\n<span class=\"hljs-number\">07</span>      <strong><span class=\"hljs-keyword\">if</span></strong> n % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>:\n<span class=\"hljs-number\">08</span>          print(<span class=\"hljs-string\">\"n is even.\"</span>)\n<span class=\"hljs-number\">09</span>      <strong><span class=\"hljs-keyword\">else</span></strong>:\n<span class=\"hljs-number\">10</span>          print(<span class=\"hljs-string\">\"n is odd.\"</span>)\n<span class=\"hljs-number\">11</span>\n<span class=\"hljs-number\">12</span>\n<span class=\"hljs-number\">13</span>  even_odd()\n<span class=\"hljs-number\">14</span>  even_odd()\n<span class=\"hljs-number\">15</span>  even_odd()\n\n&gt;&gt; type a number:</code></pre>\n<p>新程序的功能与前一个程序完全相同，但是由于将功能封装在了一个可随时按需调用的函数中，代码量大幅减少，可读性大大提升。</p>\n<h3 id=\"46\">4.6　必选及可选参数</h3>\n<p>函数可接受两种参数。目前所看到的都是<strong>必选参数</strong>（required parameter）。当用户调用函数时，必须传入所有必选参数，否则 Python 将报告异常错误。</p>\n<p>Python 中还有另一种参数，即<strong>可选参数</strong>（optional parameter）。函数只在需要时才会传入，并不是执行程序所必须的。如果没有传入可选参数，函数将使用其默认值。使用如下语法定义可选参数：<code>[函数名]([参数名]=[参数值])</code>。与必选参数一样，可选参数也得使用逗号分隔。一个带可选参数的函数示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h3ych4h</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(x=<span class=\"hljs-number\">2</span>)</span></span>:\n<span class=\"hljs-number\">5</span>      <strong><span class=\"hljs-keyword\">return</span></strong> x ** x\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  print(f())\n<span class=\"hljs-number\">9</span>  print(f(<span class=\"hljs-number\">4</span>))\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">4</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">256</span></code></pre>\n<p>首先，这里没有传入参数而是直接调用函数。因为参数是可选的，<code>x</code> 自动获得值为 2，函数返回 4。</p>\n<p>接下来，传入参数 4 并调用函数。函数没有使用默认值，<code>x</code> 获得值为 4，函数返回 256。你可以定义一个既有必选参数也有可选参数的函数，但是必选参数必须位于可选参数之前。</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hm5svn9</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">add_it</span><span class=\"hljs-params\">(x, y=<span class=\"hljs-number\">10</span>)</span></span>:\n<span class=\"hljs-number\">5</span>      <strong><span class=\"hljs-keyword\">return</span></strong> x + y\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  result = add_it(<span class=\"hljs-number\">2</span>)\n<span class=\"hljs-number\">9</span>  print(result)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">12</span></code></pre>\n<h3 id=\"47\">4.7　作用域</h3>\n<p>变量有一个很重要的属性，<strong>作用域</strong>（scope）。定义变量时，其作用域指的是哪部分程序可以对其进行读写。读取一个变量意味着获取它的值，写变量意味着修改它的值。变量的作用域由其定义在程序中所处的位置决定。</p>\n<p>如果在函数（或类，本书第二部分将介绍）之外定义了一个变量，则变量拥有<strong>全局作用域</strong>（global scope）：即在程序中任意地方都可以对其进行读写操作。带有全局作用域的变量，被称为<strong>全局变量</strong>（global variable）。如果在函数（或类）内部定义一个变量，则变量拥有<strong>局部作用域</strong>（local scope）：即程序只有在定义该变量的函数内部才可对其进行读写。下面示例中的变量拥有全局作用域：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/zhmxnqt</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  x = <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">5</span>  y = <span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">6</span>  z = <span class=\"hljs-number\">3</span>\n</code></pre>\n<p>这些变量不是在函数（或类）内部定义的，因此拥有全局作用域。这意味着可以在程序的任意地方对其进行读写，包含在函数内部。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hgvnj4p</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  x = <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">05</span>  y = <span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">06</span>  z = <span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">07</span>\n08\n09  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span></span>:\n<span class=\"hljs-number\">10</span>      print(x)\n<span class=\"hljs-number\">11</span>      print(y)\n<span class=\"hljs-number\">12</span>      print(z)\n<span class=\"hljs-number\">13</span>\n<span class=\"hljs-number\">14</span>\n<span class=\"hljs-number\">15</span>  f()\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">1</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">2</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">3</span></code></pre>\n<p>如果是在函数内部定义的这些变量，则只能在那个函数内部对其进行读写。如果尝试在该函数之外访问它们，Python 会报异常错误。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs python\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/znka93k</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span>:</span>\n<span class=\"hljs-number\">05</span>      x = <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">06</span>      y = <span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">07</span>      z = <span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">08</span>\n<span class=\"hljs-number\">09</span>\n<span class=\"hljs-number\">10</span>  print(x)\n<span class=\"hljs-number\">11</span>  print(y)\n<span class=\"hljs-number\">12</span>  print(z)\n\n&gt;&gt; NameError: name <span class=\"hljs-string\">'x'</span> <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> defined</code></pre>\n<p>如果在函数内部定义这些变量，则会成功运行。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z2k3jds</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span></span>:\n<span class=\"hljs-number\">05</span>      x = <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">06</span>      y = <span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">07</span>      z = <span class=\"hljs-number\">3</span>\n08      print(x)\n09      print(y)\n<span class=\"hljs-number\">10</span>      print(z)\n<span class=\"hljs-number\">11</span>\n<span class=\"hljs-number\">12</span>\n<span class=\"hljs-number\">13</span>  f()\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">1</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">2</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">3</span></code></pre>\n<p>在定义变量的函数之外使用变量，相当于使用一个尚未定义的变量，二者都会使 Python 报告相同的异常错误：</p>\n<pre class=\"代码无行号\"><code class=\"hljs coffeescript\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zn8zjmr</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-keyword\">if</span></strong> x &gt; <span class=\"hljs-number\">100</span>:\n<span class=\"hljs-number\">5</span>      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"x is &gt; 100\"</span>)\n\n&gt;&gt; NameError: name <span class=\"hljs-string\">'x'</span> <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> defined</code></pre>\n<p>可以在程序的任何地方对全局变量进行写操作，但是在局部作用域中需稍加注意：必须明确使用 <code>global</code> 关键字，并在其后写上希望修改的变量。Python 要求这样做，是为了确保在函数内部定义变量 <code>x</code> 时，不会意外变更之前在函数外部定义的变量的值。在函数内部对全局变量进行写操作的示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs python\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zclmda7</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  x = <span class=\"hljs-number\">100</span>\n<span class=\"hljs-number\">05</span>\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span>:</span>\n<span class=\"hljs-number\">08</span>      <strong><span class=\"hljs-keyword\">global</span></strong> x\n<span class=\"hljs-number\">09</span>      x += <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">10</span>      print(x)\n<span class=\"hljs-number\">11</span>\n<span class=\"hljs-number\">12</span>\n<span class=\"hljs-number\">13</span>  f()\n\n&gt;&gt; <span class=\"hljs-number\">101</span></code></pre>\n<p>没有作用域，则可以在程序任何地方访问所有变量，这样会造成很大的问题。如果程序代码量很大，其中有一个使用变量 x 的函数，你可能会在其他地方修改该变量的值。类似这样的错误会改变程序的行为，并导致意料之外的结果。程序规模越大，变量数量越多，出现问题的可能性就越高。</p>\n<h3 id=\"48\">4.8　异常处理</h3>\n<p>依赖 input 函数获得用户输入，则意味着无法控制程序的输入（用户提供的输入可能会导致错误）。例如，假设你写了一个程序，从用户端收集两个数字并打印第一个数字除以第二个数字的结果。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jcg5qwp</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  a = input(<span class=\"hljs-string\">\"type a nubmer:\"</span>)\n<span class=\"hljs-number\">5</span>  b = input(<span class=\"hljs-string\">\"type another:\"</span>)\n<span class=\"hljs-number\">6</span>  a = int(a)\n<span class=\"hljs-number\">7</span>  b = int(b)\n<span class=\"hljs-number\">8</span>  print(a / b)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> type a <span class=\"hljs-symbol\">number:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">10</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> type <span class=\"hljs-symbol\">another:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">5</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">2</span>\n</code></pre>\n<p>程序看起来运行正常。但是，如果用户第二个数字输入的是 0，则会出现问题，如下所示：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/ztpcjs4</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  a = input(<span class=\"hljs-string\">\"type a nubmer:\"</span>)\n<span class=\"hljs-number\">5</span>  b = input(<span class=\"hljs-string\">\"type another:\"</span>)\n<span class=\"hljs-number\">6</span>  a = int(a)\n<span class=\"hljs-number\">7</span>  b = int(b)\n<span class=\"hljs-number\">8</span>  print(a / b)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> type a <span class=\"hljs-symbol\">number:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">10</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> type <span class=\"hljs-symbol\">another:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">0</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-symbol\">ZeroDivisionError:</span> integer division or modulo by zero\n</code></pre>\n<p>这里不能指望使用程序的用户不会输入 0 作为第二个数字。其解决方法是使用<strong>异常处理</strong>（exception handling），支持测试错误条件，在错误发生时捕获异常，然后决定如何处理。</p>\n<p>异常处理使用 <code>try</code> 和 <code>except</code> 关键字。在你修改程序使用异常处理之后，如果用户第二个数字输入 0，程序不会报错，而是会打印一段话告诉用户不要输入 0。</p>\n<p>Python 中的每一个异常都是一个对象，可在如下网址查看所有内置异常：https://www.tutorialspoint.com/python/standard_exceptions.htm。如果你认为代码可能会报告异常，可使用关键字 <code>try</code> 和 <code>except</code> 来捕获。</p>\n<p><code>try</code> 从句包含可能会发生的错误，<code>except</code> 从句包含仅在错误发生时执行的代码。下面是在程序中进行异常处理的一个示例，这样如果用户输入0作为第二个数字，程序也不会崩溃。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/j2scn4f</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  a = input(<span class=\"hljs-string\">\"type a nubmer:\"</span>)\n<span class=\"hljs-number\">05</span>  b = input(<span class=\"hljs-string\">\"type another:\"</span>)\n<span class=\"hljs-number\">06</span>  a = int(a)\n<span class=\"hljs-number\">07</span>  b = int(b)\n08  <strong><span class=\"hljs-symbol\">try</span></strong><span class=\"hljs-symbol\">:</span>\n09      print(a / b)\n<span class=\"hljs-number\">10</span>  <strong>except</strong> <span class=\"hljs-symbol\">ZeroDivisionError:</span>\n<span class=\"hljs-number\">11</span>      print(<span class=\"hljs-string\">\"b cannot be zero.\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> type a <span class=\"hljs-symbol\">number:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">10</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> type <span class=\"hljs-symbol\">another:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">0</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> b cannot be zero.</code></pre>\n<p>如果用户为 <code>b</code> 参数提供的输入不是 0，则执行 <code>try</code> 代码块，<code>except</code> 代码块不执行。如果用户为 <code>b</code> 参数提供的输入为 0，Python 不会报错，而是执行 <code>except</code> 代码块，并打印“<code>b cannot be zero.</code>”。</p>\n<p>如果用户输入的是无法转换为整型数的字符串，程序也会崩溃。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  a = input(<span class=\"hljs-string\">\"type a nubmer:\"</span>)\n<span class=\"hljs-number\">2</span>  b = input(<span class=\"hljs-string\">\"type another:\"</span>)\n<span class=\"hljs-number\">3</span>  a = int(a)\n<span class=\"hljs-number\">4</span>  b = int(b)\n<span class=\"hljs-number\">5</span>  <strong><span class=\"hljs-symbol\">try</span></strong><span class=\"hljs-symbol\">:</span>\n<span class=\"hljs-number\">6</span>      print(a / b)\n<span class=\"hljs-number\">7</span>  <strong>except</strong> <span class=\"hljs-symbol\">ZeroDivisionError:</span>\n<span class=\"hljs-number\">8</span>      print(<span class=\"hljs-string\">\"b cannot be zero.\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> type a <span class=\"hljs-symbol\">number:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> Hundo\n<span class=\"hljs-meta\">&gt;&gt;</span> type <span class=\"hljs-symbol\">another:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> Million\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-symbol\">ValueError:</span> invalid literal for int() with base <span class=\"hljs-number\">10</span>: <span class=\"hljs-string\">'Hundo'</span></code></pre>\n<p>将收集用户收入的部分代码移入 <code>try</code> 语句内，并让 <code>except</code> 语句注意两个异常（ZeroDivisionError 和 ValueError）即可解决问题。如果向 <code>int</code>、<code>str</code> 或 <code>float</code> 等内置函数中传入无效输入，则会出现 <code>ValueError</code>。在 <code>except</code> 关键字后添加圆括号，并用逗号分隔两个异常即可将二者捕获。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jlus42v</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  <strong><span class=\"hljs-symbol\">try</span></strong><span class=\"hljs-symbol\">:</span>\n<span class=\"hljs-number\">05</span>      a = input(<span class=\"hljs-string\">\"type a nubmer:\"</span>)\n<span class=\"hljs-number\">06</span>      b = input(<span class=\"hljs-string\">\"type another:\"</span>)\n<span class=\"hljs-number\">07</span>      a = int(a)\n08      b = int(b)\n09      print(a / b)\n<span class=\"hljs-number\">10</span>  <strong>except</strong> (ZeroDivisionError,\n<span class=\"hljs-number\">11</span>          ValueError):\n<span class=\"hljs-number\">12</span>      print(<span class=\"hljs-string\">\"Invalid input.\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> type a <span class=\"hljs-symbol\">number:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> Hundo\n<span class=\"hljs-meta\">&gt;&gt;</span> type <span class=\"hljs-symbol\">another:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> Million\n<span class=\"hljs-meta\">&gt;&gt;</span> Invalid input.</code></pre>\n<p>不要在 <code>except</code> 语句中使用 <code>try</code> 语句定义的变量，因为异常可能是在变量定义之前发生的，如果在 <code>except</code> 语句中这样做可能又会导致新的异常出现。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hockur5</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-keyword\">try</span></strong>:\n<span class=\"hljs-number\">5</span>      <span class=\"hljs-number\">10</span> / <span class=\"hljs-number\">0</span>\n<span class=\"hljs-number\">6</span>      c = <span class=\"hljs-string\">\"I will never get defined.\"</span>\n<span class=\"hljs-number\">7</span>  <strong><span class=\"hljs-keyword\">except</span></strong> ZeroDivisionError:\n<span class=\"hljs-number\">8</span>      print(c)\n\n&gt;&gt; NameError: name <span class=\"hljs-string\">'c'</span> <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> defined</code></pre>\n<h3 id=\"49\">4.9　文档字符串</h3>\n<p>定义一个带参数的函数时，有时要求参数必须是某种数据类型，函数才能成功执行。那么该如何将这点告知函数的调用者？在编写函数时，在函数顶部留下注释来解释每个参数应该为何种数据类型，是比较好的做法。这些注释被称为<strong>文档字符串</strong>（docstring）。文档字符串用于解释函数的功能，记录所需的参数类型。</p>\n<pre class=\"代码无行号\"><code class=\"hljs python\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zhahdcg</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(x, y)</span>:</span>\n<span class=\"hljs-number\">05</span>      <span class=\"hljs-string\">\"\"\"\n06      返回 x + y 的值\n07      :param x: int.\n08      :param y: int.\n09      :return: int, x 与 y 之和\n10      \"\"\"</span>\n<span class=\"hljs-number\">11</span>      <strong><span class=\"hljs-keyword\">return</span></strong> x + y</code></pre>\n<p>文档字符串的第一行清楚地解释了函数的功能，因此当其他开发者使用该函数或方法时，他们不必读完所有代码才能弄清其目的。文档字符串的其他行列出了函数的参数、参数类型和返回值。文档字符串有助于开发者快速编程，因为不必通读代码，只需通过文档字符串即可了解函数的作用等必要信息。</p>\n<p>为了保证本书的示例简洁，书中省略了一般都会加上的文档字符串。正常情况下，我在编码时会加上文档字符串，以供其他开发者之后阅读。</p>\n<h3 id=\"410\">4.10　有需要才使用变量</h3>\n<p>只有在后面的程序中会用到数据，才有必要将其保存至变量。不要仅仅为了打印数值就将整数保存至变量。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zptktex</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  x = <span class=\"hljs-number\">100</span>\n<span class=\"hljs-number\">5</span>  print(x)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">100</span>\n</code></pre>\n<p>这里应该直接将整数传给 print 函数：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hmwr4kd</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  print(<span class=\"hljs-number\">100</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">100</span>\n</code></pre>\n<p>本书中的一些示例多次违背了这条准则，目的是为了方便大家理解。读者在写代码时没有必要这样做。</p>\n<h3 id=\"411\">4.11　术语表</h3>\n<p><strong>函数</strong>：可接受输入和执行指令，并返回输出的复合语句。</p>\n<p><strong>惯例</strong>：普遍认可的行为方式。</p>\n<p><strong>调用</strong>：向函数提供执行指令、返回输出所需的输入。</p>\n<p><strong>参数</strong>：传递给函数的数据。</p>\n<p><strong>必选参数</strong>：非可选参数。</p>\n<p><strong>可选参数</strong>：非必须提供的参数。</p>\n<p><strong>内置函数</strong>：Python 自带的函数。</p>\n<p><strong>作用域</strong>：变量可进行读写的范围。</p>\n<p><strong>全局作用域</strong>：可在程序中任何地方读写的变量的作用域。</p>\n<p><strong>全局变量</strong>：拥有全局作用域的变量。</p>\n<p><strong>局部作用域</strong>：只能在其定义所在的函数（或类）中读写的变量的作用域。</p>\n<p><strong>异常处理</strong>：一个编程概念，要求检测错误条件。如果符合则捕获异常，并决定如何处理。</p>\n<p><strong>文档字符串</strong>：解释函数功能，记录其参数类型的字符串。</p>\n<h3 id=\"412\">4.12　挑战练习</h3>\n<p>1．编写一个函数，接受数字作为输入，并返回该数字的平方。</p>\n<p>2．编写一个以字符串为参数并将其打印的函数。</p>\n<p>3．编写一个接受 3 个必选参数、两个可选参数的函数。</p>\n<p>4．编写一个带两个函数的程序。第一个函数应接受一个整数为参数，并返回该整数除以 2 的值。第二个函数应接受一个整数作为参数，并返回该整数乘以 4 的值。调用第一个函数，将结果保存至变量，并将变量作为参数传递给第二个函数。</p>\n<p>5．编写一个将字符串转换为 float 对象并返回该结果的函数。使用异常处理来捕获可能发生的异常。</p>\n<p>6．为挑战练习 1～5 中编写的所有函数添加文档字符串。</p>\n<p>答案可从异步社区（www.epubit.com）本书详情页的配套资源中下载。</p></div></article>\n\n</body>\n</html>","source":"_posts/Python无师自通/4_function.html","raw":"---\ntitle: 函数\n---\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>函数</title>\n</head>\n<body>\n<article id=\"articleDiv\"><div class=\"mazi-article-content dont-break-out\"><p></p><div class=\"toc\">\n<ul>\n<li><ul>\n<li><ul>\n<li><a href=\"#41\">4.1　表达概念</a></li>\n<li><a href=\"#42\">4.2　函数</a></li>\n<li><a href=\"#43\">4.3　定义函数</a></li>\n<li><a href=\"#44\">4.4　内置函数</a></li>\n<li><a href=\"#45\">4.5　复用函数</a></li>\n<li><a href=\"#46\">4.6　必选及可选参数</a></li>\n<li><a href=\"#47\">4.7　作用域</a></li>\n<li><a href=\"#48\">4.8　异常处理</a></li>\n<li><a href=\"#49\">4.9　文档字符串</a></li>\n<li><a href=\"#410\">4.10　有需要才使用变量</a></li>\n<li><a href=\"#411\">4.11　术语表</a></li>\n<li><a href=\"#412\">4.12　挑战练习</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>\n<p></p>\n<blockquote>\n  <p><span style=\"font-family: Times New Roman,楷体_GB2312\">“函数应该做一件事。做好这件事。只能做这一件事。”</span></p>\n  <p><span style=\"font-family: Times New Roman,楷体_GB2312\">——罗伯特 · C. 马丁（Robert C.Martin）</span></p>\n</blockquote>\n<p>本章将介绍<strong>函数（function）</strong>：可接受输入，执行指令并返回输出的复合语句。通过函数，我们可以在程序中定义功能，并重复使用。其示例如图 4-1 所示。</p>\n<p><img src=\"https://images.gitbook.cn/8f24fa40-6fc0-11e9-9e1b-5b6158413fa5\" alt=\"enter image description here\"></p>\n<p>图 4-1　函数</p>\n<h3 id=\"41\">4.1　表达概念</h3>\n<p>从此处开始，本书将在解释编程概念时使用一种新<strong>约定</strong>（convention）（一种共同认同的方式）。例如，通过 <code>print(\"[想打印的内容]\")</code> 来介绍如何使用 print 函数。</p>\n<p>新约定中结合使用了 Python 代码和方括号，方括号中的描述用来解释编程概念。当给出类似示例时，除了方括号及其中的内容之外，其他所有都是有效的 Python 代码。方括号中的内容隐含了你应该使用何种代码进行替换。Python 语法中也有使用方括号，因此在代码中本该应用方括号的处置将使用两个方括号体现。</p>\n<h3 id=\"42\">4.2　函数</h3>\n<p><strong>调用</strong>（call）一个函数，意味着为函数提供执行指令并返回输出所需的输入。函数的每一个输入就是一个<strong>参数</strong>（parameter）。当你为函数提供参数时，则被称为“函数传参”。</p>\n<p>Python 中的函数类似于数学函数。如果忘记了代数中的函数，请看下面这个示例：</p>\n<pre><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># 请不要运行代码</span>\n2\n3\n4\n5  f(x) = x * 2\n</code></pre>\n<p>上面代码中语句左侧定义了一个函数 <code>f</code>，接受一个参数 <code>x</code>。语句右侧是函数的具体定义，利用 <code>(x)</code> 中传递的参数进行计算并返回结果（输出）。本例中，函数的值被定义为函数的参数乘以 2。</p>\n<p>Python 和代数均使用如下语法调用函数：<code>[函数名]([逗号分隔的参数])</code>。在函数名后加上圆括号即可进行调用，参数放置在圆括号中，以逗号分隔。对于 <code>f(x) = x * 2</code> 这个数学函数，<code>f(2)</code> 的值是 4，<code>f(10)</code> 的值是 20。</p>\n<h3 id=\"43\">4.3　定义函数</h3>\n<p>在 Python 中创建一个函数，需要选择函数名，并定义其参数、行为和返回值。下面是定义函数的语法：</p>\n<pre class=\"代码无行号\"><code class=\"hljs markdown\">1  # 请不要执行代码\n2\n3\n4\n5  <strong>def</strong> [<span class=\"hljs-string\">函数名</span>](<span class=\"hljs-link\">[参数]</span>):\n6      [函数定义]</code></pre>\n<p>数学函数 f(x) = x * 2 在 Python 中应该表示如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/j9dctwl</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(x)</span>:</span>\n<span class=\"hljs-number\">5</span>      <strong><span class=\"hljs-keyword\">return</span></strong> x * <span class=\"hljs-number\">2</span></code></pre>\n<p>关键字 <code>def</code> 告诉 Python 操作者正在定义一个函数。在 <code>def</code> 关键字后面，指定函数的名称，名称选择遵循与变量名相同的规则。按惯例，函数名不应使用大写字母，单词用下划线分隔：<code>like_this</code>。</p>\n<p>命名函数之后，在名称后加上一对圆括号，圆括号中则是希望函数接受的参数。</p>\n<p>在圆括号之后加入冒号，然后换行并缩进 4 个空格符（和其他复合语句一样）。冒号之后所有缩进 4 个空格符的代码，就是函数的定义。本例中，函数的定义仅有一行，即 <code>return x * 2</code>。关键字 <code>return</code> 指定了调用函数时输出的值，我们称之为函数的返回值。</p>\n<p>在 Python 中，可以使用语法“<code>[函数名]([逗号分隔的参数])</code>”来调用一个函数。以下就是以 2 作为参数调用上述示例中函数 <code>f</code> 的示例：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># http://tinyurl.com/zheas3d</span>\n2\n3\n4  <span class=\"hljs-comment\"># 接上一个示例</span>\n5\n6\n7\n8  f(2)</code></pre>\n<p>控制台没有打印任何输出。你可以将函数的输出保存在一个变量中，然后将其传给 <code>print</code> 函数。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gspjcgj</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-comment\"># 接上一个示例</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  result = f(<span class=\"hljs-number\">2</span>)\n<span class=\"hljs-number\">9</span>  print(result)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">4</span></code></pre>\n<p>如果后面在程序中有需要使用函数返回值的地方，建议将函数的返回值保存到一个变量中。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs python\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/znqp8fk</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(x)</span>:</span>\n<span class=\"hljs-number\">05</span>      <strong><span class=\"hljs-keyword\">return</span></strong> x + <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>\n<span class=\"hljs-number\">08</span>  z = f(<span class=\"hljs-number\">4</span>)\n<span class=\"hljs-number\">09</span>\n<span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">11</span>  <strong><span class=\"hljs-keyword\">if</span></strong> z == <span class=\"hljs-number\">5</span>:\n<span class=\"hljs-number\">12</span>      <strong>print</strong>(<span class=\"hljs-string\">\"z is 5\"</span>)\n<span class=\"hljs-number\">13</span>  <strong><span class=\"hljs-keyword\">else</span></strong>:\n<span class=\"hljs-number\">14</span>      print(<span class=\"hljs-string\">\"z is not 5\"</span>)\n\n&gt;&gt; z <span class=\"hljs-keyword\">is</span> <span class=\"hljs-number\">5</span></code></pre>\n<p>函数可以有一个或多个参数，也可以不接受任何参数。如要定义不需要参数的函数，只需要在定义函数时把圆括号内置为空即可：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/htk7tr6</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span></span>:\n<span class=\"hljs-number\">5</span>      <strong><span class=\"hljs-keyword\">return</span></strong> <span class=\"hljs-number\">1</span> + <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  result = f()\n<span class=\"hljs-number\">9</span>  print(result)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">2</span></code></pre>\n<p>如要函数要接受多个参数，则必须将圆括号中的参数以逗号相隔：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gqmkft7</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(x, y, z)</span></span>:\n<span class=\"hljs-number\">5</span>      <strong><span class=\"hljs-keyword\">return</span></strong> x + y + z\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  result = f(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>)\n<span class=\"hljs-number\">9</span>  print(result)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">6</span></code></pre>\n<p>最后，函数必须包含 <code>return</code> 语句。如果函数没有 <code>return</code> 语句，则会返回 <code>None</code>。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/j8qyqov</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span>:</span>\n<span class=\"hljs-number\">5</span>      z = <span class=\"hljs-number\">1</span> + <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  result = f()\n<span class=\"hljs-number\">9</span>  print(result)\n\n&gt;&gt; <span class=\"hljs-keyword\">None</span></code></pre>\n<h3 id=\"44\">4.4　内置函数</h3>\n<p>Python 编程语言中自带了一个被称为<strong>内置函数</strong>（builtin function）的函数库，它可执行各式各样的计算和任务，而不需任何额外的工作。在前面已经看到过一个内置函数的例子：我们编写的第一个程序就使用了 <code>print</code> 函数打印 <code>\"Hello, World!\"</code>。</p>\n<p>len 也是一个内置函数，表示返回对象的长度，如字符串的长度（字符的数量）。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zfkzqw6</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  len(<span class=\"hljs-string\">\"Monty\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">5</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h75c3cf</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  len(<span class=\"hljs-string\">\"Python\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">6</span>\n</code></pre>\n<p>内置函数 <code>str</code> 接受一个对象作为参数，并返回一个数据类型为 <code>str</code> 的新对象。例如，可使用 <code>str</code> 将一个整型数据转换成一个字符串。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/juzxg2z</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  str(<span class=\"hljs-number\">100</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'100'</span>\n</code></pre>\n<p><code>int</code> 函数可接受一个对象作为参数，并返回一个整型对象。示例如下：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/j42qhkf</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-keyword\">int</span>(<span class=\"hljs-string\">\"1\"</span>)\n\n&gt;&gt; <span class=\"hljs-number\">1</span>\n</code></pre>\n<p><code>float</code> 函数可接受一个对象作为参数，并返回一个浮点数对象。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hnk8gh2</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  fload(<span class=\"hljs-number\">100</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">100.0</span>\n</code></pre>\n<p>传给 <code>str</code>、<code>int</code> 或 <code>float</code> 函数的参数，必须要能够转换为字符串、整数或浮点数。<code>str</code> 函数可接受大部分对象作为参数，但是 <code>int</code> 函数只能接受内容为数字的字符串或浮点数对象。<code>float</code> 函数只能接受内容为数字的字符串或整型对象。具体示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jcchmlx</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  int(<span class=\"hljs-string\">\"110\"</span>)\n<span class=\"hljs-number\">5</span>  int(<span class=\"hljs-number\">20.54</span>)\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  float(<span class=\"hljs-string\">\"16.4\"</span>)\n<span class=\"hljs-number\">9</span>  float(<span class=\"hljs-number\">99</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">100</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">20</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">16.4</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">99.0</span>\n</code></pre>\n<p>如果向 <code>int</code> 或 <code>float</code> 函数中传递的是无法转换为整数或浮点数的参数，Python 将会报出异常错误如下：</p>\n<pre><code class=\"hljs perl\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zseo21s</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-keyword\">int</span>(<span class=\"hljs-string\">\"Prince\"</span>)\n\n&gt;&gt; ValueError: invalid literal <span class=\"hljs-keyword\">for</span> <span class=\"hljs-keyword\">int</span>() with base <span class=\"hljs-number\">10</span>: <span class=\"hljs-string\">'Prince'</span>\n</code></pre>\n<p>使用内置函数 <code>input</code> 收集用户的信息的示例代码如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs perl\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zynprpg</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  age = input(<span class=\"hljs-string\">\"Enter your age:\"</span>)\n<span class=\"hljs-number\">5</span>  int_age = <span class=\"hljs-keyword\">int</span>(age)\n<span class=\"hljs-number\">6</span>  <strong><span class=\"hljs-keyword\">if</span></strong> int_age &lt; <span class=\"hljs-number\">21</span>:\n<span class=\"hljs-number\">7</span>      <span class=\"hljs-keyword\">print</span>(<span class=\"hljs-string\">\"You are young!\"</span>)\n<span class=\"hljs-number\">8</span>  <strong><span class=\"hljs-keyword\">else</span></strong>:\n<span class=\"hljs-number\">9</span>      <span class=\"hljs-keyword\">print</span>(<span class=\"hljs-string\">\"Wow, you are old!\"</span>)\n\n&gt;&gt; Enter your age:</code></pre>\n<p><code>input</code> 函数接受一个字符串作为参数，并将其展示给使用该程序的用户。用户在 shell 中输入回答，程序将回答保存在变量 <code>age</code> 中。</p>\n<p>接下来，使用 <code>int</code> 函数将 <code>age</code> 变量的值从字符串转换为整数。<code>input</code> 函数从用户收集数据以作为 <code>str</code>，但是需要将变量设为 <code>int</code> 才能与其他整数进行比较。转换为整数后，<code>if-else</code> 语句根据用户的输入决定为用户打印什么信息。如果用户输入的数字小于 21，则打印“<code>You are young!”</code>。如果用户输入的数字大于 21，则打印“<code>Wow, you are old!”</code>。</p>\n<h3 id=\"45\">4.5　复用函数</h3>\n<p>函数不仅可用于计算并返回值，还可以封装我们希望复用的功能。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zhy8y4m</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">even_odd</span><span class=\"hljs-params\">(x)</span></span>:\n<span class=\"hljs-number\">05</span>      <strong><span class=\"hljs-keyword\">if</span></strong> x % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>:\n<span class=\"hljs-number\">06</span>          print(<span class=\"hljs-string\">\"even\"</span>)\n<span class=\"hljs-number\">07</span>      <strong><span class=\"hljs-symbol\">else</span></strong><span class=\"hljs-symbol\">:</span>\n08          print(<span class=\"hljs-string\">\"odd\"</span>)\n09\n<span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">11</span>  even_odd(<span class=\"hljs-number\">2</span>)\n<span class=\"hljs-number\">12</span>  even_odd(<span class=\"hljs-number\">3</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> even\n<span class=\"hljs-meta\">&gt;&gt;</span> odd</code></pre>\n<p>这里虽然没有定义函数的返回值，但是该函数还是有用的：它检测 <code>x % 2 == 0</code> 是否为真，并打印 <code>x</code> 是奇数还是偶数。</p>\n<p>因为可以对函数进行复用，所以利用函数可以减少代码量。一个未使用函数的示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs perl\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jk8lugl</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  n = input(<span class=\"hljs-string\">\"type a number:\"</span>)\n<span class=\"hljs-number\">05</span>  n = <span class=\"hljs-keyword\">int</span>(n)\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>\n08  <strong><span class=\"hljs-keyword\">if</span></strong> n % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>:\n09      <span class=\"hljs-keyword\">print</span>(<span class=\"hljs-string\">\"n is even.\"</span>)\n<span class=\"hljs-number\">10</span>  <strong><span class=\"hljs-keyword\">else</span></strong>:\n<span class=\"hljs-number\">11</span>      <strong><span class=\"hljs-keyword\">print</span></strong>(<span class=\"hljs-string\">\"n is odd.\"</span>)\n<span class=\"hljs-number\">12</span>\n<span class=\"hljs-number\">13</span>\n<span class=\"hljs-number\">14</span>  n = input(<span class=\"hljs-string\">\"type a number:\"</span>)\n<span class=\"hljs-number\">15</span>  n = <span class=\"hljs-keyword\">int</span>(n)\n<span class=\"hljs-number\">16</span>  <strong><span class=\"hljs-keyword\">if</span></strong> n % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>:\n<span class=\"hljs-number\">17</span>      <span class=\"hljs-keyword\">print</span>(<span class=\"hljs-string\">\"n is even.\"</span>)\n<span class=\"hljs-number\">18</span>  <strong><span class=\"hljs-keyword\">else</span></strong>:\n<span class=\"hljs-number\">19</span>      <span class=\"hljs-keyword\">print</span>(<span class=\"hljs-string\">\"n is odd.\"</span>)\n<span class=\"hljs-number\">20</span>\n<span class=\"hljs-number\">21</span>\n<span class=\"hljs-number\">22</span>  n = input(<span class=\"hljs-string\">\"type a number:\"</span>)\n<span class=\"hljs-number\">23</span>  n = <span class=\"hljs-keyword\">int</span>(n)\n<span class=\"hljs-number\">24</span>  <strong><span class=\"hljs-keyword\">if</span></strong> n % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>:\n<span class=\"hljs-number\">25</span>      <span class=\"hljs-keyword\">print</span>(<span class=\"hljs-string\">\"n is even.\"</span>)\n<span class=\"hljs-number\">26</span>  <strong><span class=\"hljs-keyword\">else</span></strong>:\n<span class=\"hljs-number\">27</span>      <span class=\"hljs-keyword\">print</span>(<span class=\"hljs-string\">\"n is odd.\"</span>)\n\n&gt;&gt; type a number:</code></pre>\n<p>上面这个程序让用户 3 次输入数字，然后通过 <code>if-else</code> 语句检查数字是否为偶数。如果为偶数，则打印“<code>n is even.”</code>，否则打印“<code>n is odd.”</code>。</p>\n<p>这个程序的问题在于相同的代码重复了 3 次。如果将功能封装在函数中，再调用函数 3 次，则可以大幅减少程序的代码量，并提高可读性。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs python\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zzn22mz</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">even_odd</span><span class=\"hljs-params\">()</span>:</span>\n<span class=\"hljs-number\">05</span>      n = input(<span class=\"hljs-string\">\"type a number:\"</span>)\n<span class=\"hljs-number\">06</span>      n = int(n)\n<span class=\"hljs-number\">07</span>      <strong><span class=\"hljs-keyword\">if</span></strong> n % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>:\n<span class=\"hljs-number\">08</span>          print(<span class=\"hljs-string\">\"n is even.\"</span>)\n<span class=\"hljs-number\">09</span>      <strong><span class=\"hljs-keyword\">else</span></strong>:\n<span class=\"hljs-number\">10</span>          print(<span class=\"hljs-string\">\"n is odd.\"</span>)\n<span class=\"hljs-number\">11</span>\n<span class=\"hljs-number\">12</span>\n<span class=\"hljs-number\">13</span>  even_odd()\n<span class=\"hljs-number\">14</span>  even_odd()\n<span class=\"hljs-number\">15</span>  even_odd()\n\n&gt;&gt; type a number:</code></pre>\n<p>新程序的功能与前一个程序完全相同，但是由于将功能封装在了一个可随时按需调用的函数中，代码量大幅减少，可读性大大提升。</p>\n<h3 id=\"46\">4.6　必选及可选参数</h3>\n<p>函数可接受两种参数。目前所看到的都是<strong>必选参数</strong>（required parameter）。当用户调用函数时，必须传入所有必选参数，否则 Python 将报告异常错误。</p>\n<p>Python 中还有另一种参数，即<strong>可选参数</strong>（optional parameter）。函数只在需要时才会传入，并不是执行程序所必须的。如果没有传入可选参数，函数将使用其默认值。使用如下语法定义可选参数：<code>[函数名]([参数名]=[参数值])</code>。与必选参数一样，可选参数也得使用逗号分隔。一个带可选参数的函数示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h3ych4h</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(x=<span class=\"hljs-number\">2</span>)</span></span>:\n<span class=\"hljs-number\">5</span>      <strong><span class=\"hljs-keyword\">return</span></strong> x ** x\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  print(f())\n<span class=\"hljs-number\">9</span>  print(f(<span class=\"hljs-number\">4</span>))\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">4</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">256</span></code></pre>\n<p>首先，这里没有传入参数而是直接调用函数。因为参数是可选的，<code>x</code> 自动获得值为 2，函数返回 4。</p>\n<p>接下来，传入参数 4 并调用函数。函数没有使用默认值，<code>x</code> 获得值为 4，函数返回 256。你可以定义一个既有必选参数也有可选参数的函数，但是必选参数必须位于可选参数之前。</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hm5svn9</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">add_it</span><span class=\"hljs-params\">(x, y=<span class=\"hljs-number\">10</span>)</span></span>:\n<span class=\"hljs-number\">5</span>      <strong><span class=\"hljs-keyword\">return</span></strong> x + y\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  result = add_it(<span class=\"hljs-number\">2</span>)\n<span class=\"hljs-number\">9</span>  print(result)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">12</span></code></pre>\n<h3 id=\"47\">4.7　作用域</h3>\n<p>变量有一个很重要的属性，<strong>作用域</strong>（scope）。定义变量时，其作用域指的是哪部分程序可以对其进行读写。读取一个变量意味着获取它的值，写变量意味着修改它的值。变量的作用域由其定义在程序中所处的位置决定。</p>\n<p>如果在函数（或类，本书第二部分将介绍）之外定义了一个变量，则变量拥有<strong>全局作用域</strong>（global scope）：即在程序中任意地方都可以对其进行读写操作。带有全局作用域的变量，被称为<strong>全局变量</strong>（global variable）。如果在函数（或类）内部定义一个变量，则变量拥有<strong>局部作用域</strong>（local scope）：即程序只有在定义该变量的函数内部才可对其进行读写。下面示例中的变量拥有全局作用域：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/zhmxnqt</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  x = <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">5</span>  y = <span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">6</span>  z = <span class=\"hljs-number\">3</span>\n</code></pre>\n<p>这些变量不是在函数（或类）内部定义的，因此拥有全局作用域。这意味着可以在程序的任意地方对其进行读写，包含在函数内部。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hgvnj4p</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  x = <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">05</span>  y = <span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">06</span>  z = <span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">07</span>\n08\n09  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span></span>:\n<span class=\"hljs-number\">10</span>      print(x)\n<span class=\"hljs-number\">11</span>      print(y)\n<span class=\"hljs-number\">12</span>      print(z)\n<span class=\"hljs-number\">13</span>\n<span class=\"hljs-number\">14</span>\n<span class=\"hljs-number\">15</span>  f()\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">1</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">2</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">3</span></code></pre>\n<p>如果是在函数内部定义的这些变量，则只能在那个函数内部对其进行读写。如果尝试在该函数之外访问它们，Python 会报异常错误。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs python\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/znka93k</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span>:</span>\n<span class=\"hljs-number\">05</span>      x = <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">06</span>      y = <span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">07</span>      z = <span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">08</span>\n<span class=\"hljs-number\">09</span>\n<span class=\"hljs-number\">10</span>  print(x)\n<span class=\"hljs-number\">11</span>  print(y)\n<span class=\"hljs-number\">12</span>  print(z)\n\n&gt;&gt; NameError: name <span class=\"hljs-string\">'x'</span> <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> defined</code></pre>\n<p>如果在函数内部定义这些变量，则会成功运行。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z2k3jds</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span></span>:\n<span class=\"hljs-number\">05</span>      x = <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">06</span>      y = <span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">07</span>      z = <span class=\"hljs-number\">3</span>\n08      print(x)\n09      print(y)\n<span class=\"hljs-number\">10</span>      print(z)\n<span class=\"hljs-number\">11</span>\n<span class=\"hljs-number\">12</span>\n<span class=\"hljs-number\">13</span>  f()\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">1</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">2</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">3</span></code></pre>\n<p>在定义变量的函数之外使用变量，相当于使用一个尚未定义的变量，二者都会使 Python 报告相同的异常错误：</p>\n<pre class=\"代码无行号\"><code class=\"hljs coffeescript\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zn8zjmr</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-keyword\">if</span></strong> x &gt; <span class=\"hljs-number\">100</span>:\n<span class=\"hljs-number\">5</span>      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"x is &gt; 100\"</span>)\n\n&gt;&gt; NameError: name <span class=\"hljs-string\">'x'</span> <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> defined</code></pre>\n<p>可以在程序的任何地方对全局变量进行写操作，但是在局部作用域中需稍加注意：必须明确使用 <code>global</code> 关键字，并在其后写上希望修改的变量。Python 要求这样做，是为了确保在函数内部定义变量 <code>x</code> 时，不会意外变更之前在函数外部定义的变量的值。在函数内部对全局变量进行写操作的示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs python\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zclmda7</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  x = <span class=\"hljs-number\">100</span>\n<span class=\"hljs-number\">05</span>\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span>:</span>\n<span class=\"hljs-number\">08</span>      <strong><span class=\"hljs-keyword\">global</span></strong> x\n<span class=\"hljs-number\">09</span>      x += <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">10</span>      print(x)\n<span class=\"hljs-number\">11</span>\n<span class=\"hljs-number\">12</span>\n<span class=\"hljs-number\">13</span>  f()\n\n&gt;&gt; <span class=\"hljs-number\">101</span></code></pre>\n<p>没有作用域，则可以在程序任何地方访问所有变量，这样会造成很大的问题。如果程序代码量很大，其中有一个使用变量 x 的函数，你可能会在其他地方修改该变量的值。类似这样的错误会改变程序的行为，并导致意料之外的结果。程序规模越大，变量数量越多，出现问题的可能性就越高。</p>\n<h3 id=\"48\">4.8　异常处理</h3>\n<p>依赖 input 函数获得用户输入，则意味着无法控制程序的输入（用户提供的输入可能会导致错误）。例如，假设你写了一个程序，从用户端收集两个数字并打印第一个数字除以第二个数字的结果。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jcg5qwp</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  a = input(<span class=\"hljs-string\">\"type a nubmer:\"</span>)\n<span class=\"hljs-number\">5</span>  b = input(<span class=\"hljs-string\">\"type another:\"</span>)\n<span class=\"hljs-number\">6</span>  a = int(a)\n<span class=\"hljs-number\">7</span>  b = int(b)\n<span class=\"hljs-number\">8</span>  print(a / b)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> type a <span class=\"hljs-symbol\">number:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">10</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> type <span class=\"hljs-symbol\">another:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">5</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">2</span>\n</code></pre>\n<p>程序看起来运行正常。但是，如果用户第二个数字输入的是 0，则会出现问题，如下所示：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/ztpcjs4</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  a = input(<span class=\"hljs-string\">\"type a nubmer:\"</span>)\n<span class=\"hljs-number\">5</span>  b = input(<span class=\"hljs-string\">\"type another:\"</span>)\n<span class=\"hljs-number\">6</span>  a = int(a)\n<span class=\"hljs-number\">7</span>  b = int(b)\n<span class=\"hljs-number\">8</span>  print(a / b)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> type a <span class=\"hljs-symbol\">number:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">10</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> type <span class=\"hljs-symbol\">another:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">0</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-symbol\">ZeroDivisionError:</span> integer division or modulo by zero\n</code></pre>\n<p>这里不能指望使用程序的用户不会输入 0 作为第二个数字。其解决方法是使用<strong>异常处理</strong>（exception handling），支持测试错误条件，在错误发生时捕获异常，然后决定如何处理。</p>\n<p>异常处理使用 <code>try</code> 和 <code>except</code> 关键字。在你修改程序使用异常处理之后，如果用户第二个数字输入 0，程序不会报错，而是会打印一段话告诉用户不要输入 0。</p>\n<p>Python 中的每一个异常都是一个对象，可在如下网址查看所有内置异常：https://www.tutorialspoint.com/python/standard_exceptions.htm。如果你认为代码可能会报告异常，可使用关键字 <code>try</code> 和 <code>except</code> 来捕获。</p>\n<p><code>try</code> 从句包含可能会发生的错误，<code>except</code> 从句包含仅在错误发生时执行的代码。下面是在程序中进行异常处理的一个示例，这样如果用户输入0作为第二个数字，程序也不会崩溃。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/j2scn4f</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  a = input(<span class=\"hljs-string\">\"type a nubmer:\"</span>)\n<span class=\"hljs-number\">05</span>  b = input(<span class=\"hljs-string\">\"type another:\"</span>)\n<span class=\"hljs-number\">06</span>  a = int(a)\n<span class=\"hljs-number\">07</span>  b = int(b)\n08  <strong><span class=\"hljs-symbol\">try</span></strong><span class=\"hljs-symbol\">:</span>\n09      print(a / b)\n<span class=\"hljs-number\">10</span>  <strong>except</strong> <span class=\"hljs-symbol\">ZeroDivisionError:</span>\n<span class=\"hljs-number\">11</span>      print(<span class=\"hljs-string\">\"b cannot be zero.\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> type a <span class=\"hljs-symbol\">number:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">10</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> type <span class=\"hljs-symbol\">another:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">0</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> b cannot be zero.</code></pre>\n<p>如果用户为 <code>b</code> 参数提供的输入不是 0，则执行 <code>try</code> 代码块，<code>except</code> 代码块不执行。如果用户为 <code>b</code> 参数提供的输入为 0，Python 不会报错，而是执行 <code>except</code> 代码块，并打印“<code>b cannot be zero.</code>”。</p>\n<p>如果用户输入的是无法转换为整型数的字符串，程序也会崩溃。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  a = input(<span class=\"hljs-string\">\"type a nubmer:\"</span>)\n<span class=\"hljs-number\">2</span>  b = input(<span class=\"hljs-string\">\"type another:\"</span>)\n<span class=\"hljs-number\">3</span>  a = int(a)\n<span class=\"hljs-number\">4</span>  b = int(b)\n<span class=\"hljs-number\">5</span>  <strong><span class=\"hljs-symbol\">try</span></strong><span class=\"hljs-symbol\">:</span>\n<span class=\"hljs-number\">6</span>      print(a / b)\n<span class=\"hljs-number\">7</span>  <strong>except</strong> <span class=\"hljs-symbol\">ZeroDivisionError:</span>\n<span class=\"hljs-number\">8</span>      print(<span class=\"hljs-string\">\"b cannot be zero.\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> type a <span class=\"hljs-symbol\">number:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> Hundo\n<span class=\"hljs-meta\">&gt;&gt;</span> type <span class=\"hljs-symbol\">another:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> Million\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-symbol\">ValueError:</span> invalid literal for int() with base <span class=\"hljs-number\">10</span>: <span class=\"hljs-string\">'Hundo'</span></code></pre>\n<p>将收集用户收入的部分代码移入 <code>try</code> 语句内，并让 <code>except</code> 语句注意两个异常（ZeroDivisionError 和 ValueError）即可解决问题。如果向 <code>int</code>、<code>str</code> 或 <code>float</code> 等内置函数中传入无效输入，则会出现 <code>ValueError</code>。在 <code>except</code> 关键字后添加圆括号，并用逗号分隔两个异常即可将二者捕获。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jlus42v</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  <strong><span class=\"hljs-symbol\">try</span></strong><span class=\"hljs-symbol\">:</span>\n<span class=\"hljs-number\">05</span>      a = input(<span class=\"hljs-string\">\"type a nubmer:\"</span>)\n<span class=\"hljs-number\">06</span>      b = input(<span class=\"hljs-string\">\"type another:\"</span>)\n<span class=\"hljs-number\">07</span>      a = int(a)\n08      b = int(b)\n09      print(a / b)\n<span class=\"hljs-number\">10</span>  <strong>except</strong> (ZeroDivisionError,\n<span class=\"hljs-number\">11</span>          ValueError):\n<span class=\"hljs-number\">12</span>      print(<span class=\"hljs-string\">\"Invalid input.\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> type a <span class=\"hljs-symbol\">number:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> Hundo\n<span class=\"hljs-meta\">&gt;&gt;</span> type <span class=\"hljs-symbol\">another:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> Million\n<span class=\"hljs-meta\">&gt;&gt;</span> Invalid input.</code></pre>\n<p>不要在 <code>except</code> 语句中使用 <code>try</code> 语句定义的变量，因为异常可能是在变量定义之前发生的，如果在 <code>except</code> 语句中这样做可能又会导致新的异常出现。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hockur5</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-keyword\">try</span></strong>:\n<span class=\"hljs-number\">5</span>      <span class=\"hljs-number\">10</span> / <span class=\"hljs-number\">0</span>\n<span class=\"hljs-number\">6</span>      c = <span class=\"hljs-string\">\"I will never get defined.\"</span>\n<span class=\"hljs-number\">7</span>  <strong><span class=\"hljs-keyword\">except</span></strong> ZeroDivisionError:\n<span class=\"hljs-number\">8</span>      print(c)\n\n&gt;&gt; NameError: name <span class=\"hljs-string\">'c'</span> <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> defined</code></pre>\n<h3 id=\"49\">4.9　文档字符串</h3>\n<p>定义一个带参数的函数时，有时要求参数必须是某种数据类型，函数才能成功执行。那么该如何将这点告知函数的调用者？在编写函数时，在函数顶部留下注释来解释每个参数应该为何种数据类型，是比较好的做法。这些注释被称为<strong>文档字符串</strong>（docstring）。文档字符串用于解释函数的功能，记录所需的参数类型。</p>\n<pre class=\"代码无行号\"><code class=\"hljs python\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zhahdcg</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(x, y)</span>:</span>\n<span class=\"hljs-number\">05</span>      <span class=\"hljs-string\">\"\"\"\n06      返回 x + y 的值\n07      :param x: int.\n08      :param y: int.\n09      :return: int, x 与 y 之和\n10      \"\"\"</span>\n<span class=\"hljs-number\">11</span>      <strong><span class=\"hljs-keyword\">return</span></strong> x + y</code></pre>\n<p>文档字符串的第一行清楚地解释了函数的功能，因此当其他开发者使用该函数或方法时，他们不必读完所有代码才能弄清其目的。文档字符串的其他行列出了函数的参数、参数类型和返回值。文档字符串有助于开发者快速编程，因为不必通读代码，只需通过文档字符串即可了解函数的作用等必要信息。</p>\n<p>为了保证本书的示例简洁，书中省略了一般都会加上的文档字符串。正常情况下，我在编码时会加上文档字符串，以供其他开发者之后阅读。</p>\n<h3 id=\"410\">4.10　有需要才使用变量</h3>\n<p>只有在后面的程序中会用到数据，才有必要将其保存至变量。不要仅仅为了打印数值就将整数保存至变量。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zptktex</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  x = <span class=\"hljs-number\">100</span>\n<span class=\"hljs-number\">5</span>  print(x)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">100</span>\n</code></pre>\n<p>这里应该直接将整数传给 print 函数：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hmwr4kd</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  print(<span class=\"hljs-number\">100</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">100</span>\n</code></pre>\n<p>本书中的一些示例多次违背了这条准则，目的是为了方便大家理解。读者在写代码时没有必要这样做。</p>\n<h3 id=\"411\">4.11　术语表</h3>\n<p><strong>函数</strong>：可接受输入和执行指令，并返回输出的复合语句。</p>\n<p><strong>惯例</strong>：普遍认可的行为方式。</p>\n<p><strong>调用</strong>：向函数提供执行指令、返回输出所需的输入。</p>\n<p><strong>参数</strong>：传递给函数的数据。</p>\n<p><strong>必选参数</strong>：非可选参数。</p>\n<p><strong>可选参数</strong>：非必须提供的参数。</p>\n<p><strong>内置函数</strong>：Python 自带的函数。</p>\n<p><strong>作用域</strong>：变量可进行读写的范围。</p>\n<p><strong>全局作用域</strong>：可在程序中任何地方读写的变量的作用域。</p>\n<p><strong>全局变量</strong>：拥有全局作用域的变量。</p>\n<p><strong>局部作用域</strong>：只能在其定义所在的函数（或类）中读写的变量的作用域。</p>\n<p><strong>异常处理</strong>：一个编程概念，要求检测错误条件。如果符合则捕获异常，并决定如何处理。</p>\n<p><strong>文档字符串</strong>：解释函数功能，记录其参数类型的字符串。</p>\n<h3 id=\"412\">4.12　挑战练习</h3>\n<p>1．编写一个函数，接受数字作为输入，并返回该数字的平方。</p>\n<p>2．编写一个以字符串为参数并将其打印的函数。</p>\n<p>3．编写一个接受 3 个必选参数、两个可选参数的函数。</p>\n<p>4．编写一个带两个函数的程序。第一个函数应接受一个整数为参数，并返回该整数除以 2 的值。第二个函数应接受一个整数作为参数，并返回该整数乘以 4 的值。调用第一个函数，将结果保存至变量，并将变量作为参数传递给第二个函数。</p>\n<p>5．编写一个将字符串转换为 float 对象并返回该结果的函数。使用异常处理来捕获可能发生的异常。</p>\n<p>6．为挑战练习 1～5 中编写的所有函数添加文档字符串。</p>\n<p>答案可从异步社区（www.epubit.com）本书详情页的配套资源中下载。</p></div></article>\n\n</body>\n</html>","slug":"Python无师自通/4_function","published":1,"date":"2019-05-31T04:48:26.278Z","updated":"2019-05-31T04:48:26.278Z","_id":"cjwd49mxc0007sv72g5xycac5","comments":1,"layout":"post","photos":[],"link":"","content":"\n<!DOCTYPE html>\n<html lang=\"en\">\n<head><meta name=\"generator\" content=\"Hexo 3.8.0\">\n    <meta charset=\"UTF-8\">\n    <title>函数</title>\n</head>\n<body>\n<article id=\"articleDiv\"><div class=\"mazi-article-content dont-break-out\"><p></p><div class=\"toc\">\n<ul>\n<li><ul>\n<li><ul>\n<li><a href=\"#41\">4.1　表达概念</a></li>\n<li><a href=\"#42\">4.2　函数</a></li>\n<li><a href=\"#43\">4.3　定义函数</a></li>\n<li><a href=\"#44\">4.4　内置函数</a></li>\n<li><a href=\"#45\">4.5　复用函数</a></li>\n<li><a href=\"#46\">4.6　必选及可选参数</a></li>\n<li><a href=\"#47\">4.7　作用域</a></li>\n<li><a href=\"#48\">4.8　异常处理</a></li>\n<li><a href=\"#49\">4.9　文档字符串</a></li>\n<li><a href=\"#410\">4.10　有需要才使用变量</a></li>\n<li><a href=\"#411\">4.11　术语表</a></li>\n<li><a href=\"#412\">4.12　挑战练习</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>\n<p></p>\n<blockquote>\n  <p><span style=\"font-family: Times New Roman,楷体_GB2312\">“函数应该做一件事。做好这件事。只能做这一件事。”</span></p>\n  <p><span style=\"font-family: Times New Roman,楷体_GB2312\">——罗伯特 · C. 马丁（Robert C.Martin）</span></p>\n</blockquote>\n<p>本章将介绍<strong>函数（function）</strong>：可接受输入，执行指令并返回输出的复合语句。通过函数，我们可以在程序中定义功能，并重复使用。其示例如图 4-1 所示。</p>\n<p><img src=\"https://images.gitbook.cn/8f24fa40-6fc0-11e9-9e1b-5b6158413fa5\" alt=\"enter image description here\"></p>\n<p>图 4-1　函数</p>\n<h3 id=\"41\">4.1　表达概念</h3>\n<p>从此处开始，本书将在解释编程概念时使用一种新<strong>约定</strong>（convention）（一种共同认同的方式）。例如，通过 <code>print(\"[想打印的内容]\")</code> 来介绍如何使用 print 函数。</p>\n<p>新约定中结合使用了 Python 代码和方括号，方括号中的描述用来解释编程概念。当给出类似示例时，除了方括号及其中的内容之外，其他所有都是有效的 Python 代码。方括号中的内容隐含了你应该使用何种代码进行替换。Python 语法中也有使用方括号，因此在代码中本该应用方括号的处置将使用两个方括号体现。</p>\n<h3 id=\"42\">4.2　函数</h3>\n<p><strong>调用</strong>（call）一个函数，意味着为函数提供执行指令并返回输出所需的输入。函数的每一个输入就是一个<strong>参数</strong>（parameter）。当你为函数提供参数时，则被称为“函数传参”。</p>\n<p>Python 中的函数类似于数学函数。如果忘记了代数中的函数，请看下面这个示例：</p>\n<pre><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># 请不要运行代码</span>\n2\n3\n4\n5  f(x) = x * 2\n</code></pre>\n<p>上面代码中语句左侧定义了一个函数 <code>f</code>，接受一个参数 <code>x</code>。语句右侧是函数的具体定义，利用 <code>(x)</code> 中传递的参数进行计算并返回结果（输出）。本例中，函数的值被定义为函数的参数乘以 2。</p>\n<p>Python 和代数均使用如下语法调用函数：<code>[函数名]([逗号分隔的参数])</code>。在函数名后加上圆括号即可进行调用，参数放置在圆括号中，以逗号分隔。对于 <code>f(x) = x * 2</code> 这个数学函数，<code>f(2)</code> 的值是 4，<code>f(10)</code> 的值是 20。</p>\n<h3 id=\"43\">4.3　定义函数</h3>\n<p>在 Python 中创建一个函数，需要选择函数名，并定义其参数、行为和返回值。下面是定义函数的语法：</p>\n<pre class=\"代码无行号\"><code class=\"hljs markdown\">1  # 请不要执行代码\n2\n3\n4\n5  <strong>def</strong> [<span class=\"hljs-string\">函数名</span>](<span class=\"hljs-link\">[参数]</span>):\n6      [函数定义]</code></pre>\n<p>数学函数 f(x) = x * 2 在 Python 中应该表示如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/j9dctwl</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(x)</span>:</span>\n<span class=\"hljs-number\">5</span>      <strong><span class=\"hljs-keyword\">return</span></strong> x * <span class=\"hljs-number\">2</span></code></pre>\n<p>关键字 <code>def</code> 告诉 Python 操作者正在定义一个函数。在 <code>def</code> 关键字后面，指定函数的名称，名称选择遵循与变量名相同的规则。按惯例，函数名不应使用大写字母，单词用下划线分隔：<code>like_this</code>。</p>\n<p>命名函数之后，在名称后加上一对圆括号，圆括号中则是希望函数接受的参数。</p>\n<p>在圆括号之后加入冒号，然后换行并缩进 4 个空格符（和其他复合语句一样）。冒号之后所有缩进 4 个空格符的代码，就是函数的定义。本例中，函数的定义仅有一行，即 <code>return x * 2</code>。关键字 <code>return</code> 指定了调用函数时输出的值，我们称之为函数的返回值。</p>\n<p>在 Python 中，可以使用语法“<code>[函数名]([逗号分隔的参数])</code>”来调用一个函数。以下就是以 2 作为参数调用上述示例中函数 <code>f</code> 的示例：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># http://tinyurl.com/zheas3d</span>\n2\n3\n4  <span class=\"hljs-comment\"># 接上一个示例</span>\n5\n6\n7\n8  f(2)</code></pre>\n<p>控制台没有打印任何输出。你可以将函数的输出保存在一个变量中，然后将其传给 <code>print</code> 函数。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gspjcgj</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-comment\"># 接上一个示例</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  result = f(<span class=\"hljs-number\">2</span>)\n<span class=\"hljs-number\">9</span>  print(result)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">4</span></code></pre>\n<p>如果后面在程序中有需要使用函数返回值的地方，建议将函数的返回值保存到一个变量中。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs python\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/znqp8fk</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(x)</span>:</span>\n<span class=\"hljs-number\">05</span>      <strong><span class=\"hljs-keyword\">return</span></strong> x + <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>\n<span class=\"hljs-number\">08</span>  z = f(<span class=\"hljs-number\">4</span>)\n<span class=\"hljs-number\">09</span>\n<span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">11</span>  <strong><span class=\"hljs-keyword\">if</span></strong> z == <span class=\"hljs-number\">5</span>:\n<span class=\"hljs-number\">12</span>      <strong>print</strong>(<span class=\"hljs-string\">\"z is 5\"</span>)\n<span class=\"hljs-number\">13</span>  <strong><span class=\"hljs-keyword\">else</span></strong>:\n<span class=\"hljs-number\">14</span>      print(<span class=\"hljs-string\">\"z is not 5\"</span>)\n\n&gt;&gt; z <span class=\"hljs-keyword\">is</span> <span class=\"hljs-number\">5</span></code></pre>\n<p>函数可以有一个或多个参数，也可以不接受任何参数。如要定义不需要参数的函数，只需要在定义函数时把圆括号内置为空即可：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/htk7tr6</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span></span>:\n<span class=\"hljs-number\">5</span>      <strong><span class=\"hljs-keyword\">return</span></strong> <span class=\"hljs-number\">1</span> + <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  result = f()\n<span class=\"hljs-number\">9</span>  print(result)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">2</span></code></pre>\n<p>如要函数要接受多个参数，则必须将圆括号中的参数以逗号相隔：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gqmkft7</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(x, y, z)</span></span>:\n<span class=\"hljs-number\">5</span>      <strong><span class=\"hljs-keyword\">return</span></strong> x + y + z\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  result = f(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>)\n<span class=\"hljs-number\">9</span>  print(result)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">6</span></code></pre>\n<p>最后，函数必须包含 <code>return</code> 语句。如果函数没有 <code>return</code> 语句，则会返回 <code>None</code>。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/j8qyqov</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span>:</span>\n<span class=\"hljs-number\">5</span>      z = <span class=\"hljs-number\">1</span> + <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  result = f()\n<span class=\"hljs-number\">9</span>  print(result)\n\n&gt;&gt; <span class=\"hljs-keyword\">None</span></code></pre>\n<h3 id=\"44\">4.4　内置函数</h3>\n<p>Python 编程语言中自带了一个被称为<strong>内置函数</strong>（builtin function）的函数库，它可执行各式各样的计算和任务，而不需任何额外的工作。在前面已经看到过一个内置函数的例子：我们编写的第一个程序就使用了 <code>print</code> 函数打印 <code>\"Hello, World!\"</code>。</p>\n<p>len 也是一个内置函数，表示返回对象的长度，如字符串的长度（字符的数量）。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zfkzqw6</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  len(<span class=\"hljs-string\">\"Monty\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">5</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h75c3cf</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  len(<span class=\"hljs-string\">\"Python\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">6</span>\n</code></pre>\n<p>内置函数 <code>str</code> 接受一个对象作为参数，并返回一个数据类型为 <code>str</code> 的新对象。例如，可使用 <code>str</code> 将一个整型数据转换成一个字符串。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/juzxg2z</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  str(<span class=\"hljs-number\">100</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'100'</span>\n</code></pre>\n<p><code>int</code> 函数可接受一个对象作为参数，并返回一个整型对象。示例如下：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/j42qhkf</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-keyword\">int</span>(<span class=\"hljs-string\">\"1\"</span>)\n\n&gt;&gt; <span class=\"hljs-number\">1</span>\n</code></pre>\n<p><code>float</code> 函数可接受一个对象作为参数，并返回一个浮点数对象。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hnk8gh2</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  fload(<span class=\"hljs-number\">100</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">100.0</span>\n</code></pre>\n<p>传给 <code>str</code>、<code>int</code> 或 <code>float</code> 函数的参数，必须要能够转换为字符串、整数或浮点数。<code>str</code> 函数可接受大部分对象作为参数，但是 <code>int</code> 函数只能接受内容为数字的字符串或浮点数对象。<code>float</code> 函数只能接受内容为数字的字符串或整型对象。具体示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jcchmlx</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  int(<span class=\"hljs-string\">\"110\"</span>)\n<span class=\"hljs-number\">5</span>  int(<span class=\"hljs-number\">20.54</span>)\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  float(<span class=\"hljs-string\">\"16.4\"</span>)\n<span class=\"hljs-number\">9</span>  float(<span class=\"hljs-number\">99</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">100</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">20</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">16.4</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">99.0</span>\n</code></pre>\n<p>如果向 <code>int</code> 或 <code>float</code> 函数中传递的是无法转换为整数或浮点数的参数，Python 将会报出异常错误如下：</p>\n<pre><code class=\"hljs perl\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zseo21s</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-keyword\">int</span>(<span class=\"hljs-string\">\"Prince\"</span>)\n\n&gt;&gt; ValueError: invalid literal <span class=\"hljs-keyword\">for</span> <span class=\"hljs-keyword\">int</span>() with base <span class=\"hljs-number\">10</span>: <span class=\"hljs-string\">'Prince'</span>\n</code></pre>\n<p>使用内置函数 <code>input</code> 收集用户的信息的示例代码如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs perl\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zynprpg</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  age = input(<span class=\"hljs-string\">\"Enter your age:\"</span>)\n<span class=\"hljs-number\">5</span>  int_age = <span class=\"hljs-keyword\">int</span>(age)\n<span class=\"hljs-number\">6</span>  <strong><span class=\"hljs-keyword\">if</span></strong> int_age &lt; <span class=\"hljs-number\">21</span>:\n<span class=\"hljs-number\">7</span>      <span class=\"hljs-keyword\">print</span>(<span class=\"hljs-string\">\"You are young!\"</span>)\n<span class=\"hljs-number\">8</span>  <strong><span class=\"hljs-keyword\">else</span></strong>:\n<span class=\"hljs-number\">9</span>      <span class=\"hljs-keyword\">print</span>(<span class=\"hljs-string\">\"Wow, you are old!\"</span>)\n\n&gt;&gt; Enter your age:</code></pre>\n<p><code>input</code> 函数接受一个字符串作为参数，并将其展示给使用该程序的用户。用户在 shell 中输入回答，程序将回答保存在变量 <code>age</code> 中。</p>\n<p>接下来，使用 <code>int</code> 函数将 <code>age</code> 变量的值从字符串转换为整数。<code>input</code> 函数从用户收集数据以作为 <code>str</code>，但是需要将变量设为 <code>int</code> 才能与其他整数进行比较。转换为整数后，<code>if-else</code> 语句根据用户的输入决定为用户打印什么信息。如果用户输入的数字小于 21，则打印“<code>You are young!”</code>。如果用户输入的数字大于 21，则打印“<code>Wow, you are old!”</code>。</p>\n<h3 id=\"45\">4.5　复用函数</h3>\n<p>函数不仅可用于计算并返回值，还可以封装我们希望复用的功能。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zhy8y4m</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">even_odd</span><span class=\"hljs-params\">(x)</span></span>:\n<span class=\"hljs-number\">05</span>      <strong><span class=\"hljs-keyword\">if</span></strong> x % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>:\n<span class=\"hljs-number\">06</span>          print(<span class=\"hljs-string\">\"even\"</span>)\n<span class=\"hljs-number\">07</span>      <strong><span class=\"hljs-symbol\">else</span></strong><span class=\"hljs-symbol\">:</span>\n08          print(<span class=\"hljs-string\">\"odd\"</span>)\n09\n<span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">11</span>  even_odd(<span class=\"hljs-number\">2</span>)\n<span class=\"hljs-number\">12</span>  even_odd(<span class=\"hljs-number\">3</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> even\n<span class=\"hljs-meta\">&gt;&gt;</span> odd</code></pre>\n<p>这里虽然没有定义函数的返回值，但是该函数还是有用的：它检测 <code>x % 2 == 0</code> 是否为真，并打印 <code>x</code> 是奇数还是偶数。</p>\n<p>因为可以对函数进行复用，所以利用函数可以减少代码量。一个未使用函数的示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs perl\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jk8lugl</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  n = input(<span class=\"hljs-string\">\"type a number:\"</span>)\n<span class=\"hljs-number\">05</span>  n = <span class=\"hljs-keyword\">int</span>(n)\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>\n08  <strong><span class=\"hljs-keyword\">if</span></strong> n % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>:\n09      <span class=\"hljs-keyword\">print</span>(<span class=\"hljs-string\">\"n is even.\"</span>)\n<span class=\"hljs-number\">10</span>  <strong><span class=\"hljs-keyword\">else</span></strong>:\n<span class=\"hljs-number\">11</span>      <strong><span class=\"hljs-keyword\">print</span></strong>(<span class=\"hljs-string\">\"n is odd.\"</span>)\n<span class=\"hljs-number\">12</span>\n<span class=\"hljs-number\">13</span>\n<span class=\"hljs-number\">14</span>  n = input(<span class=\"hljs-string\">\"type a number:\"</span>)\n<span class=\"hljs-number\">15</span>  n = <span class=\"hljs-keyword\">int</span>(n)\n<span class=\"hljs-number\">16</span>  <strong><span class=\"hljs-keyword\">if</span></strong> n % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>:\n<span class=\"hljs-number\">17</span>      <span class=\"hljs-keyword\">print</span>(<span class=\"hljs-string\">\"n is even.\"</span>)\n<span class=\"hljs-number\">18</span>  <strong><span class=\"hljs-keyword\">else</span></strong>:\n<span class=\"hljs-number\">19</span>      <span class=\"hljs-keyword\">print</span>(<span class=\"hljs-string\">\"n is odd.\"</span>)\n<span class=\"hljs-number\">20</span>\n<span class=\"hljs-number\">21</span>\n<span class=\"hljs-number\">22</span>  n = input(<span class=\"hljs-string\">\"type a number:\"</span>)\n<span class=\"hljs-number\">23</span>  n = <span class=\"hljs-keyword\">int</span>(n)\n<span class=\"hljs-number\">24</span>  <strong><span class=\"hljs-keyword\">if</span></strong> n % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>:\n<span class=\"hljs-number\">25</span>      <span class=\"hljs-keyword\">print</span>(<span class=\"hljs-string\">\"n is even.\"</span>)\n<span class=\"hljs-number\">26</span>  <strong><span class=\"hljs-keyword\">else</span></strong>:\n<span class=\"hljs-number\">27</span>      <span class=\"hljs-keyword\">print</span>(<span class=\"hljs-string\">\"n is odd.\"</span>)\n\n&gt;&gt; type a number:</code></pre>\n<p>上面这个程序让用户 3 次输入数字，然后通过 <code>if-else</code> 语句检查数字是否为偶数。如果为偶数，则打印“<code>n is even.”</code>，否则打印“<code>n is odd.”</code>。</p>\n<p>这个程序的问题在于相同的代码重复了 3 次。如果将功能封装在函数中，再调用函数 3 次，则可以大幅减少程序的代码量，并提高可读性。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs python\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zzn22mz</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">even_odd</span><span class=\"hljs-params\">()</span>:</span>\n<span class=\"hljs-number\">05</span>      n = input(<span class=\"hljs-string\">\"type a number:\"</span>)\n<span class=\"hljs-number\">06</span>      n = int(n)\n<span class=\"hljs-number\">07</span>      <strong><span class=\"hljs-keyword\">if</span></strong> n % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>:\n<span class=\"hljs-number\">08</span>          print(<span class=\"hljs-string\">\"n is even.\"</span>)\n<span class=\"hljs-number\">09</span>      <strong><span class=\"hljs-keyword\">else</span></strong>:\n<span class=\"hljs-number\">10</span>          print(<span class=\"hljs-string\">\"n is odd.\"</span>)\n<span class=\"hljs-number\">11</span>\n<span class=\"hljs-number\">12</span>\n<span class=\"hljs-number\">13</span>  even_odd()\n<span class=\"hljs-number\">14</span>  even_odd()\n<span class=\"hljs-number\">15</span>  even_odd()\n\n&gt;&gt; type a number:</code></pre>\n<p>新程序的功能与前一个程序完全相同，但是由于将功能封装在了一个可随时按需调用的函数中，代码量大幅减少，可读性大大提升。</p>\n<h3 id=\"46\">4.6　必选及可选参数</h3>\n<p>函数可接受两种参数。目前所看到的都是<strong>必选参数</strong>（required parameter）。当用户调用函数时，必须传入所有必选参数，否则 Python 将报告异常错误。</p>\n<p>Python 中还有另一种参数，即<strong>可选参数</strong>（optional parameter）。函数只在需要时才会传入，并不是执行程序所必须的。如果没有传入可选参数，函数将使用其默认值。使用如下语法定义可选参数：<code>[函数名]([参数名]=[参数值])</code>。与必选参数一样，可选参数也得使用逗号分隔。一个带可选参数的函数示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h3ych4h</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(x=<span class=\"hljs-number\">2</span>)</span></span>:\n<span class=\"hljs-number\">5</span>      <strong><span class=\"hljs-keyword\">return</span></strong> x ** x\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  print(f())\n<span class=\"hljs-number\">9</span>  print(f(<span class=\"hljs-number\">4</span>))\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">4</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">256</span></code></pre>\n<p>首先，这里没有传入参数而是直接调用函数。因为参数是可选的，<code>x</code> 自动获得值为 2，函数返回 4。</p>\n<p>接下来，传入参数 4 并调用函数。函数没有使用默认值，<code>x</code> 获得值为 4，函数返回 256。你可以定义一个既有必选参数也有可选参数的函数，但是必选参数必须位于可选参数之前。</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hm5svn9</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">add_it</span><span class=\"hljs-params\">(x, y=<span class=\"hljs-number\">10</span>)</span></span>:\n<span class=\"hljs-number\">5</span>      <strong><span class=\"hljs-keyword\">return</span></strong> x + y\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  result = add_it(<span class=\"hljs-number\">2</span>)\n<span class=\"hljs-number\">9</span>  print(result)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">12</span></code></pre>\n<h3 id=\"47\">4.7　作用域</h3>\n<p>变量有一个很重要的属性，<strong>作用域</strong>（scope）。定义变量时，其作用域指的是哪部分程序可以对其进行读写。读取一个变量意味着获取它的值，写变量意味着修改它的值。变量的作用域由其定义在程序中所处的位置决定。</p>\n<p>如果在函数（或类，本书第二部分将介绍）之外定义了一个变量，则变量拥有<strong>全局作用域</strong>（global scope）：即在程序中任意地方都可以对其进行读写操作。带有全局作用域的变量，被称为<strong>全局变量</strong>（global variable）。如果在函数（或类）内部定义一个变量，则变量拥有<strong>局部作用域</strong>（local scope）：即程序只有在定义该变量的函数内部才可对其进行读写。下面示例中的变量拥有全局作用域：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/zhmxnqt</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  x = <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">5</span>  y = <span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">6</span>  z = <span class=\"hljs-number\">3</span>\n</code></pre>\n<p>这些变量不是在函数（或类）内部定义的，因此拥有全局作用域。这意味着可以在程序的任意地方对其进行读写，包含在函数内部。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hgvnj4p</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  x = <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">05</span>  y = <span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">06</span>  z = <span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">07</span>\n08\n09  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span></span>:\n<span class=\"hljs-number\">10</span>      print(x)\n<span class=\"hljs-number\">11</span>      print(y)\n<span class=\"hljs-number\">12</span>      print(z)\n<span class=\"hljs-number\">13</span>\n<span class=\"hljs-number\">14</span>\n<span class=\"hljs-number\">15</span>  f()\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">1</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">2</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">3</span></code></pre>\n<p>如果是在函数内部定义的这些变量，则只能在那个函数内部对其进行读写。如果尝试在该函数之外访问它们，Python 会报异常错误。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs python\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/znka93k</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span>:</span>\n<span class=\"hljs-number\">05</span>      x = <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">06</span>      y = <span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">07</span>      z = <span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">08</span>\n<span class=\"hljs-number\">09</span>\n<span class=\"hljs-number\">10</span>  print(x)\n<span class=\"hljs-number\">11</span>  print(y)\n<span class=\"hljs-number\">12</span>  print(z)\n\n&gt;&gt; NameError: name <span class=\"hljs-string\">'x'</span> <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> defined</code></pre>\n<p>如果在函数内部定义这些变量，则会成功运行。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z2k3jds</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span></span>:\n<span class=\"hljs-number\">05</span>      x = <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">06</span>      y = <span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">07</span>      z = <span class=\"hljs-number\">3</span>\n08      print(x)\n09      print(y)\n<span class=\"hljs-number\">10</span>      print(z)\n<span class=\"hljs-number\">11</span>\n<span class=\"hljs-number\">12</span>\n<span class=\"hljs-number\">13</span>  f()\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">1</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">2</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">3</span></code></pre>\n<p>在定义变量的函数之外使用变量，相当于使用一个尚未定义的变量，二者都会使 Python 报告相同的异常错误：</p>\n<pre class=\"代码无行号\"><code class=\"hljs coffeescript\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zn8zjmr</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-keyword\">if</span></strong> x &gt; <span class=\"hljs-number\">100</span>:\n<span class=\"hljs-number\">5</span>      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"x is &gt; 100\"</span>)\n\n&gt;&gt; NameError: name <span class=\"hljs-string\">'x'</span> <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> defined</code></pre>\n<p>可以在程序的任何地方对全局变量进行写操作，但是在局部作用域中需稍加注意：必须明确使用 <code>global</code> 关键字，并在其后写上希望修改的变量。Python 要求这样做，是为了确保在函数内部定义变量 <code>x</code> 时，不会意外变更之前在函数外部定义的变量的值。在函数内部对全局变量进行写操作的示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs python\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zclmda7</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  x = <span class=\"hljs-number\">100</span>\n<span class=\"hljs-number\">05</span>\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span>:</span>\n<span class=\"hljs-number\">08</span>      <strong><span class=\"hljs-keyword\">global</span></strong> x\n<span class=\"hljs-number\">09</span>      x += <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">10</span>      print(x)\n<span class=\"hljs-number\">11</span>\n<span class=\"hljs-number\">12</span>\n<span class=\"hljs-number\">13</span>  f()\n\n&gt;&gt; <span class=\"hljs-number\">101</span></code></pre>\n<p>没有作用域，则可以在程序任何地方访问所有变量，这样会造成很大的问题。如果程序代码量很大，其中有一个使用变量 x 的函数，你可能会在其他地方修改该变量的值。类似这样的错误会改变程序的行为，并导致意料之外的结果。程序规模越大，变量数量越多，出现问题的可能性就越高。</p>\n<h3 id=\"48\">4.8　异常处理</h3>\n<p>依赖 input 函数获得用户输入，则意味着无法控制程序的输入（用户提供的输入可能会导致错误）。例如，假设你写了一个程序，从用户端收集两个数字并打印第一个数字除以第二个数字的结果。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jcg5qwp</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  a = input(<span class=\"hljs-string\">\"type a nubmer:\"</span>)\n<span class=\"hljs-number\">5</span>  b = input(<span class=\"hljs-string\">\"type another:\"</span>)\n<span class=\"hljs-number\">6</span>  a = int(a)\n<span class=\"hljs-number\">7</span>  b = int(b)\n<span class=\"hljs-number\">8</span>  print(a / b)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> type a <span class=\"hljs-symbol\">number:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">10</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> type <span class=\"hljs-symbol\">another:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">5</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">2</span>\n</code></pre>\n<p>程序看起来运行正常。但是，如果用户第二个数字输入的是 0，则会出现问题，如下所示：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/ztpcjs4</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  a = input(<span class=\"hljs-string\">\"type a nubmer:\"</span>)\n<span class=\"hljs-number\">5</span>  b = input(<span class=\"hljs-string\">\"type another:\"</span>)\n<span class=\"hljs-number\">6</span>  a = int(a)\n<span class=\"hljs-number\">7</span>  b = int(b)\n<span class=\"hljs-number\">8</span>  print(a / b)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> type a <span class=\"hljs-symbol\">number:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">10</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> type <span class=\"hljs-symbol\">another:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">0</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-symbol\">ZeroDivisionError:</span> integer division or modulo by zero\n</code></pre>\n<p>这里不能指望使用程序的用户不会输入 0 作为第二个数字。其解决方法是使用<strong>异常处理</strong>（exception handling），支持测试错误条件，在错误发生时捕获异常，然后决定如何处理。</p>\n<p>异常处理使用 <code>try</code> 和 <code>except</code> 关键字。在你修改程序使用异常处理之后，如果用户第二个数字输入 0，程序不会报错，而是会打印一段话告诉用户不要输入 0。</p>\n<p>Python 中的每一个异常都是一个对象，可在如下网址查看所有内置异常：https://www.tutorialspoint.com/python/standard_exceptions.htm。如果你认为代码可能会报告异常，可使用关键字 <code>try</code> 和 <code>except</code> 来捕获。</p>\n<p><code>try</code> 从句包含可能会发生的错误，<code>except</code> 从句包含仅在错误发生时执行的代码。下面是在程序中进行异常处理的一个示例，这样如果用户输入0作为第二个数字，程序也不会崩溃。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/j2scn4f</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  a = input(<span class=\"hljs-string\">\"type a nubmer:\"</span>)\n<span class=\"hljs-number\">05</span>  b = input(<span class=\"hljs-string\">\"type another:\"</span>)\n<span class=\"hljs-number\">06</span>  a = int(a)\n<span class=\"hljs-number\">07</span>  b = int(b)\n08  <strong><span class=\"hljs-symbol\">try</span></strong><span class=\"hljs-symbol\">:</span>\n09      print(a / b)\n<span class=\"hljs-number\">10</span>  <strong>except</strong> <span class=\"hljs-symbol\">ZeroDivisionError:</span>\n<span class=\"hljs-number\">11</span>      print(<span class=\"hljs-string\">\"b cannot be zero.\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> type a <span class=\"hljs-symbol\">number:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">10</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> type <span class=\"hljs-symbol\">another:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">0</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> b cannot be zero.</code></pre>\n<p>如果用户为 <code>b</code> 参数提供的输入不是 0，则执行 <code>try</code> 代码块，<code>except</code> 代码块不执行。如果用户为 <code>b</code> 参数提供的输入为 0，Python 不会报错，而是执行 <code>except</code> 代码块，并打印“<code>b cannot be zero.</code>”。</p>\n<p>如果用户输入的是无法转换为整型数的字符串，程序也会崩溃。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  a = input(<span class=\"hljs-string\">\"type a nubmer:\"</span>)\n<span class=\"hljs-number\">2</span>  b = input(<span class=\"hljs-string\">\"type another:\"</span>)\n<span class=\"hljs-number\">3</span>  a = int(a)\n<span class=\"hljs-number\">4</span>  b = int(b)\n<span class=\"hljs-number\">5</span>  <strong><span class=\"hljs-symbol\">try</span></strong><span class=\"hljs-symbol\">:</span>\n<span class=\"hljs-number\">6</span>      print(a / b)\n<span class=\"hljs-number\">7</span>  <strong>except</strong> <span class=\"hljs-symbol\">ZeroDivisionError:</span>\n<span class=\"hljs-number\">8</span>      print(<span class=\"hljs-string\">\"b cannot be zero.\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> type a <span class=\"hljs-symbol\">number:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> Hundo\n<span class=\"hljs-meta\">&gt;&gt;</span> type <span class=\"hljs-symbol\">another:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> Million\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-symbol\">ValueError:</span> invalid literal for int() with base <span class=\"hljs-number\">10</span>: <span class=\"hljs-string\">'Hundo'</span></code></pre>\n<p>将收集用户收入的部分代码移入 <code>try</code> 语句内，并让 <code>except</code> 语句注意两个异常（ZeroDivisionError 和 ValueError）即可解决问题。如果向 <code>int</code>、<code>str</code> 或 <code>float</code> 等内置函数中传入无效输入，则会出现 <code>ValueError</code>。在 <code>except</code> 关键字后添加圆括号，并用逗号分隔两个异常即可将二者捕获。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jlus42v</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  <strong><span class=\"hljs-symbol\">try</span></strong><span class=\"hljs-symbol\">:</span>\n<span class=\"hljs-number\">05</span>      a = input(<span class=\"hljs-string\">\"type a nubmer:\"</span>)\n<span class=\"hljs-number\">06</span>      b = input(<span class=\"hljs-string\">\"type another:\"</span>)\n<span class=\"hljs-number\">07</span>      a = int(a)\n08      b = int(b)\n09      print(a / b)\n<span class=\"hljs-number\">10</span>  <strong>except</strong> (ZeroDivisionError,\n<span class=\"hljs-number\">11</span>          ValueError):\n<span class=\"hljs-number\">12</span>      print(<span class=\"hljs-string\">\"Invalid input.\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> type a <span class=\"hljs-symbol\">number:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> Hundo\n<span class=\"hljs-meta\">&gt;&gt;</span> type <span class=\"hljs-symbol\">another:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> Million\n<span class=\"hljs-meta\">&gt;&gt;</span> Invalid input.</code></pre>\n<p>不要在 <code>except</code> 语句中使用 <code>try</code> 语句定义的变量，因为异常可能是在变量定义之前发生的，如果在 <code>except</code> 语句中这样做可能又会导致新的异常出现。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hockur5</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-keyword\">try</span></strong>:\n<span class=\"hljs-number\">5</span>      <span class=\"hljs-number\">10</span> / <span class=\"hljs-number\">0</span>\n<span class=\"hljs-number\">6</span>      c = <span class=\"hljs-string\">\"I will never get defined.\"</span>\n<span class=\"hljs-number\">7</span>  <strong><span class=\"hljs-keyword\">except</span></strong> ZeroDivisionError:\n<span class=\"hljs-number\">8</span>      print(c)\n\n&gt;&gt; NameError: name <span class=\"hljs-string\">'c'</span> <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> defined</code></pre>\n<h3 id=\"49\">4.9　文档字符串</h3>\n<p>定义一个带参数的函数时，有时要求参数必须是某种数据类型，函数才能成功执行。那么该如何将这点告知函数的调用者？在编写函数时，在函数顶部留下注释来解释每个参数应该为何种数据类型，是比较好的做法。这些注释被称为<strong>文档字符串</strong>（docstring）。文档字符串用于解释函数的功能，记录所需的参数类型。</p>\n<pre class=\"代码无行号\"><code class=\"hljs python\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zhahdcg</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(x, y)</span>:</span>\n<span class=\"hljs-number\">05</span>      <span class=\"hljs-string\">\"\"\"\n06      返回 x + y 的值\n07      :param x: int.\n08      :param y: int.\n09      :return: int, x 与 y 之和\n10      \"\"\"</span>\n<span class=\"hljs-number\">11</span>      <strong><span class=\"hljs-keyword\">return</span></strong> x + y</code></pre>\n<p>文档字符串的第一行清楚地解释了函数的功能，因此当其他开发者使用该函数或方法时，他们不必读完所有代码才能弄清其目的。文档字符串的其他行列出了函数的参数、参数类型和返回值。文档字符串有助于开发者快速编程，因为不必通读代码，只需通过文档字符串即可了解函数的作用等必要信息。</p>\n<p>为了保证本书的示例简洁，书中省略了一般都会加上的文档字符串。正常情况下，我在编码时会加上文档字符串，以供其他开发者之后阅读。</p>\n<h3 id=\"410\">4.10　有需要才使用变量</h3>\n<p>只有在后面的程序中会用到数据，才有必要将其保存至变量。不要仅仅为了打印数值就将整数保存至变量。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zptktex</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  x = <span class=\"hljs-number\">100</span>\n<span class=\"hljs-number\">5</span>  print(x)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">100</span>\n</code></pre>\n<p>这里应该直接将整数传给 print 函数：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hmwr4kd</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  print(<span class=\"hljs-number\">100</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">100</span>\n</code></pre>\n<p>本书中的一些示例多次违背了这条准则，目的是为了方便大家理解。读者在写代码时没有必要这样做。</p>\n<h3 id=\"411\">4.11　术语表</h3>\n<p><strong>函数</strong>：可接受输入和执行指令，并返回输出的复合语句。</p>\n<p><strong>惯例</strong>：普遍认可的行为方式。</p>\n<p><strong>调用</strong>：向函数提供执行指令、返回输出所需的输入。</p>\n<p><strong>参数</strong>：传递给函数的数据。</p>\n<p><strong>必选参数</strong>：非可选参数。</p>\n<p><strong>可选参数</strong>：非必须提供的参数。</p>\n<p><strong>内置函数</strong>：Python 自带的函数。</p>\n<p><strong>作用域</strong>：变量可进行读写的范围。</p>\n<p><strong>全局作用域</strong>：可在程序中任何地方读写的变量的作用域。</p>\n<p><strong>全局变量</strong>：拥有全局作用域的变量。</p>\n<p><strong>局部作用域</strong>：只能在其定义所在的函数（或类）中读写的变量的作用域。</p>\n<p><strong>异常处理</strong>：一个编程概念，要求检测错误条件。如果符合则捕获异常，并决定如何处理。</p>\n<p><strong>文档字符串</strong>：解释函数功能，记录其参数类型的字符串。</p>\n<h3 id=\"412\">4.12　挑战练习</h3>\n<p>1．编写一个函数，接受数字作为输入，并返回该数字的平方。</p>\n<p>2．编写一个以字符串为参数并将其打印的函数。</p>\n<p>3．编写一个接受 3 个必选参数、两个可选参数的函数。</p>\n<p>4．编写一个带两个函数的程序。第一个函数应接受一个整数为参数，并返回该整数除以 2 的值。第二个函数应接受一个整数作为参数，并返回该整数乘以 4 的值。调用第一个函数，将结果保存至变量，并将变量作为参数传递给第二个函数。</p>\n<p>5．编写一个将字符串转换为 float 对象并返回该结果的函数。使用异常处理来捕获可能发生的异常。</p>\n<p>6．为挑战练习 1～5 中编写的所有函数添加文档字符串。</p>\n<p>答案可从异步社区（www.epubit.com）本书详情页的配套资源中下载。</p></div></article>\n\n</body>\n</html>","site":{"data":{}},"excerpt":"","more":"\n<!DOCTYPE html>\n<html lang=\"en\">\n<head><meta name=\"generator\" content=\"Hexo 3.8.0\">\n    <meta charset=\"UTF-8\">\n    <title>函数</title>\n</head>\n<body>\n<article id=\"articleDiv\"><div class=\"mazi-article-content dont-break-out\"><p></p><div class=\"toc\">\n<ul>\n<li><ul>\n<li><ul>\n<li><a href=\"#41\">4.1　表达概念</a></li>\n<li><a href=\"#42\">4.2　函数</a></li>\n<li><a href=\"#43\">4.3　定义函数</a></li>\n<li><a href=\"#44\">4.4　内置函数</a></li>\n<li><a href=\"#45\">4.5　复用函数</a></li>\n<li><a href=\"#46\">4.6　必选及可选参数</a></li>\n<li><a href=\"#47\">4.7　作用域</a></li>\n<li><a href=\"#48\">4.8　异常处理</a></li>\n<li><a href=\"#49\">4.9　文档字符串</a></li>\n<li><a href=\"#410\">4.10　有需要才使用变量</a></li>\n<li><a href=\"#411\">4.11　术语表</a></li>\n<li><a href=\"#412\">4.12　挑战练习</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>\n<p></p>\n<blockquote>\n  <p><span style=\"font-family: Times New Roman,楷体_GB2312\">“函数应该做一件事。做好这件事。只能做这一件事。”</span></p>\n  <p><span style=\"font-family: Times New Roman,楷体_GB2312\">——罗伯特 · C. 马丁（Robert C.Martin）</span></p>\n</blockquote>\n<p>本章将介绍<strong>函数（function）</strong>：可接受输入，执行指令并返回输出的复合语句。通过函数，我们可以在程序中定义功能，并重复使用。其示例如图 4-1 所示。</p>\n<p><img src=\"https://images.gitbook.cn/8f24fa40-6fc0-11e9-9e1b-5b6158413fa5\" alt=\"enter image description here\"></p>\n<p>图 4-1　函数</p>\n<h3 id=\"41\">4.1　表达概念</h3>\n<p>从此处开始，本书将在解释编程概念时使用一种新<strong>约定</strong>（convention）（一种共同认同的方式）。例如，通过 <code>print(\"[想打印的内容]\")</code> 来介绍如何使用 print 函数。</p>\n<p>新约定中结合使用了 Python 代码和方括号，方括号中的描述用来解释编程概念。当给出类似示例时，除了方括号及其中的内容之外，其他所有都是有效的 Python 代码。方括号中的内容隐含了你应该使用何种代码进行替换。Python 语法中也有使用方括号，因此在代码中本该应用方括号的处置将使用两个方括号体现。</p>\n<h3 id=\"42\">4.2　函数</h3>\n<p><strong>调用</strong>（call）一个函数，意味着为函数提供执行指令并返回输出所需的输入。函数的每一个输入就是一个<strong>参数</strong>（parameter）。当你为函数提供参数时，则被称为“函数传参”。</p>\n<p>Python 中的函数类似于数学函数。如果忘记了代数中的函数，请看下面这个示例：</p>\n<pre><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># 请不要运行代码</span>\n2\n3\n4\n5  f(x) = x * 2\n</code></pre>\n<p>上面代码中语句左侧定义了一个函数 <code>f</code>，接受一个参数 <code>x</code>。语句右侧是函数的具体定义，利用 <code>(x)</code> 中传递的参数进行计算并返回结果（输出）。本例中，函数的值被定义为函数的参数乘以 2。</p>\n<p>Python 和代数均使用如下语法调用函数：<code>[函数名]([逗号分隔的参数])</code>。在函数名后加上圆括号即可进行调用，参数放置在圆括号中，以逗号分隔。对于 <code>f(x) = x * 2</code> 这个数学函数，<code>f(2)</code> 的值是 4，<code>f(10)</code> 的值是 20。</p>\n<h3 id=\"43\">4.3　定义函数</h3>\n<p>在 Python 中创建一个函数，需要选择函数名，并定义其参数、行为和返回值。下面是定义函数的语法：</p>\n<pre class=\"代码无行号\"><code class=\"hljs markdown\">1  # 请不要执行代码\n2\n3\n4\n5  <strong>def</strong> [<span class=\"hljs-string\">函数名</span>](<span class=\"hljs-link\">[参数]</span>):\n6      [函数定义]</code></pre>\n<p>数学函数 f(x) = x * 2 在 Python 中应该表示如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/j9dctwl</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(x)</span>:</span>\n<span class=\"hljs-number\">5</span>      <strong><span class=\"hljs-keyword\">return</span></strong> x * <span class=\"hljs-number\">2</span></code></pre>\n<p>关键字 <code>def</code> 告诉 Python 操作者正在定义一个函数。在 <code>def</code> 关键字后面，指定函数的名称，名称选择遵循与变量名相同的规则。按惯例，函数名不应使用大写字母，单词用下划线分隔：<code>like_this</code>。</p>\n<p>命名函数之后，在名称后加上一对圆括号，圆括号中则是希望函数接受的参数。</p>\n<p>在圆括号之后加入冒号，然后换行并缩进 4 个空格符（和其他复合语句一样）。冒号之后所有缩进 4 个空格符的代码，就是函数的定义。本例中，函数的定义仅有一行，即 <code>return x * 2</code>。关键字 <code>return</code> 指定了调用函数时输出的值，我们称之为函数的返回值。</p>\n<p>在 Python 中，可以使用语法“<code>[函数名]([逗号分隔的参数])</code>”来调用一个函数。以下就是以 2 作为参数调用上述示例中函数 <code>f</code> 的示例：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">1  <span class=\"hljs-comment\"># http://tinyurl.com/zheas3d</span>\n2\n3\n4  <span class=\"hljs-comment\"># 接上一个示例</span>\n5\n6\n7\n8  f(2)</code></pre>\n<p>控制台没有打印任何输出。你可以将函数的输出保存在一个变量中，然后将其传给 <code>print</code> 函数。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gspjcgj</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-comment\"># 接上一个示例</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  result = f(<span class=\"hljs-number\">2</span>)\n<span class=\"hljs-number\">9</span>  print(result)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">4</span></code></pre>\n<p>如果后面在程序中有需要使用函数返回值的地方，建议将函数的返回值保存到一个变量中。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs python\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/znqp8fk</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(x)</span>:</span>\n<span class=\"hljs-number\">05</span>      <strong><span class=\"hljs-keyword\">return</span></strong> x + <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>\n<span class=\"hljs-number\">08</span>  z = f(<span class=\"hljs-number\">4</span>)\n<span class=\"hljs-number\">09</span>\n<span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">11</span>  <strong><span class=\"hljs-keyword\">if</span></strong> z == <span class=\"hljs-number\">5</span>:\n<span class=\"hljs-number\">12</span>      <strong>print</strong>(<span class=\"hljs-string\">\"z is 5\"</span>)\n<span class=\"hljs-number\">13</span>  <strong><span class=\"hljs-keyword\">else</span></strong>:\n<span class=\"hljs-number\">14</span>      print(<span class=\"hljs-string\">\"z is not 5\"</span>)\n\n&gt;&gt; z <span class=\"hljs-keyword\">is</span> <span class=\"hljs-number\">5</span></code></pre>\n<p>函数可以有一个或多个参数，也可以不接受任何参数。如要定义不需要参数的函数，只需要在定义函数时把圆括号内置为空即可：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/htk7tr6</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span></span>:\n<span class=\"hljs-number\">5</span>      <strong><span class=\"hljs-keyword\">return</span></strong> <span class=\"hljs-number\">1</span> + <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  result = f()\n<span class=\"hljs-number\">9</span>  print(result)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">2</span></code></pre>\n<p>如要函数要接受多个参数，则必须将圆括号中的参数以逗号相隔：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gqmkft7</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(x, y, z)</span></span>:\n<span class=\"hljs-number\">5</span>      <strong><span class=\"hljs-keyword\">return</span></strong> x + y + z\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  result = f(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>)\n<span class=\"hljs-number\">9</span>  print(result)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">6</span></code></pre>\n<p>最后，函数必须包含 <code>return</code> 语句。如果函数没有 <code>return</code> 语句，则会返回 <code>None</code>。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/j8qyqov</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span>:</span>\n<span class=\"hljs-number\">5</span>      z = <span class=\"hljs-number\">1</span> + <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  result = f()\n<span class=\"hljs-number\">9</span>  print(result)\n\n&gt;&gt; <span class=\"hljs-keyword\">None</span></code></pre>\n<h3 id=\"44\">4.4　内置函数</h3>\n<p>Python 编程语言中自带了一个被称为<strong>内置函数</strong>（builtin function）的函数库，它可执行各式各样的计算和任务，而不需任何额外的工作。在前面已经看到过一个内置函数的例子：我们编写的第一个程序就使用了 <code>print</code> 函数打印 <code>\"Hello, World!\"</code>。</p>\n<p>len 也是一个内置函数，表示返回对象的长度，如字符串的长度（字符的数量）。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zfkzqw6</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  len(<span class=\"hljs-string\">\"Monty\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">5</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h75c3cf</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  len(<span class=\"hljs-string\">\"Python\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">6</span>\n</code></pre>\n<p>内置函数 <code>str</code> 接受一个对象作为参数，并返回一个数据类型为 <code>str</code> 的新对象。例如，可使用 <code>str</code> 将一个整型数据转换成一个字符串。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/juzxg2z</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  str(<span class=\"hljs-number\">100</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'100'</span>\n</code></pre>\n<p><code>int</code> 函数可接受一个对象作为参数，并返回一个整型对象。示例如下：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/j42qhkf</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-keyword\">int</span>(<span class=\"hljs-string\">\"1\"</span>)\n\n&gt;&gt; <span class=\"hljs-number\">1</span>\n</code></pre>\n<p><code>float</code> 函数可接受一个对象作为参数，并返回一个浮点数对象。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hnk8gh2</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  fload(<span class=\"hljs-number\">100</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">100.0</span>\n</code></pre>\n<p>传给 <code>str</code>、<code>int</code> 或 <code>float</code> 函数的参数，必须要能够转换为字符串、整数或浮点数。<code>str</code> 函数可接受大部分对象作为参数，但是 <code>int</code> 函数只能接受内容为数字的字符串或浮点数对象。<code>float</code> 函数只能接受内容为数字的字符串或整型对象。具体示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jcchmlx</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  int(<span class=\"hljs-string\">\"110\"</span>)\n<span class=\"hljs-number\">5</span>  int(<span class=\"hljs-number\">20.54</span>)\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  float(<span class=\"hljs-string\">\"16.4\"</span>)\n<span class=\"hljs-number\">9</span>  float(<span class=\"hljs-number\">99</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">100</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">20</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">16.4</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">99.0</span>\n</code></pre>\n<p>如果向 <code>int</code> 或 <code>float</code> 函数中传递的是无法转换为整数或浮点数的参数，Python 将会报出异常错误如下：</p>\n<pre><code class=\"hljs perl\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zseo21s</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-keyword\">int</span>(<span class=\"hljs-string\">\"Prince\"</span>)\n\n&gt;&gt; ValueError: invalid literal <span class=\"hljs-keyword\">for</span> <span class=\"hljs-keyword\">int</span>() with base <span class=\"hljs-number\">10</span>: <span class=\"hljs-string\">'Prince'</span>\n</code></pre>\n<p>使用内置函数 <code>input</code> 收集用户的信息的示例代码如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs perl\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zynprpg</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  age = input(<span class=\"hljs-string\">\"Enter your age:\"</span>)\n<span class=\"hljs-number\">5</span>  int_age = <span class=\"hljs-keyword\">int</span>(age)\n<span class=\"hljs-number\">6</span>  <strong><span class=\"hljs-keyword\">if</span></strong> int_age &lt; <span class=\"hljs-number\">21</span>:\n<span class=\"hljs-number\">7</span>      <span class=\"hljs-keyword\">print</span>(<span class=\"hljs-string\">\"You are young!\"</span>)\n<span class=\"hljs-number\">8</span>  <strong><span class=\"hljs-keyword\">else</span></strong>:\n<span class=\"hljs-number\">9</span>      <span class=\"hljs-keyword\">print</span>(<span class=\"hljs-string\">\"Wow, you are old!\"</span>)\n\n&gt;&gt; Enter your age:</code></pre>\n<p><code>input</code> 函数接受一个字符串作为参数，并将其展示给使用该程序的用户。用户在 shell 中输入回答，程序将回答保存在变量 <code>age</code> 中。</p>\n<p>接下来，使用 <code>int</code> 函数将 <code>age</code> 变量的值从字符串转换为整数。<code>input</code> 函数从用户收集数据以作为 <code>str</code>，但是需要将变量设为 <code>int</code> 才能与其他整数进行比较。转换为整数后，<code>if-else</code> 语句根据用户的输入决定为用户打印什么信息。如果用户输入的数字小于 21，则打印“<code>You are young!”</code>。如果用户输入的数字大于 21，则打印“<code>Wow, you are old!”</code>。</p>\n<h3 id=\"45\">4.5　复用函数</h3>\n<p>函数不仅可用于计算并返回值，还可以封装我们希望复用的功能。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zhy8y4m</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">even_odd</span><span class=\"hljs-params\">(x)</span></span>:\n<span class=\"hljs-number\">05</span>      <strong><span class=\"hljs-keyword\">if</span></strong> x % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>:\n<span class=\"hljs-number\">06</span>          print(<span class=\"hljs-string\">\"even\"</span>)\n<span class=\"hljs-number\">07</span>      <strong><span class=\"hljs-symbol\">else</span></strong><span class=\"hljs-symbol\">:</span>\n08          print(<span class=\"hljs-string\">\"odd\"</span>)\n09\n<span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">11</span>  even_odd(<span class=\"hljs-number\">2</span>)\n<span class=\"hljs-number\">12</span>  even_odd(<span class=\"hljs-number\">3</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> even\n<span class=\"hljs-meta\">&gt;&gt;</span> odd</code></pre>\n<p>这里虽然没有定义函数的返回值，但是该函数还是有用的：它检测 <code>x % 2 == 0</code> 是否为真，并打印 <code>x</code> 是奇数还是偶数。</p>\n<p>因为可以对函数进行复用，所以利用函数可以减少代码量。一个未使用函数的示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs perl\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jk8lugl</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  n = input(<span class=\"hljs-string\">\"type a number:\"</span>)\n<span class=\"hljs-number\">05</span>  n = <span class=\"hljs-keyword\">int</span>(n)\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>\n08  <strong><span class=\"hljs-keyword\">if</span></strong> n % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>:\n09      <span class=\"hljs-keyword\">print</span>(<span class=\"hljs-string\">\"n is even.\"</span>)\n<span class=\"hljs-number\">10</span>  <strong><span class=\"hljs-keyword\">else</span></strong>:\n<span class=\"hljs-number\">11</span>      <strong><span class=\"hljs-keyword\">print</span></strong>(<span class=\"hljs-string\">\"n is odd.\"</span>)\n<span class=\"hljs-number\">12</span>\n<span class=\"hljs-number\">13</span>\n<span class=\"hljs-number\">14</span>  n = input(<span class=\"hljs-string\">\"type a number:\"</span>)\n<span class=\"hljs-number\">15</span>  n = <span class=\"hljs-keyword\">int</span>(n)\n<span class=\"hljs-number\">16</span>  <strong><span class=\"hljs-keyword\">if</span></strong> n % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>:\n<span class=\"hljs-number\">17</span>      <span class=\"hljs-keyword\">print</span>(<span class=\"hljs-string\">\"n is even.\"</span>)\n<span class=\"hljs-number\">18</span>  <strong><span class=\"hljs-keyword\">else</span></strong>:\n<span class=\"hljs-number\">19</span>      <span class=\"hljs-keyword\">print</span>(<span class=\"hljs-string\">\"n is odd.\"</span>)\n<span class=\"hljs-number\">20</span>\n<span class=\"hljs-number\">21</span>\n<span class=\"hljs-number\">22</span>  n = input(<span class=\"hljs-string\">\"type a number:\"</span>)\n<span class=\"hljs-number\">23</span>  n = <span class=\"hljs-keyword\">int</span>(n)\n<span class=\"hljs-number\">24</span>  <strong><span class=\"hljs-keyword\">if</span></strong> n % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>:\n<span class=\"hljs-number\">25</span>      <span class=\"hljs-keyword\">print</span>(<span class=\"hljs-string\">\"n is even.\"</span>)\n<span class=\"hljs-number\">26</span>  <strong><span class=\"hljs-keyword\">else</span></strong>:\n<span class=\"hljs-number\">27</span>      <span class=\"hljs-keyword\">print</span>(<span class=\"hljs-string\">\"n is odd.\"</span>)\n\n&gt;&gt; type a number:</code></pre>\n<p>上面这个程序让用户 3 次输入数字，然后通过 <code>if-else</code> 语句检查数字是否为偶数。如果为偶数，则打印“<code>n is even.”</code>，否则打印“<code>n is odd.”</code>。</p>\n<p>这个程序的问题在于相同的代码重复了 3 次。如果将功能封装在函数中，再调用函数 3 次，则可以大幅减少程序的代码量，并提高可读性。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs python\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zzn22mz</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">even_odd</span><span class=\"hljs-params\">()</span>:</span>\n<span class=\"hljs-number\">05</span>      n = input(<span class=\"hljs-string\">\"type a number:\"</span>)\n<span class=\"hljs-number\">06</span>      n = int(n)\n<span class=\"hljs-number\">07</span>      <strong><span class=\"hljs-keyword\">if</span></strong> n % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>:\n<span class=\"hljs-number\">08</span>          print(<span class=\"hljs-string\">\"n is even.\"</span>)\n<span class=\"hljs-number\">09</span>      <strong><span class=\"hljs-keyword\">else</span></strong>:\n<span class=\"hljs-number\">10</span>          print(<span class=\"hljs-string\">\"n is odd.\"</span>)\n<span class=\"hljs-number\">11</span>\n<span class=\"hljs-number\">12</span>\n<span class=\"hljs-number\">13</span>  even_odd()\n<span class=\"hljs-number\">14</span>  even_odd()\n<span class=\"hljs-number\">15</span>  even_odd()\n\n&gt;&gt; type a number:</code></pre>\n<p>新程序的功能与前一个程序完全相同，但是由于将功能封装在了一个可随时按需调用的函数中，代码量大幅减少，可读性大大提升。</p>\n<h3 id=\"46\">4.6　必选及可选参数</h3>\n<p>函数可接受两种参数。目前所看到的都是<strong>必选参数</strong>（required parameter）。当用户调用函数时，必须传入所有必选参数，否则 Python 将报告异常错误。</p>\n<p>Python 中还有另一种参数，即<strong>可选参数</strong>（optional parameter）。函数只在需要时才会传入，并不是执行程序所必须的。如果没有传入可选参数，函数将使用其默认值。使用如下语法定义可选参数：<code>[函数名]([参数名]=[参数值])</code>。与必选参数一样，可选参数也得使用逗号分隔。一个带可选参数的函数示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h3ych4h</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(x=<span class=\"hljs-number\">2</span>)</span></span>:\n<span class=\"hljs-number\">5</span>      <strong><span class=\"hljs-keyword\">return</span></strong> x ** x\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  print(f())\n<span class=\"hljs-number\">9</span>  print(f(<span class=\"hljs-number\">4</span>))\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">4</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">256</span></code></pre>\n<p>首先，这里没有传入参数而是直接调用函数。因为参数是可选的，<code>x</code> 自动获得值为 2，函数返回 4。</p>\n<p>接下来，传入参数 4 并调用函数。函数没有使用默认值，<code>x</code> 获得值为 4，函数返回 256。你可以定义一个既有必选参数也有可选参数的函数，但是必选参数必须位于可选参数之前。</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hm5svn9</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">add_it</span><span class=\"hljs-params\">(x, y=<span class=\"hljs-number\">10</span>)</span></span>:\n<span class=\"hljs-number\">5</span>      <strong><span class=\"hljs-keyword\">return</span></strong> x + y\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  result = add_it(<span class=\"hljs-number\">2</span>)\n<span class=\"hljs-number\">9</span>  print(result)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">12</span></code></pre>\n<h3 id=\"47\">4.7　作用域</h3>\n<p>变量有一个很重要的属性，<strong>作用域</strong>（scope）。定义变量时，其作用域指的是哪部分程序可以对其进行读写。读取一个变量意味着获取它的值，写变量意味着修改它的值。变量的作用域由其定义在程序中所处的位置决定。</p>\n<p>如果在函数（或类，本书第二部分将介绍）之外定义了一个变量，则变量拥有<strong>全局作用域</strong>（global scope）：即在程序中任意地方都可以对其进行读写操作。带有全局作用域的变量，被称为<strong>全局变量</strong>（global variable）。如果在函数（或类）内部定义一个变量，则变量拥有<strong>局部作用域</strong>（local scope）：即程序只有在定义该变量的函数内部才可对其进行读写。下面示例中的变量拥有全局作用域：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/zhmxnqt</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  x = <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">5</span>  y = <span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">6</span>  z = <span class=\"hljs-number\">3</span>\n</code></pre>\n<p>这些变量不是在函数（或类）内部定义的，因此拥有全局作用域。这意味着可以在程序的任意地方对其进行读写，包含在函数内部。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hgvnj4p</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  x = <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">05</span>  y = <span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">06</span>  z = <span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">07</span>\n08\n09  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span></span>:\n<span class=\"hljs-number\">10</span>      print(x)\n<span class=\"hljs-number\">11</span>      print(y)\n<span class=\"hljs-number\">12</span>      print(z)\n<span class=\"hljs-number\">13</span>\n<span class=\"hljs-number\">14</span>\n<span class=\"hljs-number\">15</span>  f()\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">1</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">2</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">3</span></code></pre>\n<p>如果是在函数内部定义的这些变量，则只能在那个函数内部对其进行读写。如果尝试在该函数之外访问它们，Python 会报异常错误。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs python\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/znka93k</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span>:</span>\n<span class=\"hljs-number\">05</span>      x = <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">06</span>      y = <span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">07</span>      z = <span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">08</span>\n<span class=\"hljs-number\">09</span>\n<span class=\"hljs-number\">10</span>  print(x)\n<span class=\"hljs-number\">11</span>  print(y)\n<span class=\"hljs-number\">12</span>  print(z)\n\n&gt;&gt; NameError: name <span class=\"hljs-string\">'x'</span> <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> defined</code></pre>\n<p>如果在函数内部定义这些变量，则会成功运行。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z2k3jds</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span></span>:\n<span class=\"hljs-number\">05</span>      x = <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">06</span>      y = <span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">07</span>      z = <span class=\"hljs-number\">3</span>\n08      print(x)\n09      print(y)\n<span class=\"hljs-number\">10</span>      print(z)\n<span class=\"hljs-number\">11</span>\n<span class=\"hljs-number\">12</span>\n<span class=\"hljs-number\">13</span>  f()\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">1</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">2</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">3</span></code></pre>\n<p>在定义变量的函数之外使用变量，相当于使用一个尚未定义的变量，二者都会使 Python 报告相同的异常错误：</p>\n<pre class=\"代码无行号\"><code class=\"hljs coffeescript\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zn8zjmr</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-keyword\">if</span></strong> x &gt; <span class=\"hljs-number\">100</span>:\n<span class=\"hljs-number\">5</span>      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"x is &gt; 100\"</span>)\n\n&gt;&gt; NameError: name <span class=\"hljs-string\">'x'</span> <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> defined</code></pre>\n<p>可以在程序的任何地方对全局变量进行写操作，但是在局部作用域中需稍加注意：必须明确使用 <code>global</code> 关键字，并在其后写上希望修改的变量。Python 要求这样做，是为了确保在函数内部定义变量 <code>x</code> 时，不会意外变更之前在函数外部定义的变量的值。在函数内部对全局变量进行写操作的示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs python\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zclmda7</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  x = <span class=\"hljs-number\">100</span>\n<span class=\"hljs-number\">05</span>\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span>:</span>\n<span class=\"hljs-number\">08</span>      <strong><span class=\"hljs-keyword\">global</span></strong> x\n<span class=\"hljs-number\">09</span>      x += <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">10</span>      print(x)\n<span class=\"hljs-number\">11</span>\n<span class=\"hljs-number\">12</span>\n<span class=\"hljs-number\">13</span>  f()\n\n&gt;&gt; <span class=\"hljs-number\">101</span></code></pre>\n<p>没有作用域，则可以在程序任何地方访问所有变量，这样会造成很大的问题。如果程序代码量很大，其中有一个使用变量 x 的函数，你可能会在其他地方修改该变量的值。类似这样的错误会改变程序的行为，并导致意料之外的结果。程序规模越大，变量数量越多，出现问题的可能性就越高。</p>\n<h3 id=\"48\">4.8　异常处理</h3>\n<p>依赖 input 函数获得用户输入，则意味着无法控制程序的输入（用户提供的输入可能会导致错误）。例如，假设你写了一个程序，从用户端收集两个数字并打印第一个数字除以第二个数字的结果。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jcg5qwp</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  a = input(<span class=\"hljs-string\">\"type a nubmer:\"</span>)\n<span class=\"hljs-number\">5</span>  b = input(<span class=\"hljs-string\">\"type another:\"</span>)\n<span class=\"hljs-number\">6</span>  a = int(a)\n<span class=\"hljs-number\">7</span>  b = int(b)\n<span class=\"hljs-number\">8</span>  print(a / b)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> type a <span class=\"hljs-symbol\">number:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">10</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> type <span class=\"hljs-symbol\">another:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">5</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">2</span>\n</code></pre>\n<p>程序看起来运行正常。但是，如果用户第二个数字输入的是 0，则会出现问题，如下所示：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/ztpcjs4</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  a = input(<span class=\"hljs-string\">\"type a nubmer:\"</span>)\n<span class=\"hljs-number\">5</span>  b = input(<span class=\"hljs-string\">\"type another:\"</span>)\n<span class=\"hljs-number\">6</span>  a = int(a)\n<span class=\"hljs-number\">7</span>  b = int(b)\n<span class=\"hljs-number\">8</span>  print(a / b)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> type a <span class=\"hljs-symbol\">number:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">10</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> type <span class=\"hljs-symbol\">another:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">0</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-symbol\">ZeroDivisionError:</span> integer division or modulo by zero\n</code></pre>\n<p>这里不能指望使用程序的用户不会输入 0 作为第二个数字。其解决方法是使用<strong>异常处理</strong>（exception handling），支持测试错误条件，在错误发生时捕获异常，然后决定如何处理。</p>\n<p>异常处理使用 <code>try</code> 和 <code>except</code> 关键字。在你修改程序使用异常处理之后，如果用户第二个数字输入 0，程序不会报错，而是会打印一段话告诉用户不要输入 0。</p>\n<p>Python 中的每一个异常都是一个对象，可在如下网址查看所有内置异常：https://www.tutorialspoint.com/python/standard_exceptions.htm。如果你认为代码可能会报告异常，可使用关键字 <code>try</code> 和 <code>except</code> 来捕获。</p>\n<p><code>try</code> 从句包含可能会发生的错误，<code>except</code> 从句包含仅在错误发生时执行的代码。下面是在程序中进行异常处理的一个示例，这样如果用户输入0作为第二个数字，程序也不会崩溃。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/j2scn4f</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  a = input(<span class=\"hljs-string\">\"type a nubmer:\"</span>)\n<span class=\"hljs-number\">05</span>  b = input(<span class=\"hljs-string\">\"type another:\"</span>)\n<span class=\"hljs-number\">06</span>  a = int(a)\n<span class=\"hljs-number\">07</span>  b = int(b)\n08  <strong><span class=\"hljs-symbol\">try</span></strong><span class=\"hljs-symbol\">:</span>\n09      print(a / b)\n<span class=\"hljs-number\">10</span>  <strong>except</strong> <span class=\"hljs-symbol\">ZeroDivisionError:</span>\n<span class=\"hljs-number\">11</span>      print(<span class=\"hljs-string\">\"b cannot be zero.\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> type a <span class=\"hljs-symbol\">number:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">10</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> type <span class=\"hljs-symbol\">another:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">0</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> b cannot be zero.</code></pre>\n<p>如果用户为 <code>b</code> 参数提供的输入不是 0，则执行 <code>try</code> 代码块，<code>except</code> 代码块不执行。如果用户为 <code>b</code> 参数提供的输入为 0，Python 不会报错，而是执行 <code>except</code> 代码块，并打印“<code>b cannot be zero.</code>”。</p>\n<p>如果用户输入的是无法转换为整型数的字符串，程序也会崩溃。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  a = input(<span class=\"hljs-string\">\"type a nubmer:\"</span>)\n<span class=\"hljs-number\">2</span>  b = input(<span class=\"hljs-string\">\"type another:\"</span>)\n<span class=\"hljs-number\">3</span>  a = int(a)\n<span class=\"hljs-number\">4</span>  b = int(b)\n<span class=\"hljs-number\">5</span>  <strong><span class=\"hljs-symbol\">try</span></strong><span class=\"hljs-symbol\">:</span>\n<span class=\"hljs-number\">6</span>      print(a / b)\n<span class=\"hljs-number\">7</span>  <strong>except</strong> <span class=\"hljs-symbol\">ZeroDivisionError:</span>\n<span class=\"hljs-number\">8</span>      print(<span class=\"hljs-string\">\"b cannot be zero.\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> type a <span class=\"hljs-symbol\">number:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> Hundo\n<span class=\"hljs-meta\">&gt;&gt;</span> type <span class=\"hljs-symbol\">another:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> Million\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-symbol\">ValueError:</span> invalid literal for int() with base <span class=\"hljs-number\">10</span>: <span class=\"hljs-string\">'Hundo'</span></code></pre>\n<p>将收集用户收入的部分代码移入 <code>try</code> 语句内，并让 <code>except</code> 语句注意两个异常（ZeroDivisionError 和 ValueError）即可解决问题。如果向 <code>int</code>、<code>str</code> 或 <code>float</code> 等内置函数中传入无效输入，则会出现 <code>ValueError</code>。在 <code>except</code> 关键字后添加圆括号，并用逗号分隔两个异常即可将二者捕获。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jlus42v</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  <strong><span class=\"hljs-symbol\">try</span></strong><span class=\"hljs-symbol\">:</span>\n<span class=\"hljs-number\">05</span>      a = input(<span class=\"hljs-string\">\"type a nubmer:\"</span>)\n<span class=\"hljs-number\">06</span>      b = input(<span class=\"hljs-string\">\"type another:\"</span>)\n<span class=\"hljs-number\">07</span>      a = int(a)\n08      b = int(b)\n09      print(a / b)\n<span class=\"hljs-number\">10</span>  <strong>except</strong> (ZeroDivisionError,\n<span class=\"hljs-number\">11</span>          ValueError):\n<span class=\"hljs-number\">12</span>      print(<span class=\"hljs-string\">\"Invalid input.\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> type a <span class=\"hljs-symbol\">number:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> Hundo\n<span class=\"hljs-meta\">&gt;&gt;</span> type <span class=\"hljs-symbol\">another:</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> Million\n<span class=\"hljs-meta\">&gt;&gt;</span> Invalid input.</code></pre>\n<p>不要在 <code>except</code> 语句中使用 <code>try</code> 语句定义的变量，因为异常可能是在变量定义之前发生的，如果在 <code>except</code> 语句中这样做可能又会导致新的异常出现。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hockur5</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-keyword\">try</span></strong>:\n<span class=\"hljs-number\">5</span>      <span class=\"hljs-number\">10</span> / <span class=\"hljs-number\">0</span>\n<span class=\"hljs-number\">6</span>      c = <span class=\"hljs-string\">\"I will never get defined.\"</span>\n<span class=\"hljs-number\">7</span>  <strong><span class=\"hljs-keyword\">except</span></strong> ZeroDivisionError:\n<span class=\"hljs-number\">8</span>      print(c)\n\n&gt;&gt; NameError: name <span class=\"hljs-string\">'c'</span> <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> defined</code></pre>\n<h3 id=\"49\">4.9　文档字符串</h3>\n<p>定义一个带参数的函数时，有时要求参数必须是某种数据类型，函数才能成功执行。那么该如何将这点告知函数的调用者？在编写函数时，在函数顶部留下注释来解释每个参数应该为何种数据类型，是比较好的做法。这些注释被称为<strong>文档字符串</strong>（docstring）。文档字符串用于解释函数的功能，记录所需的参数类型。</p>\n<pre class=\"代码无行号\"><code class=\"hljs python\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zhahdcg</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  <strong><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span></span></strong><span class=\"hljs-function\"> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(x, y)</span>:</span>\n<span class=\"hljs-number\">05</span>      <span class=\"hljs-string\">\"\"\"\n06      返回 x + y 的值\n07      :param x: int.\n08      :param y: int.\n09      :return: int, x 与 y 之和\n10      \"\"\"</span>\n<span class=\"hljs-number\">11</span>      <strong><span class=\"hljs-keyword\">return</span></strong> x + y</code></pre>\n<p>文档字符串的第一行清楚地解释了函数的功能，因此当其他开发者使用该函数或方法时，他们不必读完所有代码才能弄清其目的。文档字符串的其他行列出了函数的参数、参数类型和返回值。文档字符串有助于开发者快速编程，因为不必通读代码，只需通过文档字符串即可了解函数的作用等必要信息。</p>\n<p>为了保证本书的示例简洁，书中省略了一般都会加上的文档字符串。正常情况下，我在编码时会加上文档字符串，以供其他开发者之后阅读。</p>\n<h3 id=\"410\">4.10　有需要才使用变量</h3>\n<p>只有在后面的程序中会用到数据，才有必要将其保存至变量。不要仅仅为了打印数值就将整数保存至变量。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zptktex</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  x = <span class=\"hljs-number\">100</span>\n<span class=\"hljs-number\">5</span>  print(x)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">100</span>\n</code></pre>\n<p>这里应该直接将整数传给 print 函数：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hmwr4kd</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  print(<span class=\"hljs-number\">100</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">100</span>\n</code></pre>\n<p>本书中的一些示例多次违背了这条准则，目的是为了方便大家理解。读者在写代码时没有必要这样做。</p>\n<h3 id=\"411\">4.11　术语表</h3>\n<p><strong>函数</strong>：可接受输入和执行指令，并返回输出的复合语句。</p>\n<p><strong>惯例</strong>：普遍认可的行为方式。</p>\n<p><strong>调用</strong>：向函数提供执行指令、返回输出所需的输入。</p>\n<p><strong>参数</strong>：传递给函数的数据。</p>\n<p><strong>必选参数</strong>：非可选参数。</p>\n<p><strong>可选参数</strong>：非必须提供的参数。</p>\n<p><strong>内置函数</strong>：Python 自带的函数。</p>\n<p><strong>作用域</strong>：变量可进行读写的范围。</p>\n<p><strong>全局作用域</strong>：可在程序中任何地方读写的变量的作用域。</p>\n<p><strong>全局变量</strong>：拥有全局作用域的变量。</p>\n<p><strong>局部作用域</strong>：只能在其定义所在的函数（或类）中读写的变量的作用域。</p>\n<p><strong>异常处理</strong>：一个编程概念，要求检测错误条件。如果符合则捕获异常，并决定如何处理。</p>\n<p><strong>文档字符串</strong>：解释函数功能，记录其参数类型的字符串。</p>\n<h3 id=\"412\">4.12　挑战练习</h3>\n<p>1．编写一个函数，接受数字作为输入，并返回该数字的平方。</p>\n<p>2．编写一个以字符串为参数并将其打印的函数。</p>\n<p>3．编写一个接受 3 个必选参数、两个可选参数的函数。</p>\n<p>4．编写一个带两个函数的程序。第一个函数应接受一个整数为参数，并返回该整数除以 2 的值。第二个函数应接受一个整数作为参数，并返回该整数乘以 4 的值。调用第一个函数，将结果保存至变量，并将变量作为参数传递给第二个函数。</p>\n<p>5．编写一个将字符串转换为 float 对象并返回该结果的函数。使用异常处理来捕获可能发生的异常。</p>\n<p>6．为挑战练习 1～5 中编写的所有函数添加文档字符串。</p>\n<p>答案可从异步社区（www.epubit.com）本书详情页的配套资源中下载。</p></div></article>\n\n</body>\n</html>"},{"title":"Python协程","_content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Python协程</title>\n</head>\n<body>\n<div id=\"article_content\" class=\"mazi-article-content dont-break-out\"><p>在 Python 3.4 时候引进了协程的概念，它使用一种单线程单进程的的方式实现并发。谈到并发，大多数朋友想到更多的应该是多进程和多线程，它们都是比较消耗系统资源的，今天我们不谈线程和进程，而是来说下当前比较火的协程。</p>\n<p>因为在爬虫操作中，协程比多线程更有优势。协程是单线程的，单线程就能实现高并发。</p>\n<h3 id=\"\">什么是协程？</h3>\n<p>协程，英文名是 Coroutine， 又称为微线程，是一种用户态的轻量级线程。协程不像线程和进程那样，需要进行系统内核上的上下文切换，协程的上下文切换是由程序员决定的。在 Python 中协程就是一个可以暂停执行的函数，听起来和生成器的概念一样。</p>\n<h3 id=\"-1\">协程的发展</h3>\n<p>从 Python3.4 开始协程被加入到标准库，当时的协程是通过 @asyncio.coroutine 和 yeild from 实现的，看起来和生成器的实现方式没什么区别。后来为了更好的区分开协程和生成器，到 Python3.5 的时候引入 async/await 语法糖临时定格了下来，直到 Python3.6 的时候才被更多的人认可，Python3.6 作为 Python3 目前最稳定的版本拥有大量的使用者，后来到了 Python3.7 官方把 async 和 await 作为保留字，同时协程的调用也变得简单了许多，但是，正是保留字的原因导致之前很多 async 为函数名的库报错，典型的有 scrapy，所以这里推荐大家使用 Python3.6。</p>\n<h3 id=\"-2\">协程相对于多线程的优点</h3>\n<p>多线程编程是比较困难的， 因为调度程序任何时候都能中断线程， 必须记住保留锁， 去保护程序中重要部分， 防止多线程在执行的过程中断。</p>\n<p>而协程默认会做好全方位保护， 以防止中断。我们必须显示产出才能让程序的余下部分运行。对协程来说， 无需保留锁， 而在多个线程之间同步操作， 协程自身就会同步， 因为在任意时刻， 只有一个协程运行。总结下大概下面几点：</p>\n<ul>\n<li>无需系统内核的上下文切换，减小开销；</li>\n<li>无需原子操作锁定及同步的开销，不用担心资源共享的问题；</li>\n<li>单线程即可实现高并发，单核 CPU 即便支持上万的协程都不是问题，所以很适合用于高并发处理，尤其是在应用在网络爬虫中。</li>\n</ul>\n<h3 id=\"-3\">协程的定义</h3>\n<p>使用协程也就意味着你需要一直写异步方法。在 Python 中我们使用 asyncio 模块来实现一个协程。如果我们把 Python 中普通函数称之为同步函数（方法），那么用协程定义的函数我们称之为异步函数（方法）。 </p>\n<blockquote>\n  <p>注意，以下所有的代码实例运行环境均要求版本大于等于 Python3.6。</p>\n</blockquote>\n<h4 id=\"-4\">同步函数和异步函数的定义</h4>\n<p><strong>同步函数定义</strong></p>\n<pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">regular_double</span><span class=\"hljs-params\">(x)</span>:</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span> * x\n</code></pre>\n<p><strong>异步函数定义</strong></p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">async_double</span><span class=\"hljs-params\">(x)</span>:</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span> * x\n</code></pre>\n<h4 id=\"-5\">同步函数和异步函数的调用</h4>\n<p>对于同步函数我们知道是这样调用的：</p>\n<pre><code class=\"hljs\"> regular_double(2)\n</code></pre>\n<p>异步函数如何调用呢？带着这个问题我们看下面的一个简单例子。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">()</span>:</span>\n    print(<span class=\"hljs-string\">\"这是一个协程\"</span>)\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    loop = asyncio.get_event_loop() <span class=\"hljs-comment\"># 定义一个事件循环</span>\n    <span class=\"hljs-keyword\">try</span>:\n        print(<span class=\"hljs-string\">\"开始运行协程\"</span>)\n        coro = foo()\n        print(<span class=\"hljs-string\">\"进入事件循环\"</span>)\n        loop.run_until_complete(coro) <span class=\"hljs-comment\"># 运行协程</span>\n    <span class=\"hljs-keyword\">finally</span>:\n        print(<span class=\"hljs-string\">\"关闭事件循环\"</span>)\n        loop.close() <span class=\"hljs-comment\"># 运行完关闭协程</span>\n</code></pre>\n<p>这就是最简单的一个协程的例子，让我们了解一下上面的代码。 </p>\n<p>首先，需要导入需要的包 -asyncio。然后，创建一个事件循环，因为协程是基于事件循环的。 之后，通过 <code>run_until_complete</code> 方法传入一个异步函数，来运行这个协程。 最后在结束的时候调用 close 方法关闭协程。 综上就是调用一个协程的写法。除此之外协程还有其他的不同之处。</p>\n<h4 id=\"-6\">协程之间的链式调用</h4>\n<p>我们可以通过使用 await 关键字，在一个协程中调用一个协程。 一个协程可以启动另一个协程，从而可以使任务根据工作内容，封装到不同的协程中。我们可以在协程中使用 await 关键字，链式地调度协程，来形成一个协程任务流。像下面的例子一样：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    print(<span class=\"hljs-string\">\"主协程\"</span>)\n    print(<span class=\"hljs-string\">\"等待result1协程运行\"</span>)\n    res1 = <span class=\"hljs-keyword\">await</span> result1()\n    print(<span class=\"hljs-string\">\"等待result2协程运行\"</span>)\n    res2 = <span class=\"hljs-keyword\">await</span> result2(res1)\n    <span class=\"hljs-keyword\">return</span> (res1，res2)\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">result1</span><span class=\"hljs-params\">()</span>:</span>\n    print(<span class=\"hljs-string\">\"这是result1协程\"</span>)\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"result1\"</span>\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">result2</span><span class=\"hljs-params\">(arg)</span>:</span>\n    print(<span class=\"hljs-string\">\"这是result2协程\"</span>)\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">f\"result2接收了一个参数，<span class=\"hljs-subst\">{arg}</span>\"</span>\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    loop = asyncio.get_event_loop()\n    <span class=\"hljs-keyword\">try</span>:\n        result = loop.run_until_complete(main())\n        print(<span class=\"hljs-string\">f\"获取返回值:<span class=\"hljs-subst\">{result}</span>\"</span>)\n    <span class=\"hljs-keyword\">finally</span>:\n        print(<span class=\"hljs-string\">\"关闭事件循环\"</span>)\n        loop.close()\n</code></pre>\n<p>输出：</p>\n<pre><code class=\"hljs bash\">主协程\n等待result1协程运行\n这是result1协程\n等待result2协程运行\n这是result2协程\n获取返回值:(<span class=\"hljs-string\">'result1'</span>， <span class=\"hljs-string\">'result2接收了一个参数，result1'</span>)\n关闭事件循环\n</code></pre>\n<p>在上面，我们知道调用协程需要通过创建一个事件循环然后再去运行。 这里我们需要了解的是如果在协程里想调用一个协程我们需要使用 <strong>await</strong> 关键字，就拿上面的例子来说在 main 函数里调用协程 result1 和 result2。 那么问题来了：await 干了什么呢？</p>\n<h4 id=\"await\">await 的作用</h4>\n<p>await 的作用就是等待当前的协程运行结束之后再继续进行下面代码。 因为我们执行 result1 的时间很短，所以在表面上看 result1 和 result2 是一起执行的。这就是 await 的作用。等待一个协程的执行完毕，如果有返回结果，那么就会接收到协程的返回结果，通过使用 return 可以返回协程的一个结果，这个和同步函数的 return 使用方法一样。</p>\n<h4 id=\"-7\">并发的执行任务</h4>\n<p>一系列的协程可以通过 await 链式调用，但是有的时候我们需要在一个协程里等待多个协程，比如我们在一个协程里等待 1000 个异步网络请求，对于访问次序没有要求的时候，就可以使用关键字 wait 来解决了。wait 可以暂停一个协程，直到后台操作完成。</p>\n<p><strong>Task 的使用</strong></p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">num</span><span class=\"hljs-params\">(n)</span>:</span>\n    print(<span class=\"hljs-string\">f\"当前的数字是:<span class=\"hljs-subst\">{n}</span>\"</span>)\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(n)\n    print(<span class=\"hljs-string\">f\"等待时间:<span class=\"hljs-subst\">{n}</span>\"</span>)\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    tasks = [num(i) <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> range(<span class=\"hljs-number\">10</span>)] <span class=\"hljs-comment\">#协程列表</span>\n    <span class=\"hljs-comment\">#await asyncio.gather(*tasks) #有序并发</span>\n    <span class=\"hljs-keyword\">await</span> asyncio.wait(tasks) <span class=\"hljs-comment\">#并发运行协程列表的协程</span>\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    loop = asyncio.get_event_loop()\n    <span class=\"hljs-keyword\">try</span>:\n        loop.run_until_complete(main())\n    <span class=\"hljs-keyword\">finally</span>:\n        loop.close()\n</code></pre>\n<p>输出：</p>\n<pre><code class=\"hljs css\">当前的数字是<span class=\"hljs-selector-pseudo\">:0</span>\n当前的数字是<span class=\"hljs-selector-pseudo\">:4</span>\n当前的数字是<span class=\"hljs-selector-pseudo\">:8</span>\n当前的数字是<span class=\"hljs-selector-pseudo\">:1</span>\n当前的数字是<span class=\"hljs-selector-pseudo\">:5</span>\n当前的数字是<span class=\"hljs-selector-pseudo\">:7</span>\n当前的数字是<span class=\"hljs-selector-pseudo\">:2</span>\n当前的数字是<span class=\"hljs-selector-pseudo\">:6</span>\n当前的数字是<span class=\"hljs-selector-pseudo\">:9</span>\n当前的数字是<span class=\"hljs-selector-pseudo\">:3</span>\n等待时间<span class=\"hljs-selector-pseudo\">:0</span>\n等待时间<span class=\"hljs-selector-pseudo\">:1</span>\n等待时间<span class=\"hljs-selector-pseudo\">:2</span>\n等待时间<span class=\"hljs-selector-pseudo\">:3</span>\n等待时间<span class=\"hljs-selector-pseudo\">:4</span>\n等待时间<span class=\"hljs-selector-pseudo\">:5</span>\n等待时间<span class=\"hljs-selector-pseudo\">:6</span>\n等待时间<span class=\"hljs-selector-pseudo\">:7</span>\n等待时间<span class=\"hljs-selector-pseudo\">:8</span>\n等待时间<span class=\"hljs-selector-pseudo\">:9</span>\n</code></pre>\n<p>如果运行的话会发现首先会打印 10 次数字，但是并不是顺序执行的，这也说明 asyncio.wait 并发执行的时候是乱序的。如果想保证顺序只要使用 gather 把 task 写成解包的形式就行了，也就是上面的注释部分的代码。</p>\n<h4 id=\"-8\">如何在协程中使用普通的函数呢？</h4>\n<p>我们知道在普通函数中调用普通函数之间，函数名加括号即可，像下面这样：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">()</span>:</span>\n   print(<span class=\"hljs-string\">\"这是一个普通函数\"</span>)\n   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"test\"</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n   print(<span class=\"hljs-string\">\"调用foo函数\"</span>)\n   res=foo()\n   print(<span class=\"hljs-string\">f\"<span class=\"hljs-subst\">{接收到来自foo函数的值}</span>:res\"</span>)\n<span class=\"hljs-keyword\">if</span> __name__==<span class=\"hljs-string\">\"__main__\"</span>\n   main()\n</code></pre>\n<p>那么在协程中如何使用一个普通函数呢？ 在协程中可以通过一些方法去调用普通的函数。可以使用的关键字有 call_soon 等。</p>\n<h4 id=\"call_soon\">call_soon</h4>\n<p>可以通过字面意思理解调用立即返回。 下面来看一下具体的使用例子：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n<span class=\"hljs-keyword\">import</span> functools\n\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">callback</span><span class=\"hljs-params\">(args， *， kwargs=<span class=\"hljs-string\">\"defalut\"</span>)</span>:</span>\n    print(<span class=\"hljs-string\">f\"普通函数做为回调函数，获取参数:<span class=\"hljs-subst\">{args}</span>，<span class=\"hljs-subst\">{kwargs}</span>\"</span>)\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(loop)</span>:</span>\n    print(<span class=\"hljs-string\">\"注册callback\"</span>)\n    loop.call_soon(callback， <span class=\"hljs-number\">1</span>)\n    wrapped = functools.partial(callback， kwargs=<span class=\"hljs-string\">\"not defalut\"</span>)\n    loop.call_soon(wrapped， <span class=\"hljs-number\">2</span>)\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">0.2</span>)\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    loop = asyncio.get_event_loop()\n<span class=\"hljs-keyword\">try</span>:\n    loop.run_until_complete(main(loop))\n<span class=\"hljs-keyword\">finally</span>:\n    loop.close()\n</code></pre>\n<p>输出结果：</p>\n<pre><code class=\"hljs css\">注册<span class=\"hljs-selector-tag\">callback</span>\n普通函数做为回调函数，获取参数<span class=\"hljs-selector-pseudo\">:1</span>，<span class=\"hljs-selector-tag\">defalut</span>\n普通函数做为回调函数，获取参数<span class=\"hljs-selector-pseudo\">:2</span>，<span class=\"hljs-selector-tag\">not</span> <span class=\"hljs-selector-tag\">defalut</span>\n</code></pre>\n<p>通过输出结果我们可以发现我们在协程中成功调用了一个普通函数，顺序地打印了 1 和 2。</p>\n<p>看过这些例子之后，也许你就有疑问了，协程没有缺点的么？</p>\n<h3 id=\"-9\">协程的缺点</h3>\n<p>同样的总结下大概以下 2 点。</p>\n<h4 id=\"cpu\">无法使用 CPU 的多核</h4>\n<p>协程的本质是个单线程，它不能同时用上单个 CPU 的多个核，协程需要和进程配合才能运行在多 CPU 上。当然我们日常所编写的绝大部分应用都没有这个必要，就比如网络爬虫来说，限制爬虫的速度还有其他的因素，比如网站并发量、网速等问题都会是爬虫速度限制的因素。除非做一些密集型应用，这个时候才可能会用到多进程和协程。</p>\n<h4 id=\"-10\">处处都要使用非阻塞代码</h4>\n<p>写协程就意味着你要一值写一些非阻塞的代码，使用各种异步版本的库，比如后面的异步爬虫教程中用的 aiohttp 就是一个异步版本的request库等。 不过这些缺点并不能影响到使用协程的优势。</p>\n<hr>\n</div>\n</body>\n</html>","source":"_posts/gitchat/python_coroutine.html","raw":"---\ntitle: Python协程\n---\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Python协程</title>\n</head>\n<body>\n<div id=\"article_content\" class=\"mazi-article-content dont-break-out\"><p>在 Python 3.4 时候引进了协程的概念，它使用一种单线程单进程的的方式实现并发。谈到并发，大多数朋友想到更多的应该是多进程和多线程，它们都是比较消耗系统资源的，今天我们不谈线程和进程，而是来说下当前比较火的协程。</p>\n<p>因为在爬虫操作中，协程比多线程更有优势。协程是单线程的，单线程就能实现高并发。</p>\n<h3 id=\"\">什么是协程？</h3>\n<p>协程，英文名是 Coroutine， 又称为微线程，是一种用户态的轻量级线程。协程不像线程和进程那样，需要进行系统内核上的上下文切换，协程的上下文切换是由程序员决定的。在 Python 中协程就是一个可以暂停执行的函数，听起来和生成器的概念一样。</p>\n<h3 id=\"-1\">协程的发展</h3>\n<p>从 Python3.4 开始协程被加入到标准库，当时的协程是通过 @asyncio.coroutine 和 yeild from 实现的，看起来和生成器的实现方式没什么区别。后来为了更好的区分开协程和生成器，到 Python3.5 的时候引入 async/await 语法糖临时定格了下来，直到 Python3.6 的时候才被更多的人认可，Python3.6 作为 Python3 目前最稳定的版本拥有大量的使用者，后来到了 Python3.7 官方把 async 和 await 作为保留字，同时协程的调用也变得简单了许多，但是，正是保留字的原因导致之前很多 async 为函数名的库报错，典型的有 scrapy，所以这里推荐大家使用 Python3.6。</p>\n<h3 id=\"-2\">协程相对于多线程的优点</h3>\n<p>多线程编程是比较困难的， 因为调度程序任何时候都能中断线程， 必须记住保留锁， 去保护程序中重要部分， 防止多线程在执行的过程中断。</p>\n<p>而协程默认会做好全方位保护， 以防止中断。我们必须显示产出才能让程序的余下部分运行。对协程来说， 无需保留锁， 而在多个线程之间同步操作， 协程自身就会同步， 因为在任意时刻， 只有一个协程运行。总结下大概下面几点：</p>\n<ul>\n<li>无需系统内核的上下文切换，减小开销；</li>\n<li>无需原子操作锁定及同步的开销，不用担心资源共享的问题；</li>\n<li>单线程即可实现高并发，单核 CPU 即便支持上万的协程都不是问题，所以很适合用于高并发处理，尤其是在应用在网络爬虫中。</li>\n</ul>\n<h3 id=\"-3\">协程的定义</h3>\n<p>使用协程也就意味着你需要一直写异步方法。在 Python 中我们使用 asyncio 模块来实现一个协程。如果我们把 Python 中普通函数称之为同步函数（方法），那么用协程定义的函数我们称之为异步函数（方法）。 </p>\n<blockquote>\n  <p>注意，以下所有的代码实例运行环境均要求版本大于等于 Python3.6。</p>\n</blockquote>\n<h4 id=\"-4\">同步函数和异步函数的定义</h4>\n<p><strong>同步函数定义</strong></p>\n<pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">regular_double</span><span class=\"hljs-params\">(x)</span>:</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span> * x\n</code></pre>\n<p><strong>异步函数定义</strong></p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">async_double</span><span class=\"hljs-params\">(x)</span>:</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span> * x\n</code></pre>\n<h4 id=\"-5\">同步函数和异步函数的调用</h4>\n<p>对于同步函数我们知道是这样调用的：</p>\n<pre><code class=\"hljs\"> regular_double(2)\n</code></pre>\n<p>异步函数如何调用呢？带着这个问题我们看下面的一个简单例子。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">()</span>:</span>\n    print(<span class=\"hljs-string\">\"这是一个协程\"</span>)\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    loop = asyncio.get_event_loop() <span class=\"hljs-comment\"># 定义一个事件循环</span>\n    <span class=\"hljs-keyword\">try</span>:\n        print(<span class=\"hljs-string\">\"开始运行协程\"</span>)\n        coro = foo()\n        print(<span class=\"hljs-string\">\"进入事件循环\"</span>)\n        loop.run_until_complete(coro) <span class=\"hljs-comment\"># 运行协程</span>\n    <span class=\"hljs-keyword\">finally</span>:\n        print(<span class=\"hljs-string\">\"关闭事件循环\"</span>)\n        loop.close() <span class=\"hljs-comment\"># 运行完关闭协程</span>\n</code></pre>\n<p>这就是最简单的一个协程的例子，让我们了解一下上面的代码。 </p>\n<p>首先，需要导入需要的包 -asyncio。然后，创建一个事件循环，因为协程是基于事件循环的。 之后，通过 <code>run_until_complete</code> 方法传入一个异步函数，来运行这个协程。 最后在结束的时候调用 close 方法关闭协程。 综上就是调用一个协程的写法。除此之外协程还有其他的不同之处。</p>\n<h4 id=\"-6\">协程之间的链式调用</h4>\n<p>我们可以通过使用 await 关键字，在一个协程中调用一个协程。 一个协程可以启动另一个协程，从而可以使任务根据工作内容，封装到不同的协程中。我们可以在协程中使用 await 关键字，链式地调度协程，来形成一个协程任务流。像下面的例子一样：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    print(<span class=\"hljs-string\">\"主协程\"</span>)\n    print(<span class=\"hljs-string\">\"等待result1协程运行\"</span>)\n    res1 = <span class=\"hljs-keyword\">await</span> result1()\n    print(<span class=\"hljs-string\">\"等待result2协程运行\"</span>)\n    res2 = <span class=\"hljs-keyword\">await</span> result2(res1)\n    <span class=\"hljs-keyword\">return</span> (res1，res2)\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">result1</span><span class=\"hljs-params\">()</span>:</span>\n    print(<span class=\"hljs-string\">\"这是result1协程\"</span>)\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"result1\"</span>\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">result2</span><span class=\"hljs-params\">(arg)</span>:</span>\n    print(<span class=\"hljs-string\">\"这是result2协程\"</span>)\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">f\"result2接收了一个参数，<span class=\"hljs-subst\">{arg}</span>\"</span>\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    loop = asyncio.get_event_loop()\n    <span class=\"hljs-keyword\">try</span>:\n        result = loop.run_until_complete(main())\n        print(<span class=\"hljs-string\">f\"获取返回值:<span class=\"hljs-subst\">{result}</span>\"</span>)\n    <span class=\"hljs-keyword\">finally</span>:\n        print(<span class=\"hljs-string\">\"关闭事件循环\"</span>)\n        loop.close()\n</code></pre>\n<p>输出：</p>\n<pre><code class=\"hljs bash\">主协程\n等待result1协程运行\n这是result1协程\n等待result2协程运行\n这是result2协程\n获取返回值:(<span class=\"hljs-string\">'result1'</span>， <span class=\"hljs-string\">'result2接收了一个参数，result1'</span>)\n关闭事件循环\n</code></pre>\n<p>在上面，我们知道调用协程需要通过创建一个事件循环然后再去运行。 这里我们需要了解的是如果在协程里想调用一个协程我们需要使用 <strong>await</strong> 关键字，就拿上面的例子来说在 main 函数里调用协程 result1 和 result2。 那么问题来了：await 干了什么呢？</p>\n<h4 id=\"await\">await 的作用</h4>\n<p>await 的作用就是等待当前的协程运行结束之后再继续进行下面代码。 因为我们执行 result1 的时间很短，所以在表面上看 result1 和 result2 是一起执行的。这就是 await 的作用。等待一个协程的执行完毕，如果有返回结果，那么就会接收到协程的返回结果，通过使用 return 可以返回协程的一个结果，这个和同步函数的 return 使用方法一样。</p>\n<h4 id=\"-7\">并发的执行任务</h4>\n<p>一系列的协程可以通过 await 链式调用，但是有的时候我们需要在一个协程里等待多个协程，比如我们在一个协程里等待 1000 个异步网络请求，对于访问次序没有要求的时候，就可以使用关键字 wait 来解决了。wait 可以暂停一个协程，直到后台操作完成。</p>\n<p><strong>Task 的使用</strong></p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">num</span><span class=\"hljs-params\">(n)</span>:</span>\n    print(<span class=\"hljs-string\">f\"当前的数字是:<span class=\"hljs-subst\">{n}</span>\"</span>)\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(n)\n    print(<span class=\"hljs-string\">f\"等待时间:<span class=\"hljs-subst\">{n}</span>\"</span>)\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    tasks = [num(i) <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> range(<span class=\"hljs-number\">10</span>)] <span class=\"hljs-comment\">#协程列表</span>\n    <span class=\"hljs-comment\">#await asyncio.gather(*tasks) #有序并发</span>\n    <span class=\"hljs-keyword\">await</span> asyncio.wait(tasks) <span class=\"hljs-comment\">#并发运行协程列表的协程</span>\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    loop = asyncio.get_event_loop()\n    <span class=\"hljs-keyword\">try</span>:\n        loop.run_until_complete(main())\n    <span class=\"hljs-keyword\">finally</span>:\n        loop.close()\n</code></pre>\n<p>输出：</p>\n<pre><code class=\"hljs css\">当前的数字是<span class=\"hljs-selector-pseudo\">:0</span>\n当前的数字是<span class=\"hljs-selector-pseudo\">:4</span>\n当前的数字是<span class=\"hljs-selector-pseudo\">:8</span>\n当前的数字是<span class=\"hljs-selector-pseudo\">:1</span>\n当前的数字是<span class=\"hljs-selector-pseudo\">:5</span>\n当前的数字是<span class=\"hljs-selector-pseudo\">:7</span>\n当前的数字是<span class=\"hljs-selector-pseudo\">:2</span>\n当前的数字是<span class=\"hljs-selector-pseudo\">:6</span>\n当前的数字是<span class=\"hljs-selector-pseudo\">:9</span>\n当前的数字是<span class=\"hljs-selector-pseudo\">:3</span>\n等待时间<span class=\"hljs-selector-pseudo\">:0</span>\n等待时间<span class=\"hljs-selector-pseudo\">:1</span>\n等待时间<span class=\"hljs-selector-pseudo\">:2</span>\n等待时间<span class=\"hljs-selector-pseudo\">:3</span>\n等待时间<span class=\"hljs-selector-pseudo\">:4</span>\n等待时间<span class=\"hljs-selector-pseudo\">:5</span>\n等待时间<span class=\"hljs-selector-pseudo\">:6</span>\n等待时间<span class=\"hljs-selector-pseudo\">:7</span>\n等待时间<span class=\"hljs-selector-pseudo\">:8</span>\n等待时间<span class=\"hljs-selector-pseudo\">:9</span>\n</code></pre>\n<p>如果运行的话会发现首先会打印 10 次数字，但是并不是顺序执行的，这也说明 asyncio.wait 并发执行的时候是乱序的。如果想保证顺序只要使用 gather 把 task 写成解包的形式就行了，也就是上面的注释部分的代码。</p>\n<h4 id=\"-8\">如何在协程中使用普通的函数呢？</h4>\n<p>我们知道在普通函数中调用普通函数之间，函数名加括号即可，像下面这样：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">()</span>:</span>\n   print(<span class=\"hljs-string\">\"这是一个普通函数\"</span>)\n   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"test\"</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n   print(<span class=\"hljs-string\">\"调用foo函数\"</span>)\n   res=foo()\n   print(<span class=\"hljs-string\">f\"<span class=\"hljs-subst\">{接收到来自foo函数的值}</span>:res\"</span>)\n<span class=\"hljs-keyword\">if</span> __name__==<span class=\"hljs-string\">\"__main__\"</span>\n   main()\n</code></pre>\n<p>那么在协程中如何使用一个普通函数呢？ 在协程中可以通过一些方法去调用普通的函数。可以使用的关键字有 call_soon 等。</p>\n<h4 id=\"call_soon\">call_soon</h4>\n<p>可以通过字面意思理解调用立即返回。 下面来看一下具体的使用例子：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n<span class=\"hljs-keyword\">import</span> functools\n\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">callback</span><span class=\"hljs-params\">(args， *， kwargs=<span class=\"hljs-string\">\"defalut\"</span>)</span>:</span>\n    print(<span class=\"hljs-string\">f\"普通函数做为回调函数，获取参数:<span class=\"hljs-subst\">{args}</span>，<span class=\"hljs-subst\">{kwargs}</span>\"</span>)\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(loop)</span>:</span>\n    print(<span class=\"hljs-string\">\"注册callback\"</span>)\n    loop.call_soon(callback， <span class=\"hljs-number\">1</span>)\n    wrapped = functools.partial(callback， kwargs=<span class=\"hljs-string\">\"not defalut\"</span>)\n    loop.call_soon(wrapped， <span class=\"hljs-number\">2</span>)\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">0.2</span>)\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    loop = asyncio.get_event_loop()\n<span class=\"hljs-keyword\">try</span>:\n    loop.run_until_complete(main(loop))\n<span class=\"hljs-keyword\">finally</span>:\n    loop.close()\n</code></pre>\n<p>输出结果：</p>\n<pre><code class=\"hljs css\">注册<span class=\"hljs-selector-tag\">callback</span>\n普通函数做为回调函数，获取参数<span class=\"hljs-selector-pseudo\">:1</span>，<span class=\"hljs-selector-tag\">defalut</span>\n普通函数做为回调函数，获取参数<span class=\"hljs-selector-pseudo\">:2</span>，<span class=\"hljs-selector-tag\">not</span> <span class=\"hljs-selector-tag\">defalut</span>\n</code></pre>\n<p>通过输出结果我们可以发现我们在协程中成功调用了一个普通函数，顺序地打印了 1 和 2。</p>\n<p>看过这些例子之后，也许你就有疑问了，协程没有缺点的么？</p>\n<h3 id=\"-9\">协程的缺点</h3>\n<p>同样的总结下大概以下 2 点。</p>\n<h4 id=\"cpu\">无法使用 CPU 的多核</h4>\n<p>协程的本质是个单线程，它不能同时用上单个 CPU 的多个核，协程需要和进程配合才能运行在多 CPU 上。当然我们日常所编写的绝大部分应用都没有这个必要，就比如网络爬虫来说，限制爬虫的速度还有其他的因素，比如网站并发量、网速等问题都会是爬虫速度限制的因素。除非做一些密集型应用，这个时候才可能会用到多进程和协程。</p>\n<h4 id=\"-10\">处处都要使用非阻塞代码</h4>\n<p>写协程就意味着你要一值写一些非阻塞的代码，使用各种异步版本的库，比如后面的异步爬虫教程中用的 aiohttp 就是一个异步版本的request库等。 不过这些缺点并不能影响到使用协程的优势。</p>\n<hr>\n</div>\n</body>\n</html>","slug":"gitchat/python_coroutine","published":1,"date":"2019-05-31T05:53:12.548Z","updated":"2019-05-31T05:53:12.548Z","_id":"cjwd4a1az0008sv72d9d2z793","comments":1,"layout":"post","photos":[],"link":"","content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head><meta name=\"generator\" content=\"Hexo 3.8.0\">\n    <meta charset=\"UTF-8\">\n    <title>Python协程</title>\n</head>\n<body>\n<div id=\"article_content\" class=\"mazi-article-content dont-break-out\"><p>在 Python 3.4 时候引进了协程的概念，它使用一种单线程单进程的的方式实现并发。谈到并发，大多数朋友想到更多的应该是多进程和多线程，它们都是比较消耗系统资源的，今天我们不谈线程和进程，而是来说下当前比较火的协程。</p>\n<p>因为在爬虫操作中，协程比多线程更有优势。协程是单线程的，单线程就能实现高并发。</p>\n<h3 id>什么是协程？</h3>\n<p>协程，英文名是 Coroutine， 又称为微线程，是一种用户态的轻量级线程。协程不像线程和进程那样，需要进行系统内核上的上下文切换，协程的上下文切换是由程序员决定的。在 Python 中协程就是一个可以暂停执行的函数，听起来和生成器的概念一样。</p>\n<h3 id=\"-1\">协程的发展</h3>\n<p>从 Python3.4 开始协程被加入到标准库，当时的协程是通过 @asyncio.coroutine 和 yeild from 实现的，看起来和生成器的实现方式没什么区别。后来为了更好的区分开协程和生成器，到 Python3.5 的时候引入 async/await 语法糖临时定格了下来，直到 Python3.6 的时候才被更多的人认可，Python3.6 作为 Python3 目前最稳定的版本拥有大量的使用者，后来到了 Python3.7 官方把 async 和 await 作为保留字，同时协程的调用也变得简单了许多，但是，正是保留字的原因导致之前很多 async 为函数名的库报错，典型的有 scrapy，所以这里推荐大家使用 Python3.6。</p>\n<h3 id=\"-2\">协程相对于多线程的优点</h3>\n<p>多线程编程是比较困难的， 因为调度程序任何时候都能中断线程， 必须记住保留锁， 去保护程序中重要部分， 防止多线程在执行的过程中断。</p>\n<p>而协程默认会做好全方位保护， 以防止中断。我们必须显示产出才能让程序的余下部分运行。对协程来说， 无需保留锁， 而在多个线程之间同步操作， 协程自身就会同步， 因为在任意时刻， 只有一个协程运行。总结下大概下面几点：</p>\n<ul>\n<li>无需系统内核的上下文切换，减小开销；</li>\n<li>无需原子操作锁定及同步的开销，不用担心资源共享的问题；</li>\n<li>单线程即可实现高并发，单核 CPU 即便支持上万的协程都不是问题，所以很适合用于高并发处理，尤其是在应用在网络爬虫中。</li>\n</ul>\n<h3 id=\"-3\">协程的定义</h3>\n<p>使用协程也就意味着你需要一直写异步方法。在 Python 中我们使用 asyncio 模块来实现一个协程。如果我们把 Python 中普通函数称之为同步函数（方法），那么用协程定义的函数我们称之为异步函数（方法）。 </p>\n<blockquote>\n  <p>注意，以下所有的代码实例运行环境均要求版本大于等于 Python3.6。</p>\n</blockquote>\n<h4 id=\"-4\">同步函数和异步函数的定义</h4>\n<p><strong>同步函数定义</strong></p>\n<pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">regular_double</span><span class=\"hljs-params\">(x)</span>:</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span> * x\n</code></pre>\n<p><strong>异步函数定义</strong></p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">async_double</span><span class=\"hljs-params\">(x)</span>:</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span> * x\n</code></pre>\n<h4 id=\"-5\">同步函数和异步函数的调用</h4>\n<p>对于同步函数我们知道是这样调用的：</p>\n<pre><code class=\"hljs\"> regular_double(2)\n</code></pre>\n<p>异步函数如何调用呢？带着这个问题我们看下面的一个简单例子。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">()</span>:</span>\n    print(<span class=\"hljs-string\">\"这是一个协程\"</span>)\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    loop = asyncio.get_event_loop() <span class=\"hljs-comment\"># 定义一个事件循环</span>\n    <span class=\"hljs-keyword\">try</span>:\n        print(<span class=\"hljs-string\">\"开始运行协程\"</span>)\n        coro = foo()\n        print(<span class=\"hljs-string\">\"进入事件循环\"</span>)\n        loop.run_until_complete(coro) <span class=\"hljs-comment\"># 运行协程</span>\n    <span class=\"hljs-keyword\">finally</span>:\n        print(<span class=\"hljs-string\">\"关闭事件循环\"</span>)\n        loop.close() <span class=\"hljs-comment\"># 运行完关闭协程</span>\n</code></pre>\n<p>这就是最简单的一个协程的例子，让我们了解一下上面的代码。 </p>\n<p>首先，需要导入需要的包 -asyncio。然后，创建一个事件循环，因为协程是基于事件循环的。 之后，通过 <code>run_until_complete</code> 方法传入一个异步函数，来运行这个协程。 最后在结束的时候调用 close 方法关闭协程。 综上就是调用一个协程的写法。除此之外协程还有其他的不同之处。</p>\n<h4 id=\"-6\">协程之间的链式调用</h4>\n<p>我们可以通过使用 await 关键字，在一个协程中调用一个协程。 一个协程可以启动另一个协程，从而可以使任务根据工作内容，封装到不同的协程中。我们可以在协程中使用 await 关键字，链式地调度协程，来形成一个协程任务流。像下面的例子一样：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    print(<span class=\"hljs-string\">\"主协程\"</span>)\n    print(<span class=\"hljs-string\">\"等待result1协程运行\"</span>)\n    res1 = <span class=\"hljs-keyword\">await</span> result1()\n    print(<span class=\"hljs-string\">\"等待result2协程运行\"</span>)\n    res2 = <span class=\"hljs-keyword\">await</span> result2(res1)\n    <span class=\"hljs-keyword\">return</span> (res1，res2)\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">result1</span><span class=\"hljs-params\">()</span>:</span>\n    print(<span class=\"hljs-string\">\"这是result1协程\"</span>)\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"result1\"</span>\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">result2</span><span class=\"hljs-params\">(arg)</span>:</span>\n    print(<span class=\"hljs-string\">\"这是result2协程\"</span>)\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">f\"result2接收了一个参数，<span class=\"hljs-subst\">{arg}</span>\"</span>\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    loop = asyncio.get_event_loop()\n    <span class=\"hljs-keyword\">try</span>:\n        result = loop.run_until_complete(main())\n        print(<span class=\"hljs-string\">f\"获取返回值:<span class=\"hljs-subst\">{result}</span>\"</span>)\n    <span class=\"hljs-keyword\">finally</span>:\n        print(<span class=\"hljs-string\">\"关闭事件循环\"</span>)\n        loop.close()\n</code></pre>\n<p>输出：</p>\n<pre><code class=\"hljs bash\">主协程\n等待result1协程运行\n这是result1协程\n等待result2协程运行\n这是result2协程\n获取返回值:(<span class=\"hljs-string\">'result1'</span>， <span class=\"hljs-string\">'result2接收了一个参数，result1'</span>)\n关闭事件循环\n</code></pre>\n<p>在上面，我们知道调用协程需要通过创建一个事件循环然后再去运行。 这里我们需要了解的是如果在协程里想调用一个协程我们需要使用 <strong>await</strong> 关键字，就拿上面的例子来说在 main 函数里调用协程 result1 和 result2。 那么问题来了：await 干了什么呢？</p>\n<h4 id=\"await\">await 的作用</h4>\n<p>await 的作用就是等待当前的协程运行结束之后再继续进行下面代码。 因为我们执行 result1 的时间很短，所以在表面上看 result1 和 result2 是一起执行的。这就是 await 的作用。等待一个协程的执行完毕，如果有返回结果，那么就会接收到协程的返回结果，通过使用 return 可以返回协程的一个结果，这个和同步函数的 return 使用方法一样。</p>\n<h4 id=\"-7\">并发的执行任务</h4>\n<p>一系列的协程可以通过 await 链式调用，但是有的时候我们需要在一个协程里等待多个协程，比如我们在一个协程里等待 1000 个异步网络请求，对于访问次序没有要求的时候，就可以使用关键字 wait 来解决了。wait 可以暂停一个协程，直到后台操作完成。</p>\n<p><strong>Task 的使用</strong></p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">num</span><span class=\"hljs-params\">(n)</span>:</span>\n    print(<span class=\"hljs-string\">f\"当前的数字是:<span class=\"hljs-subst\">{n}</span>\"</span>)\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(n)\n    print(<span class=\"hljs-string\">f\"等待时间:<span class=\"hljs-subst\">{n}</span>\"</span>)\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    tasks = [num(i) <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> range(<span class=\"hljs-number\">10</span>)] <span class=\"hljs-comment\">#协程列表</span>\n    <span class=\"hljs-comment\">#await asyncio.gather(*tasks) #有序并发</span>\n    <span class=\"hljs-keyword\">await</span> asyncio.wait(tasks) <span class=\"hljs-comment\">#并发运行协程列表的协程</span>\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    loop = asyncio.get_event_loop()\n    <span class=\"hljs-keyword\">try</span>:\n        loop.run_until_complete(main())\n    <span class=\"hljs-keyword\">finally</span>:\n        loop.close()\n</code></pre>\n<p>输出：</p>\n<pre><code class=\"hljs css\">当前的数字是<span class=\"hljs-selector-pseudo\">:0</span>\n当前的数字是<span class=\"hljs-selector-pseudo\">:4</span>\n当前的数字是<span class=\"hljs-selector-pseudo\">:8</span>\n当前的数字是<span class=\"hljs-selector-pseudo\">:1</span>\n当前的数字是<span class=\"hljs-selector-pseudo\">:5</span>\n当前的数字是<span class=\"hljs-selector-pseudo\">:7</span>\n当前的数字是<span class=\"hljs-selector-pseudo\">:2</span>\n当前的数字是<span class=\"hljs-selector-pseudo\">:6</span>\n当前的数字是<span class=\"hljs-selector-pseudo\">:9</span>\n当前的数字是<span class=\"hljs-selector-pseudo\">:3</span>\n等待时间<span class=\"hljs-selector-pseudo\">:0</span>\n等待时间<span class=\"hljs-selector-pseudo\">:1</span>\n等待时间<span class=\"hljs-selector-pseudo\">:2</span>\n等待时间<span class=\"hljs-selector-pseudo\">:3</span>\n等待时间<span class=\"hljs-selector-pseudo\">:4</span>\n等待时间<span class=\"hljs-selector-pseudo\">:5</span>\n等待时间<span class=\"hljs-selector-pseudo\">:6</span>\n等待时间<span class=\"hljs-selector-pseudo\">:7</span>\n等待时间<span class=\"hljs-selector-pseudo\">:8</span>\n等待时间<span class=\"hljs-selector-pseudo\">:9</span>\n</code></pre>\n<p>如果运行的话会发现首先会打印 10 次数字，但是并不是顺序执行的，这也说明 asyncio.wait 并发执行的时候是乱序的。如果想保证顺序只要使用 gather 把 task 写成解包的形式就行了，也就是上面的注释部分的代码。</p>\n<h4 id=\"-8\">如何在协程中使用普通的函数呢？</h4>\n<p>我们知道在普通函数中调用普通函数之间，函数名加括号即可，像下面这样：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">()</span>:</span>\n   print(<span class=\"hljs-string\">\"这是一个普通函数\"</span>)\n   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"test\"</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n   print(<span class=\"hljs-string\">\"调用foo函数\"</span>)\n   res=foo()\n   print(<span class=\"hljs-string\">f\"<span class=\"hljs-subst\">{接收到来自foo函数的值}</span>:res\"</span>)\n<span class=\"hljs-keyword\">if</span> __name__==<span class=\"hljs-string\">\"__main__\"</span>\n   main()\n</code></pre>\n<p>那么在协程中如何使用一个普通函数呢？ 在协程中可以通过一些方法去调用普通的函数。可以使用的关键字有 call_soon 等。</p>\n<h4 id=\"call_soon\">call_soon</h4>\n<p>可以通过字面意思理解调用立即返回。 下面来看一下具体的使用例子：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n<span class=\"hljs-keyword\">import</span> functools\n\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">callback</span><span class=\"hljs-params\">(args， *， kwargs=<span class=\"hljs-string\">\"defalut\"</span>)</span>:</span>\n    print(<span class=\"hljs-string\">f\"普通函数做为回调函数，获取参数:<span class=\"hljs-subst\">{args}</span>，<span class=\"hljs-subst\">{kwargs}</span>\"</span>)\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(loop)</span>:</span>\n    print(<span class=\"hljs-string\">\"注册callback\"</span>)\n    loop.call_soon(callback， <span class=\"hljs-number\">1</span>)\n    wrapped = functools.partial(callback， kwargs=<span class=\"hljs-string\">\"not defalut\"</span>)\n    loop.call_soon(wrapped， <span class=\"hljs-number\">2</span>)\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">0.2</span>)\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    loop = asyncio.get_event_loop()\n<span class=\"hljs-keyword\">try</span>:\n    loop.run_until_complete(main(loop))\n<span class=\"hljs-keyword\">finally</span>:\n    loop.close()\n</code></pre>\n<p>输出结果：</p>\n<pre><code class=\"hljs css\">注册<span class=\"hljs-selector-tag\">callback</span>\n普通函数做为回调函数，获取参数<span class=\"hljs-selector-pseudo\">:1</span>，<span class=\"hljs-selector-tag\">defalut</span>\n普通函数做为回调函数，获取参数<span class=\"hljs-selector-pseudo\">:2</span>，<span class=\"hljs-selector-tag\">not</span> <span class=\"hljs-selector-tag\">defalut</span>\n</code></pre>\n<p>通过输出结果我们可以发现我们在协程中成功调用了一个普通函数，顺序地打印了 1 和 2。</p>\n<p>看过这些例子之后，也许你就有疑问了，协程没有缺点的么？</p>\n<h3 id=\"-9\">协程的缺点</h3>\n<p>同样的总结下大概以下 2 点。</p>\n<h4 id=\"cpu\">无法使用 CPU 的多核</h4>\n<p>协程的本质是个单线程，它不能同时用上单个 CPU 的多个核，协程需要和进程配合才能运行在多 CPU 上。当然我们日常所编写的绝大部分应用都没有这个必要，就比如网络爬虫来说，限制爬虫的速度还有其他的因素，比如网站并发量、网速等问题都会是爬虫速度限制的因素。除非做一些密集型应用，这个时候才可能会用到多进程和协程。</p>\n<h4 id=\"-10\">处处都要使用非阻塞代码</h4>\n<p>写协程就意味着你要一值写一些非阻塞的代码，使用各种异步版本的库，比如后面的异步爬虫教程中用的 aiohttp 就是一个异步版本的request库等。 不过这些缺点并不能影响到使用协程的优势。</p>\n<hr>\n</div>\n</body>\n</html>","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE html>\n<html lang=\"en\">\n<head><meta name=\"generator\" content=\"Hexo 3.8.0\">\n    <meta charset=\"UTF-8\">\n    <title>Python协程</title>\n</head>\n<body>\n<div id=\"article_content\" class=\"mazi-article-content dont-break-out\"><p>在 Python 3.4 时候引进了协程的概念，它使用一种单线程单进程的的方式实现并发。谈到并发，大多数朋友想到更多的应该是多进程和多线程，它们都是比较消耗系统资源的，今天我们不谈线程和进程，而是来说下当前比较火的协程。</p>\n<p>因为在爬虫操作中，协程比多线程更有优势。协程是单线程的，单线程就能实现高并发。</p>\n<h3 id>什么是协程？</h3>\n<p>协程，英文名是 Coroutine， 又称为微线程，是一种用户态的轻量级线程。协程不像线程和进程那样，需要进行系统内核上的上下文切换，协程的上下文切换是由程序员决定的。在 Python 中协程就是一个可以暂停执行的函数，听起来和生成器的概念一样。</p>\n<h3 id=\"-1\">协程的发展</h3>\n<p>从 Python3.4 开始协程被加入到标准库，当时的协程是通过 @asyncio.coroutine 和 yeild from 实现的，看起来和生成器的实现方式没什么区别。后来为了更好的区分开协程和生成器，到 Python3.5 的时候引入 async/await 语法糖临时定格了下来，直到 Python3.6 的时候才被更多的人认可，Python3.6 作为 Python3 目前最稳定的版本拥有大量的使用者，后来到了 Python3.7 官方把 async 和 await 作为保留字，同时协程的调用也变得简单了许多，但是，正是保留字的原因导致之前很多 async 为函数名的库报错，典型的有 scrapy，所以这里推荐大家使用 Python3.6。</p>\n<h3 id=\"-2\">协程相对于多线程的优点</h3>\n<p>多线程编程是比较困难的， 因为调度程序任何时候都能中断线程， 必须记住保留锁， 去保护程序中重要部分， 防止多线程在执行的过程中断。</p>\n<p>而协程默认会做好全方位保护， 以防止中断。我们必须显示产出才能让程序的余下部分运行。对协程来说， 无需保留锁， 而在多个线程之间同步操作， 协程自身就会同步， 因为在任意时刻， 只有一个协程运行。总结下大概下面几点：</p>\n<ul>\n<li>无需系统内核的上下文切换，减小开销；</li>\n<li>无需原子操作锁定及同步的开销，不用担心资源共享的问题；</li>\n<li>单线程即可实现高并发，单核 CPU 即便支持上万的协程都不是问题，所以很适合用于高并发处理，尤其是在应用在网络爬虫中。</li>\n</ul>\n<h3 id=\"-3\">协程的定义</h3>\n<p>使用协程也就意味着你需要一直写异步方法。在 Python 中我们使用 asyncio 模块来实现一个协程。如果我们把 Python 中普通函数称之为同步函数（方法），那么用协程定义的函数我们称之为异步函数（方法）。 </p>\n<blockquote>\n  <p>注意，以下所有的代码实例运行环境均要求版本大于等于 Python3.6。</p>\n</blockquote>\n<h4 id=\"-4\">同步函数和异步函数的定义</h4>\n<p><strong>同步函数定义</strong></p>\n<pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">regular_double</span><span class=\"hljs-params\">(x)</span>:</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span> * x\n</code></pre>\n<p><strong>异步函数定义</strong></p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">async_double</span><span class=\"hljs-params\">(x)</span>:</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span> * x\n</code></pre>\n<h4 id=\"-5\">同步函数和异步函数的调用</h4>\n<p>对于同步函数我们知道是这样调用的：</p>\n<pre><code class=\"hljs\"> regular_double(2)\n</code></pre>\n<p>异步函数如何调用呢？带着这个问题我们看下面的一个简单例子。</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">()</span>:</span>\n    print(<span class=\"hljs-string\">\"这是一个协程\"</span>)\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    loop = asyncio.get_event_loop() <span class=\"hljs-comment\"># 定义一个事件循环</span>\n    <span class=\"hljs-keyword\">try</span>:\n        print(<span class=\"hljs-string\">\"开始运行协程\"</span>)\n        coro = foo()\n        print(<span class=\"hljs-string\">\"进入事件循环\"</span>)\n        loop.run_until_complete(coro) <span class=\"hljs-comment\"># 运行协程</span>\n    <span class=\"hljs-keyword\">finally</span>:\n        print(<span class=\"hljs-string\">\"关闭事件循环\"</span>)\n        loop.close() <span class=\"hljs-comment\"># 运行完关闭协程</span>\n</code></pre>\n<p>这就是最简单的一个协程的例子，让我们了解一下上面的代码。 </p>\n<p>首先，需要导入需要的包 -asyncio。然后，创建一个事件循环，因为协程是基于事件循环的。 之后，通过 <code>run_until_complete</code> 方法传入一个异步函数，来运行这个协程。 最后在结束的时候调用 close 方法关闭协程。 综上就是调用一个协程的写法。除此之外协程还有其他的不同之处。</p>\n<h4 id=\"-6\">协程之间的链式调用</h4>\n<p>我们可以通过使用 await 关键字，在一个协程中调用一个协程。 一个协程可以启动另一个协程，从而可以使任务根据工作内容，封装到不同的协程中。我们可以在协程中使用 await 关键字，链式地调度协程，来形成一个协程任务流。像下面的例子一样：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    print(<span class=\"hljs-string\">\"主协程\"</span>)\n    print(<span class=\"hljs-string\">\"等待result1协程运行\"</span>)\n    res1 = <span class=\"hljs-keyword\">await</span> result1()\n    print(<span class=\"hljs-string\">\"等待result2协程运行\"</span>)\n    res2 = <span class=\"hljs-keyword\">await</span> result2(res1)\n    <span class=\"hljs-keyword\">return</span> (res1，res2)\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">result1</span><span class=\"hljs-params\">()</span>:</span>\n    print(<span class=\"hljs-string\">\"这是result1协程\"</span>)\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"result1\"</span>\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">result2</span><span class=\"hljs-params\">(arg)</span>:</span>\n    print(<span class=\"hljs-string\">\"这是result2协程\"</span>)\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">f\"result2接收了一个参数，<span class=\"hljs-subst\">{arg}</span>\"</span>\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    loop = asyncio.get_event_loop()\n    <span class=\"hljs-keyword\">try</span>:\n        result = loop.run_until_complete(main())\n        print(<span class=\"hljs-string\">f\"获取返回值:<span class=\"hljs-subst\">{result}</span>\"</span>)\n    <span class=\"hljs-keyword\">finally</span>:\n        print(<span class=\"hljs-string\">\"关闭事件循环\"</span>)\n        loop.close()\n</code></pre>\n<p>输出：</p>\n<pre><code class=\"hljs bash\">主协程\n等待result1协程运行\n这是result1协程\n等待result2协程运行\n这是result2协程\n获取返回值:(<span class=\"hljs-string\">'result1'</span>， <span class=\"hljs-string\">'result2接收了一个参数，result1'</span>)\n关闭事件循环\n</code></pre>\n<p>在上面，我们知道调用协程需要通过创建一个事件循环然后再去运行。 这里我们需要了解的是如果在协程里想调用一个协程我们需要使用 <strong>await</strong> 关键字，就拿上面的例子来说在 main 函数里调用协程 result1 和 result2。 那么问题来了：await 干了什么呢？</p>\n<h4 id=\"await\">await 的作用</h4>\n<p>await 的作用就是等待当前的协程运行结束之后再继续进行下面代码。 因为我们执行 result1 的时间很短，所以在表面上看 result1 和 result2 是一起执行的。这就是 await 的作用。等待一个协程的执行完毕，如果有返回结果，那么就会接收到协程的返回结果，通过使用 return 可以返回协程的一个结果，这个和同步函数的 return 使用方法一样。</p>\n<h4 id=\"-7\">并发的执行任务</h4>\n<p>一系列的协程可以通过 await 链式调用，但是有的时候我们需要在一个协程里等待多个协程，比如我们在一个协程里等待 1000 个异步网络请求，对于访问次序没有要求的时候，就可以使用关键字 wait 来解决了。wait 可以暂停一个协程，直到后台操作完成。</p>\n<p><strong>Task 的使用</strong></p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">num</span><span class=\"hljs-params\">(n)</span>:</span>\n    print(<span class=\"hljs-string\">f\"当前的数字是:<span class=\"hljs-subst\">{n}</span>\"</span>)\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(n)\n    print(<span class=\"hljs-string\">f\"等待时间:<span class=\"hljs-subst\">{n}</span>\"</span>)\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    tasks = [num(i) <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> range(<span class=\"hljs-number\">10</span>)] <span class=\"hljs-comment\">#协程列表</span>\n    <span class=\"hljs-comment\">#await asyncio.gather(*tasks) #有序并发</span>\n    <span class=\"hljs-keyword\">await</span> asyncio.wait(tasks) <span class=\"hljs-comment\">#并发运行协程列表的协程</span>\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    loop = asyncio.get_event_loop()\n    <span class=\"hljs-keyword\">try</span>:\n        loop.run_until_complete(main())\n    <span class=\"hljs-keyword\">finally</span>:\n        loop.close()\n</code></pre>\n<p>输出：</p>\n<pre><code class=\"hljs css\">当前的数字是<span class=\"hljs-selector-pseudo\">:0</span>\n当前的数字是<span class=\"hljs-selector-pseudo\">:4</span>\n当前的数字是<span class=\"hljs-selector-pseudo\">:8</span>\n当前的数字是<span class=\"hljs-selector-pseudo\">:1</span>\n当前的数字是<span class=\"hljs-selector-pseudo\">:5</span>\n当前的数字是<span class=\"hljs-selector-pseudo\">:7</span>\n当前的数字是<span class=\"hljs-selector-pseudo\">:2</span>\n当前的数字是<span class=\"hljs-selector-pseudo\">:6</span>\n当前的数字是<span class=\"hljs-selector-pseudo\">:9</span>\n当前的数字是<span class=\"hljs-selector-pseudo\">:3</span>\n等待时间<span class=\"hljs-selector-pseudo\">:0</span>\n等待时间<span class=\"hljs-selector-pseudo\">:1</span>\n等待时间<span class=\"hljs-selector-pseudo\">:2</span>\n等待时间<span class=\"hljs-selector-pseudo\">:3</span>\n等待时间<span class=\"hljs-selector-pseudo\">:4</span>\n等待时间<span class=\"hljs-selector-pseudo\">:5</span>\n等待时间<span class=\"hljs-selector-pseudo\">:6</span>\n等待时间<span class=\"hljs-selector-pseudo\">:7</span>\n等待时间<span class=\"hljs-selector-pseudo\">:8</span>\n等待时间<span class=\"hljs-selector-pseudo\">:9</span>\n</code></pre>\n<p>如果运行的话会发现首先会打印 10 次数字，但是并不是顺序执行的，这也说明 asyncio.wait 并发执行的时候是乱序的。如果想保证顺序只要使用 gather 把 task 写成解包的形式就行了，也就是上面的注释部分的代码。</p>\n<h4 id=\"-8\">如何在协程中使用普通的函数呢？</h4>\n<p>我们知道在普通函数中调用普通函数之间，函数名加括号即可，像下面这样：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">()</span>:</span>\n   print(<span class=\"hljs-string\">\"这是一个普通函数\"</span>)\n   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"test\"</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n   print(<span class=\"hljs-string\">\"调用foo函数\"</span>)\n   res=foo()\n   print(<span class=\"hljs-string\">f\"<span class=\"hljs-subst\">{接收到来自foo函数的值}</span>:res\"</span>)\n<span class=\"hljs-keyword\">if</span> __name__==<span class=\"hljs-string\">\"__main__\"</span>\n   main()\n</code></pre>\n<p>那么在协程中如何使用一个普通函数呢？ 在协程中可以通过一些方法去调用普通的函数。可以使用的关键字有 call_soon 等。</p>\n<h4 id=\"call_soon\">call_soon</h4>\n<p>可以通过字面意思理解调用立即返回。 下面来看一下具体的使用例子：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n<span class=\"hljs-keyword\">import</span> functools\n\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">callback</span><span class=\"hljs-params\">(args， *， kwargs=<span class=\"hljs-string\">\"defalut\"</span>)</span>:</span>\n    print(<span class=\"hljs-string\">f\"普通函数做为回调函数，获取参数:<span class=\"hljs-subst\">{args}</span>，<span class=\"hljs-subst\">{kwargs}</span>\"</span>)\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(loop)</span>:</span>\n    print(<span class=\"hljs-string\">\"注册callback\"</span>)\n    loop.call_soon(callback， <span class=\"hljs-number\">1</span>)\n    wrapped = functools.partial(callback， kwargs=<span class=\"hljs-string\">\"not defalut\"</span>)\n    loop.call_soon(wrapped， <span class=\"hljs-number\">2</span>)\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">0.2</span>)\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    loop = asyncio.get_event_loop()\n<span class=\"hljs-keyword\">try</span>:\n    loop.run_until_complete(main(loop))\n<span class=\"hljs-keyword\">finally</span>:\n    loop.close()\n</code></pre>\n<p>输出结果：</p>\n<pre><code class=\"hljs css\">注册<span class=\"hljs-selector-tag\">callback</span>\n普通函数做为回调函数，获取参数<span class=\"hljs-selector-pseudo\">:1</span>，<span class=\"hljs-selector-tag\">defalut</span>\n普通函数做为回调函数，获取参数<span class=\"hljs-selector-pseudo\">:2</span>，<span class=\"hljs-selector-tag\">not</span> <span class=\"hljs-selector-tag\">defalut</span>\n</code></pre>\n<p>通过输出结果我们可以发现我们在协程中成功调用了一个普通函数，顺序地打印了 1 和 2。</p>\n<p>看过这些例子之后，也许你就有疑问了，协程没有缺点的么？</p>\n<h3 id=\"-9\">协程的缺点</h3>\n<p>同样的总结下大概以下 2 点。</p>\n<h4 id=\"cpu\">无法使用 CPU 的多核</h4>\n<p>协程的本质是个单线程，它不能同时用上单个 CPU 的多个核，协程需要和进程配合才能运行在多 CPU 上。当然我们日常所编写的绝大部分应用都没有这个必要，就比如网络爬虫来说，限制爬虫的速度还有其他的因素，比如网站并发量、网速等问题都会是爬虫速度限制的因素。除非做一些密集型应用，这个时候才可能会用到多进程和协程。</p>\n<h4 id=\"-10\">处处都要使用非阻塞代码</h4>\n<p>写协程就意味着你要一值写一些非阻塞的代码，使用各种异步版本的库，比如后面的异步爬虫教程中用的 aiohttp 就是一个异步版本的request库等。 不过这些缺点并不能影响到使用协程的优势。</p>\n<hr>\n</div>\n</body>\n</html>"},{"title":"asyncio使用指南","_content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>asyncio使用指南</title>\n</head>\n<body>\n<div id=\"article_content\" class=\"mazi-article-content dont-break-out\">\n    <h3 id=\"\">协程的演变</h3>\n    <p>其实早在 Python3.4 的时候就有协程,当时的协程是通过 @asyncio.coroutine 和 yeild from 实现的。在一些很老教程中你可能看到的是下面这种形式:</p>\n    <pre><code class=\"hljs coffeescript\"><span class=\"hljs-keyword\">import</span> asyncio\n\n@asyncio.coroutine\ndef print_hello():\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello world!\"</span>)\n    r = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-keyword\">from</span> asyncio.sleep(<span\n                class=\"hljs-number\">1</span>)\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello again!\"</span>)\n\n<span class=\"hljs-comment\"># 创建并获取EventLoop:</span>\n<span class=\"hljs-keyword\">loop</span> = asyncio.get_event_loop()\n<span class=\"hljs-comment\"># 执行协程</span>\n<span class=\"hljs-keyword\">loop</span>.run_until_complete(print_hello())\n<span class=\"hljs-keyword\">loop</span>.close()\n</code></pre>\n    <p>因为现在几乎没有人这样写了，所以仅作为了解即可。</p>\n    <p>然后到了 Python3.5 引入了 async/await 语法糖，一直到现在Python3.8 都是用这种形式来表示协程，示例如下。</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">print_hello</span><span class=\"hljs-params\">()</span>:</span>\n     print(<span class=\"hljs-string\">\"Hello world!\"</span>)\n     <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">1</span>)\n     print(<span class=\"hljs-string\">\"Hello again!\"</span>)\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    loop = asyncio.get_event_loop()\n    <span class=\"hljs-keyword\">try</span>:\n        print(<span class=\"hljs-string\">\"开始运行协程\"</span>)\n        coro = print_hello()\n        print(<span class=\"hljs-string\">\"进入事件循环\"</span>)\n        loop.run_until_complete(coro)\n    <span class=\"hljs-keyword\">finally</span>:\n        print(<span class=\"hljs-string\">\"关闭事件循环\"</span>)\n        loop.close()\n</code></pre>\n    <p>这种是目前应用范围最广的，可以看到比之前的代码舒服了不少，不用再使用装饰器的形式了。</p>\n    <p>然后就到了 Python3.7 和 Python3.8，协程发生了很多细小的变化，但是最大的一个变化就是，启动协程的方法变简单了，一句就可以搞定，不用再像上面那样，创建循环然后再仍到事件循环去执行。使用 asyncio.run\n        这个顶级 API 就可以了。</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">print_hello</span><span class=\"hljs-params\">()</span>:</span>\n     print(<span class=\"hljs-string\">\"Hello world!\"</span>)\n     <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">1</span>)\n     print(<span class=\"hljs-string\">\"Hello again!\"</span>)\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n        print(<span class=\"hljs-string\">\"开始运行协程\"</span>)\n        asyncio.run(print_hello())\n        print(<span class=\"hljs-string\">\"进入事件循环\"</span>)\n</code></pre>\n    <p>怎么样是不是代码更少了，启动协程更简单了。所以这也正是我们使用 3.8 作为本教程的 Python 版，与时俱进嘛。</p>\n    <h3 id=\"asyncio\">asyncio 的组成部分</h3>\n    <p>根据目前的官方文档，总的来说分为了两部分：高层级 API 和低层级 API。</p>\n    <p>首先看高层级 API 也是接下来重点要讲的。</p>\n    <h4 id=\"api\">高层级 API</h4>\n    <ul>\n        <li>协程对象和 Tasks 对象</li>\n        <li>数据流</li>\n        <li>同步源语</li>\n        <li>子进程</li>\n        <li>队列</li>\n        <li>异常</li>\n    </ul>\n    <h4 id=\"api-1\">低层级 API</h4>\n    <ul>\n        <li>事件循环</li>\n        <li>Futures 对象</li>\n        <li>传输和协议</li>\n        <li>策略</li>\n        <li>平台支持</li>\n    </ul>\n    <p>上面列出了这么多的项目我们怎么去选择自己所需要的呢，总的来说对于刚入门的新手或者只是写一个自己用的程序一般都只会用到高级 API\n        的部分，这部分就属于开箱即用的那种，对于高级用户比如框架开发者，往往可以需要去适应各种需要，需要重新改写一些内部的结构，这个时候就需要用到低层级的 API，但是这两个层级呢只能是一个大概方向吧，主要是方便 API\n        的查看，下面呢我将围绕者高层级 API 和低层级 API 在日常实际工作中经常用到的内容做一些讲解。</p>\n    <h3 id=\"-1\">了解几个概念</h3>\n    <p>在学习 asyncio 之前需要知道这样的几个概念。</p>\n    <h4 id=\"-2\">事件循环</h4>\n    <p>事件循环是一种处理多并发量的有效方式，在维基百科中它被描述为「一种等待程序分配事件或消息的编程架构」，我们可以定义事件循环来简化使用轮询方法来监控事件，通俗的说法就是「当 A 发生时，执行\n        B」。所谓的事件，其实就是函数。事件循环，就是有一个队列，里面存放着一堆函数，从第一个函数开始执行，在函数执行的过程中，可能会有新的函数继续加入到这个队列中。一直到队列中所有的函数被执行完毕，并且再也不会有新的函数被添加到这个队列中，程序就结束了。</p>\n    <h4 id=\"future\">Future</h4>\n    <p>Future 是一个数据结构，表示还未完成的工作结果。事件循环可以监视 Future 对象是否完成。从而允许应用的一部分等待另一部分完成一些工作。</p>\n    <p>简单说，Future 就是一个类，用生成器实现了回调。</p>\n    <h4 id=\"task\">Task</h4>\n    <p>Task 是 Future 的一个子类，它知道如何包装和管理一个协程的执行。任务所需的资源可用时，事件循环会调度任务允许，并生成一个结果，从而可以由其他协程消费。一般操作最多的还是 Task。用 Task\n        来封装协程，给原本没有状态的协程增加一些状态。</p>\n    <h4 id=\"awaitableobjects\">awaitable objects（可等待对象）</h4>\n    <p>如果一个对象可以用在 wait 表达式中，那么它就是一个可等待的对象。在 asyncio 模块中会一直提到这个概念，其中协程函数，Task，Future 都是 awaitable 对象。</p>\n    <p>用于 await 表达式中的对象。可以是 coroutine 也可以是实现了 <code>__await__()</code> 方法的对象，参见 PEP 492。类比于 Iterable 对象是 Generator 或实现了\n        <code>__iter__()</code> 方法的对象。</p>\n    <p><strong>object._<em>await</em>_(self)</strong></p>\n    <p>必须返回生成器，asyncio.Future 类也实现了该方法，用于兼容 await 表达式。</p>\n    <p>而 Task 继承自 Future，因此 awaitable 对象有三种：coroutines、Tasks 和 Futures。</p>\n    <p>await 的目的：</p>\n    <ul>\n        <li>获取协程的结果</li>\n        <li>挂起当前协程，将控制交由事件循环，切换到其他协程，然后等待结果，最后恢复协程继续执行</li>\n    </ul>\n    <h3 id=\"-3\">启动一个协程</h3>\n    <p>现在我们使用 async/await 语法来声明一个协程。 代码如下：</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n     print(<span class=\"hljs-string\">'hello'</span>)\n     <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">1</span>)\n     print(<span class=\"hljs-string\">'world'</span>)\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    asyncio.run(main())\n</code></pre>\n    <p>asyncio.run 只能用来启动程序入口协程，反过来你在程序中如果使用 asyncio.run 就会出错，之前我们提到对于其他的协程通过 await 链来实现，这里也是一样的。</p>\n    <p>下面说下代码的含义，首先启动 main 这个协程，main 方法就是先打印 hello，然后在打印过程中通过使用 asyncio.sleep 来等待 1 秒，之后再打印\n        world。前面我们提到用协程就意味着我们要一直使用非阻塞的代码，才能达到速度提升，所以这里我们用了非阻塞版的 time.sleep 即 asyncio.sleep 。</p>\n    <h3 id=\"-4\">协程中调用协程</h3>\n    <p>之前我们提到了在协程中，可以使用 await 来调用一个协程。</p>\n    <p>就像下面的代码:</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n<span class=\"hljs-keyword\">import</span> time\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">say_after</span><span class=\"hljs-params\">(delay, what)</span>:</span>\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(delay)\n    print(what)\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    <span class=\"hljs-comment\">#使用f-string拼接字符串</span>\n    print(<span class=\"hljs-string\">f\"开始运行 <span class=\"hljs-subst\">{time.strftime(<span class=\"hljs-string\">'%X'</span>)}</span>\"</span>)\n\n    child1=<span class=\"hljs-keyword\">await</span> say_after(<span class=\"hljs-number\">1</span>, <span\n                class=\"hljs-string\">'hello'</span>) <span class=\"hljs-comment\">#通过await调用协程，然后接收一下返回值</span>\n    child2=<span class=\"hljs-keyword\">await</span> say_after(<span class=\"hljs-number\">2</span>, <span\n                class=\"hljs-string\">'world'</span>)\n    print(<span class=\"hljs-string\">\"child1\"</span>,child1)\n    print(<span class=\"hljs-string\">\"child2\"</span>,child2)\n\n    print(<span class=\"hljs-string\">f\"结束运行 <span class=\"hljs-subst\">{time.strftime(<span class=\"hljs-string\">'%X'</span>)}</span>\"</span>)\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n      asyncio.run(main())\n</code></pre>\n    <p>运行结果：</p>\n    <pre><code class=\"hljs css\">开始运行 11<span class=\"hljs-selector-pseudo\">:17</span><span class=\"hljs-selector-pseudo\">:26</span>\n<span class=\"hljs-selector-tag\">hello</span>\n<span class=\"hljs-selector-tag\">world</span>\n<span class=\"hljs-selector-tag\">child1</span> <span class=\"hljs-selector-tag\">None</span>\n<span class=\"hljs-selector-tag\">child2</span> <span class=\"hljs-selector-tag\">None</span>\n结束运行 11<span class=\"hljs-selector-pseudo\">:17</span><span class=\"hljs-selector-pseudo\">:29</span>\n<span class=\"hljs-selector-attr\">[Finished in 3.1s]</span>\n</code></pre>\n    <p>代码是没什么问题,正常运行。但是一般情况下我们用到更多的是下面的方式。将协程封装为 Task 让原本没有状态标示的协程添加上状态 。</p>\n    <p>我们可以通过 asyncio.create_task 方法来实现。</p>\n    <h4 id=\"asynciocreate_task\">asyncio.create_task</h4>\n    <p><code>create_task</code>（在 3.6 版本中需要使用低层级的 API <code>asyncio.ensure_future</code>。）是\n        3.7以后加入的语法，作用是将协程包装为一个任务（Task），相比 3.6 版本的 <code>ensure_future</code> 可读性提高。</p>\n    <p>将上面的代码做如下修改：</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n<span class=\"hljs-keyword\">import</span> time\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">say_after</span><span class=\"hljs-params\">(delay, what)</span>:</span>\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(delay)\n    print(what)\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    print(<span class=\"hljs-string\">f\"开始运行 <span class=\"hljs-subst\">{time.strftime(<span class=\"hljs-string\">'%X'</span>)}</span>\"</span>)\n\n    child1=asyncio.create_task(say_after(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'hello'</span>)) <span\n                class=\"hljs-comment\">#通过await调用协程，然后接收一下返回值</span>\n    child2=asyncio.create_task(say_after(<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">'world'</span>))\n    print(<span class=\"hljs-string\">\"调用任务child1前\"</span>,child1)\n    print(<span class=\"hljs-string\">\"调用任务child2前\"</span>,child2)\n    <span class=\"hljs-keyword\">await</span> child1\n    <span class=\"hljs-keyword\">await</span> child2\n    print(<span class=\"hljs-string\">\"调用任务child1后\"</span>,child1)\n    print(<span class=\"hljs-string\">\"调用任务child2前\"</span>,child2)\n\n    print(<span class=\"hljs-string\">f\"结束运行 <span class=\"hljs-subst\">{time.strftime(<span class=\"hljs-string\">'%X'</span>)}</span>\"</span>)\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n      asyncio.run(main())\n</code></pre>\n    <p>运行结果如下:</p>\n    <pre><code class=\"hljs ruby\">开始运行 <span class=\"hljs-number\">11</span><span class=\"hljs-symbol\">:</span><span\n            class=\"hljs-number\">37</span><span class=\"hljs-symbol\">:</span><span class=\"hljs-number\">54</span>\n调用任务child1前 &lt;Task pending name=<span class=\"hljs-string\">'Task-2'</span> coro=&lt;say_after() running at /Users/chennan/Desktop/<span\n                class=\"hljs-number\">2019</span>/aiochatuse/hello.<span class=\"hljs-symbol\">py:</span><span\n                class=\"hljs-number\">4</span><span class=\"hljs-meta\">&gt;&gt;\n</span>调用任务child2前 &lt;Task pending name=<span class=\"hljs-string\">'Task-3'</span> coro=&lt;say_after() running at /Users/chennan/Desktop/<span\n                class=\"hljs-number\">2019</span>/aiochatuse/hello.<span class=\"hljs-symbol\">py:</span><span\n                class=\"hljs-number\">4</span>&gt;&gt;\nhello\nworld\n调用任务child1后 &lt;Task finished name=<span class=\"hljs-string\">'Task-2'</span> coro=&lt;say_after() done, <span\n                class=\"hljs-keyword\">defined</span> at /Users/chennan/Desktop/<span class=\"hljs-number\">2019</span>/aiochatuse/hello.<span\n                class=\"hljs-symbol\">py:</span><span class=\"hljs-number\">4</span>&gt; result=None&gt;\n调用任务child2前 &lt;Task finished name=<span class=\"hljs-string\">'Task-3'</span> coro=&lt;say_after() done, <span\n                class=\"hljs-keyword\">defined</span> at /Users/chennan/Desktop/<span class=\"hljs-number\">2019</span>/aiochatuse/hello.<span\n                class=\"hljs-symbol\">py:</span><span class=\"hljs-number\">4</span>&gt; result=None&gt;\n结束运行 <span class=\"hljs-number\">11</span><span class=\"hljs-symbol\">:</span><span class=\"hljs-number\">37</span><span\n                class=\"hljs-symbol\">:</span><span class=\"hljs-number\">56</span>\n</code></pre>\n    <p>可以发现，我们的结果中多了\"&lt;Task pending ...\"和\"&lt;Task finised ...\"几行语句。这就是 Task\n        的一个状态变化，知道状态的好处就是我们可以根据任务的状态做进一步操作，不像协程函数那样没有状态标示，当然 Task 的状态不只有这些。</p>\n    <p>前面说到 Task 是 Future 的子类，所以 Task 拥有 Future 的一些状态。</p>\n    <h4 id=\"future-1\">Future 的状态</h4>\n    <p>大概有如下几种:</p>\n    <ul>\n        <li>Pending</li>\n        <li>Running</li>\n        <li>Done</li>\n        <li>Cancelled</li>\n    </ul>\n    <p>创建 future 的时候，task 为 pending，事件循环调用执行的时候当然就是 running，调用完毕自然就是 done，如果需要停止事件循环，就需要先把 task 取消，状态为 cancel。这里先做了解知道\n        Task 是有状态的就够了。</p>\n    <h3 id=\"-5\">并发运行任务</h3>\n    <p>一系列的协程可以通过 await 链式的调用，但是有的时候我们需要在一个协程里等待多个协程，比如我们在一个协程里等待 1000 个异步网络请求，对于访问次序有没有要求的时候，就可以使用另外的关键字 asyncio.wait 或\n        asyncio.gather 来解决了。</p>\n    <h4 id=\"asynciogather\">asyncio.gather</h4>\n    <p>使用方法：</p>\n    <pre><code class=\"hljs python\">asyncio.gather(*aws, loop=<span\n            class=\"hljs-keyword\">None</span>, return_exceptions=<span class=\"hljs-keyword\">False</span>)¶\n</code></pre>\n    <p>也就是说使用 gather 语句并发协程，就得用 await 去执行它。这个方法可以接收三个参数，第一个 aws。</p>\n    <p>aws 一般是一个列表，如果里面的元素是 awaitable 类型，在运行的时候它将自动被包装成 Task，gather 会根据 aws 中元素添加的顺序。顺序执行并返回结果列表。</p>\n    <p>第二个 loop 可以传入一个事件循环对象，一般不用管，最后一个 <code>return_exceptions</code> 默认是 False，如果 return_exceptions 为\n        True，异常将被视为成功结果，然后添加到结果列表中。</p>\n    <p>下面是一个 10 个数字并输出的例子：</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">foo</span><span class=\"hljs-params\">(num)</span>:</span>\n    <span class=\"hljs-keyword\">return</span> num\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    coro = [asyncio.create_task(foo(i)) <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> range(<span\n                class=\"hljs-number\">10</span>) ]\n    done= <span class=\"hljs-keyword\">await</span> asyncio.gather(*coro)\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> done:\n        print(i)\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    asyncio.run(main())\n</code></pre>\n    <p>运行之后结果如下：</p>\n    <pre><code class=\"hljs\">0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n</code></pre>\n    <p>gather 返回的结果是一个列表，迭代这个列表可以看到任务依次输出。</p>\n    <p>gather 通常被用来阶段性的一个操作，做完第一步才能做第二步，比如下面这样：</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">import</span> time\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">step1</span><span class=\"hljs-params\">(n, start)</span>:</span>\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(n)\n    print(<span class=\"hljs-string\">\"第一阶段完成\"</span>)\n    print(<span class=\"hljs-string\">\"此时用时\"</span>, time.time() - start)\n    <span class=\"hljs-keyword\">return</span> n\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">step2</span><span class=\"hljs-params\">(n, start)</span>:</span>\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(n)\n    print(<span class=\"hljs-string\">\"第二阶段完成\"</span>)\n    print(<span class=\"hljs-string\">\"此时用时\"</span>, time.time() - start)\n    <span class=\"hljs-keyword\">return</span> n\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    now = time.time()\n    result = <span class=\"hljs-keyword\">await</span> asyncio.gather(step1(<span class=\"hljs-number\">5</span>, now), step2(<span\n                class=\"hljs-number\">2</span>, now))\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> result:\n        print(i)\n    print(<span class=\"hljs-string\">\"总用时\"</span>, time.time() - now)\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n   asyncio.run(main())\n</code></pre>\n    <p>输出内容：</p>\n    <pre><code class=\"hljs css\">第二阶段完成\n此时用时 2<span class=\"hljs-selector-class\">.0041821002960205</span>\n第一阶段完成\n此时用时 5<span class=\"hljs-selector-class\">.0009942054748535</span>\n5\n2\n总用时 5<span class=\"hljs-selector-class\">.001508951187134</span>\n</code></pre>\n    <p>可以通过上面结果得到如下结论：</p>\n    <ol>\n        <li>step1 和 step2 是并行运行的。</li>\n        <li>gather 会等待最耗时的那个完成之后才返回结果，耗时总时间取决于其中任务最长时间的那个。</li>\n    </ol>\n    <h4 id=\"asynciowait\">asyncio.wait</h4>\n    <p>我们先看一下 wait 的语法结构：</p>\n    <pre><code class=\"hljs python\">asyncio.wait(aws, *, loop=<span class=\"hljs-keyword\">None</span>, timeout=<span\n            class=\"hljs-keyword\">None</span>, return_when=ALL_COMPLETED)¶\n</code></pre>\n    <p>wait 一共有 4 个参数，第一个参数 aws，一般是一个任务列表。</p>\n    <p>第二个*之后的都是强制关键字参数，即 loop、timeout、return_when。</p>\n    <p>loop 通 gather 的参数是一个事件循环，该参数计划在 Python 3.10 中删除。</p>\n    <p>timeout 可以指定这组任务的超时时间，请注意，此函数不会引发 asyncio.TimeoutError，超时的时候会返回已完成的任务。</p>\n    <p>return_when 可以指定什么条件下返回结果，默认是所以任务完成就返回结果列表。</p>\n    <p>return_when 的具体参数看下面的表格：</p>\n    <table>\n        <thead>\n        <tr>\n            <th>参数名</th>\n            <th>含义</th>\n        </tr>\n        </thead>\n        <tbody>\n        <tr>\n            <td>FIRST_COMPLETED</td>\n            <td>任何一个 future 完成或取消时返回</td>\n        </tr>\n        <tr>\n            <td>FIRST_EXCEPTION</td>\n            <td>任何一个 future 出现错误将返回，如果没有出现异常等价于 ALL_COMPLETED</td>\n        </tr>\n        <tr>\n            <td>ALL_COMPLETED</td>\n            <td>当所有任务完成或者被取消时返回结果，默认值。</td>\n        </tr>\n        </tbody>\n    </table>\n    <p>wait 返回的结果是一个元组，第一部分是完成的任务，第二部分是准备中的任务。</p>\n    <pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">done</span>, pending = await asyncio.wait(aws)\n</code></pre>\n    <p>其中 done 表示完成的任务，可以通过迭代获取每个任务。</p>\n    <p>pending 表示的是还没执行的任务。</p>\n    <p>下面看一个例子来进一步了解：</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">foo</span><span class=\"hljs-params\">(num)</span>:</span>\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">0.99991</span>)\n    <span class=\"hljs-keyword\">return</span> num\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    <span class=\"hljs-comment\">#coro = foo()</span>\n    coro = [asyncio.create_task(foo(i)) <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> range(<span\n                class=\"hljs-number\">10</span>) ]\n    done, pending = <span class=\"hljs-keyword\">await</span> asyncio.wait(coro,timeout=<span class=\"hljs-number\">1</span>,return_when=<span\n                class=\"hljs-string\">\"ALL_COMPLETED\"</span>)\n\n    <span class=\"hljs-keyword\">for</span> coro <span class=\"hljs-keyword\">in</span> done:\n        print(coro.result())\n    print(<span class=\"hljs-string\">\"pending\"</span>,pending)\n    <span class=\"hljs-keyword\">for</span> item <span class=\"hljs-keyword\">in</span> pending:\n         print(item)\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    asyncio.run(main())\n</code></pre>\n    <p>运行结果如下:</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">0</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">4</span>\n<span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">7</span>\npending {&lt;Task pending name=<span class=\"hljs-string\">'Task-10'</span> coro=&lt;foo() running at /Users/chennan/Desktop/<span\n                class=\"hljs-number\">2019</span>/aiochatuse/waitdemo.py:<span class=\"hljs-number\">4</span>&gt; wait_for=&lt;Future finished result=<span\n                class=\"hljs-keyword\">None</span>&gt;&gt;, &lt;Task pending name=<span\n                class=\"hljs-string\">'Task-11'</span> coro=&lt;foo() running at /Users/chennan/Desktop/<span\n                class=\"hljs-number\">2019</span>/aiochatuse/waitdemo.py:<span class=\"hljs-number\">4</span>&gt; wait_for=&lt;Future finished result=<span\n                class=\"hljs-keyword\">None</span>&gt;&gt;}\n&lt;Task pending name=<span class=\"hljs-string\">'Task-10'</span> coro=&lt;foo() running at /Users/chennan/Desktop/<span\n                class=\"hljs-number\">2019</span>/aiochatuse/waitdemo.py:<span class=\"hljs-number\">4</span>&gt; wait_for=&lt;Future finished result=<span\n                class=\"hljs-keyword\">None</span>&gt;&gt;\n&lt;Task pending name=<span class=\"hljs-string\">'Task-11'</span> coro=&lt;foo() running at /Users/chennan/Desktop/<span\n                class=\"hljs-number\">2019</span>/aiochatuse/waitdemo.py:<span class=\"hljs-number\">4</span>&gt; wait_for=&lt;Future finished result=<span\n                class=\"hljs-keyword\">None</span>&gt;&gt;\n</code></pre>\n    <p>首先说代码，使用 wait 实现并发的程序是无序的，所以我们看到数字不是一次出现的，这个是和 gather 的不同之处。另外在返回的参数上也有差别，wait 返回两个参数 done 和 pending。</p>\n    <p>上面的代码指定了一个 timeout，因为任务没在指定时间完成，所以就导致只有完成的任务输出了结果，没有完成的部分可以看到它们的状态是 pending。</p>\n    <h4 id=\"-6\">总结</h4>\n    <p>最后我们总结一下 wait 和 gather 的相同之处和不同之处：</p>\n    <p>相同之处：都可以完成多个任务的并发操作。\n        不同之外：gather 适合按照顺序去做的任务，或者按照阶段去做的任务，返回的是结果列表，而 wait 不讲究任务的顺序，这个在做爬虫中经常使用到，然后 wait 可以返回 2 个结果，done 和 pending。</p>\n    <h3 id=\"-7\">任务完成时处理</h3>\n    <h4 id=\"asyncioas_completed\">asyncio.as_completed</h4>\n    <p><code>as_complete</code> 是一个生成器，会管理指定的一个任务列表，并生成他们的结果。每个协程结束运行时一次生成一个结果。与 wait 一样，<code>as_complete</code>\n        不能保证顺序，不过执行其他动作之前没有必要等待所有后台操作完成。</p>\n    <p>我们看下这个函数都有哪些参数：</p>\n    <pre><code class=\"hljs python\">asyncio.as_completed(aws, *, loop=<span\n            class=\"hljs-keyword\">None</span>, timeout=<span class=\"hljs-keyword\">None</span>)\n</code></pre>\n    <p>和前面的 wait 类似，第一个参数 awas，然后 loop，最后 timeout，需要注意的是 timeout 如果指定了，那么在指定时间没完成的话会抛出 asyncio.exceptions.TimeoutError\n        异常。</p>\n    <p>下面看一个例子:</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n<span class=\"hljs-keyword\">import</span> time\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">foo</span><span class=\"hljs-params\">(n)</span>:</span>\n    print(<span class=\"hljs-string\">f'等待<span class=\"hljs-subst\">{n}</span>秒'</span>)\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(n)\n    <span class=\"hljs-keyword\">return</span> n\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    coroutine1 = foo(<span class=\"hljs-number\">1</span>)\n    coroutine2 = foo(<span class=\"hljs-number\">2</span>)\n    coroutine3 = foo(<span class=\"hljs-number\">4</span>)\n\n    tasks = [asyncio.create_task(coroutine1),asyncio.create_task(coroutine2),asyncio.create_task(coroutine3)]\n    <span class=\"hljs-keyword\">for</span> task <span class=\"hljs-keyword\">in</span> asyncio.as_completed(tasks):\n        result = <span class=\"hljs-keyword\">await</span> task\n        print(<span class=\"hljs-string\">f'获取返回结果: <span class=\"hljs-subst\">{result}</span>'</span>)\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    now = <span class=\"hljs-keyword\">lambda</span> : time.time()\n    start = now()\n    asyncio.run(main())\n    print(now() - start)\n</code></pre>\n    <p>输出结果：</p>\n    <pre><code class=\"hljs makefile\">等待1秒\n等待2秒\n等待4秒\n<span class=\"hljs-section\">获取返回结果: 1</span>\n<span class=\"hljs-section\">获取返回结果: 2</span>\n<span class=\"hljs-section\">获取返回结果: 4</span>\n4.002715826034546\n</code></pre>\n    <p>可以看出整个执行过程总用时取决 等待时间最长的那个，即 4 秒。</p>\n    <p>接下来，对上面的代码稍作修改。</p>\n    <p>将</p>\n    <pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">for</span> task <span class=\"hljs-keyword\">in</span> asyncio.as_completed(tasks):\n</code></pre>\n    <p>改为</p>\n    <pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">for</span> task <span class=\"hljs-keyword\">in</span> asyncio.as_completed(tasks,timeout=2):\n</code></pre>\n    <p>其他地方不变，改完运行之后会看到上面提到的错误。</p>\n    <pre><code class=\"hljs sql\">等待1秒\n等待2秒\n等待4秒\n获取返回结果: 1\nTraceback (most recent <span class=\"hljs-keyword\">call</span> <span class=\"hljs-keyword\">last</span>):\n  <span class=\"hljs-keyword\">File</span> <span class=\"hljs-string\">\"/Users/chennan/Desktop/2019/aiochatuse/ascomplete.py\"</span>, line <span\n                class=\"hljs-number\">25</span>, <span class=\"hljs-keyword\">in</span> &lt;<span class=\"hljs-keyword\">module</span>&gt;\n    asyncio.run(<span class=\"hljs-keyword\">main</span>())\n  <span class=\"hljs-keyword\">File</span> <span class=\"hljs-string\">\"/Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/asyncio/runners.py\"</span>, line <span\n                class=\"hljs-number\">43</span>, <span class=\"hljs-keyword\">in</span> run\n    <span class=\"hljs-keyword\">return</span> loop.run_until_complete(<span class=\"hljs-keyword\">main</span>)\n  <span class=\"hljs-keyword\">File</span> <span class=\"hljs-string\">\"/Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/asyncio/base_events.py\"</span>, line <span\n                class=\"hljs-number\">589</span>, <span class=\"hljs-keyword\">in</span> run_until_complete\n    <span class=\"hljs-keyword\">return</span> future.result()\n  <span class=\"hljs-keyword\">File</span> <span class=\"hljs-string\">\"/Users/chennan/Desktop/2019/aiochatuse/ascomplete.py\"</span>, line <span\n                class=\"hljs-number\">18</span>, <span class=\"hljs-keyword\">in</span> <span\n                class=\"hljs-keyword\">main</span>\n    <span class=\"hljs-keyword\">result</span> = await task\n  <span class=\"hljs-keyword\">File</span> <span class=\"hljs-string\">\"/Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/asyncio/tasks.py\"</span>, line <span\n                class=\"hljs-number\">570</span>, <span class=\"hljs-keyword\">in</span> _wait_for_one\n    <span class=\"hljs-keyword\">raise</span> exceptions.TimeoutError\nasyncio.exceptions.TimeoutError\n</code></pre>\n    <h3 id=\"-8\">取消任务的时候保证其他协程运行完毕</h3>\n    <p>在取消任务的时候存在一个问题,首先先看一段代码：</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">coro</span><span class=\"hljs-params\">()</span>:</span>\n    print(<span class=\"hljs-string\">'开始休眠'</span>)\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">2</span>)\n    print(<span class=\"hljs-string\">'结束休眠'</span>)\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">cancel_it</span><span class=\"hljs-params\">(some_task)</span>:</span>\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">0.5</span>)\n    some_task.cancel()\n    print(<span class=\"hljs-string\">'取消some_task任务'</span>)\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    real_task = asyncio.create_task(coro())\n    <span class=\"hljs-keyword\">await</span> cancel_it(real_task)\n    <span class=\"hljs-keyword\">await</span> real_task\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    asyncio.run(main())\n</code></pre>\n    <p>运行之后你会看到如下结果：</p>\n    <pre><code class=\"hljs sql\">开始休眠\n取消some_task任务\nTraceback (most recent <span class=\"hljs-keyword\">call</span> <span class=\"hljs-keyword\">last</span>):\n  <span class=\"hljs-keyword\">File</span> <span class=\"hljs-string\">\"/Users/chennan/Desktop/2019/aiochatuse/shielddemo.py\"</span>, line <span\n                class=\"hljs-number\">24</span>, <span class=\"hljs-keyword\">in</span> &lt;<span class=\"hljs-keyword\">module</span>&gt;\n    asyncio.run(<span class=\"hljs-keyword\">main</span>())\n  <span class=\"hljs-keyword\">File</span> <span class=\"hljs-string\">\"/Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/asyncio/runners.py\"</span>, line <span\n                class=\"hljs-number\">43</span>, <span class=\"hljs-keyword\">in</span> run\n    <span class=\"hljs-keyword\">return</span> loop.run_until_complete(<span class=\"hljs-keyword\">main</span>)\n  <span class=\"hljs-keyword\">File</span> <span class=\"hljs-string\">\"/Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/asyncio/base_events.py\"</span>, line <span\n                class=\"hljs-number\">589</span>, <span class=\"hljs-keyword\">in</span> run_until_complete\n    <span class=\"hljs-keyword\">return</span> future.result()\nasyncio.exceptions.CancelledError\n</code></pre>\n    <p>下面说一下代码中的逻辑，在 main 协程中将 coro 协程封装为任务 <code>real_task</code>，然后 <code>cancel_it</code> 方法做了一个取消任务的逻辑 <code>some_task.cancel()</code>，并打印一句话。然后通过\n        await 去运行 <code>real_task</code> 方法，执行代码之后看到上面的结果。出现了 asyncio.exceptions.CancelledError 错误，同时看到 coro\n        只打印了一个开始休眠，后面的结束休眠没有打印。也就是说我们在取消一个任务的时候，里面对于的协程也被取消了。如果我们想在取消任务之后协程还能顺利执行完，就需要用到另外一个函数 shield。</p>\n    <h4 id=\"asyncioshield\">asyncio.shield</h4>\n    <p>该方法的作用是，在执行 cancel 取消一个 task 之后，task 里面的协程仍然可以执行结束，不会像上面的 coro 那样出现错误。</p>\n    <pre><code class=\"hljs coffeescript\">asyncio.shield(aw, *, <span class=\"hljs-keyword\">loop</span>=None)\n</code></pre>\n    <p>aw 表示需要传入一个 Task。</p>\n    <p>接下来我们就使用这个方法对上面的例子做一个修改。</p>\n    <p>从代码中体会它的作用。</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">coro</span><span class=\"hljs-params\">()</span>:</span>\n    print(<span class=\"hljs-string\">'开始休眠'</span>)\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">2</span>)\n    print(<span class=\"hljs-string\">'结束休眠'</span>)\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">cancel_it</span><span class=\"hljs-params\">(some_task)</span>:</span>\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">0.5</span>)\n    some_task.cancel()\n    print(<span class=\"hljs-string\">'取消some_task任务'</span>)\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    real_task = asyncio.create_task(coro())\n    shield = asyncio.shield(real_task)\n    <span class=\"hljs-keyword\">await</span> cancel_it(shield)\n    <span class=\"hljs-keyword\">await</span> real_task\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    asyncio.run(main())\n</code></pre>\n    <p>运行之后的结果：</p>\n    <pre><code class=\"hljs\">开始休眠\n取消some_task任务\n结束休眠\n</code></pre>\n    <p>可以看到尽管 some_task 任务被取消，但是 coro 仍然成功的打印了最好的“结束休眠”。通过上面的例子我想大家应该知道 shield 的作用了。 </p>\n    <h3 id=\"-9\">超时等待</h3>\n    <p>有时候需要等待一个任务完成之后再进行下一个，但是有的时候并不需要运行完就返回。</p>\n    <p>这个时候可以使用 wait_for。</p>\n    <h4 id=\"asynciowait_for\">asyncio.wait_for</h4>\n    <p>该方法的语法如下：</p>\n    <pre><code class=\"hljs coffeescript\">asyncio.wait_for(aw, timeout, *, <span class=\"hljs-keyword\">loop</span>=None)\n</code></pre>\n    <p>aw 是一个任务，timeout 可以指定超时时间。如果发生超时，它将取消该任务并引发 asyncio.TimeoutError，此时为了保证任务中协程完成可以使用上面说的 shield。</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">foo</span><span class=\"hljs-params\">()</span>:</span>\n     <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">1</span>)\n     print(<span class=\"hljs-string\">\"in foo\"</span>)\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">eternity</span><span class=\"hljs-params\">()</span>:</span>\n    <span class=\"hljs-comment\"># Sleep for one hour</span>\n    <span class=\"hljs-keyword\">await</span> foo()\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">3600</span>)\n    print(<span class=\"hljs-string\">'yay!'</span>)\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    <span class=\"hljs-comment\"># Wait for at most 1 second</span>\n    <span class=\"hljs-keyword\">try</span>:\n        <span class=\"hljs-keyword\">await</span> asyncio.wait_for(asyncio.shield(eternity()), timeout=<span\n                class=\"hljs-number\">1.0</span>)\n    <span class=\"hljs-keyword\">except</span> asyncio.TimeoutError:\n        print(<span class=\"hljs-string\">'timeout!'</span>)\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    asyncio.run(main())\n</code></pre>\n    <p>输出：</p>\n    <pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">in</span> foo\ntimeout!\n</code></pre>\n    <p>按照上面的经验可知道，如果我们把 asyncio.shield 去掉之后，“in foo” 就无法输出了。</p>\n    <h3 id=\"-10\">协程配合线程</h3>\n    <h4 id=\"asynciorun_coroutine_threadsafe\">asyncio.run<em>coroutine</em>threadsafe</h4>\n    <p>该方法的语法如下：</p>\n    <pre><code class=\"hljs coffeescript\">asyncio.run_coroutine_threadsafe(coro, <span class=\"hljs-keyword\">loop</span>)\n</code></pre>\n    <p>其实在协程中也可以使用多线程,有时候我们需要在主线程中启动一个子线程去做别的任务，这个时候我们就要用到下面的方法了，先上一个流畅的 Python 中的代码。</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> time\n<span class=\"hljs-keyword\">import</span> asyncio\n<span class=\"hljs-keyword\">from</span>  threading <span class=\"hljs-keyword\">import</span> Thread\n\nnow = <span class=\"hljs-keyword\">lambda</span>: time.time()\n\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">start_loop</span><span\n        class=\"hljs-params\">(loop)</span>:</span>\n    asyncio.set_event_loop(loop)\n    loop.run_forever()\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">do_some_work</span><span class=\"hljs-params\">(x)</span>:</span>\n    print(<span class=\"hljs-string\">f'Waiting <span class=\"hljs-subst\">{x}</span>'</span>)\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(x)\n    print(<span class=\"hljs-string\">f'Done after <span class=\"hljs-subst\">{x}</span>s'</span>)\n\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">more_work</span><span\n        class=\"hljs-params\">(x)</span>:</span>\n    print(<span class=\"hljs-string\">f'More work <span class=\"hljs-subst\">{x}</span>'</span>)\n    time.sleep(x)\n    print(<span class=\"hljs-string\">'Finished more work {x}'</span>)\n\n\nstart = now()\n<span class=\"hljs-comment\"># 主线程中创建一个 new_loop</span>\nnew_loop = asyncio.get_event_loop()\n<span class=\"hljs-comment\"># 创建子线程 在其中开启无限事件循环</span>\nt = Thread(target=start_loop, args=(new_loop,))\nt.start()\nprint(<span class=\"hljs-string\">f'TIME: <span class=\"hljs-subst\">{time.time() - start}</span>'</span>)\n\n<span class=\"hljs-comment\"># 在主线程中新注册协程对象</span>\n<span class=\"hljs-comment\"># 这样即可在子线程中进行事件循环的并发操作 同时主线程又不会被 block </span>\n<span class=\"hljs-comment\"># 一共执行的时间大概在 6 s 左右 </span>\nasyncio.run_coroutine_threadsafe(do_some_work(<span class=\"hljs-number\">6</span>), new_loop)\nasyncio.run_coroutine_threadsafe(do_some_work(<span class=\"hljs-number\">4</span>), new_loop)\n</code></pre>\n    <p>上述的例子，主线程中创建一个 <code>new_loop</code>，然后在另外的子线程中开启一个无限事件循环。主线程通过 <code>run_coroutine_threadsafe</code>\n        新注册协程对象。这样就能在子线程中进行事件循环的并发操作，同时主线程又不会被 block。一共执行的时间大概在 6s 左右。</p>\n    <h3 id=\"-11\">同步原语</h3>\n    <p>尽管 asyncio 应用通常作为单线程运行，不过仍被构建为并发应用。由于 I/O 以及其他外部事件的延迟和中断，每个协程或任务可能按一种不可预知的顺序执行。为了支持安全的并发执行，asyncio 包含了 threading\n        和 multiprocessing 模块中的一些底层原语的实现。</p>\n    <p>这里介绍两个经常用到的例子。</p>\n    <h4 id=\"queue\">队列（Queue）</h4>\n    <p>asyncio.Queue 为协程提供了一个先进先出的数据结构，这与线程的 queue.Queue 或进程的multiprocessing.Queue 很类似，下面先看一个简单的例子，它是一个非阻塞的队列。</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n<span class=\"hljs-keyword\">from</span> asyncio <span class=\"hljs-keyword\">import</span> Queue\n\nqueue=Queue()\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">start</span><span class=\"hljs-params\">()</span>:</span>\n        [queue.put_nowait(i) <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> range(<span\n                class=\"hljs-number\">1</span>, <span class=\"hljs-number\">10</span>)]\n        <span class=\"hljs-keyword\">await</span> asyncio.create_task(work()) <span\n                class=\"hljs-comment\">#put_nowait表示放入元素</span>\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">work</span><span class=\"hljs-params\">()</span>:</span>\n    <span class=\"hljs-keyword\">try</span>:\n        <span class=\"hljs-keyword\">while</span> <span class=\"hljs-keyword\">not</span> queue.empty():<span\n                class=\"hljs-comment\">#判断队列的元素是否为空</span>\n            num = queue.get_nowait()<span class=\"hljs-comment\">#获取元素</span>\n            print(<span class=\"hljs-string\">f\"获取数字:<span class=\"hljs-subst\">{num}</span>\"</span>)\n            queue.task_done()<span class=\"hljs-comment\">#告诉队列该任务处理完。</span>\n    <span class=\"hljs-keyword\">except</span> asyncio.CancelledError:\n        <span class=\"hljs-keyword\">pass</span>\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    asyncio.run(start())\n</code></pre>\n    <p>输出结果:</p>\n    <pre><code class=\"hljs css\">获取数字<span class=\"hljs-selector-pseudo\">:1</span>\n获取数字<span class=\"hljs-selector-pseudo\">:2</span>\n获取数字<span class=\"hljs-selector-pseudo\">:3</span>\n获取数字<span class=\"hljs-selector-pseudo\">:4</span>\n获取数字<span class=\"hljs-selector-pseudo\">:5</span>\n获取数字<span class=\"hljs-selector-pseudo\">:6</span>\n获取数字<span class=\"hljs-selector-pseudo\">:7</span>\n获取数字<span class=\"hljs-selector-pseudo\">:8</span>\n获取数字<span class=\"hljs-selector-pseudo\">:9</span>\n</code></pre>\n    <p>在做爬虫的时候对于 url 的处理，经常会用到队列的操作。另外一个要说的同步原语就是信号量。</p>\n    <h2 id=\"semaphore\">信号量（Semaphore）</h2>\n    <p>简单说下什么是信号量，我们用停车场和车进行比喻。一个停车场一共就 5 个车位，所以我们知道可以同时容纳最多 5 辆车，这五个车位就是信号量。</p>\n    <p>然后说信号量的行为，当有车离开停车场的时候外面的车就会进来补，比如有 2 辆车离开，那么就可以再进来 2 辆车，依次类推，上面这个过程就是描述了信号量这个东西。</p>\n    <p>下面我们看如何在程序中使用。</p>\n    <p>asyncio.Semaphore 模块就是一个维持并发量的模块，我们用它起到一个限流的效果。首先来一段代码：</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\nsem=asyncio.Semaphore(<span class=\"hljs-number\">3</span>) <span class=\"hljs-comment\">#信号量指定为3</span>\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">branch</span><span class=\"hljs-params\">(num)</span>:</span>\n    <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">with</span> sem:  <span class=\"hljs-comment\">#通过异步上下文关键子控制并发量</span>\n        print(<span class=\"hljs-string\">f\"获取当前数字:<span class=\"hljs-subst\">{num}</span>\"</span>)\n        <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">0.5</span>)\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n\n     tasks=[asyncio.create_task(branch(i)) <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> range(<span\n                class=\"hljs-number\">10</span>)] <span class=\"hljs-comment\">#将协程封装成任务共10个</span>\n     <span class=\"hljs-keyword\">await</span> asyncio.wait(tasks) <span class=\"hljs-comment\">#执行这些任务</span>\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    asyncio.run(main())\n</code></pre>\n    <p>执行之后你会发现：</p>\n    <pre><code class=\"hljs makefile\"><span class=\"hljs-section\">获取当前数字:0</span>\n<span class=\"hljs-section\">获取当前数字:1</span>\n<span class=\"hljs-section\">获取当前数字:2</span>\nTask exception was never retrieved\n<span class=\"hljs-section\">future: &lt;Task finished name='Task-11' coro=&lt;branch() done, defined at /Users/chennan/Desktop/2019/aiochatuse/semaphoredemo.py:26&gt; exception=RuntimeError(\"Task &lt;Task pending name='Task-11' coro=&lt;branch() running at /Users/chennan/Desktop/2019/aiochatuse/semaphoredemo.py:27&gt; cb=[_wait.&lt;locals&gt;._on_completion() at /Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/asyncio/tasks.py:478]&gt; got Future &lt;Future pending&gt; attached to a different loop\")&gt;</span>\n</code></pre>\n    <p>关键就是 attached to a different loop，这个地方说是当前的事件循环发生了改变，这个问题在Python3.6 的时候是不会出现的。</p>\n    <p>为什么 3.8 出错了？</p>\n    <p>这是因为：</p>\n    <p>我的信号量没有在循环内创建。也就是在 asyncio.run() 创建的循环之外创建了它们，因此它们使用 <code>events.get_event_loop()</code> 这就导致了新的事件循环产生。\n        asyncio.run() 创建一个新循环，然后在一个循环中创建的 future\n        不能在另一个循环中使用。所以问题就明确了，我们需要在循环之内创建。也就是我们需要定义一个全局变量，然后在主循环内部给其赋值。看到这，可能大家想到了 global，Python 3.7 增加了上下文变量 Context\n        Variables，至于为什么不用全局变量，因为可能会被其他协程修改，不安全，在这里也可以使用。</p>\n    <p>所以我们的代码变成了下面这个样子：</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n<span class=\"hljs-keyword\">from</span> contextvars <span class=\"hljs-keyword\">import</span> ContextVar\n\nconcurrent=ContextVar(<span class=\"hljs-string\">\"concurrent\"</span>)<span class=\"hljs-comment\">#定义全局上下文管理器</span>\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">branch</span><span class=\"hljs-params\">(num)</span>:</span>\n    sem=concurrent.get()<span class=\"hljs-comment\">#获取上下文关键字</span>\n    <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">with</span> sem:\n        print(<span class=\"hljs-string\">f\"获取当前数字:<span class=\"hljs-subst\">{num}</span>\"</span>)\n        <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">0.5</span>) <span\n                class=\"hljs-comment\">#为了看到明显的效果</span>\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n     concurrent.set(asyncio.Semaphore(<span class=\"hljs-number\">3</span>)) <span class=\"hljs-comment\">#上下文管理器赋值</span>\n     tasks=[asyncio.create_task(branch(i)) <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> range(<span\n                class=\"hljs-number\">10</span>)]\n     <span class=\"hljs-keyword\">await</span> asyncio.wait(tasks)\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    asyncio.run(main())\n</code></pre>\n    <p>然后我们再次输出：</p>\n    <pre><code class=\"hljs css\">获取当前数字<span class=\"hljs-selector-pseudo\">:0</span>\n获取当前数字<span class=\"hljs-selector-pseudo\">:1</span>\n获取当前数字<span class=\"hljs-selector-pseudo\">:2</span>\n获取当前数字<span class=\"hljs-selector-pseudo\">:3</span>\n获取当前数字<span class=\"hljs-selector-pseudo\">:4</span>\n获取当前数字<span class=\"hljs-selector-pseudo\">:5</span>\n获取当前数字<span class=\"hljs-selector-pseudo\">:6</span>\n获取当前数字<span class=\"hljs-selector-pseudo\">:7</span>\n获取当前数字<span class=\"hljs-selector-pseudo\">:8</span>\n获取当前数字<span class=\"hljs-selector-pseudo\">:9</span>\n</code></pre>\n    <p>可以看到程序每隔 3 组输出一次，这就达到了我们想要的效果了。</p>\n    </div>\n</body>\n</html>","source":"_posts/gitchat/python_asyncio_guidelines.html","raw":"---\ntitle: asyncio使用指南\n---\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>asyncio使用指南</title>\n</head>\n<body>\n<div id=\"article_content\" class=\"mazi-article-content dont-break-out\">\n    <h3 id=\"\">协程的演变</h3>\n    <p>其实早在 Python3.4 的时候就有协程,当时的协程是通过 @asyncio.coroutine 和 yeild from 实现的。在一些很老教程中你可能看到的是下面这种形式:</p>\n    <pre><code class=\"hljs coffeescript\"><span class=\"hljs-keyword\">import</span> asyncio\n\n@asyncio.coroutine\ndef print_hello():\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello world!\"</span>)\n    r = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-keyword\">from</span> asyncio.sleep(<span\n                class=\"hljs-number\">1</span>)\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello again!\"</span>)\n\n<span class=\"hljs-comment\"># 创建并获取EventLoop:</span>\n<span class=\"hljs-keyword\">loop</span> = asyncio.get_event_loop()\n<span class=\"hljs-comment\"># 执行协程</span>\n<span class=\"hljs-keyword\">loop</span>.run_until_complete(print_hello())\n<span class=\"hljs-keyword\">loop</span>.close()\n</code></pre>\n    <p>因为现在几乎没有人这样写了，所以仅作为了解即可。</p>\n    <p>然后到了 Python3.5 引入了 async/await 语法糖，一直到现在Python3.8 都是用这种形式来表示协程，示例如下。</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">print_hello</span><span class=\"hljs-params\">()</span>:</span>\n     print(<span class=\"hljs-string\">\"Hello world!\"</span>)\n     <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">1</span>)\n     print(<span class=\"hljs-string\">\"Hello again!\"</span>)\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    loop = asyncio.get_event_loop()\n    <span class=\"hljs-keyword\">try</span>:\n        print(<span class=\"hljs-string\">\"开始运行协程\"</span>)\n        coro = print_hello()\n        print(<span class=\"hljs-string\">\"进入事件循环\"</span>)\n        loop.run_until_complete(coro)\n    <span class=\"hljs-keyword\">finally</span>:\n        print(<span class=\"hljs-string\">\"关闭事件循环\"</span>)\n        loop.close()\n</code></pre>\n    <p>这种是目前应用范围最广的，可以看到比之前的代码舒服了不少，不用再使用装饰器的形式了。</p>\n    <p>然后就到了 Python3.7 和 Python3.8，协程发生了很多细小的变化，但是最大的一个变化就是，启动协程的方法变简单了，一句就可以搞定，不用再像上面那样，创建循环然后再仍到事件循环去执行。使用 asyncio.run\n        这个顶级 API 就可以了。</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">print_hello</span><span class=\"hljs-params\">()</span>:</span>\n     print(<span class=\"hljs-string\">\"Hello world!\"</span>)\n     <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">1</span>)\n     print(<span class=\"hljs-string\">\"Hello again!\"</span>)\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n        print(<span class=\"hljs-string\">\"开始运行协程\"</span>)\n        asyncio.run(print_hello())\n        print(<span class=\"hljs-string\">\"进入事件循环\"</span>)\n</code></pre>\n    <p>怎么样是不是代码更少了，启动协程更简单了。所以这也正是我们使用 3.8 作为本教程的 Python 版，与时俱进嘛。</p>\n    <h3 id=\"asyncio\">asyncio 的组成部分</h3>\n    <p>根据目前的官方文档，总的来说分为了两部分：高层级 API 和低层级 API。</p>\n    <p>首先看高层级 API 也是接下来重点要讲的。</p>\n    <h4 id=\"api\">高层级 API</h4>\n    <ul>\n        <li>协程对象和 Tasks 对象</li>\n        <li>数据流</li>\n        <li>同步源语</li>\n        <li>子进程</li>\n        <li>队列</li>\n        <li>异常</li>\n    </ul>\n    <h4 id=\"api-1\">低层级 API</h4>\n    <ul>\n        <li>事件循环</li>\n        <li>Futures 对象</li>\n        <li>传输和协议</li>\n        <li>策略</li>\n        <li>平台支持</li>\n    </ul>\n    <p>上面列出了这么多的项目我们怎么去选择自己所需要的呢，总的来说对于刚入门的新手或者只是写一个自己用的程序一般都只会用到高级 API\n        的部分，这部分就属于开箱即用的那种，对于高级用户比如框架开发者，往往可以需要去适应各种需要，需要重新改写一些内部的结构，这个时候就需要用到低层级的 API，但是这两个层级呢只能是一个大概方向吧，主要是方便 API\n        的查看，下面呢我将围绕者高层级 API 和低层级 API 在日常实际工作中经常用到的内容做一些讲解。</p>\n    <h3 id=\"-1\">了解几个概念</h3>\n    <p>在学习 asyncio 之前需要知道这样的几个概念。</p>\n    <h4 id=\"-2\">事件循环</h4>\n    <p>事件循环是一种处理多并发量的有效方式，在维基百科中它被描述为「一种等待程序分配事件或消息的编程架构」，我们可以定义事件循环来简化使用轮询方法来监控事件，通俗的说法就是「当 A 发生时，执行\n        B」。所谓的事件，其实就是函数。事件循环，就是有一个队列，里面存放着一堆函数，从第一个函数开始执行，在函数执行的过程中，可能会有新的函数继续加入到这个队列中。一直到队列中所有的函数被执行完毕，并且再也不会有新的函数被添加到这个队列中，程序就结束了。</p>\n    <h4 id=\"future\">Future</h4>\n    <p>Future 是一个数据结构，表示还未完成的工作结果。事件循环可以监视 Future 对象是否完成。从而允许应用的一部分等待另一部分完成一些工作。</p>\n    <p>简单说，Future 就是一个类，用生成器实现了回调。</p>\n    <h4 id=\"task\">Task</h4>\n    <p>Task 是 Future 的一个子类，它知道如何包装和管理一个协程的执行。任务所需的资源可用时，事件循环会调度任务允许，并生成一个结果，从而可以由其他协程消费。一般操作最多的还是 Task。用 Task\n        来封装协程，给原本没有状态的协程增加一些状态。</p>\n    <h4 id=\"awaitableobjects\">awaitable objects（可等待对象）</h4>\n    <p>如果一个对象可以用在 wait 表达式中，那么它就是一个可等待的对象。在 asyncio 模块中会一直提到这个概念，其中协程函数，Task，Future 都是 awaitable 对象。</p>\n    <p>用于 await 表达式中的对象。可以是 coroutine 也可以是实现了 <code>__await__()</code> 方法的对象，参见 PEP 492。类比于 Iterable 对象是 Generator 或实现了\n        <code>__iter__()</code> 方法的对象。</p>\n    <p><strong>object._<em>await</em>_(self)</strong></p>\n    <p>必须返回生成器，asyncio.Future 类也实现了该方法，用于兼容 await 表达式。</p>\n    <p>而 Task 继承自 Future，因此 awaitable 对象有三种：coroutines、Tasks 和 Futures。</p>\n    <p>await 的目的：</p>\n    <ul>\n        <li>获取协程的结果</li>\n        <li>挂起当前协程，将控制交由事件循环，切换到其他协程，然后等待结果，最后恢复协程继续执行</li>\n    </ul>\n    <h3 id=\"-3\">启动一个协程</h3>\n    <p>现在我们使用 async/await 语法来声明一个协程。 代码如下：</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n     print(<span class=\"hljs-string\">'hello'</span>)\n     <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">1</span>)\n     print(<span class=\"hljs-string\">'world'</span>)\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    asyncio.run(main())\n</code></pre>\n    <p>asyncio.run 只能用来启动程序入口协程，反过来你在程序中如果使用 asyncio.run 就会出错，之前我们提到对于其他的协程通过 await 链来实现，这里也是一样的。</p>\n    <p>下面说下代码的含义，首先启动 main 这个协程，main 方法就是先打印 hello，然后在打印过程中通过使用 asyncio.sleep 来等待 1 秒，之后再打印\n        world。前面我们提到用协程就意味着我们要一直使用非阻塞的代码，才能达到速度提升，所以这里我们用了非阻塞版的 time.sleep 即 asyncio.sleep 。</p>\n    <h3 id=\"-4\">协程中调用协程</h3>\n    <p>之前我们提到了在协程中，可以使用 await 来调用一个协程。</p>\n    <p>就像下面的代码:</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n<span class=\"hljs-keyword\">import</span> time\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">say_after</span><span class=\"hljs-params\">(delay, what)</span>:</span>\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(delay)\n    print(what)\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    <span class=\"hljs-comment\">#使用f-string拼接字符串</span>\n    print(<span class=\"hljs-string\">f\"开始运行 <span class=\"hljs-subst\">{time.strftime(<span class=\"hljs-string\">'%X'</span>)}</span>\"</span>)\n\n    child1=<span class=\"hljs-keyword\">await</span> say_after(<span class=\"hljs-number\">1</span>, <span\n                class=\"hljs-string\">'hello'</span>) <span class=\"hljs-comment\">#通过await调用协程，然后接收一下返回值</span>\n    child2=<span class=\"hljs-keyword\">await</span> say_after(<span class=\"hljs-number\">2</span>, <span\n                class=\"hljs-string\">'world'</span>)\n    print(<span class=\"hljs-string\">\"child1\"</span>,child1)\n    print(<span class=\"hljs-string\">\"child2\"</span>,child2)\n\n    print(<span class=\"hljs-string\">f\"结束运行 <span class=\"hljs-subst\">{time.strftime(<span class=\"hljs-string\">'%X'</span>)}</span>\"</span>)\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n      asyncio.run(main())\n</code></pre>\n    <p>运行结果：</p>\n    <pre><code class=\"hljs css\">开始运行 11<span class=\"hljs-selector-pseudo\">:17</span><span class=\"hljs-selector-pseudo\">:26</span>\n<span class=\"hljs-selector-tag\">hello</span>\n<span class=\"hljs-selector-tag\">world</span>\n<span class=\"hljs-selector-tag\">child1</span> <span class=\"hljs-selector-tag\">None</span>\n<span class=\"hljs-selector-tag\">child2</span> <span class=\"hljs-selector-tag\">None</span>\n结束运行 11<span class=\"hljs-selector-pseudo\">:17</span><span class=\"hljs-selector-pseudo\">:29</span>\n<span class=\"hljs-selector-attr\">[Finished in 3.1s]</span>\n</code></pre>\n    <p>代码是没什么问题,正常运行。但是一般情况下我们用到更多的是下面的方式。将协程封装为 Task 让原本没有状态标示的协程添加上状态 。</p>\n    <p>我们可以通过 asyncio.create_task 方法来实现。</p>\n    <h4 id=\"asynciocreate_task\">asyncio.create_task</h4>\n    <p><code>create_task</code>（在 3.6 版本中需要使用低层级的 API <code>asyncio.ensure_future</code>。）是\n        3.7以后加入的语法，作用是将协程包装为一个任务（Task），相比 3.6 版本的 <code>ensure_future</code> 可读性提高。</p>\n    <p>将上面的代码做如下修改：</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n<span class=\"hljs-keyword\">import</span> time\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">say_after</span><span class=\"hljs-params\">(delay, what)</span>:</span>\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(delay)\n    print(what)\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    print(<span class=\"hljs-string\">f\"开始运行 <span class=\"hljs-subst\">{time.strftime(<span class=\"hljs-string\">'%X'</span>)}</span>\"</span>)\n\n    child1=asyncio.create_task(say_after(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'hello'</span>)) <span\n                class=\"hljs-comment\">#通过await调用协程，然后接收一下返回值</span>\n    child2=asyncio.create_task(say_after(<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">'world'</span>))\n    print(<span class=\"hljs-string\">\"调用任务child1前\"</span>,child1)\n    print(<span class=\"hljs-string\">\"调用任务child2前\"</span>,child2)\n    <span class=\"hljs-keyword\">await</span> child1\n    <span class=\"hljs-keyword\">await</span> child2\n    print(<span class=\"hljs-string\">\"调用任务child1后\"</span>,child1)\n    print(<span class=\"hljs-string\">\"调用任务child2前\"</span>,child2)\n\n    print(<span class=\"hljs-string\">f\"结束运行 <span class=\"hljs-subst\">{time.strftime(<span class=\"hljs-string\">'%X'</span>)}</span>\"</span>)\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n      asyncio.run(main())\n</code></pre>\n    <p>运行结果如下:</p>\n    <pre><code class=\"hljs ruby\">开始运行 <span class=\"hljs-number\">11</span><span class=\"hljs-symbol\">:</span><span\n            class=\"hljs-number\">37</span><span class=\"hljs-symbol\">:</span><span class=\"hljs-number\">54</span>\n调用任务child1前 &lt;Task pending name=<span class=\"hljs-string\">'Task-2'</span> coro=&lt;say_after() running at /Users/chennan/Desktop/<span\n                class=\"hljs-number\">2019</span>/aiochatuse/hello.<span class=\"hljs-symbol\">py:</span><span\n                class=\"hljs-number\">4</span><span class=\"hljs-meta\">&gt;&gt;\n</span>调用任务child2前 &lt;Task pending name=<span class=\"hljs-string\">'Task-3'</span> coro=&lt;say_after() running at /Users/chennan/Desktop/<span\n                class=\"hljs-number\">2019</span>/aiochatuse/hello.<span class=\"hljs-symbol\">py:</span><span\n                class=\"hljs-number\">4</span>&gt;&gt;\nhello\nworld\n调用任务child1后 &lt;Task finished name=<span class=\"hljs-string\">'Task-2'</span> coro=&lt;say_after() done, <span\n                class=\"hljs-keyword\">defined</span> at /Users/chennan/Desktop/<span class=\"hljs-number\">2019</span>/aiochatuse/hello.<span\n                class=\"hljs-symbol\">py:</span><span class=\"hljs-number\">4</span>&gt; result=None&gt;\n调用任务child2前 &lt;Task finished name=<span class=\"hljs-string\">'Task-3'</span> coro=&lt;say_after() done, <span\n                class=\"hljs-keyword\">defined</span> at /Users/chennan/Desktop/<span class=\"hljs-number\">2019</span>/aiochatuse/hello.<span\n                class=\"hljs-symbol\">py:</span><span class=\"hljs-number\">4</span>&gt; result=None&gt;\n结束运行 <span class=\"hljs-number\">11</span><span class=\"hljs-symbol\">:</span><span class=\"hljs-number\">37</span><span\n                class=\"hljs-symbol\">:</span><span class=\"hljs-number\">56</span>\n</code></pre>\n    <p>可以发现，我们的结果中多了\"&lt;Task pending ...\"和\"&lt;Task finised ...\"几行语句。这就是 Task\n        的一个状态变化，知道状态的好处就是我们可以根据任务的状态做进一步操作，不像协程函数那样没有状态标示，当然 Task 的状态不只有这些。</p>\n    <p>前面说到 Task 是 Future 的子类，所以 Task 拥有 Future 的一些状态。</p>\n    <h4 id=\"future-1\">Future 的状态</h4>\n    <p>大概有如下几种:</p>\n    <ul>\n        <li>Pending</li>\n        <li>Running</li>\n        <li>Done</li>\n        <li>Cancelled</li>\n    </ul>\n    <p>创建 future 的时候，task 为 pending，事件循环调用执行的时候当然就是 running，调用完毕自然就是 done，如果需要停止事件循环，就需要先把 task 取消，状态为 cancel。这里先做了解知道\n        Task 是有状态的就够了。</p>\n    <h3 id=\"-5\">并发运行任务</h3>\n    <p>一系列的协程可以通过 await 链式的调用，但是有的时候我们需要在一个协程里等待多个协程，比如我们在一个协程里等待 1000 个异步网络请求，对于访问次序有没有要求的时候，就可以使用另外的关键字 asyncio.wait 或\n        asyncio.gather 来解决了。</p>\n    <h4 id=\"asynciogather\">asyncio.gather</h4>\n    <p>使用方法：</p>\n    <pre><code class=\"hljs python\">asyncio.gather(*aws, loop=<span\n            class=\"hljs-keyword\">None</span>, return_exceptions=<span class=\"hljs-keyword\">False</span>)¶\n</code></pre>\n    <p>也就是说使用 gather 语句并发协程，就得用 await 去执行它。这个方法可以接收三个参数，第一个 aws。</p>\n    <p>aws 一般是一个列表，如果里面的元素是 awaitable 类型，在运行的时候它将自动被包装成 Task，gather 会根据 aws 中元素添加的顺序。顺序执行并返回结果列表。</p>\n    <p>第二个 loop 可以传入一个事件循环对象，一般不用管，最后一个 <code>return_exceptions</code> 默认是 False，如果 return_exceptions 为\n        True，异常将被视为成功结果，然后添加到结果列表中。</p>\n    <p>下面是一个 10 个数字并输出的例子：</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">foo</span><span class=\"hljs-params\">(num)</span>:</span>\n    <span class=\"hljs-keyword\">return</span> num\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    coro = [asyncio.create_task(foo(i)) <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> range(<span\n                class=\"hljs-number\">10</span>) ]\n    done= <span class=\"hljs-keyword\">await</span> asyncio.gather(*coro)\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> done:\n        print(i)\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    asyncio.run(main())\n</code></pre>\n    <p>运行之后结果如下：</p>\n    <pre><code class=\"hljs\">0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n</code></pre>\n    <p>gather 返回的结果是一个列表，迭代这个列表可以看到任务依次输出。</p>\n    <p>gather 通常被用来阶段性的一个操作，做完第一步才能做第二步，比如下面这样：</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">import</span> time\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">step1</span><span class=\"hljs-params\">(n, start)</span>:</span>\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(n)\n    print(<span class=\"hljs-string\">\"第一阶段完成\"</span>)\n    print(<span class=\"hljs-string\">\"此时用时\"</span>, time.time() - start)\n    <span class=\"hljs-keyword\">return</span> n\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">step2</span><span class=\"hljs-params\">(n, start)</span>:</span>\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(n)\n    print(<span class=\"hljs-string\">\"第二阶段完成\"</span>)\n    print(<span class=\"hljs-string\">\"此时用时\"</span>, time.time() - start)\n    <span class=\"hljs-keyword\">return</span> n\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    now = time.time()\n    result = <span class=\"hljs-keyword\">await</span> asyncio.gather(step1(<span class=\"hljs-number\">5</span>, now), step2(<span\n                class=\"hljs-number\">2</span>, now))\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> result:\n        print(i)\n    print(<span class=\"hljs-string\">\"总用时\"</span>, time.time() - now)\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n   asyncio.run(main())\n</code></pre>\n    <p>输出内容：</p>\n    <pre><code class=\"hljs css\">第二阶段完成\n此时用时 2<span class=\"hljs-selector-class\">.0041821002960205</span>\n第一阶段完成\n此时用时 5<span class=\"hljs-selector-class\">.0009942054748535</span>\n5\n2\n总用时 5<span class=\"hljs-selector-class\">.001508951187134</span>\n</code></pre>\n    <p>可以通过上面结果得到如下结论：</p>\n    <ol>\n        <li>step1 和 step2 是并行运行的。</li>\n        <li>gather 会等待最耗时的那个完成之后才返回结果，耗时总时间取决于其中任务最长时间的那个。</li>\n    </ol>\n    <h4 id=\"asynciowait\">asyncio.wait</h4>\n    <p>我们先看一下 wait 的语法结构：</p>\n    <pre><code class=\"hljs python\">asyncio.wait(aws, *, loop=<span class=\"hljs-keyword\">None</span>, timeout=<span\n            class=\"hljs-keyword\">None</span>, return_when=ALL_COMPLETED)¶\n</code></pre>\n    <p>wait 一共有 4 个参数，第一个参数 aws，一般是一个任务列表。</p>\n    <p>第二个*之后的都是强制关键字参数，即 loop、timeout、return_when。</p>\n    <p>loop 通 gather 的参数是一个事件循环，该参数计划在 Python 3.10 中删除。</p>\n    <p>timeout 可以指定这组任务的超时时间，请注意，此函数不会引发 asyncio.TimeoutError，超时的时候会返回已完成的任务。</p>\n    <p>return_when 可以指定什么条件下返回结果，默认是所以任务完成就返回结果列表。</p>\n    <p>return_when 的具体参数看下面的表格：</p>\n    <table>\n        <thead>\n        <tr>\n            <th>参数名</th>\n            <th>含义</th>\n        </tr>\n        </thead>\n        <tbody>\n        <tr>\n            <td>FIRST_COMPLETED</td>\n            <td>任何一个 future 完成或取消时返回</td>\n        </tr>\n        <tr>\n            <td>FIRST_EXCEPTION</td>\n            <td>任何一个 future 出现错误将返回，如果没有出现异常等价于 ALL_COMPLETED</td>\n        </tr>\n        <tr>\n            <td>ALL_COMPLETED</td>\n            <td>当所有任务完成或者被取消时返回结果，默认值。</td>\n        </tr>\n        </tbody>\n    </table>\n    <p>wait 返回的结果是一个元组，第一部分是完成的任务，第二部分是准备中的任务。</p>\n    <pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">done</span>, pending = await asyncio.wait(aws)\n</code></pre>\n    <p>其中 done 表示完成的任务，可以通过迭代获取每个任务。</p>\n    <p>pending 表示的是还没执行的任务。</p>\n    <p>下面看一个例子来进一步了解：</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">foo</span><span class=\"hljs-params\">(num)</span>:</span>\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">0.99991</span>)\n    <span class=\"hljs-keyword\">return</span> num\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    <span class=\"hljs-comment\">#coro = foo()</span>\n    coro = [asyncio.create_task(foo(i)) <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> range(<span\n                class=\"hljs-number\">10</span>) ]\n    done, pending = <span class=\"hljs-keyword\">await</span> asyncio.wait(coro,timeout=<span class=\"hljs-number\">1</span>,return_when=<span\n                class=\"hljs-string\">\"ALL_COMPLETED\"</span>)\n\n    <span class=\"hljs-keyword\">for</span> coro <span class=\"hljs-keyword\">in</span> done:\n        print(coro.result())\n    print(<span class=\"hljs-string\">\"pending\"</span>,pending)\n    <span class=\"hljs-keyword\">for</span> item <span class=\"hljs-keyword\">in</span> pending:\n         print(item)\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    asyncio.run(main())\n</code></pre>\n    <p>运行结果如下:</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">0</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">4</span>\n<span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">7</span>\npending {&lt;Task pending name=<span class=\"hljs-string\">'Task-10'</span> coro=&lt;foo() running at /Users/chennan/Desktop/<span\n                class=\"hljs-number\">2019</span>/aiochatuse/waitdemo.py:<span class=\"hljs-number\">4</span>&gt; wait_for=&lt;Future finished result=<span\n                class=\"hljs-keyword\">None</span>&gt;&gt;, &lt;Task pending name=<span\n                class=\"hljs-string\">'Task-11'</span> coro=&lt;foo() running at /Users/chennan/Desktop/<span\n                class=\"hljs-number\">2019</span>/aiochatuse/waitdemo.py:<span class=\"hljs-number\">4</span>&gt; wait_for=&lt;Future finished result=<span\n                class=\"hljs-keyword\">None</span>&gt;&gt;}\n&lt;Task pending name=<span class=\"hljs-string\">'Task-10'</span> coro=&lt;foo() running at /Users/chennan/Desktop/<span\n                class=\"hljs-number\">2019</span>/aiochatuse/waitdemo.py:<span class=\"hljs-number\">4</span>&gt; wait_for=&lt;Future finished result=<span\n                class=\"hljs-keyword\">None</span>&gt;&gt;\n&lt;Task pending name=<span class=\"hljs-string\">'Task-11'</span> coro=&lt;foo() running at /Users/chennan/Desktop/<span\n                class=\"hljs-number\">2019</span>/aiochatuse/waitdemo.py:<span class=\"hljs-number\">4</span>&gt; wait_for=&lt;Future finished result=<span\n                class=\"hljs-keyword\">None</span>&gt;&gt;\n</code></pre>\n    <p>首先说代码，使用 wait 实现并发的程序是无序的，所以我们看到数字不是一次出现的，这个是和 gather 的不同之处。另外在返回的参数上也有差别，wait 返回两个参数 done 和 pending。</p>\n    <p>上面的代码指定了一个 timeout，因为任务没在指定时间完成，所以就导致只有完成的任务输出了结果，没有完成的部分可以看到它们的状态是 pending。</p>\n    <h4 id=\"-6\">总结</h4>\n    <p>最后我们总结一下 wait 和 gather 的相同之处和不同之处：</p>\n    <p>相同之处：都可以完成多个任务的并发操作。\n        不同之外：gather 适合按照顺序去做的任务，或者按照阶段去做的任务，返回的是结果列表，而 wait 不讲究任务的顺序，这个在做爬虫中经常使用到，然后 wait 可以返回 2 个结果，done 和 pending。</p>\n    <h3 id=\"-7\">任务完成时处理</h3>\n    <h4 id=\"asyncioas_completed\">asyncio.as_completed</h4>\n    <p><code>as_complete</code> 是一个生成器，会管理指定的一个任务列表，并生成他们的结果。每个协程结束运行时一次生成一个结果。与 wait 一样，<code>as_complete</code>\n        不能保证顺序，不过执行其他动作之前没有必要等待所有后台操作完成。</p>\n    <p>我们看下这个函数都有哪些参数：</p>\n    <pre><code class=\"hljs python\">asyncio.as_completed(aws, *, loop=<span\n            class=\"hljs-keyword\">None</span>, timeout=<span class=\"hljs-keyword\">None</span>)\n</code></pre>\n    <p>和前面的 wait 类似，第一个参数 awas，然后 loop，最后 timeout，需要注意的是 timeout 如果指定了，那么在指定时间没完成的话会抛出 asyncio.exceptions.TimeoutError\n        异常。</p>\n    <p>下面看一个例子:</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n<span class=\"hljs-keyword\">import</span> time\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">foo</span><span class=\"hljs-params\">(n)</span>:</span>\n    print(<span class=\"hljs-string\">f'等待<span class=\"hljs-subst\">{n}</span>秒'</span>)\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(n)\n    <span class=\"hljs-keyword\">return</span> n\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    coroutine1 = foo(<span class=\"hljs-number\">1</span>)\n    coroutine2 = foo(<span class=\"hljs-number\">2</span>)\n    coroutine3 = foo(<span class=\"hljs-number\">4</span>)\n\n    tasks = [asyncio.create_task(coroutine1),asyncio.create_task(coroutine2),asyncio.create_task(coroutine3)]\n    <span class=\"hljs-keyword\">for</span> task <span class=\"hljs-keyword\">in</span> asyncio.as_completed(tasks):\n        result = <span class=\"hljs-keyword\">await</span> task\n        print(<span class=\"hljs-string\">f'获取返回结果: <span class=\"hljs-subst\">{result}</span>'</span>)\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    now = <span class=\"hljs-keyword\">lambda</span> : time.time()\n    start = now()\n    asyncio.run(main())\n    print(now() - start)\n</code></pre>\n    <p>输出结果：</p>\n    <pre><code class=\"hljs makefile\">等待1秒\n等待2秒\n等待4秒\n<span class=\"hljs-section\">获取返回结果: 1</span>\n<span class=\"hljs-section\">获取返回结果: 2</span>\n<span class=\"hljs-section\">获取返回结果: 4</span>\n4.002715826034546\n</code></pre>\n    <p>可以看出整个执行过程总用时取决 等待时间最长的那个，即 4 秒。</p>\n    <p>接下来，对上面的代码稍作修改。</p>\n    <p>将</p>\n    <pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">for</span> task <span class=\"hljs-keyword\">in</span> asyncio.as_completed(tasks):\n</code></pre>\n    <p>改为</p>\n    <pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">for</span> task <span class=\"hljs-keyword\">in</span> asyncio.as_completed(tasks,timeout=2):\n</code></pre>\n    <p>其他地方不变，改完运行之后会看到上面提到的错误。</p>\n    <pre><code class=\"hljs sql\">等待1秒\n等待2秒\n等待4秒\n获取返回结果: 1\nTraceback (most recent <span class=\"hljs-keyword\">call</span> <span class=\"hljs-keyword\">last</span>):\n  <span class=\"hljs-keyword\">File</span> <span class=\"hljs-string\">\"/Users/chennan/Desktop/2019/aiochatuse/ascomplete.py\"</span>, line <span\n                class=\"hljs-number\">25</span>, <span class=\"hljs-keyword\">in</span> &lt;<span class=\"hljs-keyword\">module</span>&gt;\n    asyncio.run(<span class=\"hljs-keyword\">main</span>())\n  <span class=\"hljs-keyword\">File</span> <span class=\"hljs-string\">\"/Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/asyncio/runners.py\"</span>, line <span\n                class=\"hljs-number\">43</span>, <span class=\"hljs-keyword\">in</span> run\n    <span class=\"hljs-keyword\">return</span> loop.run_until_complete(<span class=\"hljs-keyword\">main</span>)\n  <span class=\"hljs-keyword\">File</span> <span class=\"hljs-string\">\"/Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/asyncio/base_events.py\"</span>, line <span\n                class=\"hljs-number\">589</span>, <span class=\"hljs-keyword\">in</span> run_until_complete\n    <span class=\"hljs-keyword\">return</span> future.result()\n  <span class=\"hljs-keyword\">File</span> <span class=\"hljs-string\">\"/Users/chennan/Desktop/2019/aiochatuse/ascomplete.py\"</span>, line <span\n                class=\"hljs-number\">18</span>, <span class=\"hljs-keyword\">in</span> <span\n                class=\"hljs-keyword\">main</span>\n    <span class=\"hljs-keyword\">result</span> = await task\n  <span class=\"hljs-keyword\">File</span> <span class=\"hljs-string\">\"/Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/asyncio/tasks.py\"</span>, line <span\n                class=\"hljs-number\">570</span>, <span class=\"hljs-keyword\">in</span> _wait_for_one\n    <span class=\"hljs-keyword\">raise</span> exceptions.TimeoutError\nasyncio.exceptions.TimeoutError\n</code></pre>\n    <h3 id=\"-8\">取消任务的时候保证其他协程运行完毕</h3>\n    <p>在取消任务的时候存在一个问题,首先先看一段代码：</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">coro</span><span class=\"hljs-params\">()</span>:</span>\n    print(<span class=\"hljs-string\">'开始休眠'</span>)\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">2</span>)\n    print(<span class=\"hljs-string\">'结束休眠'</span>)\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">cancel_it</span><span class=\"hljs-params\">(some_task)</span>:</span>\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">0.5</span>)\n    some_task.cancel()\n    print(<span class=\"hljs-string\">'取消some_task任务'</span>)\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    real_task = asyncio.create_task(coro())\n    <span class=\"hljs-keyword\">await</span> cancel_it(real_task)\n    <span class=\"hljs-keyword\">await</span> real_task\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    asyncio.run(main())\n</code></pre>\n    <p>运行之后你会看到如下结果：</p>\n    <pre><code class=\"hljs sql\">开始休眠\n取消some_task任务\nTraceback (most recent <span class=\"hljs-keyword\">call</span> <span class=\"hljs-keyword\">last</span>):\n  <span class=\"hljs-keyword\">File</span> <span class=\"hljs-string\">\"/Users/chennan/Desktop/2019/aiochatuse/shielddemo.py\"</span>, line <span\n                class=\"hljs-number\">24</span>, <span class=\"hljs-keyword\">in</span> &lt;<span class=\"hljs-keyword\">module</span>&gt;\n    asyncio.run(<span class=\"hljs-keyword\">main</span>())\n  <span class=\"hljs-keyword\">File</span> <span class=\"hljs-string\">\"/Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/asyncio/runners.py\"</span>, line <span\n                class=\"hljs-number\">43</span>, <span class=\"hljs-keyword\">in</span> run\n    <span class=\"hljs-keyword\">return</span> loop.run_until_complete(<span class=\"hljs-keyword\">main</span>)\n  <span class=\"hljs-keyword\">File</span> <span class=\"hljs-string\">\"/Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/asyncio/base_events.py\"</span>, line <span\n                class=\"hljs-number\">589</span>, <span class=\"hljs-keyword\">in</span> run_until_complete\n    <span class=\"hljs-keyword\">return</span> future.result()\nasyncio.exceptions.CancelledError\n</code></pre>\n    <p>下面说一下代码中的逻辑，在 main 协程中将 coro 协程封装为任务 <code>real_task</code>，然后 <code>cancel_it</code> 方法做了一个取消任务的逻辑 <code>some_task.cancel()</code>，并打印一句话。然后通过\n        await 去运行 <code>real_task</code> 方法，执行代码之后看到上面的结果。出现了 asyncio.exceptions.CancelledError 错误，同时看到 coro\n        只打印了一个开始休眠，后面的结束休眠没有打印。也就是说我们在取消一个任务的时候，里面对于的协程也被取消了。如果我们想在取消任务之后协程还能顺利执行完，就需要用到另外一个函数 shield。</p>\n    <h4 id=\"asyncioshield\">asyncio.shield</h4>\n    <p>该方法的作用是，在执行 cancel 取消一个 task 之后，task 里面的协程仍然可以执行结束，不会像上面的 coro 那样出现错误。</p>\n    <pre><code class=\"hljs coffeescript\">asyncio.shield(aw, *, <span class=\"hljs-keyword\">loop</span>=None)\n</code></pre>\n    <p>aw 表示需要传入一个 Task。</p>\n    <p>接下来我们就使用这个方法对上面的例子做一个修改。</p>\n    <p>从代码中体会它的作用。</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">coro</span><span class=\"hljs-params\">()</span>:</span>\n    print(<span class=\"hljs-string\">'开始休眠'</span>)\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">2</span>)\n    print(<span class=\"hljs-string\">'结束休眠'</span>)\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">cancel_it</span><span class=\"hljs-params\">(some_task)</span>:</span>\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">0.5</span>)\n    some_task.cancel()\n    print(<span class=\"hljs-string\">'取消some_task任务'</span>)\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    real_task = asyncio.create_task(coro())\n    shield = asyncio.shield(real_task)\n    <span class=\"hljs-keyword\">await</span> cancel_it(shield)\n    <span class=\"hljs-keyword\">await</span> real_task\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    asyncio.run(main())\n</code></pre>\n    <p>运行之后的结果：</p>\n    <pre><code class=\"hljs\">开始休眠\n取消some_task任务\n结束休眠\n</code></pre>\n    <p>可以看到尽管 some_task 任务被取消，但是 coro 仍然成功的打印了最好的“结束休眠”。通过上面的例子我想大家应该知道 shield 的作用了。 </p>\n    <h3 id=\"-9\">超时等待</h3>\n    <p>有时候需要等待一个任务完成之后再进行下一个，但是有的时候并不需要运行完就返回。</p>\n    <p>这个时候可以使用 wait_for。</p>\n    <h4 id=\"asynciowait_for\">asyncio.wait_for</h4>\n    <p>该方法的语法如下：</p>\n    <pre><code class=\"hljs coffeescript\">asyncio.wait_for(aw, timeout, *, <span class=\"hljs-keyword\">loop</span>=None)\n</code></pre>\n    <p>aw 是一个任务，timeout 可以指定超时时间。如果发生超时，它将取消该任务并引发 asyncio.TimeoutError，此时为了保证任务中协程完成可以使用上面说的 shield。</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">foo</span><span class=\"hljs-params\">()</span>:</span>\n     <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">1</span>)\n     print(<span class=\"hljs-string\">\"in foo\"</span>)\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">eternity</span><span class=\"hljs-params\">()</span>:</span>\n    <span class=\"hljs-comment\"># Sleep for one hour</span>\n    <span class=\"hljs-keyword\">await</span> foo()\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">3600</span>)\n    print(<span class=\"hljs-string\">'yay!'</span>)\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    <span class=\"hljs-comment\"># Wait for at most 1 second</span>\n    <span class=\"hljs-keyword\">try</span>:\n        <span class=\"hljs-keyword\">await</span> asyncio.wait_for(asyncio.shield(eternity()), timeout=<span\n                class=\"hljs-number\">1.0</span>)\n    <span class=\"hljs-keyword\">except</span> asyncio.TimeoutError:\n        print(<span class=\"hljs-string\">'timeout!'</span>)\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    asyncio.run(main())\n</code></pre>\n    <p>输出：</p>\n    <pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">in</span> foo\ntimeout!\n</code></pre>\n    <p>按照上面的经验可知道，如果我们把 asyncio.shield 去掉之后，“in foo” 就无法输出了。</p>\n    <h3 id=\"-10\">协程配合线程</h3>\n    <h4 id=\"asynciorun_coroutine_threadsafe\">asyncio.run<em>coroutine</em>threadsafe</h4>\n    <p>该方法的语法如下：</p>\n    <pre><code class=\"hljs coffeescript\">asyncio.run_coroutine_threadsafe(coro, <span class=\"hljs-keyword\">loop</span>)\n</code></pre>\n    <p>其实在协程中也可以使用多线程,有时候我们需要在主线程中启动一个子线程去做别的任务，这个时候我们就要用到下面的方法了，先上一个流畅的 Python 中的代码。</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> time\n<span class=\"hljs-keyword\">import</span> asyncio\n<span class=\"hljs-keyword\">from</span>  threading <span class=\"hljs-keyword\">import</span> Thread\n\nnow = <span class=\"hljs-keyword\">lambda</span>: time.time()\n\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">start_loop</span><span\n        class=\"hljs-params\">(loop)</span>:</span>\n    asyncio.set_event_loop(loop)\n    loop.run_forever()\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">do_some_work</span><span class=\"hljs-params\">(x)</span>:</span>\n    print(<span class=\"hljs-string\">f'Waiting <span class=\"hljs-subst\">{x}</span>'</span>)\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(x)\n    print(<span class=\"hljs-string\">f'Done after <span class=\"hljs-subst\">{x}</span>s'</span>)\n\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">more_work</span><span\n        class=\"hljs-params\">(x)</span>:</span>\n    print(<span class=\"hljs-string\">f'More work <span class=\"hljs-subst\">{x}</span>'</span>)\n    time.sleep(x)\n    print(<span class=\"hljs-string\">'Finished more work {x}'</span>)\n\n\nstart = now()\n<span class=\"hljs-comment\"># 主线程中创建一个 new_loop</span>\nnew_loop = asyncio.get_event_loop()\n<span class=\"hljs-comment\"># 创建子线程 在其中开启无限事件循环</span>\nt = Thread(target=start_loop, args=(new_loop,))\nt.start()\nprint(<span class=\"hljs-string\">f'TIME: <span class=\"hljs-subst\">{time.time() - start}</span>'</span>)\n\n<span class=\"hljs-comment\"># 在主线程中新注册协程对象</span>\n<span class=\"hljs-comment\"># 这样即可在子线程中进行事件循环的并发操作 同时主线程又不会被 block </span>\n<span class=\"hljs-comment\"># 一共执行的时间大概在 6 s 左右 </span>\nasyncio.run_coroutine_threadsafe(do_some_work(<span class=\"hljs-number\">6</span>), new_loop)\nasyncio.run_coroutine_threadsafe(do_some_work(<span class=\"hljs-number\">4</span>), new_loop)\n</code></pre>\n    <p>上述的例子，主线程中创建一个 <code>new_loop</code>，然后在另外的子线程中开启一个无限事件循环。主线程通过 <code>run_coroutine_threadsafe</code>\n        新注册协程对象。这样就能在子线程中进行事件循环的并发操作，同时主线程又不会被 block。一共执行的时间大概在 6s 左右。</p>\n    <h3 id=\"-11\">同步原语</h3>\n    <p>尽管 asyncio 应用通常作为单线程运行，不过仍被构建为并发应用。由于 I/O 以及其他外部事件的延迟和中断，每个协程或任务可能按一种不可预知的顺序执行。为了支持安全的并发执行，asyncio 包含了 threading\n        和 multiprocessing 模块中的一些底层原语的实现。</p>\n    <p>这里介绍两个经常用到的例子。</p>\n    <h4 id=\"queue\">队列（Queue）</h4>\n    <p>asyncio.Queue 为协程提供了一个先进先出的数据结构，这与线程的 queue.Queue 或进程的multiprocessing.Queue 很类似，下面先看一个简单的例子，它是一个非阻塞的队列。</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n<span class=\"hljs-keyword\">from</span> asyncio <span class=\"hljs-keyword\">import</span> Queue\n\nqueue=Queue()\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">start</span><span class=\"hljs-params\">()</span>:</span>\n        [queue.put_nowait(i) <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> range(<span\n                class=\"hljs-number\">1</span>, <span class=\"hljs-number\">10</span>)]\n        <span class=\"hljs-keyword\">await</span> asyncio.create_task(work()) <span\n                class=\"hljs-comment\">#put_nowait表示放入元素</span>\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">work</span><span class=\"hljs-params\">()</span>:</span>\n    <span class=\"hljs-keyword\">try</span>:\n        <span class=\"hljs-keyword\">while</span> <span class=\"hljs-keyword\">not</span> queue.empty():<span\n                class=\"hljs-comment\">#判断队列的元素是否为空</span>\n            num = queue.get_nowait()<span class=\"hljs-comment\">#获取元素</span>\n            print(<span class=\"hljs-string\">f\"获取数字:<span class=\"hljs-subst\">{num}</span>\"</span>)\n            queue.task_done()<span class=\"hljs-comment\">#告诉队列该任务处理完。</span>\n    <span class=\"hljs-keyword\">except</span> asyncio.CancelledError:\n        <span class=\"hljs-keyword\">pass</span>\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    asyncio.run(start())\n</code></pre>\n    <p>输出结果:</p>\n    <pre><code class=\"hljs css\">获取数字<span class=\"hljs-selector-pseudo\">:1</span>\n获取数字<span class=\"hljs-selector-pseudo\">:2</span>\n获取数字<span class=\"hljs-selector-pseudo\">:3</span>\n获取数字<span class=\"hljs-selector-pseudo\">:4</span>\n获取数字<span class=\"hljs-selector-pseudo\">:5</span>\n获取数字<span class=\"hljs-selector-pseudo\">:6</span>\n获取数字<span class=\"hljs-selector-pseudo\">:7</span>\n获取数字<span class=\"hljs-selector-pseudo\">:8</span>\n获取数字<span class=\"hljs-selector-pseudo\">:9</span>\n</code></pre>\n    <p>在做爬虫的时候对于 url 的处理，经常会用到队列的操作。另外一个要说的同步原语就是信号量。</p>\n    <h2 id=\"semaphore\">信号量（Semaphore）</h2>\n    <p>简单说下什么是信号量，我们用停车场和车进行比喻。一个停车场一共就 5 个车位，所以我们知道可以同时容纳最多 5 辆车，这五个车位就是信号量。</p>\n    <p>然后说信号量的行为，当有车离开停车场的时候外面的车就会进来补，比如有 2 辆车离开，那么就可以再进来 2 辆车，依次类推，上面这个过程就是描述了信号量这个东西。</p>\n    <p>下面我们看如何在程序中使用。</p>\n    <p>asyncio.Semaphore 模块就是一个维持并发量的模块，我们用它起到一个限流的效果。首先来一段代码：</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\nsem=asyncio.Semaphore(<span class=\"hljs-number\">3</span>) <span class=\"hljs-comment\">#信号量指定为3</span>\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">branch</span><span class=\"hljs-params\">(num)</span>:</span>\n    <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">with</span> sem:  <span class=\"hljs-comment\">#通过异步上下文关键子控制并发量</span>\n        print(<span class=\"hljs-string\">f\"获取当前数字:<span class=\"hljs-subst\">{num}</span>\"</span>)\n        <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">0.5</span>)\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n\n     tasks=[asyncio.create_task(branch(i)) <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> range(<span\n                class=\"hljs-number\">10</span>)] <span class=\"hljs-comment\">#将协程封装成任务共10个</span>\n     <span class=\"hljs-keyword\">await</span> asyncio.wait(tasks) <span class=\"hljs-comment\">#执行这些任务</span>\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    asyncio.run(main())\n</code></pre>\n    <p>执行之后你会发现：</p>\n    <pre><code class=\"hljs makefile\"><span class=\"hljs-section\">获取当前数字:0</span>\n<span class=\"hljs-section\">获取当前数字:1</span>\n<span class=\"hljs-section\">获取当前数字:2</span>\nTask exception was never retrieved\n<span class=\"hljs-section\">future: &lt;Task finished name='Task-11' coro=&lt;branch() done, defined at /Users/chennan/Desktop/2019/aiochatuse/semaphoredemo.py:26&gt; exception=RuntimeError(\"Task &lt;Task pending name='Task-11' coro=&lt;branch() running at /Users/chennan/Desktop/2019/aiochatuse/semaphoredemo.py:27&gt; cb=[_wait.&lt;locals&gt;._on_completion() at /Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/asyncio/tasks.py:478]&gt; got Future &lt;Future pending&gt; attached to a different loop\")&gt;</span>\n</code></pre>\n    <p>关键就是 attached to a different loop，这个地方说是当前的事件循环发生了改变，这个问题在Python3.6 的时候是不会出现的。</p>\n    <p>为什么 3.8 出错了？</p>\n    <p>这是因为：</p>\n    <p>我的信号量没有在循环内创建。也就是在 asyncio.run() 创建的循环之外创建了它们，因此它们使用 <code>events.get_event_loop()</code> 这就导致了新的事件循环产生。\n        asyncio.run() 创建一个新循环，然后在一个循环中创建的 future\n        不能在另一个循环中使用。所以问题就明确了，我们需要在循环之内创建。也就是我们需要定义一个全局变量，然后在主循环内部给其赋值。看到这，可能大家想到了 global，Python 3.7 增加了上下文变量 Context\n        Variables，至于为什么不用全局变量，因为可能会被其他协程修改，不安全，在这里也可以使用。</p>\n    <p>所以我们的代码变成了下面这个样子：</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n<span class=\"hljs-keyword\">from</span> contextvars <span class=\"hljs-keyword\">import</span> ContextVar\n\nconcurrent=ContextVar(<span class=\"hljs-string\">\"concurrent\"</span>)<span class=\"hljs-comment\">#定义全局上下文管理器</span>\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">branch</span><span class=\"hljs-params\">(num)</span>:</span>\n    sem=concurrent.get()<span class=\"hljs-comment\">#获取上下文关键字</span>\n    <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">with</span> sem:\n        print(<span class=\"hljs-string\">f\"获取当前数字:<span class=\"hljs-subst\">{num}</span>\"</span>)\n        <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">0.5</span>) <span\n                class=\"hljs-comment\">#为了看到明显的效果</span>\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span\n                class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n     concurrent.set(asyncio.Semaphore(<span class=\"hljs-number\">3</span>)) <span class=\"hljs-comment\">#上下文管理器赋值</span>\n     tasks=[asyncio.create_task(branch(i)) <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> range(<span\n                class=\"hljs-number\">10</span>)]\n     <span class=\"hljs-keyword\">await</span> asyncio.wait(tasks)\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    asyncio.run(main())\n</code></pre>\n    <p>然后我们再次输出：</p>\n    <pre><code class=\"hljs css\">获取当前数字<span class=\"hljs-selector-pseudo\">:0</span>\n获取当前数字<span class=\"hljs-selector-pseudo\">:1</span>\n获取当前数字<span class=\"hljs-selector-pseudo\">:2</span>\n获取当前数字<span class=\"hljs-selector-pseudo\">:3</span>\n获取当前数字<span class=\"hljs-selector-pseudo\">:4</span>\n获取当前数字<span class=\"hljs-selector-pseudo\">:5</span>\n获取当前数字<span class=\"hljs-selector-pseudo\">:6</span>\n获取当前数字<span class=\"hljs-selector-pseudo\">:7</span>\n获取当前数字<span class=\"hljs-selector-pseudo\">:8</span>\n获取当前数字<span class=\"hljs-selector-pseudo\">:9</span>\n</code></pre>\n    <p>可以看到程序每隔 3 组输出一次，这就达到了我们想要的效果了。</p>\n    </div>\n</body>\n</html>","slug":"gitchat/python_asyncio_guidelines","published":1,"date":"2019-05-31T05:47:40.753Z","updated":"2019-05-31T05:47:40.753Z","_id":"cjwd4a1mf0009sv72wktgt2bz","comments":1,"layout":"post","photos":[],"link":"","content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head><meta name=\"generator\" content=\"Hexo 3.8.0\">\n    <meta charset=\"UTF-8\">\n    <title>asyncio使用指南</title>\n</head>\n<body>\n<div id=\"article_content\" class=\"mazi-article-content dont-break-out\">\n    <h3 id>协程的演变</h3>\n    <p>其实早在 Python3.4 的时候就有协程,当时的协程是通过 @asyncio.coroutine 和 yeild from 实现的。在一些很老教程中你可能看到的是下面这种形式:</p>\n    <pre><code class=\"hljs coffeescript\"><span class=\"hljs-keyword\">import</span> asyncio\n\n@asyncio.coroutine\ndef print_hello():\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello world!\"</span>)\n    r = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-keyword\">from</span> asyncio.sleep(<span class=\"hljs-number\">1</span>)\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello again!\"</span>)\n\n<span class=\"hljs-comment\"># 创建并获取EventLoop:</span>\n<span class=\"hljs-keyword\">loop</span> = asyncio.get_event_loop()\n<span class=\"hljs-comment\"># 执行协程</span>\n<span class=\"hljs-keyword\">loop</span>.run_until_complete(print_hello())\n<span class=\"hljs-keyword\">loop</span>.close()\n</code></pre>\n    <p>因为现在几乎没有人这样写了，所以仅作为了解即可。</p>\n    <p>然后到了 Python3.5 引入了 async/await 语法糖，一直到现在Python3.8 都是用这种形式来表示协程，示例如下。</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">print_hello</span><span class=\"hljs-params\">()</span>:</span>\n     print(<span class=\"hljs-string\">\"Hello world!\"</span>)\n     <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">1</span>)\n     print(<span class=\"hljs-string\">\"Hello again!\"</span>)\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    loop = asyncio.get_event_loop()\n    <span class=\"hljs-keyword\">try</span>:\n        print(<span class=\"hljs-string\">\"开始运行协程\"</span>)\n        coro = print_hello()\n        print(<span class=\"hljs-string\">\"进入事件循环\"</span>)\n        loop.run_until_complete(coro)\n    <span class=\"hljs-keyword\">finally</span>:\n        print(<span class=\"hljs-string\">\"关闭事件循环\"</span>)\n        loop.close()\n</code></pre>\n    <p>这种是目前应用范围最广的，可以看到比之前的代码舒服了不少，不用再使用装饰器的形式了。</p>\n    <p>然后就到了 Python3.7 和 Python3.8，协程发生了很多细小的变化，但是最大的一个变化就是，启动协程的方法变简单了，一句就可以搞定，不用再像上面那样，创建循环然后再仍到事件循环去执行。使用 asyncio.run\n        这个顶级 API 就可以了。</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">print_hello</span><span class=\"hljs-params\">()</span>:</span>\n     print(<span class=\"hljs-string\">\"Hello world!\"</span>)\n     <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">1</span>)\n     print(<span class=\"hljs-string\">\"Hello again!\"</span>)\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n        print(<span class=\"hljs-string\">\"开始运行协程\"</span>)\n        asyncio.run(print_hello())\n        print(<span class=\"hljs-string\">\"进入事件循环\"</span>)\n</code></pre>\n    <p>怎么样是不是代码更少了，启动协程更简单了。所以这也正是我们使用 3.8 作为本教程的 Python 版，与时俱进嘛。</p>\n    <h3 id=\"asyncio\">asyncio 的组成部分</h3>\n    <p>根据目前的官方文档，总的来说分为了两部分：高层级 API 和低层级 API。</p>\n    <p>首先看高层级 API 也是接下来重点要讲的。</p>\n    <h4 id=\"api\">高层级 API</h4>\n    <ul>\n        <li>协程对象和 Tasks 对象</li>\n        <li>数据流</li>\n        <li>同步源语</li>\n        <li>子进程</li>\n        <li>队列</li>\n        <li>异常</li>\n    </ul>\n    <h4 id=\"api-1\">低层级 API</h4>\n    <ul>\n        <li>事件循环</li>\n        <li>Futures 对象</li>\n        <li>传输和协议</li>\n        <li>策略</li>\n        <li>平台支持</li>\n    </ul>\n    <p>上面列出了这么多的项目我们怎么去选择自己所需要的呢，总的来说对于刚入门的新手或者只是写一个自己用的程序一般都只会用到高级 API\n        的部分，这部分就属于开箱即用的那种，对于高级用户比如框架开发者，往往可以需要去适应各种需要，需要重新改写一些内部的结构，这个时候就需要用到低层级的 API，但是这两个层级呢只能是一个大概方向吧，主要是方便 API\n        的查看，下面呢我将围绕者高层级 API 和低层级 API 在日常实际工作中经常用到的内容做一些讲解。</p>\n    <h3 id=\"-1\">了解几个概念</h3>\n    <p>在学习 asyncio 之前需要知道这样的几个概念。</p>\n    <h4 id=\"-2\">事件循环</h4>\n    <p>事件循环是一种处理多并发量的有效方式，在维基百科中它被描述为「一种等待程序分配事件或消息的编程架构」，我们可以定义事件循环来简化使用轮询方法来监控事件，通俗的说法就是「当 A 发生时，执行\n        B」。所谓的事件，其实就是函数。事件循环，就是有一个队列，里面存放着一堆函数，从第一个函数开始执行，在函数执行的过程中，可能会有新的函数继续加入到这个队列中。一直到队列中所有的函数被执行完毕，并且再也不会有新的函数被添加到这个队列中，程序就结束了。</p>\n    <h4 id=\"future\">Future</h4>\n    <p>Future 是一个数据结构，表示还未完成的工作结果。事件循环可以监视 Future 对象是否完成。从而允许应用的一部分等待另一部分完成一些工作。</p>\n    <p>简单说，Future 就是一个类，用生成器实现了回调。</p>\n    <h4 id=\"task\">Task</h4>\n    <p>Task 是 Future 的一个子类，它知道如何包装和管理一个协程的执行。任务所需的资源可用时，事件循环会调度任务允许，并生成一个结果，从而可以由其他协程消费。一般操作最多的还是 Task。用 Task\n        来封装协程，给原本没有状态的协程增加一些状态。</p>\n    <h4 id=\"awaitableobjects\">awaitable objects（可等待对象）</h4>\n    <p>如果一个对象可以用在 wait 表达式中，那么它就是一个可等待的对象。在 asyncio 模块中会一直提到这个概念，其中协程函数，Task，Future 都是 awaitable 对象。</p>\n    <p>用于 await 表达式中的对象。可以是 coroutine 也可以是实现了 <code>__await__()</code> 方法的对象，参见 PEP 492。类比于 Iterable 对象是 Generator 或实现了\n        <code>__iter__()</code> 方法的对象。</p>\n    <p><strong>object._<em>await</em>_(self)</strong></p>\n    <p>必须返回生成器，asyncio.Future 类也实现了该方法，用于兼容 await 表达式。</p>\n    <p>而 Task 继承自 Future，因此 awaitable 对象有三种：coroutines、Tasks 和 Futures。</p>\n    <p>await 的目的：</p>\n    <ul>\n        <li>获取协程的结果</li>\n        <li>挂起当前协程，将控制交由事件循环，切换到其他协程，然后等待结果，最后恢复协程继续执行</li>\n    </ul>\n    <h3 id=\"-3\">启动一个协程</h3>\n    <p>现在我们使用 async/await 语法来声明一个协程。 代码如下：</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n     print(<span class=\"hljs-string\">'hello'</span>)\n     <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">1</span>)\n     print(<span class=\"hljs-string\">'world'</span>)\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    asyncio.run(main())\n</code></pre>\n    <p>asyncio.run 只能用来启动程序入口协程，反过来你在程序中如果使用 asyncio.run 就会出错，之前我们提到对于其他的协程通过 await 链来实现，这里也是一样的。</p>\n    <p>下面说下代码的含义，首先启动 main 这个协程，main 方法就是先打印 hello，然后在打印过程中通过使用 asyncio.sleep 来等待 1 秒，之后再打印\n        world。前面我们提到用协程就意味着我们要一直使用非阻塞的代码，才能达到速度提升，所以这里我们用了非阻塞版的 time.sleep 即 asyncio.sleep 。</p>\n    <h3 id=\"-4\">协程中调用协程</h3>\n    <p>之前我们提到了在协程中，可以使用 await 来调用一个协程。</p>\n    <p>就像下面的代码:</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n<span class=\"hljs-keyword\">import</span> time\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">say_after</span><span class=\"hljs-params\">(delay, what)</span>:</span>\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(delay)\n    print(what)\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    <span class=\"hljs-comment\">#使用f-string拼接字符串</span>\n    print(<span class=\"hljs-string\">f\"开始运行 <span class=\"hljs-subst\">{time.strftime(<span class=\"hljs-string\">'%X'</span>)}</span>\"</span>)\n\n    child1=<span class=\"hljs-keyword\">await</span> say_after(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'hello'</span>) <span class=\"hljs-comment\">#通过await调用协程，然后接收一下返回值</span>\n    child2=<span class=\"hljs-keyword\">await</span> say_after(<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">'world'</span>)\n    print(<span class=\"hljs-string\">\"child1\"</span>,child1)\n    print(<span class=\"hljs-string\">\"child2\"</span>,child2)\n\n    print(<span class=\"hljs-string\">f\"结束运行 <span class=\"hljs-subst\">{time.strftime(<span class=\"hljs-string\">'%X'</span>)}</span>\"</span>)\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n      asyncio.run(main())\n</code></pre>\n    <p>运行结果：</p>\n    <pre><code class=\"hljs css\">开始运行 11<span class=\"hljs-selector-pseudo\">:17</span><span class=\"hljs-selector-pseudo\">:26</span>\n<span class=\"hljs-selector-tag\">hello</span>\n<span class=\"hljs-selector-tag\">world</span>\n<span class=\"hljs-selector-tag\">child1</span> <span class=\"hljs-selector-tag\">None</span>\n<span class=\"hljs-selector-tag\">child2</span> <span class=\"hljs-selector-tag\">None</span>\n结束运行 11<span class=\"hljs-selector-pseudo\">:17</span><span class=\"hljs-selector-pseudo\">:29</span>\n<span class=\"hljs-selector-attr\">[Finished in 3.1s]</span>\n</code></pre>\n    <p>代码是没什么问题,正常运行。但是一般情况下我们用到更多的是下面的方式。将协程封装为 Task 让原本没有状态标示的协程添加上状态 。</p>\n    <p>我们可以通过 asyncio.create_task 方法来实现。</p>\n    <h4 id=\"asynciocreate_task\">asyncio.create_task</h4>\n    <p><code>create_task</code>（在 3.6 版本中需要使用低层级的 API <code>asyncio.ensure_future</code>。）是\n        3.7以后加入的语法，作用是将协程包装为一个任务（Task），相比 3.6 版本的 <code>ensure_future</code> 可读性提高。</p>\n    <p>将上面的代码做如下修改：</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n<span class=\"hljs-keyword\">import</span> time\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">say_after</span><span class=\"hljs-params\">(delay, what)</span>:</span>\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(delay)\n    print(what)\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    print(<span class=\"hljs-string\">f\"开始运行 <span class=\"hljs-subst\">{time.strftime(<span class=\"hljs-string\">'%X'</span>)}</span>\"</span>)\n\n    child1=asyncio.create_task(say_after(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'hello'</span>)) <span class=\"hljs-comment\">#通过await调用协程，然后接收一下返回值</span>\n    child2=asyncio.create_task(say_after(<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">'world'</span>))\n    print(<span class=\"hljs-string\">\"调用任务child1前\"</span>,child1)\n    print(<span class=\"hljs-string\">\"调用任务child2前\"</span>,child2)\n    <span class=\"hljs-keyword\">await</span> child1\n    <span class=\"hljs-keyword\">await</span> child2\n    print(<span class=\"hljs-string\">\"调用任务child1后\"</span>,child1)\n    print(<span class=\"hljs-string\">\"调用任务child2前\"</span>,child2)\n\n    print(<span class=\"hljs-string\">f\"结束运行 <span class=\"hljs-subst\">{time.strftime(<span class=\"hljs-string\">'%X'</span>)}</span>\"</span>)\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n      asyncio.run(main())\n</code></pre>\n    <p>运行结果如下:</p>\n    <pre><code class=\"hljs ruby\">开始运行 <span class=\"hljs-number\">11</span><span class=\"hljs-symbol\">:</span><span class=\"hljs-number\">37</span><span class=\"hljs-symbol\">:</span><span class=\"hljs-number\">54</span>\n调用任务child1前 &lt;Task pending name=<span class=\"hljs-string\">'Task-2'</span> coro=&lt;say_after() running at /Users/chennan/Desktop/<span class=\"hljs-number\">2019</span>/aiochatuse/hello.<span class=\"hljs-symbol\">py:</span><span class=\"hljs-number\">4</span><span class=\"hljs-meta\">&gt;&gt;\n</span>调用任务child2前 &lt;Task pending name=<span class=\"hljs-string\">'Task-3'</span> coro=&lt;say_after() running at /Users/chennan/Desktop/<span class=\"hljs-number\">2019</span>/aiochatuse/hello.<span class=\"hljs-symbol\">py:</span><span class=\"hljs-number\">4</span>&gt;&gt;\nhello\nworld\n调用任务child1后 &lt;Task finished name=<span class=\"hljs-string\">'Task-2'</span> coro=&lt;say_after() done, <span class=\"hljs-keyword\">defined</span> at /Users/chennan/Desktop/<span class=\"hljs-number\">2019</span>/aiochatuse/hello.<span class=\"hljs-symbol\">py:</span><span class=\"hljs-number\">4</span>&gt; result=None&gt;\n调用任务child2前 &lt;Task finished name=<span class=\"hljs-string\">'Task-3'</span> coro=&lt;say_after() done, <span class=\"hljs-keyword\">defined</span> at /Users/chennan/Desktop/<span class=\"hljs-number\">2019</span>/aiochatuse/hello.<span class=\"hljs-symbol\">py:</span><span class=\"hljs-number\">4</span>&gt; result=None&gt;\n结束运行 <span class=\"hljs-number\">11</span><span class=\"hljs-symbol\">:</span><span class=\"hljs-number\">37</span><span class=\"hljs-symbol\">:</span><span class=\"hljs-number\">56</span>\n</code></pre>\n    <p>可以发现，我们的结果中多了\"&lt;Task pending ...\"和\"&lt;Task finised ...\"几行语句。这就是 Task\n        的一个状态变化，知道状态的好处就是我们可以根据任务的状态做进一步操作，不像协程函数那样没有状态标示，当然 Task 的状态不只有这些。</p>\n    <p>前面说到 Task 是 Future 的子类，所以 Task 拥有 Future 的一些状态。</p>\n    <h4 id=\"future-1\">Future 的状态</h4>\n    <p>大概有如下几种:</p>\n    <ul>\n        <li>Pending</li>\n        <li>Running</li>\n        <li>Done</li>\n        <li>Cancelled</li>\n    </ul>\n    <p>创建 future 的时候，task 为 pending，事件循环调用执行的时候当然就是 running，调用完毕自然就是 done，如果需要停止事件循环，就需要先把 task 取消，状态为 cancel。这里先做了解知道\n        Task 是有状态的就够了。</p>\n    <h3 id=\"-5\">并发运行任务</h3>\n    <p>一系列的协程可以通过 await 链式的调用，但是有的时候我们需要在一个协程里等待多个协程，比如我们在一个协程里等待 1000 个异步网络请求，对于访问次序有没有要求的时候，就可以使用另外的关键字 asyncio.wait 或\n        asyncio.gather 来解决了。</p>\n    <h4 id=\"asynciogather\">asyncio.gather</h4>\n    <p>使用方法：</p>\n    <pre><code class=\"hljs python\">asyncio.gather(*aws, loop=<span class=\"hljs-keyword\">None</span>, return_exceptions=<span class=\"hljs-keyword\">False</span>)¶\n</code></pre>\n    <p>也就是说使用 gather 语句并发协程，就得用 await 去执行它。这个方法可以接收三个参数，第一个 aws。</p>\n    <p>aws 一般是一个列表，如果里面的元素是 awaitable 类型，在运行的时候它将自动被包装成 Task，gather 会根据 aws 中元素添加的顺序。顺序执行并返回结果列表。</p>\n    <p>第二个 loop 可以传入一个事件循环对象，一般不用管，最后一个 <code>return_exceptions</code> 默认是 False，如果 return_exceptions 为\n        True，异常将被视为成功结果，然后添加到结果列表中。</p>\n    <p>下面是一个 10 个数字并输出的例子：</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(num)</span>:</span>\n    <span class=\"hljs-keyword\">return</span> num\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    coro = [asyncio.create_task(foo(i)) <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> range(<span class=\"hljs-number\">10</span>) ]\n    done= <span class=\"hljs-keyword\">await</span> asyncio.gather(*coro)\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> done:\n        print(i)\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    asyncio.run(main())\n</code></pre>\n    <p>运行之后结果如下：</p>\n    <pre><code class=\"hljs\">0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n</code></pre>\n    <p>gather 返回的结果是一个列表，迭代这个列表可以看到任务依次输出。</p>\n    <p>gather 通常被用来阶段性的一个操作，做完第一步才能做第二步，比如下面这样：</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">import</span> time\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">step1</span><span class=\"hljs-params\">(n, start)</span>:</span>\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(n)\n    print(<span class=\"hljs-string\">\"第一阶段完成\"</span>)\n    print(<span class=\"hljs-string\">\"此时用时\"</span>, time.time() - start)\n    <span class=\"hljs-keyword\">return</span> n\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">step2</span><span class=\"hljs-params\">(n, start)</span>:</span>\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(n)\n    print(<span class=\"hljs-string\">\"第二阶段完成\"</span>)\n    print(<span class=\"hljs-string\">\"此时用时\"</span>, time.time() - start)\n    <span class=\"hljs-keyword\">return</span> n\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    now = time.time()\n    result = <span class=\"hljs-keyword\">await</span> asyncio.gather(step1(<span class=\"hljs-number\">5</span>, now), step2(<span class=\"hljs-number\">2</span>, now))\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> result:\n        print(i)\n    print(<span class=\"hljs-string\">\"总用时\"</span>, time.time() - now)\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n   asyncio.run(main())\n</code></pre>\n    <p>输出内容：</p>\n    <pre><code class=\"hljs css\">第二阶段完成\n此时用时 2<span class=\"hljs-selector-class\">.0041821002960205</span>\n第一阶段完成\n此时用时 5<span class=\"hljs-selector-class\">.0009942054748535</span>\n5\n2\n总用时 5<span class=\"hljs-selector-class\">.001508951187134</span>\n</code></pre>\n    <p>可以通过上面结果得到如下结论：</p>\n    <ol>\n        <li>step1 和 step2 是并行运行的。</li>\n        <li>gather 会等待最耗时的那个完成之后才返回结果，耗时总时间取决于其中任务最长时间的那个。</li>\n    </ol>\n    <h4 id=\"asynciowait\">asyncio.wait</h4>\n    <p>我们先看一下 wait 的语法结构：</p>\n    <pre><code class=\"hljs python\">asyncio.wait(aws, *, loop=<span class=\"hljs-keyword\">None</span>, timeout=<span class=\"hljs-keyword\">None</span>, return_when=ALL_COMPLETED)¶\n</code></pre>\n    <p>wait 一共有 4 个参数，第一个参数 aws，一般是一个任务列表。</p>\n    <p>第二个*之后的都是强制关键字参数，即 loop、timeout、return_when。</p>\n    <p>loop 通 gather 的参数是一个事件循环，该参数计划在 Python 3.10 中删除。</p>\n    <p>timeout 可以指定这组任务的超时时间，请注意，此函数不会引发 asyncio.TimeoutError，超时的时候会返回已完成的任务。</p>\n    <p>return_when 可以指定什么条件下返回结果，默认是所以任务完成就返回结果列表。</p>\n    <p>return_when 的具体参数看下面的表格：</p>\n    <table>\n        <thead>\n        <tr>\n            <th>参数名</th>\n            <th>含义</th>\n        </tr>\n        </thead>\n        <tbody>\n        <tr>\n            <td>FIRST_COMPLETED</td>\n            <td>任何一个 future 完成或取消时返回</td>\n        </tr>\n        <tr>\n            <td>FIRST_EXCEPTION</td>\n            <td>任何一个 future 出现错误将返回，如果没有出现异常等价于 ALL_COMPLETED</td>\n        </tr>\n        <tr>\n            <td>ALL_COMPLETED</td>\n            <td>当所有任务完成或者被取消时返回结果，默认值。</td>\n        </tr>\n        </tbody>\n    </table>\n    <p>wait 返回的结果是一个元组，第一部分是完成的任务，第二部分是准备中的任务。</p>\n    <pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">done</span>, pending = await asyncio.wait(aws)\n</code></pre>\n    <p>其中 done 表示完成的任务，可以通过迭代获取每个任务。</p>\n    <p>pending 表示的是还没执行的任务。</p>\n    <p>下面看一个例子来进一步了解：</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(num)</span>:</span>\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">0.99991</span>)\n    <span class=\"hljs-keyword\">return</span> num\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    <span class=\"hljs-comment\">#coro = foo()</span>\n    coro = [asyncio.create_task(foo(i)) <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> range(<span class=\"hljs-number\">10</span>) ]\n    done, pending = <span class=\"hljs-keyword\">await</span> asyncio.wait(coro,timeout=<span class=\"hljs-number\">1</span>,return_when=<span class=\"hljs-string\">\"ALL_COMPLETED\"</span>)\n\n    <span class=\"hljs-keyword\">for</span> coro <span class=\"hljs-keyword\">in</span> done:\n        print(coro.result())\n    print(<span class=\"hljs-string\">\"pending\"</span>,pending)\n    <span class=\"hljs-keyword\">for</span> item <span class=\"hljs-keyword\">in</span> pending:\n         print(item)\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    asyncio.run(main())\n</code></pre>\n    <p>运行结果如下:</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">0</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">4</span>\n<span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">7</span>\npending {&lt;Task pending name=<span class=\"hljs-string\">'Task-10'</span> coro=&lt;foo() running at /Users/chennan/Desktop/<span class=\"hljs-number\">2019</span>/aiochatuse/waitdemo.py:<span class=\"hljs-number\">4</span>&gt; wait_for=&lt;Future finished result=<span class=\"hljs-keyword\">None</span>&gt;&gt;, &lt;Task pending name=<span class=\"hljs-string\">'Task-11'</span> coro=&lt;foo() running at /Users/chennan/Desktop/<span class=\"hljs-number\">2019</span>/aiochatuse/waitdemo.py:<span class=\"hljs-number\">4</span>&gt; wait_for=&lt;Future finished result=<span class=\"hljs-keyword\">None</span>&gt;&gt;}\n&lt;Task pending name=<span class=\"hljs-string\">'Task-10'</span> coro=&lt;foo() running at /Users/chennan/Desktop/<span class=\"hljs-number\">2019</span>/aiochatuse/waitdemo.py:<span class=\"hljs-number\">4</span>&gt; wait_for=&lt;Future finished result=<span class=\"hljs-keyword\">None</span>&gt;&gt;\n&lt;Task pending name=<span class=\"hljs-string\">'Task-11'</span> coro=&lt;foo() running at /Users/chennan/Desktop/<span class=\"hljs-number\">2019</span>/aiochatuse/waitdemo.py:<span class=\"hljs-number\">4</span>&gt; wait_for=&lt;Future finished result=<span class=\"hljs-keyword\">None</span>&gt;&gt;\n</code></pre>\n    <p>首先说代码，使用 wait 实现并发的程序是无序的，所以我们看到数字不是一次出现的，这个是和 gather 的不同之处。另外在返回的参数上也有差别，wait 返回两个参数 done 和 pending。</p>\n    <p>上面的代码指定了一个 timeout，因为任务没在指定时间完成，所以就导致只有完成的任务输出了结果，没有完成的部分可以看到它们的状态是 pending。</p>\n    <h4 id=\"-6\">总结</h4>\n    <p>最后我们总结一下 wait 和 gather 的相同之处和不同之处：</p>\n    <p>相同之处：都可以完成多个任务的并发操作。\n        不同之外：gather 适合按照顺序去做的任务，或者按照阶段去做的任务，返回的是结果列表，而 wait 不讲究任务的顺序，这个在做爬虫中经常使用到，然后 wait 可以返回 2 个结果，done 和 pending。</p>\n    <h3 id=\"-7\">任务完成时处理</h3>\n    <h4 id=\"asyncioas_completed\">asyncio.as_completed</h4>\n    <p><code>as_complete</code> 是一个生成器，会管理指定的一个任务列表，并生成他们的结果。每个协程结束运行时一次生成一个结果。与 wait 一样，<code>as_complete</code>\n        不能保证顺序，不过执行其他动作之前没有必要等待所有后台操作完成。</p>\n    <p>我们看下这个函数都有哪些参数：</p>\n    <pre><code class=\"hljs python\">asyncio.as_completed(aws, *, loop=<span class=\"hljs-keyword\">None</span>, timeout=<span class=\"hljs-keyword\">None</span>)\n</code></pre>\n    <p>和前面的 wait 类似，第一个参数 awas，然后 loop，最后 timeout，需要注意的是 timeout 如果指定了，那么在指定时间没完成的话会抛出 asyncio.exceptions.TimeoutError\n        异常。</p>\n    <p>下面看一个例子:</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n<span class=\"hljs-keyword\">import</span> time\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(n)</span>:</span>\n    print(<span class=\"hljs-string\">f'等待<span class=\"hljs-subst\">{n}</span>秒'</span>)\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(n)\n    <span class=\"hljs-keyword\">return</span> n\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    coroutine1 = foo(<span class=\"hljs-number\">1</span>)\n    coroutine2 = foo(<span class=\"hljs-number\">2</span>)\n    coroutine3 = foo(<span class=\"hljs-number\">4</span>)\n\n    tasks = [asyncio.create_task(coroutine1),asyncio.create_task(coroutine2),asyncio.create_task(coroutine3)]\n    <span class=\"hljs-keyword\">for</span> task <span class=\"hljs-keyword\">in</span> asyncio.as_completed(tasks):\n        result = <span class=\"hljs-keyword\">await</span> task\n        print(<span class=\"hljs-string\">f'获取返回结果: <span class=\"hljs-subst\">{result}</span>'</span>)\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    now = <span class=\"hljs-keyword\">lambda</span> : time.time()\n    start = now()\n    asyncio.run(main())\n    print(now() - start)\n</code></pre>\n    <p>输出结果：</p>\n    <pre><code class=\"hljs makefile\">等待1秒\n等待2秒\n等待4秒\n<span class=\"hljs-section\">获取返回结果: 1</span>\n<span class=\"hljs-section\">获取返回结果: 2</span>\n<span class=\"hljs-section\">获取返回结果: 4</span>\n4.002715826034546\n</code></pre>\n    <p>可以看出整个执行过程总用时取决 等待时间最长的那个，即 4 秒。</p>\n    <p>接下来，对上面的代码稍作修改。</p>\n    <p>将</p>\n    <pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">for</span> task <span class=\"hljs-keyword\">in</span> asyncio.as_completed(tasks):\n</code></pre>\n    <p>改为</p>\n    <pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">for</span> task <span class=\"hljs-keyword\">in</span> asyncio.as_completed(tasks,timeout=2):\n</code></pre>\n    <p>其他地方不变，改完运行之后会看到上面提到的错误。</p>\n    <pre><code class=\"hljs sql\">等待1秒\n等待2秒\n等待4秒\n获取返回结果: 1\nTraceback (most recent <span class=\"hljs-keyword\">call</span> <span class=\"hljs-keyword\">last</span>):\n  <span class=\"hljs-keyword\">File</span> <span class=\"hljs-string\">\"/Users/chennan/Desktop/2019/aiochatuse/ascomplete.py\"</span>, line <span class=\"hljs-number\">25</span>, <span class=\"hljs-keyword\">in</span> &lt;<span class=\"hljs-keyword\">module</span>&gt;\n    asyncio.run(<span class=\"hljs-keyword\">main</span>())\n  <span class=\"hljs-keyword\">File</span> <span class=\"hljs-string\">\"/Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/asyncio/runners.py\"</span>, line <span class=\"hljs-number\">43</span>, <span class=\"hljs-keyword\">in</span> run\n    <span class=\"hljs-keyword\">return</span> loop.run_until_complete(<span class=\"hljs-keyword\">main</span>)\n  <span class=\"hljs-keyword\">File</span> <span class=\"hljs-string\">\"/Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/asyncio/base_events.py\"</span>, line <span class=\"hljs-number\">589</span>, <span class=\"hljs-keyword\">in</span> run_until_complete\n    <span class=\"hljs-keyword\">return</span> future.result()\n  <span class=\"hljs-keyword\">File</span> <span class=\"hljs-string\">\"/Users/chennan/Desktop/2019/aiochatuse/ascomplete.py\"</span>, line <span class=\"hljs-number\">18</span>, <span class=\"hljs-keyword\">in</span> <span class=\"hljs-keyword\">main</span>\n    <span class=\"hljs-keyword\">result</span> = await task\n  <span class=\"hljs-keyword\">File</span> <span class=\"hljs-string\">\"/Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/asyncio/tasks.py\"</span>, line <span class=\"hljs-number\">570</span>, <span class=\"hljs-keyword\">in</span> _wait_for_one\n    <span class=\"hljs-keyword\">raise</span> exceptions.TimeoutError\nasyncio.exceptions.TimeoutError\n</code></pre>\n    <h3 id=\"-8\">取消任务的时候保证其他协程运行完毕</h3>\n    <p>在取消任务的时候存在一个问题,首先先看一段代码：</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">coro</span><span class=\"hljs-params\">()</span>:</span>\n    print(<span class=\"hljs-string\">'开始休眠'</span>)\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">2</span>)\n    print(<span class=\"hljs-string\">'结束休眠'</span>)\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">cancel_it</span><span class=\"hljs-params\">(some_task)</span>:</span>\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">0.5</span>)\n    some_task.cancel()\n    print(<span class=\"hljs-string\">'取消some_task任务'</span>)\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    real_task = asyncio.create_task(coro())\n    <span class=\"hljs-keyword\">await</span> cancel_it(real_task)\n    <span class=\"hljs-keyword\">await</span> real_task\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    asyncio.run(main())\n</code></pre>\n    <p>运行之后你会看到如下结果：</p>\n    <pre><code class=\"hljs sql\">开始休眠\n取消some_task任务\nTraceback (most recent <span class=\"hljs-keyword\">call</span> <span class=\"hljs-keyword\">last</span>):\n  <span class=\"hljs-keyword\">File</span> <span class=\"hljs-string\">\"/Users/chennan/Desktop/2019/aiochatuse/shielddemo.py\"</span>, line <span class=\"hljs-number\">24</span>, <span class=\"hljs-keyword\">in</span> &lt;<span class=\"hljs-keyword\">module</span>&gt;\n    asyncio.run(<span class=\"hljs-keyword\">main</span>())\n  <span class=\"hljs-keyword\">File</span> <span class=\"hljs-string\">\"/Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/asyncio/runners.py\"</span>, line <span class=\"hljs-number\">43</span>, <span class=\"hljs-keyword\">in</span> run\n    <span class=\"hljs-keyword\">return</span> loop.run_until_complete(<span class=\"hljs-keyword\">main</span>)\n  <span class=\"hljs-keyword\">File</span> <span class=\"hljs-string\">\"/Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/asyncio/base_events.py\"</span>, line <span class=\"hljs-number\">589</span>, <span class=\"hljs-keyword\">in</span> run_until_complete\n    <span class=\"hljs-keyword\">return</span> future.result()\nasyncio.exceptions.CancelledError\n</code></pre>\n    <p>下面说一下代码中的逻辑，在 main 协程中将 coro 协程封装为任务 <code>real_task</code>，然后 <code>cancel_it</code> 方法做了一个取消任务的逻辑 <code>some_task.cancel()</code>，并打印一句话。然后通过\n        await 去运行 <code>real_task</code> 方法，执行代码之后看到上面的结果。出现了 asyncio.exceptions.CancelledError 错误，同时看到 coro\n        只打印了一个开始休眠，后面的结束休眠没有打印。也就是说我们在取消一个任务的时候，里面对于的协程也被取消了。如果我们想在取消任务之后协程还能顺利执行完，就需要用到另外一个函数 shield。</p>\n    <h4 id=\"asyncioshield\">asyncio.shield</h4>\n    <p>该方法的作用是，在执行 cancel 取消一个 task 之后，task 里面的协程仍然可以执行结束，不会像上面的 coro 那样出现错误。</p>\n    <pre><code class=\"hljs coffeescript\">asyncio.shield(aw, *, <span class=\"hljs-keyword\">loop</span>=None)\n</code></pre>\n    <p>aw 表示需要传入一个 Task。</p>\n    <p>接下来我们就使用这个方法对上面的例子做一个修改。</p>\n    <p>从代码中体会它的作用。</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">coro</span><span class=\"hljs-params\">()</span>:</span>\n    print(<span class=\"hljs-string\">'开始休眠'</span>)\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">2</span>)\n    print(<span class=\"hljs-string\">'结束休眠'</span>)\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">cancel_it</span><span class=\"hljs-params\">(some_task)</span>:</span>\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">0.5</span>)\n    some_task.cancel()\n    print(<span class=\"hljs-string\">'取消some_task任务'</span>)\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    real_task = asyncio.create_task(coro())\n    shield = asyncio.shield(real_task)\n    <span class=\"hljs-keyword\">await</span> cancel_it(shield)\n    <span class=\"hljs-keyword\">await</span> real_task\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    asyncio.run(main())\n</code></pre>\n    <p>运行之后的结果：</p>\n    <pre><code class=\"hljs\">开始休眠\n取消some_task任务\n结束休眠\n</code></pre>\n    <p>可以看到尽管 some_task 任务被取消，但是 coro 仍然成功的打印了最好的“结束休眠”。通过上面的例子我想大家应该知道 shield 的作用了。 </p>\n    <h3 id=\"-9\">超时等待</h3>\n    <p>有时候需要等待一个任务完成之后再进行下一个，但是有的时候并不需要运行完就返回。</p>\n    <p>这个时候可以使用 wait_for。</p>\n    <h4 id=\"asynciowait_for\">asyncio.wait_for</h4>\n    <p>该方法的语法如下：</p>\n    <pre><code class=\"hljs coffeescript\">asyncio.wait_for(aw, timeout, *, <span class=\"hljs-keyword\">loop</span>=None)\n</code></pre>\n    <p>aw 是一个任务，timeout 可以指定超时时间。如果发生超时，它将取消该任务并引发 asyncio.TimeoutError，此时为了保证任务中协程完成可以使用上面说的 shield。</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">()</span>:</span>\n     <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">1</span>)\n     print(<span class=\"hljs-string\">\"in foo\"</span>)\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">eternity</span><span class=\"hljs-params\">()</span>:</span>\n    <span class=\"hljs-comment\"># Sleep for one hour</span>\n    <span class=\"hljs-keyword\">await</span> foo()\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">3600</span>)\n    print(<span class=\"hljs-string\">'yay!'</span>)\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    <span class=\"hljs-comment\"># Wait for at most 1 second</span>\n    <span class=\"hljs-keyword\">try</span>:\n        <span class=\"hljs-keyword\">await</span> asyncio.wait_for(asyncio.shield(eternity()), timeout=<span class=\"hljs-number\">1.0</span>)\n    <span class=\"hljs-keyword\">except</span> asyncio.TimeoutError:\n        print(<span class=\"hljs-string\">'timeout!'</span>)\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    asyncio.run(main())\n</code></pre>\n    <p>输出：</p>\n    <pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">in</span> foo\ntimeout!\n</code></pre>\n    <p>按照上面的经验可知道，如果我们把 asyncio.shield 去掉之后，“in foo” 就无法输出了。</p>\n    <h3 id=\"-10\">协程配合线程</h3>\n    <h4 id=\"asynciorun_coroutine_threadsafe\">asyncio.run<em>coroutine</em>threadsafe</h4>\n    <p>该方法的语法如下：</p>\n    <pre><code class=\"hljs coffeescript\">asyncio.run_coroutine_threadsafe(coro, <span class=\"hljs-keyword\">loop</span>)\n</code></pre>\n    <p>其实在协程中也可以使用多线程,有时候我们需要在主线程中启动一个子线程去做别的任务，这个时候我们就要用到下面的方法了，先上一个流畅的 Python 中的代码。</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> time\n<span class=\"hljs-keyword\">import</span> asyncio\n<span class=\"hljs-keyword\">from</span>  threading <span class=\"hljs-keyword\">import</span> Thread\n\nnow = <span class=\"hljs-keyword\">lambda</span>: time.time()\n\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">start_loop</span><span class=\"hljs-params\">(loop)</span>:</span>\n    asyncio.set_event_loop(loop)\n    loop.run_forever()\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">do_some_work</span><span class=\"hljs-params\">(x)</span>:</span>\n    print(<span class=\"hljs-string\">f'Waiting <span class=\"hljs-subst\">{x}</span>'</span>)\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(x)\n    print(<span class=\"hljs-string\">f'Done after <span class=\"hljs-subst\">{x}</span>s'</span>)\n\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">more_work</span><span class=\"hljs-params\">(x)</span>:</span>\n    print(<span class=\"hljs-string\">f'More work <span class=\"hljs-subst\">{x}</span>'</span>)\n    time.sleep(x)\n    print(<span class=\"hljs-string\">'Finished more work {x}'</span>)\n\n\nstart = now()\n<span class=\"hljs-comment\"># 主线程中创建一个 new_loop</span>\nnew_loop = asyncio.get_event_loop()\n<span class=\"hljs-comment\"># 创建子线程 在其中开启无限事件循环</span>\nt = Thread(target=start_loop, args=(new_loop,))\nt.start()\nprint(<span class=\"hljs-string\">f'TIME: <span class=\"hljs-subst\">{time.time() - start}</span>'</span>)\n\n<span class=\"hljs-comment\"># 在主线程中新注册协程对象</span>\n<span class=\"hljs-comment\"># 这样即可在子线程中进行事件循环的并发操作 同时主线程又不会被 block </span>\n<span class=\"hljs-comment\"># 一共执行的时间大概在 6 s 左右 </span>\nasyncio.run_coroutine_threadsafe(do_some_work(<span class=\"hljs-number\">6</span>), new_loop)\nasyncio.run_coroutine_threadsafe(do_some_work(<span class=\"hljs-number\">4</span>), new_loop)\n</code></pre>\n    <p>上述的例子，主线程中创建一个 <code>new_loop</code>，然后在另外的子线程中开启一个无限事件循环。主线程通过 <code>run_coroutine_threadsafe</code>\n        新注册协程对象。这样就能在子线程中进行事件循环的并发操作，同时主线程又不会被 block。一共执行的时间大概在 6s 左右。</p>\n    <h3 id=\"-11\">同步原语</h3>\n    <p>尽管 asyncio 应用通常作为单线程运行，不过仍被构建为并发应用。由于 I/O 以及其他外部事件的延迟和中断，每个协程或任务可能按一种不可预知的顺序执行。为了支持安全的并发执行，asyncio 包含了 threading\n        和 multiprocessing 模块中的一些底层原语的实现。</p>\n    <p>这里介绍两个经常用到的例子。</p>\n    <h4 id=\"queue\">队列（Queue）</h4>\n    <p>asyncio.Queue 为协程提供了一个先进先出的数据结构，这与线程的 queue.Queue 或进程的multiprocessing.Queue 很类似，下面先看一个简单的例子，它是一个非阻塞的队列。</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n<span class=\"hljs-keyword\">from</span> asyncio <span class=\"hljs-keyword\">import</span> Queue\n\nqueue=Queue()\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">start</span><span class=\"hljs-params\">()</span>:</span>\n        [queue.put_nowait(i) <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> range(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">10</span>)]\n        <span class=\"hljs-keyword\">await</span> asyncio.create_task(work()) <span class=\"hljs-comment\">#put_nowait表示放入元素</span>\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">work</span><span class=\"hljs-params\">()</span>:</span>\n    <span class=\"hljs-keyword\">try</span>:\n        <span class=\"hljs-keyword\">while</span> <span class=\"hljs-keyword\">not</span> queue.empty():<span class=\"hljs-comment\">#判断队列的元素是否为空</span>\n            num = queue.get_nowait()<span class=\"hljs-comment\">#获取元素</span>\n            print(<span class=\"hljs-string\">f\"获取数字:<span class=\"hljs-subst\">{num}</span>\"</span>)\n            queue.task_done()<span class=\"hljs-comment\">#告诉队列该任务处理完。</span>\n    <span class=\"hljs-keyword\">except</span> asyncio.CancelledError:\n        <span class=\"hljs-keyword\">pass</span>\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    asyncio.run(start())\n</code></pre>\n    <p>输出结果:</p>\n    <pre><code class=\"hljs css\">获取数字<span class=\"hljs-selector-pseudo\">:1</span>\n获取数字<span class=\"hljs-selector-pseudo\">:2</span>\n获取数字<span class=\"hljs-selector-pseudo\">:3</span>\n获取数字<span class=\"hljs-selector-pseudo\">:4</span>\n获取数字<span class=\"hljs-selector-pseudo\">:5</span>\n获取数字<span class=\"hljs-selector-pseudo\">:6</span>\n获取数字<span class=\"hljs-selector-pseudo\">:7</span>\n获取数字<span class=\"hljs-selector-pseudo\">:8</span>\n获取数字<span class=\"hljs-selector-pseudo\">:9</span>\n</code></pre>\n    <p>在做爬虫的时候对于 url 的处理，经常会用到队列的操作。另外一个要说的同步原语就是信号量。</p>\n    <h2 id=\"semaphore\">信号量（Semaphore）</h2>\n    <p>简单说下什么是信号量，我们用停车场和车进行比喻。一个停车场一共就 5 个车位，所以我们知道可以同时容纳最多 5 辆车，这五个车位就是信号量。</p>\n    <p>然后说信号量的行为，当有车离开停车场的时候外面的车就会进来补，比如有 2 辆车离开，那么就可以再进来 2 辆车，依次类推，上面这个过程就是描述了信号量这个东西。</p>\n    <p>下面我们看如何在程序中使用。</p>\n    <p>asyncio.Semaphore 模块就是一个维持并发量的模块，我们用它起到一个限流的效果。首先来一段代码：</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\nsem=asyncio.Semaphore(<span class=\"hljs-number\">3</span>) <span class=\"hljs-comment\">#信号量指定为3</span>\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">branch</span><span class=\"hljs-params\">(num)</span>:</span>\n    <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">with</span> sem:  <span class=\"hljs-comment\">#通过异步上下文关键子控制并发量</span>\n        print(<span class=\"hljs-string\">f\"获取当前数字:<span class=\"hljs-subst\">{num}</span>\"</span>)\n        <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">0.5</span>)\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n\n     tasks=[asyncio.create_task(branch(i)) <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> range(<span class=\"hljs-number\">10</span>)] <span class=\"hljs-comment\">#将协程封装成任务共10个</span>\n     <span class=\"hljs-keyword\">await</span> asyncio.wait(tasks) <span class=\"hljs-comment\">#执行这些任务</span>\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    asyncio.run(main())\n</code></pre>\n    <p>执行之后你会发现：</p>\n    <pre><code class=\"hljs makefile\"><span class=\"hljs-section\">获取当前数字:0</span>\n<span class=\"hljs-section\">获取当前数字:1</span>\n<span class=\"hljs-section\">获取当前数字:2</span>\nTask exception was never retrieved\n<span class=\"hljs-section\">future: &lt;Task finished name='Task-11' coro=&lt;branch() done, defined at /Users/chennan/Desktop/2019/aiochatuse/semaphoredemo.py:26&gt; exception=RuntimeError(\"Task &lt;Task pending name='Task-11' coro=&lt;branch() running at /Users/chennan/Desktop/2019/aiochatuse/semaphoredemo.py:27&gt; cb=[_wait.&lt;locals&gt;._on_completion() at /Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/asyncio/tasks.py:478]&gt; got Future &lt;Future pending&gt; attached to a different loop\")&gt;</span>\n</code></pre>\n    <p>关键就是 attached to a different loop，这个地方说是当前的事件循环发生了改变，这个问题在Python3.6 的时候是不会出现的。</p>\n    <p>为什么 3.8 出错了？</p>\n    <p>这是因为：</p>\n    <p>我的信号量没有在循环内创建。也就是在 asyncio.run() 创建的循环之外创建了它们，因此它们使用 <code>events.get_event_loop()</code> 这就导致了新的事件循环产生。\n        asyncio.run() 创建一个新循环，然后在一个循环中创建的 future\n        不能在另一个循环中使用。所以问题就明确了，我们需要在循环之内创建。也就是我们需要定义一个全局变量，然后在主循环内部给其赋值。看到这，可能大家想到了 global，Python 3.7 增加了上下文变量 Context\n        Variables，至于为什么不用全局变量，因为可能会被其他协程修改，不安全，在这里也可以使用。</p>\n    <p>所以我们的代码变成了下面这个样子：</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n<span class=\"hljs-keyword\">from</span> contextvars <span class=\"hljs-keyword\">import</span> ContextVar\n\nconcurrent=ContextVar(<span class=\"hljs-string\">\"concurrent\"</span>)<span class=\"hljs-comment\">#定义全局上下文管理器</span>\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">branch</span><span class=\"hljs-params\">(num)</span>:</span>\n    sem=concurrent.get()<span class=\"hljs-comment\">#获取上下文关键字</span>\n    <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">with</span> sem:\n        print(<span class=\"hljs-string\">f\"获取当前数字:<span class=\"hljs-subst\">{num}</span>\"</span>)\n        <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">0.5</span>) <span class=\"hljs-comment\">#为了看到明显的效果</span>\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n     concurrent.set(asyncio.Semaphore(<span class=\"hljs-number\">3</span>)) <span class=\"hljs-comment\">#上下文管理器赋值</span>\n     tasks=[asyncio.create_task(branch(i)) <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> range(<span class=\"hljs-number\">10</span>)]\n     <span class=\"hljs-keyword\">await</span> asyncio.wait(tasks)\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    asyncio.run(main())\n</code></pre>\n    <p>然后我们再次输出：</p>\n    <pre><code class=\"hljs css\">获取当前数字<span class=\"hljs-selector-pseudo\">:0</span>\n获取当前数字<span class=\"hljs-selector-pseudo\">:1</span>\n获取当前数字<span class=\"hljs-selector-pseudo\">:2</span>\n获取当前数字<span class=\"hljs-selector-pseudo\">:3</span>\n获取当前数字<span class=\"hljs-selector-pseudo\">:4</span>\n获取当前数字<span class=\"hljs-selector-pseudo\">:5</span>\n获取当前数字<span class=\"hljs-selector-pseudo\">:6</span>\n获取当前数字<span class=\"hljs-selector-pseudo\">:7</span>\n获取当前数字<span class=\"hljs-selector-pseudo\">:8</span>\n获取当前数字<span class=\"hljs-selector-pseudo\">:9</span>\n</code></pre>\n    <p>可以看到程序每隔 3 组输出一次，这就达到了我们想要的效果了。</p>\n    </div>\n</body>\n</html>","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE html>\n<html lang=\"en\">\n<head><meta name=\"generator\" content=\"Hexo 3.8.0\">\n    <meta charset=\"UTF-8\">\n    <title>asyncio使用指南</title>\n</head>\n<body>\n<div id=\"article_content\" class=\"mazi-article-content dont-break-out\">\n    <h3 id>协程的演变</h3>\n    <p>其实早在 Python3.4 的时候就有协程,当时的协程是通过 @asyncio.coroutine 和 yeild from 实现的。在一些很老教程中你可能看到的是下面这种形式:</p>\n    <pre><code class=\"hljs coffeescript\"><span class=\"hljs-keyword\">import</span> asyncio\n\n@asyncio.coroutine\ndef print_hello():\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello world!\"</span>)\n    r = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-keyword\">from</span> asyncio.sleep(<span class=\"hljs-number\">1</span>)\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello again!\"</span>)\n\n<span class=\"hljs-comment\"># 创建并获取EventLoop:</span>\n<span class=\"hljs-keyword\">loop</span> = asyncio.get_event_loop()\n<span class=\"hljs-comment\"># 执行协程</span>\n<span class=\"hljs-keyword\">loop</span>.run_until_complete(print_hello())\n<span class=\"hljs-keyword\">loop</span>.close()\n</code></pre>\n    <p>因为现在几乎没有人这样写了，所以仅作为了解即可。</p>\n    <p>然后到了 Python3.5 引入了 async/await 语法糖，一直到现在Python3.8 都是用这种形式来表示协程，示例如下。</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">print_hello</span><span class=\"hljs-params\">()</span>:</span>\n     print(<span class=\"hljs-string\">\"Hello world!\"</span>)\n     <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">1</span>)\n     print(<span class=\"hljs-string\">\"Hello again!\"</span>)\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    loop = asyncio.get_event_loop()\n    <span class=\"hljs-keyword\">try</span>:\n        print(<span class=\"hljs-string\">\"开始运行协程\"</span>)\n        coro = print_hello()\n        print(<span class=\"hljs-string\">\"进入事件循环\"</span>)\n        loop.run_until_complete(coro)\n    <span class=\"hljs-keyword\">finally</span>:\n        print(<span class=\"hljs-string\">\"关闭事件循环\"</span>)\n        loop.close()\n</code></pre>\n    <p>这种是目前应用范围最广的，可以看到比之前的代码舒服了不少，不用再使用装饰器的形式了。</p>\n    <p>然后就到了 Python3.7 和 Python3.8，协程发生了很多细小的变化，但是最大的一个变化就是，启动协程的方法变简单了，一句就可以搞定，不用再像上面那样，创建循环然后再仍到事件循环去执行。使用 asyncio.run\n        这个顶级 API 就可以了。</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">print_hello</span><span class=\"hljs-params\">()</span>:</span>\n     print(<span class=\"hljs-string\">\"Hello world!\"</span>)\n     <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">1</span>)\n     print(<span class=\"hljs-string\">\"Hello again!\"</span>)\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n        print(<span class=\"hljs-string\">\"开始运行协程\"</span>)\n        asyncio.run(print_hello())\n        print(<span class=\"hljs-string\">\"进入事件循环\"</span>)\n</code></pre>\n    <p>怎么样是不是代码更少了，启动协程更简单了。所以这也正是我们使用 3.8 作为本教程的 Python 版，与时俱进嘛。</p>\n    <h3 id=\"asyncio\">asyncio 的组成部分</h3>\n    <p>根据目前的官方文档，总的来说分为了两部分：高层级 API 和低层级 API。</p>\n    <p>首先看高层级 API 也是接下来重点要讲的。</p>\n    <h4 id=\"api\">高层级 API</h4>\n    <ul>\n        <li>协程对象和 Tasks 对象</li>\n        <li>数据流</li>\n        <li>同步源语</li>\n        <li>子进程</li>\n        <li>队列</li>\n        <li>异常</li>\n    </ul>\n    <h4 id=\"api-1\">低层级 API</h4>\n    <ul>\n        <li>事件循环</li>\n        <li>Futures 对象</li>\n        <li>传输和协议</li>\n        <li>策略</li>\n        <li>平台支持</li>\n    </ul>\n    <p>上面列出了这么多的项目我们怎么去选择自己所需要的呢，总的来说对于刚入门的新手或者只是写一个自己用的程序一般都只会用到高级 API\n        的部分，这部分就属于开箱即用的那种，对于高级用户比如框架开发者，往往可以需要去适应各种需要，需要重新改写一些内部的结构，这个时候就需要用到低层级的 API，但是这两个层级呢只能是一个大概方向吧，主要是方便 API\n        的查看，下面呢我将围绕者高层级 API 和低层级 API 在日常实际工作中经常用到的内容做一些讲解。</p>\n    <h3 id=\"-1\">了解几个概念</h3>\n    <p>在学习 asyncio 之前需要知道这样的几个概念。</p>\n    <h4 id=\"-2\">事件循环</h4>\n    <p>事件循环是一种处理多并发量的有效方式，在维基百科中它被描述为「一种等待程序分配事件或消息的编程架构」，我们可以定义事件循环来简化使用轮询方法来监控事件，通俗的说法就是「当 A 发生时，执行\n        B」。所谓的事件，其实就是函数。事件循环，就是有一个队列，里面存放着一堆函数，从第一个函数开始执行，在函数执行的过程中，可能会有新的函数继续加入到这个队列中。一直到队列中所有的函数被执行完毕，并且再也不会有新的函数被添加到这个队列中，程序就结束了。</p>\n    <h4 id=\"future\">Future</h4>\n    <p>Future 是一个数据结构，表示还未完成的工作结果。事件循环可以监视 Future 对象是否完成。从而允许应用的一部分等待另一部分完成一些工作。</p>\n    <p>简单说，Future 就是一个类，用生成器实现了回调。</p>\n    <h4 id=\"task\">Task</h4>\n    <p>Task 是 Future 的一个子类，它知道如何包装和管理一个协程的执行。任务所需的资源可用时，事件循环会调度任务允许，并生成一个结果，从而可以由其他协程消费。一般操作最多的还是 Task。用 Task\n        来封装协程，给原本没有状态的协程增加一些状态。</p>\n    <h4 id=\"awaitableobjects\">awaitable objects（可等待对象）</h4>\n    <p>如果一个对象可以用在 wait 表达式中，那么它就是一个可等待的对象。在 asyncio 模块中会一直提到这个概念，其中协程函数，Task，Future 都是 awaitable 对象。</p>\n    <p>用于 await 表达式中的对象。可以是 coroutine 也可以是实现了 <code>__await__()</code> 方法的对象，参见 PEP 492。类比于 Iterable 对象是 Generator 或实现了\n        <code>__iter__()</code> 方法的对象。</p>\n    <p><strong>object._<em>await</em>_(self)</strong></p>\n    <p>必须返回生成器，asyncio.Future 类也实现了该方法，用于兼容 await 表达式。</p>\n    <p>而 Task 继承自 Future，因此 awaitable 对象有三种：coroutines、Tasks 和 Futures。</p>\n    <p>await 的目的：</p>\n    <ul>\n        <li>获取协程的结果</li>\n        <li>挂起当前协程，将控制交由事件循环，切换到其他协程，然后等待结果，最后恢复协程继续执行</li>\n    </ul>\n    <h3 id=\"-3\">启动一个协程</h3>\n    <p>现在我们使用 async/await 语法来声明一个协程。 代码如下：</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n     print(<span class=\"hljs-string\">'hello'</span>)\n     <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">1</span>)\n     print(<span class=\"hljs-string\">'world'</span>)\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    asyncio.run(main())\n</code></pre>\n    <p>asyncio.run 只能用来启动程序入口协程，反过来你在程序中如果使用 asyncio.run 就会出错，之前我们提到对于其他的协程通过 await 链来实现，这里也是一样的。</p>\n    <p>下面说下代码的含义，首先启动 main 这个协程，main 方法就是先打印 hello，然后在打印过程中通过使用 asyncio.sleep 来等待 1 秒，之后再打印\n        world。前面我们提到用协程就意味着我们要一直使用非阻塞的代码，才能达到速度提升，所以这里我们用了非阻塞版的 time.sleep 即 asyncio.sleep 。</p>\n    <h3 id=\"-4\">协程中调用协程</h3>\n    <p>之前我们提到了在协程中，可以使用 await 来调用一个协程。</p>\n    <p>就像下面的代码:</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n<span class=\"hljs-keyword\">import</span> time\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">say_after</span><span class=\"hljs-params\">(delay, what)</span>:</span>\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(delay)\n    print(what)\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    <span class=\"hljs-comment\">#使用f-string拼接字符串</span>\n    print(<span class=\"hljs-string\">f\"开始运行 <span class=\"hljs-subst\">{time.strftime(<span class=\"hljs-string\">'%X'</span>)}</span>\"</span>)\n\n    child1=<span class=\"hljs-keyword\">await</span> say_after(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'hello'</span>) <span class=\"hljs-comment\">#通过await调用协程，然后接收一下返回值</span>\n    child2=<span class=\"hljs-keyword\">await</span> say_after(<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">'world'</span>)\n    print(<span class=\"hljs-string\">\"child1\"</span>,child1)\n    print(<span class=\"hljs-string\">\"child2\"</span>,child2)\n\n    print(<span class=\"hljs-string\">f\"结束运行 <span class=\"hljs-subst\">{time.strftime(<span class=\"hljs-string\">'%X'</span>)}</span>\"</span>)\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n      asyncio.run(main())\n</code></pre>\n    <p>运行结果：</p>\n    <pre><code class=\"hljs css\">开始运行 11<span class=\"hljs-selector-pseudo\">:17</span><span class=\"hljs-selector-pseudo\">:26</span>\n<span class=\"hljs-selector-tag\">hello</span>\n<span class=\"hljs-selector-tag\">world</span>\n<span class=\"hljs-selector-tag\">child1</span> <span class=\"hljs-selector-tag\">None</span>\n<span class=\"hljs-selector-tag\">child2</span> <span class=\"hljs-selector-tag\">None</span>\n结束运行 11<span class=\"hljs-selector-pseudo\">:17</span><span class=\"hljs-selector-pseudo\">:29</span>\n<span class=\"hljs-selector-attr\">[Finished in 3.1s]</span>\n</code></pre>\n    <p>代码是没什么问题,正常运行。但是一般情况下我们用到更多的是下面的方式。将协程封装为 Task 让原本没有状态标示的协程添加上状态 。</p>\n    <p>我们可以通过 asyncio.create_task 方法来实现。</p>\n    <h4 id=\"asynciocreate_task\">asyncio.create_task</h4>\n    <p><code>create_task</code>（在 3.6 版本中需要使用低层级的 API <code>asyncio.ensure_future</code>。）是\n        3.7以后加入的语法，作用是将协程包装为一个任务（Task），相比 3.6 版本的 <code>ensure_future</code> 可读性提高。</p>\n    <p>将上面的代码做如下修改：</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n<span class=\"hljs-keyword\">import</span> time\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">say_after</span><span class=\"hljs-params\">(delay, what)</span>:</span>\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(delay)\n    print(what)\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    print(<span class=\"hljs-string\">f\"开始运行 <span class=\"hljs-subst\">{time.strftime(<span class=\"hljs-string\">'%X'</span>)}</span>\"</span>)\n\n    child1=asyncio.create_task(say_after(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'hello'</span>)) <span class=\"hljs-comment\">#通过await调用协程，然后接收一下返回值</span>\n    child2=asyncio.create_task(say_after(<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">'world'</span>))\n    print(<span class=\"hljs-string\">\"调用任务child1前\"</span>,child1)\n    print(<span class=\"hljs-string\">\"调用任务child2前\"</span>,child2)\n    <span class=\"hljs-keyword\">await</span> child1\n    <span class=\"hljs-keyword\">await</span> child2\n    print(<span class=\"hljs-string\">\"调用任务child1后\"</span>,child1)\n    print(<span class=\"hljs-string\">\"调用任务child2前\"</span>,child2)\n\n    print(<span class=\"hljs-string\">f\"结束运行 <span class=\"hljs-subst\">{time.strftime(<span class=\"hljs-string\">'%X'</span>)}</span>\"</span>)\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n      asyncio.run(main())\n</code></pre>\n    <p>运行结果如下:</p>\n    <pre><code class=\"hljs ruby\">开始运行 <span class=\"hljs-number\">11</span><span class=\"hljs-symbol\">:</span><span class=\"hljs-number\">37</span><span class=\"hljs-symbol\">:</span><span class=\"hljs-number\">54</span>\n调用任务child1前 &lt;Task pending name=<span class=\"hljs-string\">'Task-2'</span> coro=&lt;say_after() running at /Users/chennan/Desktop/<span class=\"hljs-number\">2019</span>/aiochatuse/hello.<span class=\"hljs-symbol\">py:</span><span class=\"hljs-number\">4</span><span class=\"hljs-meta\">&gt;&gt;\n</span>调用任务child2前 &lt;Task pending name=<span class=\"hljs-string\">'Task-3'</span> coro=&lt;say_after() running at /Users/chennan/Desktop/<span class=\"hljs-number\">2019</span>/aiochatuse/hello.<span class=\"hljs-symbol\">py:</span><span class=\"hljs-number\">4</span>&gt;&gt;\nhello\nworld\n调用任务child1后 &lt;Task finished name=<span class=\"hljs-string\">'Task-2'</span> coro=&lt;say_after() done, <span class=\"hljs-keyword\">defined</span> at /Users/chennan/Desktop/<span class=\"hljs-number\">2019</span>/aiochatuse/hello.<span class=\"hljs-symbol\">py:</span><span class=\"hljs-number\">4</span>&gt; result=None&gt;\n调用任务child2前 &lt;Task finished name=<span class=\"hljs-string\">'Task-3'</span> coro=&lt;say_after() done, <span class=\"hljs-keyword\">defined</span> at /Users/chennan/Desktop/<span class=\"hljs-number\">2019</span>/aiochatuse/hello.<span class=\"hljs-symbol\">py:</span><span class=\"hljs-number\">4</span>&gt; result=None&gt;\n结束运行 <span class=\"hljs-number\">11</span><span class=\"hljs-symbol\">:</span><span class=\"hljs-number\">37</span><span class=\"hljs-symbol\">:</span><span class=\"hljs-number\">56</span>\n</code></pre>\n    <p>可以发现，我们的结果中多了\"&lt;Task pending ...\"和\"&lt;Task finised ...\"几行语句。这就是 Task\n        的一个状态变化，知道状态的好处就是我们可以根据任务的状态做进一步操作，不像协程函数那样没有状态标示，当然 Task 的状态不只有这些。</p>\n    <p>前面说到 Task 是 Future 的子类，所以 Task 拥有 Future 的一些状态。</p>\n    <h4 id=\"future-1\">Future 的状态</h4>\n    <p>大概有如下几种:</p>\n    <ul>\n        <li>Pending</li>\n        <li>Running</li>\n        <li>Done</li>\n        <li>Cancelled</li>\n    </ul>\n    <p>创建 future 的时候，task 为 pending，事件循环调用执行的时候当然就是 running，调用完毕自然就是 done，如果需要停止事件循环，就需要先把 task 取消，状态为 cancel。这里先做了解知道\n        Task 是有状态的就够了。</p>\n    <h3 id=\"-5\">并发运行任务</h3>\n    <p>一系列的协程可以通过 await 链式的调用，但是有的时候我们需要在一个协程里等待多个协程，比如我们在一个协程里等待 1000 个异步网络请求，对于访问次序有没有要求的时候，就可以使用另外的关键字 asyncio.wait 或\n        asyncio.gather 来解决了。</p>\n    <h4 id=\"asynciogather\">asyncio.gather</h4>\n    <p>使用方法：</p>\n    <pre><code class=\"hljs python\">asyncio.gather(*aws, loop=<span class=\"hljs-keyword\">None</span>, return_exceptions=<span class=\"hljs-keyword\">False</span>)¶\n</code></pre>\n    <p>也就是说使用 gather 语句并发协程，就得用 await 去执行它。这个方法可以接收三个参数，第一个 aws。</p>\n    <p>aws 一般是一个列表，如果里面的元素是 awaitable 类型，在运行的时候它将自动被包装成 Task，gather 会根据 aws 中元素添加的顺序。顺序执行并返回结果列表。</p>\n    <p>第二个 loop 可以传入一个事件循环对象，一般不用管，最后一个 <code>return_exceptions</code> 默认是 False，如果 return_exceptions 为\n        True，异常将被视为成功结果，然后添加到结果列表中。</p>\n    <p>下面是一个 10 个数字并输出的例子：</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(num)</span>:</span>\n    <span class=\"hljs-keyword\">return</span> num\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    coro = [asyncio.create_task(foo(i)) <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> range(<span class=\"hljs-number\">10</span>) ]\n    done= <span class=\"hljs-keyword\">await</span> asyncio.gather(*coro)\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> done:\n        print(i)\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    asyncio.run(main())\n</code></pre>\n    <p>运行之后结果如下：</p>\n    <pre><code class=\"hljs\">0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n</code></pre>\n    <p>gather 返回的结果是一个列表，迭代这个列表可以看到任务依次输出。</p>\n    <p>gather 通常被用来阶段性的一个操作，做完第一步才能做第二步，比如下面这样：</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">import</span> time\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">step1</span><span class=\"hljs-params\">(n, start)</span>:</span>\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(n)\n    print(<span class=\"hljs-string\">\"第一阶段完成\"</span>)\n    print(<span class=\"hljs-string\">\"此时用时\"</span>, time.time() - start)\n    <span class=\"hljs-keyword\">return</span> n\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">step2</span><span class=\"hljs-params\">(n, start)</span>:</span>\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(n)\n    print(<span class=\"hljs-string\">\"第二阶段完成\"</span>)\n    print(<span class=\"hljs-string\">\"此时用时\"</span>, time.time() - start)\n    <span class=\"hljs-keyword\">return</span> n\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    now = time.time()\n    result = <span class=\"hljs-keyword\">await</span> asyncio.gather(step1(<span class=\"hljs-number\">5</span>, now), step2(<span class=\"hljs-number\">2</span>, now))\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> result:\n        print(i)\n    print(<span class=\"hljs-string\">\"总用时\"</span>, time.time() - now)\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n   asyncio.run(main())\n</code></pre>\n    <p>输出内容：</p>\n    <pre><code class=\"hljs css\">第二阶段完成\n此时用时 2<span class=\"hljs-selector-class\">.0041821002960205</span>\n第一阶段完成\n此时用时 5<span class=\"hljs-selector-class\">.0009942054748535</span>\n5\n2\n总用时 5<span class=\"hljs-selector-class\">.001508951187134</span>\n</code></pre>\n    <p>可以通过上面结果得到如下结论：</p>\n    <ol>\n        <li>step1 和 step2 是并行运行的。</li>\n        <li>gather 会等待最耗时的那个完成之后才返回结果，耗时总时间取决于其中任务最长时间的那个。</li>\n    </ol>\n    <h4 id=\"asynciowait\">asyncio.wait</h4>\n    <p>我们先看一下 wait 的语法结构：</p>\n    <pre><code class=\"hljs python\">asyncio.wait(aws, *, loop=<span class=\"hljs-keyword\">None</span>, timeout=<span class=\"hljs-keyword\">None</span>, return_when=ALL_COMPLETED)¶\n</code></pre>\n    <p>wait 一共有 4 个参数，第一个参数 aws，一般是一个任务列表。</p>\n    <p>第二个*之后的都是强制关键字参数，即 loop、timeout、return_when。</p>\n    <p>loop 通 gather 的参数是一个事件循环，该参数计划在 Python 3.10 中删除。</p>\n    <p>timeout 可以指定这组任务的超时时间，请注意，此函数不会引发 asyncio.TimeoutError，超时的时候会返回已完成的任务。</p>\n    <p>return_when 可以指定什么条件下返回结果，默认是所以任务完成就返回结果列表。</p>\n    <p>return_when 的具体参数看下面的表格：</p>\n    <table>\n        <thead>\n        <tr>\n            <th>参数名</th>\n            <th>含义</th>\n        </tr>\n        </thead>\n        <tbody>\n        <tr>\n            <td>FIRST_COMPLETED</td>\n            <td>任何一个 future 完成或取消时返回</td>\n        </tr>\n        <tr>\n            <td>FIRST_EXCEPTION</td>\n            <td>任何一个 future 出现错误将返回，如果没有出现异常等价于 ALL_COMPLETED</td>\n        </tr>\n        <tr>\n            <td>ALL_COMPLETED</td>\n            <td>当所有任务完成或者被取消时返回结果，默认值。</td>\n        </tr>\n        </tbody>\n    </table>\n    <p>wait 返回的结果是一个元组，第一部分是完成的任务，第二部分是准备中的任务。</p>\n    <pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">done</span>, pending = await asyncio.wait(aws)\n</code></pre>\n    <p>其中 done 表示完成的任务，可以通过迭代获取每个任务。</p>\n    <p>pending 表示的是还没执行的任务。</p>\n    <p>下面看一个例子来进一步了解：</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(num)</span>:</span>\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">0.99991</span>)\n    <span class=\"hljs-keyword\">return</span> num\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    <span class=\"hljs-comment\">#coro = foo()</span>\n    coro = [asyncio.create_task(foo(i)) <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> range(<span class=\"hljs-number\">10</span>) ]\n    done, pending = <span class=\"hljs-keyword\">await</span> asyncio.wait(coro,timeout=<span class=\"hljs-number\">1</span>,return_when=<span class=\"hljs-string\">\"ALL_COMPLETED\"</span>)\n\n    <span class=\"hljs-keyword\">for</span> coro <span class=\"hljs-keyword\">in</span> done:\n        print(coro.result())\n    print(<span class=\"hljs-string\">\"pending\"</span>,pending)\n    <span class=\"hljs-keyword\">for</span> item <span class=\"hljs-keyword\">in</span> pending:\n         print(item)\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    asyncio.run(main())\n</code></pre>\n    <p>运行结果如下:</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">0</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">4</span>\n<span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">7</span>\npending {&lt;Task pending name=<span class=\"hljs-string\">'Task-10'</span> coro=&lt;foo() running at /Users/chennan/Desktop/<span class=\"hljs-number\">2019</span>/aiochatuse/waitdemo.py:<span class=\"hljs-number\">4</span>&gt; wait_for=&lt;Future finished result=<span class=\"hljs-keyword\">None</span>&gt;&gt;, &lt;Task pending name=<span class=\"hljs-string\">'Task-11'</span> coro=&lt;foo() running at /Users/chennan/Desktop/<span class=\"hljs-number\">2019</span>/aiochatuse/waitdemo.py:<span class=\"hljs-number\">4</span>&gt; wait_for=&lt;Future finished result=<span class=\"hljs-keyword\">None</span>&gt;&gt;}\n&lt;Task pending name=<span class=\"hljs-string\">'Task-10'</span> coro=&lt;foo() running at /Users/chennan/Desktop/<span class=\"hljs-number\">2019</span>/aiochatuse/waitdemo.py:<span class=\"hljs-number\">4</span>&gt; wait_for=&lt;Future finished result=<span class=\"hljs-keyword\">None</span>&gt;&gt;\n&lt;Task pending name=<span class=\"hljs-string\">'Task-11'</span> coro=&lt;foo() running at /Users/chennan/Desktop/<span class=\"hljs-number\">2019</span>/aiochatuse/waitdemo.py:<span class=\"hljs-number\">4</span>&gt; wait_for=&lt;Future finished result=<span class=\"hljs-keyword\">None</span>&gt;&gt;\n</code></pre>\n    <p>首先说代码，使用 wait 实现并发的程序是无序的，所以我们看到数字不是一次出现的，这个是和 gather 的不同之处。另外在返回的参数上也有差别，wait 返回两个参数 done 和 pending。</p>\n    <p>上面的代码指定了一个 timeout，因为任务没在指定时间完成，所以就导致只有完成的任务输出了结果，没有完成的部分可以看到它们的状态是 pending。</p>\n    <h4 id=\"-6\">总结</h4>\n    <p>最后我们总结一下 wait 和 gather 的相同之处和不同之处：</p>\n    <p>相同之处：都可以完成多个任务的并发操作。\n        不同之外：gather 适合按照顺序去做的任务，或者按照阶段去做的任务，返回的是结果列表，而 wait 不讲究任务的顺序，这个在做爬虫中经常使用到，然后 wait 可以返回 2 个结果，done 和 pending。</p>\n    <h3 id=\"-7\">任务完成时处理</h3>\n    <h4 id=\"asyncioas_completed\">asyncio.as_completed</h4>\n    <p><code>as_complete</code> 是一个生成器，会管理指定的一个任务列表，并生成他们的结果。每个协程结束运行时一次生成一个结果。与 wait 一样，<code>as_complete</code>\n        不能保证顺序，不过执行其他动作之前没有必要等待所有后台操作完成。</p>\n    <p>我们看下这个函数都有哪些参数：</p>\n    <pre><code class=\"hljs python\">asyncio.as_completed(aws, *, loop=<span class=\"hljs-keyword\">None</span>, timeout=<span class=\"hljs-keyword\">None</span>)\n</code></pre>\n    <p>和前面的 wait 类似，第一个参数 awas，然后 loop，最后 timeout，需要注意的是 timeout 如果指定了，那么在指定时间没完成的话会抛出 asyncio.exceptions.TimeoutError\n        异常。</p>\n    <p>下面看一个例子:</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n<span class=\"hljs-keyword\">import</span> time\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(n)</span>:</span>\n    print(<span class=\"hljs-string\">f'等待<span class=\"hljs-subst\">{n}</span>秒'</span>)\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(n)\n    <span class=\"hljs-keyword\">return</span> n\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    coroutine1 = foo(<span class=\"hljs-number\">1</span>)\n    coroutine2 = foo(<span class=\"hljs-number\">2</span>)\n    coroutine3 = foo(<span class=\"hljs-number\">4</span>)\n\n    tasks = [asyncio.create_task(coroutine1),asyncio.create_task(coroutine2),asyncio.create_task(coroutine3)]\n    <span class=\"hljs-keyword\">for</span> task <span class=\"hljs-keyword\">in</span> asyncio.as_completed(tasks):\n        result = <span class=\"hljs-keyword\">await</span> task\n        print(<span class=\"hljs-string\">f'获取返回结果: <span class=\"hljs-subst\">{result}</span>'</span>)\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    now = <span class=\"hljs-keyword\">lambda</span> : time.time()\n    start = now()\n    asyncio.run(main())\n    print(now() - start)\n</code></pre>\n    <p>输出结果：</p>\n    <pre><code class=\"hljs makefile\">等待1秒\n等待2秒\n等待4秒\n<span class=\"hljs-section\">获取返回结果: 1</span>\n<span class=\"hljs-section\">获取返回结果: 2</span>\n<span class=\"hljs-section\">获取返回结果: 4</span>\n4.002715826034546\n</code></pre>\n    <p>可以看出整个执行过程总用时取决 等待时间最长的那个，即 4 秒。</p>\n    <p>接下来，对上面的代码稍作修改。</p>\n    <p>将</p>\n    <pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">for</span> task <span class=\"hljs-keyword\">in</span> asyncio.as_completed(tasks):\n</code></pre>\n    <p>改为</p>\n    <pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">for</span> task <span class=\"hljs-keyword\">in</span> asyncio.as_completed(tasks,timeout=2):\n</code></pre>\n    <p>其他地方不变，改完运行之后会看到上面提到的错误。</p>\n    <pre><code class=\"hljs sql\">等待1秒\n等待2秒\n等待4秒\n获取返回结果: 1\nTraceback (most recent <span class=\"hljs-keyword\">call</span> <span class=\"hljs-keyword\">last</span>):\n  <span class=\"hljs-keyword\">File</span> <span class=\"hljs-string\">\"/Users/chennan/Desktop/2019/aiochatuse/ascomplete.py\"</span>, line <span class=\"hljs-number\">25</span>, <span class=\"hljs-keyword\">in</span> &lt;<span class=\"hljs-keyword\">module</span>&gt;\n    asyncio.run(<span class=\"hljs-keyword\">main</span>())\n  <span class=\"hljs-keyword\">File</span> <span class=\"hljs-string\">\"/Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/asyncio/runners.py\"</span>, line <span class=\"hljs-number\">43</span>, <span class=\"hljs-keyword\">in</span> run\n    <span class=\"hljs-keyword\">return</span> loop.run_until_complete(<span class=\"hljs-keyword\">main</span>)\n  <span class=\"hljs-keyword\">File</span> <span class=\"hljs-string\">\"/Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/asyncio/base_events.py\"</span>, line <span class=\"hljs-number\">589</span>, <span class=\"hljs-keyword\">in</span> run_until_complete\n    <span class=\"hljs-keyword\">return</span> future.result()\n  <span class=\"hljs-keyword\">File</span> <span class=\"hljs-string\">\"/Users/chennan/Desktop/2019/aiochatuse/ascomplete.py\"</span>, line <span class=\"hljs-number\">18</span>, <span class=\"hljs-keyword\">in</span> <span class=\"hljs-keyword\">main</span>\n    <span class=\"hljs-keyword\">result</span> = await task\n  <span class=\"hljs-keyword\">File</span> <span class=\"hljs-string\">\"/Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/asyncio/tasks.py\"</span>, line <span class=\"hljs-number\">570</span>, <span class=\"hljs-keyword\">in</span> _wait_for_one\n    <span class=\"hljs-keyword\">raise</span> exceptions.TimeoutError\nasyncio.exceptions.TimeoutError\n</code></pre>\n    <h3 id=\"-8\">取消任务的时候保证其他协程运行完毕</h3>\n    <p>在取消任务的时候存在一个问题,首先先看一段代码：</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">coro</span><span class=\"hljs-params\">()</span>:</span>\n    print(<span class=\"hljs-string\">'开始休眠'</span>)\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">2</span>)\n    print(<span class=\"hljs-string\">'结束休眠'</span>)\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">cancel_it</span><span class=\"hljs-params\">(some_task)</span>:</span>\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">0.5</span>)\n    some_task.cancel()\n    print(<span class=\"hljs-string\">'取消some_task任务'</span>)\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    real_task = asyncio.create_task(coro())\n    <span class=\"hljs-keyword\">await</span> cancel_it(real_task)\n    <span class=\"hljs-keyword\">await</span> real_task\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    asyncio.run(main())\n</code></pre>\n    <p>运行之后你会看到如下结果：</p>\n    <pre><code class=\"hljs sql\">开始休眠\n取消some_task任务\nTraceback (most recent <span class=\"hljs-keyword\">call</span> <span class=\"hljs-keyword\">last</span>):\n  <span class=\"hljs-keyword\">File</span> <span class=\"hljs-string\">\"/Users/chennan/Desktop/2019/aiochatuse/shielddemo.py\"</span>, line <span class=\"hljs-number\">24</span>, <span class=\"hljs-keyword\">in</span> &lt;<span class=\"hljs-keyword\">module</span>&gt;\n    asyncio.run(<span class=\"hljs-keyword\">main</span>())\n  <span class=\"hljs-keyword\">File</span> <span class=\"hljs-string\">\"/Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/asyncio/runners.py\"</span>, line <span class=\"hljs-number\">43</span>, <span class=\"hljs-keyword\">in</span> run\n    <span class=\"hljs-keyword\">return</span> loop.run_until_complete(<span class=\"hljs-keyword\">main</span>)\n  <span class=\"hljs-keyword\">File</span> <span class=\"hljs-string\">\"/Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/asyncio/base_events.py\"</span>, line <span class=\"hljs-number\">589</span>, <span class=\"hljs-keyword\">in</span> run_until_complete\n    <span class=\"hljs-keyword\">return</span> future.result()\nasyncio.exceptions.CancelledError\n</code></pre>\n    <p>下面说一下代码中的逻辑，在 main 协程中将 coro 协程封装为任务 <code>real_task</code>，然后 <code>cancel_it</code> 方法做了一个取消任务的逻辑 <code>some_task.cancel()</code>，并打印一句话。然后通过\n        await 去运行 <code>real_task</code> 方法，执行代码之后看到上面的结果。出现了 asyncio.exceptions.CancelledError 错误，同时看到 coro\n        只打印了一个开始休眠，后面的结束休眠没有打印。也就是说我们在取消一个任务的时候，里面对于的协程也被取消了。如果我们想在取消任务之后协程还能顺利执行完，就需要用到另外一个函数 shield。</p>\n    <h4 id=\"asyncioshield\">asyncio.shield</h4>\n    <p>该方法的作用是，在执行 cancel 取消一个 task 之后，task 里面的协程仍然可以执行结束，不会像上面的 coro 那样出现错误。</p>\n    <pre><code class=\"hljs coffeescript\">asyncio.shield(aw, *, <span class=\"hljs-keyword\">loop</span>=None)\n</code></pre>\n    <p>aw 表示需要传入一个 Task。</p>\n    <p>接下来我们就使用这个方法对上面的例子做一个修改。</p>\n    <p>从代码中体会它的作用。</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">coro</span><span class=\"hljs-params\">()</span>:</span>\n    print(<span class=\"hljs-string\">'开始休眠'</span>)\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">2</span>)\n    print(<span class=\"hljs-string\">'结束休眠'</span>)\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">cancel_it</span><span class=\"hljs-params\">(some_task)</span>:</span>\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">0.5</span>)\n    some_task.cancel()\n    print(<span class=\"hljs-string\">'取消some_task任务'</span>)\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    real_task = asyncio.create_task(coro())\n    shield = asyncio.shield(real_task)\n    <span class=\"hljs-keyword\">await</span> cancel_it(shield)\n    <span class=\"hljs-keyword\">await</span> real_task\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    asyncio.run(main())\n</code></pre>\n    <p>运行之后的结果：</p>\n    <pre><code class=\"hljs\">开始休眠\n取消some_task任务\n结束休眠\n</code></pre>\n    <p>可以看到尽管 some_task 任务被取消，但是 coro 仍然成功的打印了最好的“结束休眠”。通过上面的例子我想大家应该知道 shield 的作用了。 </p>\n    <h3 id=\"-9\">超时等待</h3>\n    <p>有时候需要等待一个任务完成之后再进行下一个，但是有的时候并不需要运行完就返回。</p>\n    <p>这个时候可以使用 wait_for。</p>\n    <h4 id=\"asynciowait_for\">asyncio.wait_for</h4>\n    <p>该方法的语法如下：</p>\n    <pre><code class=\"hljs coffeescript\">asyncio.wait_for(aw, timeout, *, <span class=\"hljs-keyword\">loop</span>=None)\n</code></pre>\n    <p>aw 是一个任务，timeout 可以指定超时时间。如果发生超时，它将取消该任务并引发 asyncio.TimeoutError，此时为了保证任务中协程完成可以使用上面说的 shield。</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">()</span>:</span>\n     <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">1</span>)\n     print(<span class=\"hljs-string\">\"in foo\"</span>)\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">eternity</span><span class=\"hljs-params\">()</span>:</span>\n    <span class=\"hljs-comment\"># Sleep for one hour</span>\n    <span class=\"hljs-keyword\">await</span> foo()\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">3600</span>)\n    print(<span class=\"hljs-string\">'yay!'</span>)\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n    <span class=\"hljs-comment\"># Wait for at most 1 second</span>\n    <span class=\"hljs-keyword\">try</span>:\n        <span class=\"hljs-keyword\">await</span> asyncio.wait_for(asyncio.shield(eternity()), timeout=<span class=\"hljs-number\">1.0</span>)\n    <span class=\"hljs-keyword\">except</span> asyncio.TimeoutError:\n        print(<span class=\"hljs-string\">'timeout!'</span>)\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    asyncio.run(main())\n</code></pre>\n    <p>输出：</p>\n    <pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">in</span> foo\ntimeout!\n</code></pre>\n    <p>按照上面的经验可知道，如果我们把 asyncio.shield 去掉之后，“in foo” 就无法输出了。</p>\n    <h3 id=\"-10\">协程配合线程</h3>\n    <h4 id=\"asynciorun_coroutine_threadsafe\">asyncio.run<em>coroutine</em>threadsafe</h4>\n    <p>该方法的语法如下：</p>\n    <pre><code class=\"hljs coffeescript\">asyncio.run_coroutine_threadsafe(coro, <span class=\"hljs-keyword\">loop</span>)\n</code></pre>\n    <p>其实在协程中也可以使用多线程,有时候我们需要在主线程中启动一个子线程去做别的任务，这个时候我们就要用到下面的方法了，先上一个流畅的 Python 中的代码。</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> time\n<span class=\"hljs-keyword\">import</span> asyncio\n<span class=\"hljs-keyword\">from</span>  threading <span class=\"hljs-keyword\">import</span> Thread\n\nnow = <span class=\"hljs-keyword\">lambda</span>: time.time()\n\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">start_loop</span><span class=\"hljs-params\">(loop)</span>:</span>\n    asyncio.set_event_loop(loop)\n    loop.run_forever()\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">do_some_work</span><span class=\"hljs-params\">(x)</span>:</span>\n    print(<span class=\"hljs-string\">f'Waiting <span class=\"hljs-subst\">{x}</span>'</span>)\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(x)\n    print(<span class=\"hljs-string\">f'Done after <span class=\"hljs-subst\">{x}</span>s'</span>)\n\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">more_work</span><span class=\"hljs-params\">(x)</span>:</span>\n    print(<span class=\"hljs-string\">f'More work <span class=\"hljs-subst\">{x}</span>'</span>)\n    time.sleep(x)\n    print(<span class=\"hljs-string\">'Finished more work {x}'</span>)\n\n\nstart = now()\n<span class=\"hljs-comment\"># 主线程中创建一个 new_loop</span>\nnew_loop = asyncio.get_event_loop()\n<span class=\"hljs-comment\"># 创建子线程 在其中开启无限事件循环</span>\nt = Thread(target=start_loop, args=(new_loop,))\nt.start()\nprint(<span class=\"hljs-string\">f'TIME: <span class=\"hljs-subst\">{time.time() - start}</span>'</span>)\n\n<span class=\"hljs-comment\"># 在主线程中新注册协程对象</span>\n<span class=\"hljs-comment\"># 这样即可在子线程中进行事件循环的并发操作 同时主线程又不会被 block </span>\n<span class=\"hljs-comment\"># 一共执行的时间大概在 6 s 左右 </span>\nasyncio.run_coroutine_threadsafe(do_some_work(<span class=\"hljs-number\">6</span>), new_loop)\nasyncio.run_coroutine_threadsafe(do_some_work(<span class=\"hljs-number\">4</span>), new_loop)\n</code></pre>\n    <p>上述的例子，主线程中创建一个 <code>new_loop</code>，然后在另外的子线程中开启一个无限事件循环。主线程通过 <code>run_coroutine_threadsafe</code>\n        新注册协程对象。这样就能在子线程中进行事件循环的并发操作，同时主线程又不会被 block。一共执行的时间大概在 6s 左右。</p>\n    <h3 id=\"-11\">同步原语</h3>\n    <p>尽管 asyncio 应用通常作为单线程运行，不过仍被构建为并发应用。由于 I/O 以及其他外部事件的延迟和中断，每个协程或任务可能按一种不可预知的顺序执行。为了支持安全的并发执行，asyncio 包含了 threading\n        和 multiprocessing 模块中的一些底层原语的实现。</p>\n    <p>这里介绍两个经常用到的例子。</p>\n    <h4 id=\"queue\">队列（Queue）</h4>\n    <p>asyncio.Queue 为协程提供了一个先进先出的数据结构，这与线程的 queue.Queue 或进程的multiprocessing.Queue 很类似，下面先看一个简单的例子，它是一个非阻塞的队列。</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n<span class=\"hljs-keyword\">from</span> asyncio <span class=\"hljs-keyword\">import</span> Queue\n\nqueue=Queue()\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">start</span><span class=\"hljs-params\">()</span>:</span>\n        [queue.put_nowait(i) <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> range(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">10</span>)]\n        <span class=\"hljs-keyword\">await</span> asyncio.create_task(work()) <span class=\"hljs-comment\">#put_nowait表示放入元素</span>\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">work</span><span class=\"hljs-params\">()</span>:</span>\n    <span class=\"hljs-keyword\">try</span>:\n        <span class=\"hljs-keyword\">while</span> <span class=\"hljs-keyword\">not</span> queue.empty():<span class=\"hljs-comment\">#判断队列的元素是否为空</span>\n            num = queue.get_nowait()<span class=\"hljs-comment\">#获取元素</span>\n            print(<span class=\"hljs-string\">f\"获取数字:<span class=\"hljs-subst\">{num}</span>\"</span>)\n            queue.task_done()<span class=\"hljs-comment\">#告诉队列该任务处理完。</span>\n    <span class=\"hljs-keyword\">except</span> asyncio.CancelledError:\n        <span class=\"hljs-keyword\">pass</span>\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    asyncio.run(start())\n</code></pre>\n    <p>输出结果:</p>\n    <pre><code class=\"hljs css\">获取数字<span class=\"hljs-selector-pseudo\">:1</span>\n获取数字<span class=\"hljs-selector-pseudo\">:2</span>\n获取数字<span class=\"hljs-selector-pseudo\">:3</span>\n获取数字<span class=\"hljs-selector-pseudo\">:4</span>\n获取数字<span class=\"hljs-selector-pseudo\">:5</span>\n获取数字<span class=\"hljs-selector-pseudo\">:6</span>\n获取数字<span class=\"hljs-selector-pseudo\">:7</span>\n获取数字<span class=\"hljs-selector-pseudo\">:8</span>\n获取数字<span class=\"hljs-selector-pseudo\">:9</span>\n</code></pre>\n    <p>在做爬虫的时候对于 url 的处理，经常会用到队列的操作。另外一个要说的同步原语就是信号量。</p>\n    <h2 id=\"semaphore\">信号量（Semaphore）</h2>\n    <p>简单说下什么是信号量，我们用停车场和车进行比喻。一个停车场一共就 5 个车位，所以我们知道可以同时容纳最多 5 辆车，这五个车位就是信号量。</p>\n    <p>然后说信号量的行为，当有车离开停车场的时候外面的车就会进来补，比如有 2 辆车离开，那么就可以再进来 2 辆车，依次类推，上面这个过程就是描述了信号量这个东西。</p>\n    <p>下面我们看如何在程序中使用。</p>\n    <p>asyncio.Semaphore 模块就是一个维持并发量的模块，我们用它起到一个限流的效果。首先来一段代码：</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n\nsem=asyncio.Semaphore(<span class=\"hljs-number\">3</span>) <span class=\"hljs-comment\">#信号量指定为3</span>\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">branch</span><span class=\"hljs-params\">(num)</span>:</span>\n    <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">with</span> sem:  <span class=\"hljs-comment\">#通过异步上下文关键子控制并发量</span>\n        print(<span class=\"hljs-string\">f\"获取当前数字:<span class=\"hljs-subst\">{num}</span>\"</span>)\n        <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">0.5</span>)\n\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n\n     tasks=[asyncio.create_task(branch(i)) <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> range(<span class=\"hljs-number\">10</span>)] <span class=\"hljs-comment\">#将协程封装成任务共10个</span>\n     <span class=\"hljs-keyword\">await</span> asyncio.wait(tasks) <span class=\"hljs-comment\">#执行这些任务</span>\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    asyncio.run(main())\n</code></pre>\n    <p>执行之后你会发现：</p>\n    <pre><code class=\"hljs makefile\"><span class=\"hljs-section\">获取当前数字:0</span>\n<span class=\"hljs-section\">获取当前数字:1</span>\n<span class=\"hljs-section\">获取当前数字:2</span>\nTask exception was never retrieved\n<span class=\"hljs-section\">future: &lt;Task finished name='Task-11' coro=&lt;branch() done, defined at /Users/chennan/Desktop/2019/aiochatuse/semaphoredemo.py:26&gt; exception=RuntimeError(\"Task &lt;Task pending name='Task-11' coro=&lt;branch() running at /Users/chennan/Desktop/2019/aiochatuse/semaphoredemo.py:27&gt; cb=[_wait.&lt;locals&gt;._on_completion() at /Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/asyncio/tasks.py:478]&gt; got Future &lt;Future pending&gt; attached to a different loop\")&gt;</span>\n</code></pre>\n    <p>关键就是 attached to a different loop，这个地方说是当前的事件循环发生了改变，这个问题在Python3.6 的时候是不会出现的。</p>\n    <p>为什么 3.8 出错了？</p>\n    <p>这是因为：</p>\n    <p>我的信号量没有在循环内创建。也就是在 asyncio.run() 创建的循环之外创建了它们，因此它们使用 <code>events.get_event_loop()</code> 这就导致了新的事件循环产生。\n        asyncio.run() 创建一个新循环，然后在一个循环中创建的 future\n        不能在另一个循环中使用。所以问题就明确了，我们需要在循环之内创建。也就是我们需要定义一个全局变量，然后在主循环内部给其赋值。看到这，可能大家想到了 global，Python 3.7 增加了上下文变量 Context\n        Variables，至于为什么不用全局变量，因为可能会被其他协程修改，不安全，在这里也可以使用。</p>\n    <p>所以我们的代码变成了下面这个样子：</p>\n    <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> asyncio\n<span class=\"hljs-keyword\">from</span> contextvars <span class=\"hljs-keyword\">import</span> ContextVar\n\nconcurrent=ContextVar(<span class=\"hljs-string\">\"concurrent\"</span>)<span class=\"hljs-comment\">#定义全局上下文管理器</span>\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">branch</span><span class=\"hljs-params\">(num)</span>:</span>\n    sem=concurrent.get()<span class=\"hljs-comment\">#获取上下文关键字</span>\n    <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">with</span> sem:\n        print(<span class=\"hljs-string\">f\"获取当前数字:<span class=\"hljs-subst\">{num}</span>\"</span>)\n        <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">0.5</span>) <span class=\"hljs-comment\">#为了看到明显的效果</span>\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>:</span>\n     concurrent.set(asyncio.Semaphore(<span class=\"hljs-number\">3</span>)) <span class=\"hljs-comment\">#上下文管理器赋值</span>\n     tasks=[asyncio.create_task(branch(i)) <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> range(<span class=\"hljs-number\">10</span>)]\n     <span class=\"hljs-keyword\">await</span> asyncio.wait(tasks)\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    asyncio.run(main())\n</code></pre>\n    <p>然后我们再次输出：</p>\n    <pre><code class=\"hljs css\">获取当前数字<span class=\"hljs-selector-pseudo\">:0</span>\n获取当前数字<span class=\"hljs-selector-pseudo\">:1</span>\n获取当前数字<span class=\"hljs-selector-pseudo\">:2</span>\n获取当前数字<span class=\"hljs-selector-pseudo\">:3</span>\n获取当前数字<span class=\"hljs-selector-pseudo\">:4</span>\n获取当前数字<span class=\"hljs-selector-pseudo\">:5</span>\n获取当前数字<span class=\"hljs-selector-pseudo\">:6</span>\n获取当前数字<span class=\"hljs-selector-pseudo\">:7</span>\n获取当前数字<span class=\"hljs-selector-pseudo\">:8</span>\n获取当前数字<span class=\"hljs-selector-pseudo\">:9</span>\n</code></pre>\n    <p>可以看到程序每隔 3 组输出一次，这就达到了我们想要的效果了。</p>\n    </div>\n</body>\n</html>"},{"title":"work_0528","_content":"\ndone\n\n    确定源数据获取准确并补充channel_id, chl_bed_type, spl_bedtype_desc等信息;\n    \n    调整对供应商携程床型更新规则，BedType非0的不更新;\n    \n    确认UI数据与数据表数据是否一致;\n    \n    观察供应商携程拼接属性（窗、面积、吸烟）后的数据，确认数据分布情况，有了初步的解决方案\n\ndoing\n    \n    排查床型错误\n    \n    房型校验兼容供应商携程拼接属性\n    \nwarning\n    \n    本地测试使用Python3.6.6版本，加载有序字典OrderDict正常，符合预期\n    服务器使用Python3.5.2版本，加载有序字典OrderDict异常，不符合预期。\n    在有严格顺序要求的情况下，不要使用 \"字典\"结构。\n    这个问题并不是\"调用接口与调用方法所得结果不一致\"\n    而是\"同一个方法在本地与服务器所得结果不一致\"，排查原因为所用Python版本不一致导致。\n    \n    确定有严格顺序要求的情况下，不要使用 \"字典\"结构\n    \n    ","source":"_posts/work_coding/work0528.md","raw":"---\ntitle: work_0528\n---\n\ndone\n\n    确定源数据获取准确并补充channel_id, chl_bed_type, spl_bedtype_desc等信息;\n    \n    调整对供应商携程床型更新规则，BedType非0的不更新;\n    \n    确认UI数据与数据表数据是否一致;\n    \n    观察供应商携程拼接属性（窗、面积、吸烟）后的数据，确认数据分布情况，有了初步的解决方案\n\ndoing\n    \n    排查床型错误\n    \n    房型校验兼容供应商携程拼接属性\n    \nwarning\n    \n    本地测试使用Python3.6.6版本，加载有序字典OrderDict正常，符合预期\n    服务器使用Python3.5.2版本，加载有序字典OrderDict异常，不符合预期。\n    在有严格顺序要求的情况下，不要使用 \"字典\"结构。\n    这个问题并不是\"调用接口与调用方法所得结果不一致\"\n    而是\"同一个方法在本地与服务器所得结果不一致\"，排查原因为所用Python版本不一致导致。\n    \n    确定有严格顺序要求的情况下，不要使用 \"字典\"结构\n    \n    ","slug":"work_coding/work0528","published":1,"date":"2019-05-29T05:42:44.637Z","updated":"2019-05-29T05:42:44.637Z","_id":"cjwd4avuf000asv72h9jnril8","comments":1,"layout":"post","photos":[],"link":"","content":"<p>done</p>\n<pre><code>确定源数据获取准确并补充channel_id, chl_bed_type, spl_bedtype_desc等信息;\n\n调整对供应商携程床型更新规则，BedType非0的不更新;\n\n确认UI数据与数据表数据是否一致;\n\n观察供应商携程拼接属性（窗、面积、吸烟）后的数据，确认数据分布情况，有了初步的解决方案\n</code></pre><p>doing</p>\n<pre><code>排查床型错误\n\n房型校验兼容供应商携程拼接属性\n</code></pre><p>warning</p>\n<pre><code>本地测试使用Python3.6.6版本，加载有序字典OrderDict正常，符合预期\n服务器使用Python3.5.2版本，加载有序字典OrderDict异常，不符合预期。\n在有严格顺序要求的情况下，不要使用 &quot;字典&quot;结构。\n这个问题并不是&quot;调用接口与调用方法所得结果不一致&quot;\n而是&quot;同一个方法在本地与服务器所得结果不一致&quot;，排查原因为所用Python版本不一致导致。\n\n确定有严格顺序要求的情况下，不要使用 &quot;字典&quot;结构\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>done</p>\n<pre><code>确定源数据获取准确并补充channel_id, chl_bed_type, spl_bedtype_desc等信息;\n\n调整对供应商携程床型更新规则，BedType非0的不更新;\n\n确认UI数据与数据表数据是否一致;\n\n观察供应商携程拼接属性（窗、面积、吸烟）后的数据，确认数据分布情况，有了初步的解决方案\n</code></pre><p>doing</p>\n<pre><code>排查床型错误\n\n房型校验兼容供应商携程拼接属性\n</code></pre><p>warning</p>\n<pre><code>本地测试使用Python3.6.6版本，加载有序字典OrderDict正常，符合预期\n服务器使用Python3.5.2版本，加载有序字典OrderDict异常，不符合预期。\n在有严格顺序要求的情况下，不要使用 &quot;字典&quot;结构。\n这个问题并不是&quot;调用接口与调用方法所得结果不一致&quot;\n而是&quot;同一个方法在本地与服务器所得结果不一致&quot;，排查原因为所用Python版本不一致导致。\n\n确定有严格顺序要求的情况下，不要使用 &quot;字典&quot;结构\n</code></pre>"},{"title":"work_0529","_content":"\ndone\n\n    解决床型分类功能在本地、服务器上有出入的BUG;\n    整理床型测试用例与单测工具;\n    发现GTA、DOTW、EAN部分房型数据有问题，需要核实\n        grid 93002564906\n        床型 1 twin bed\n        房型 Executive Harbour View Twin Suite with Lounge Access\n             行政海港景双床床套房 - 可享用行政贵宾廊\n             \n        grid 272064016602\n        床型 \n        房型 Deluxe Twin Bed\n             精致客房双床房\n             \n        grid 87691875005\n        床型\n        房型 DELUXE TWIN BED\n             豪华房\n    数据部反馈的几个床型分类错误\n\ndoing\n    \n    分析供应商反馈信息，进行代码修改\n    房型校验兼容现在的供应商携程房型数据\n    ","source":"_posts/work_coding/work0529.md","raw":"---\ntitle: work_0529\n---\n\ndone\n\n    解决床型分类功能在本地、服务器上有出入的BUG;\n    整理床型测试用例与单测工具;\n    发现GTA、DOTW、EAN部分房型数据有问题，需要核实\n        grid 93002564906\n        床型 1 twin bed\n        房型 Executive Harbour View Twin Suite with Lounge Access\n             行政海港景双床床套房 - 可享用行政贵宾廊\n             \n        grid 272064016602\n        床型 \n        房型 Deluxe Twin Bed\n             精致客房双床房\n             \n        grid 87691875005\n        床型\n        房型 DELUXE TWIN BED\n             豪华房\n    数据部反馈的几个床型分类错误\n\ndoing\n    \n    分析供应商反馈信息，进行代码修改\n    房型校验兼容现在的供应商携程房型数据\n    ","slug":"work_coding/work0529","published":1,"date":"2019-05-30T02:12:46.134Z","updated":"2019-05-30T02:12:46.134Z","_id":"cjwd4avug000bsv72jtg9hiyf","comments":1,"layout":"post","photos":[],"link":"","content":"<p>done</p>\n<pre><code>解决床型分类功能在本地、服务器上有出入的BUG;\n整理床型测试用例与单测工具;\n发现GTA、DOTW、EAN部分房型数据有问题，需要核实\n    grid 93002564906\n    床型 1 twin bed\n    房型 Executive Harbour View Twin Suite with Lounge Access\n         行政海港景双床床套房 - 可享用行政贵宾廊\n\n    grid 272064016602\n    床型 \n    房型 Deluxe Twin Bed\n         精致客房双床房\n\n    grid 87691875005\n    床型\n    房型 DELUXE TWIN BED\n         豪华房\n数据部反馈的几个床型分类错误\n</code></pre><p>doing</p>\n<pre><code>分析供应商反馈信息，进行代码修改\n房型校验兼容现在的供应商携程房型数据\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>done</p>\n<pre><code>解决床型分类功能在本地、服务器上有出入的BUG;\n整理床型测试用例与单测工具;\n发现GTA、DOTW、EAN部分房型数据有问题，需要核实\n    grid 93002564906\n    床型 1 twin bed\n    房型 Executive Harbour View Twin Suite with Lounge Access\n         行政海港景双床床套房 - 可享用行政贵宾廊\n\n    grid 272064016602\n    床型 \n    房型 Deluxe Twin Bed\n         精致客房双床房\n\n    grid 87691875005\n    床型\n    房型 DELUXE TWIN BED\n         豪华房\n数据部反馈的几个床型分类错误\n</code></pre><p>doing</p>\n<pre><code>分析供应商反馈信息，进行代码修改\n房型校验兼容现在的供应商携程房型数据\n</code></pre>"},{"title":"work_0530","_content":"\ndone\n\n    解决携程房型拼接属性不兼容问题\n    \n        过滤属性\n![](../../img/190530解决携程房型拼接属性不兼容问题.jpg)\n\n\ndoing \n    \n    测试用例与单测工具","source":"_posts/work_coding/work0530.md","raw":"---\ntitle: work_0530\n---\n\ndone\n\n    解决携程房型拼接属性不兼容问题\n    \n        过滤属性\n![](../../img/190530解决携程房型拼接属性不兼容问题.jpg)\n\n\ndoing \n    \n    测试用例与单测工具","slug":"work_coding/work0530","published":1,"date":"2019-06-01T06:12:07.169Z","updated":"2019-06-01T06:12:07.170Z","_id":"cjwd4avuh000csv723v4rlb90","comments":1,"layout":"post","photos":[],"link":"","content":"<p>done</p>\n<pre><code>解决携程房型拼接属性不兼容问题\n\n    过滤属性\n</code></pre><p><img src=\"../../img/190530解决携程房型拼接属性不兼容问题.jpg\" alt></p>\n<p>doing </p>\n<pre><code>测试用例与单测工具\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>done</p>\n<pre><code>解决携程房型拼接属性不兼容问题\n\n    过滤属性\n</code></pre><p><img src=\"../../img/190530解决携程房型拼接属性不兼容问题.jpg\" alt></p>\n<p>doing </p>\n<pre><code>测试用例与单测工具\n</code></pre>"},{"title":"work_0531","_content":"\ndone\n    \n    针对供应商美团补充部分房型中文关键词\n    新增RoomAuto接口测试工具\n\ndoing\n\n    ","source":"_posts/work_coding/work_0531.md","raw":"---\ntitle: work_0531\n---\n\ndone\n    \n    针对供应商美团补充部分房型中文关键词\n    新增RoomAuto接口测试工具\n\ndoing\n\n    ","slug":"work_coding/work_0531","published":1,"date":"2019-05-31T10:19:52.747Z","updated":"2019-05-31T10:19:52.748Z","_id":"cjwd4avui000dsv72ggcnf2pg","comments":1,"layout":"post","photos":[],"link":"","content":"<p>done</p>\n<pre><code>针对供应商美团补充部分房型中文关键词\n新增RoomAuto接口测试工具\n</code></pre><p>doing</p>\n","site":{"data":{}},"excerpt":"","more":"<p>done</p>\n<pre><code>针对供应商美团补充部分房型中文关键词\n新增RoomAuto接口测试工具\n</code></pre><p>doing</p>\n"},{"title":"投资问题","_content":"\n动态规划理论的提出\n    \n    最早是用来解决资源的有效分配问题。\n    在总资源量有限，要分配给若干个项目，\n    每个项目都有一个投入与收益的关系，\n    最终的问题是求如何规划在不同项目上的投资，\n    使得收益能够最大化。\n\n问题分析\n\n项目投资/回报表, 可投资600万元 \n\n![](https://images.gitbook.cn/eb8bacc0-eba9-11e8-af4c-6f74b09e97f2)\n\n显然，投资和收益不是线性等比例关系，否则的话，把钱全投到收益比最高的那个项目上就行了，也没啥好规划的了。这个算法也可以用穷举法，因为 N 不是固定的值，所以穷举时可以考虑用递归的方式实现，但是这一课我们考虑用动态规划法来设计这个算法。\n\n投资 N 个项目，看起来好像是毫无关系的离散事件，但是因为投资的总钱数是固定的，这就使它们有了关系。如果我们换个角度看投资的项目，把所有的投资看作是一个求最优解的操作，把对每个项目的投资看作这个操作的一个阶段，就成功地将其转换成了多阶段决策问题。如果要考虑用动态规划解决这个多阶段决策问题，就需要首先证明每个阶段的决策能满足无后向性的要求。在这之前，先要确定决策状态的定义。\n\n状态里肯定要有一个量是标识决策阶段（也就是当前决策的项目）的，不妨用 i 表示决策阶段。肯定还要有一个量是标识投资的钱数，如果我们定义 j 为当前项目（阶段）i 投入的钱数，那么状态 \nd\n[\ni\n,\nj\n]\nd[i,j] 就表示项目 i 投入 j 万元获取的最大收益。现在考虑一下这个状态的定义是否满足无后向性，我们假设给第 2 个项目投入 2 百万元时获取的最大收益为 \nd\n[\n2\n,\n2\n]\nd[2,2]，这个 \nd\n[\n2\n,\n2\n]\nd[2,2] 包含两部分收益，一部分是第 2 个项目投 2 百万元获得的 85 万元固定收益，另一部分是给另两个项目投入剩下的（M − 2）百万元获取的收益。很显然，这（M − 2）百万元在第 1 个项目中有很多种投资方法，每种方法获取的收益都不一样，这会使得通过不同的 d[1,x] 计算出来的 \nd\n[\n2\n,\n2\n]\nd[2,2] 各不相同，后续依赖 \nd\n[\n2\n,\n2\n]\nd[2,2] 的决策就如同建立在浮沙之上，因此不满足无后向性要求。\n\n单独对第 i 个项目定义状态不能满足无后向性要求，现在换个思路，我们将前 i 个项目合在一起考虑，即定义状态 \nd\n[\ni\n,\nj\n]\nd[i,j] 为给前 i 个项目投入 j 万元时能获得的最大收益。前 i 个项目无论怎么分配这 j 万元投资，总能得到一个确定的最大收益，并且这个最大收益在到达 \nd\n[\ni\n,\nj\n]\nd[i,j] 状态后不会因为之前的分配方式不同而变化，后续做决策时也不会变化，因此满足无后向性要求。","source":"_posts/训练营/动态规划05.md","raw":"---\ntitle: 投资问题\n---\n\n动态规划理论的提出\n    \n    最早是用来解决资源的有效分配问题。\n    在总资源量有限，要分配给若干个项目，\n    每个项目都有一个投入与收益的关系，\n    最终的问题是求如何规划在不同项目上的投资，\n    使得收益能够最大化。\n\n问题分析\n\n项目投资/回报表, 可投资600万元 \n\n![](https://images.gitbook.cn/eb8bacc0-eba9-11e8-af4c-6f74b09e97f2)\n\n显然，投资和收益不是线性等比例关系，否则的话，把钱全投到收益比最高的那个项目上就行了，也没啥好规划的了。这个算法也可以用穷举法，因为 N 不是固定的值，所以穷举时可以考虑用递归的方式实现，但是这一课我们考虑用动态规划法来设计这个算法。\n\n投资 N 个项目，看起来好像是毫无关系的离散事件，但是因为投资的总钱数是固定的，这就使它们有了关系。如果我们换个角度看投资的项目，把所有的投资看作是一个求最优解的操作，把对每个项目的投资看作这个操作的一个阶段，就成功地将其转换成了多阶段决策问题。如果要考虑用动态规划解决这个多阶段决策问题，就需要首先证明每个阶段的决策能满足无后向性的要求。在这之前，先要确定决策状态的定义。\n\n状态里肯定要有一个量是标识决策阶段（也就是当前决策的项目）的，不妨用 i 表示决策阶段。肯定还要有一个量是标识投资的钱数，如果我们定义 j 为当前项目（阶段）i 投入的钱数，那么状态 \nd\n[\ni\n,\nj\n]\nd[i,j] 就表示项目 i 投入 j 万元获取的最大收益。现在考虑一下这个状态的定义是否满足无后向性，我们假设给第 2 个项目投入 2 百万元时获取的最大收益为 \nd\n[\n2\n,\n2\n]\nd[2,2]，这个 \nd\n[\n2\n,\n2\n]\nd[2,2] 包含两部分收益，一部分是第 2 个项目投 2 百万元获得的 85 万元固定收益，另一部分是给另两个项目投入剩下的（M − 2）百万元获取的收益。很显然，这（M − 2）百万元在第 1 个项目中有很多种投资方法，每种方法获取的收益都不一样，这会使得通过不同的 d[1,x] 计算出来的 \nd\n[\n2\n,\n2\n]\nd[2,2] 各不相同，后续依赖 \nd\n[\n2\n,\n2\n]\nd[2,2] 的决策就如同建立在浮沙之上，因此不满足无后向性要求。\n\n单独对第 i 个项目定义状态不能满足无后向性要求，现在换个思路，我们将前 i 个项目合在一起考虑，即定义状态 \nd\n[\ni\n,\nj\n]\nd[i,j] 为给前 i 个项目投入 j 万元时能获得的最大收益。前 i 个项目无论怎么分配这 j 万元投资，总能得到一个确定的最大收益，并且这个最大收益在到达 \nd\n[\ni\n,\nj\n]\nd[i,j] 状态后不会因为之前的分配方式不同而变化，后续做决策时也不会变化，因此满足无后向性要求。","slug":"训练营/动态规划05","published":1,"date":"2019-04-15T07:02:00.836Z","updated":"2019-04-15T07:02:00.837Z","_id":"cjwd4bmoo000esv72y8dat94r","comments":1,"layout":"post","photos":[],"link":"","content":"<p>动态规划理论的提出</p>\n<pre><code>最早是用来解决资源的有效分配问题。\n在总资源量有限，要分配给若干个项目，\n每个项目都有一个投入与收益的关系，\n最终的问题是求如何规划在不同项目上的投资，\n使得收益能够最大化。\n</code></pre><p>问题分析</p>\n<p>项目投资/回报表, 可投资600万元 </p>\n<p><img src=\"https://images.gitbook.cn/eb8bacc0-eba9-11e8-af4c-6f74b09e97f2\" alt></p>\n<p>显然，投资和收益不是线性等比例关系，否则的话，把钱全投到收益比最高的那个项目上就行了，也没啥好规划的了。这个算法也可以用穷举法，因为 N 不是固定的值，所以穷举时可以考虑用递归的方式实现，但是这一课我们考虑用动态规划法来设计这个算法。</p>\n<p>投资 N 个项目，看起来好像是毫无关系的离散事件，但是因为投资的总钱数是固定的，这就使它们有了关系。如果我们换个角度看投资的项目，把所有的投资看作是一个求最优解的操作，把对每个项目的投资看作这个操作的一个阶段，就成功地将其转换成了多阶段决策问题。如果要考虑用动态规划解决这个多阶段决策问题，就需要首先证明每个阶段的决策能满足无后向性的要求。在这之前，先要确定决策状态的定义。</p>\n<p>状态里肯定要有一个量是标识决策阶段（也就是当前决策的项目）的，不妨用 i 表示决策阶段。肯定还要有一个量是标识投资的钱数，如果我们定义 j 为当前项目（阶段）i 投入的钱数，那么状态<br>d<br>[<br>i<br>,<br>j<br>]<br>d[i,j] 就表示项目 i 投入 j 万元获取的最大收益。现在考虑一下这个状态的定义是否满足无后向性，我们假设给第 2 个项目投入 2 百万元时获取的最大收益为<br>d<br>[<br>2<br>,<br>2<br>]<br>d[2,2]，这个<br>d<br>[<br>2<br>,<br>2<br>]<br>d[2,2] 包含两部分收益，一部分是第 2 个项目投 2 百万元获得的 85 万元固定收益，另一部分是给另两个项目投入剩下的（M − 2）百万元获取的收益。很显然，这（M − 2）百万元在第 1 个项目中有很多种投资方法，每种方法获取的收益都不一样，这会使得通过不同的 d[1,x] 计算出来的<br>d<br>[<br>2<br>,<br>2<br>]<br>d[2,2] 各不相同，后续依赖<br>d<br>[<br>2<br>,<br>2<br>]<br>d[2,2] 的决策就如同建立在浮沙之上，因此不满足无后向性要求。</p>\n<p>单独对第 i 个项目定义状态不能满足无后向性要求，现在换个思路，我们将前 i 个项目合在一起考虑，即定义状态<br>d<br>[<br>i<br>,<br>j<br>]<br>d[i,j] 为给前 i 个项目投入 j 万元时能获得的最大收益。前 i 个项目无论怎么分配这 j 万元投资，总能得到一个确定的最大收益，并且这个最大收益在到达<br>d<br>[<br>i<br>,<br>j<br>]<br>d[i,j] 状态后不会因为之前的分配方式不同而变化，后续做决策时也不会变化，因此满足无后向性要求。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>动态规划理论的提出</p>\n<pre><code>最早是用来解决资源的有效分配问题。\n在总资源量有限，要分配给若干个项目，\n每个项目都有一个投入与收益的关系，\n最终的问题是求如何规划在不同项目上的投资，\n使得收益能够最大化。\n</code></pre><p>问题分析</p>\n<p>项目投资/回报表, 可投资600万元 </p>\n<p><img src=\"https://images.gitbook.cn/eb8bacc0-eba9-11e8-af4c-6f74b09e97f2\" alt></p>\n<p>显然，投资和收益不是线性等比例关系，否则的话，把钱全投到收益比最高的那个项目上就行了，也没啥好规划的了。这个算法也可以用穷举法，因为 N 不是固定的值，所以穷举时可以考虑用递归的方式实现，但是这一课我们考虑用动态规划法来设计这个算法。</p>\n<p>投资 N 个项目，看起来好像是毫无关系的离散事件，但是因为投资的总钱数是固定的，这就使它们有了关系。如果我们换个角度看投资的项目，把所有的投资看作是一个求最优解的操作，把对每个项目的投资看作这个操作的一个阶段，就成功地将其转换成了多阶段决策问题。如果要考虑用动态规划解决这个多阶段决策问题，就需要首先证明每个阶段的决策能满足无后向性的要求。在这之前，先要确定决策状态的定义。</p>\n<p>状态里肯定要有一个量是标识决策阶段（也就是当前决策的项目）的，不妨用 i 表示决策阶段。肯定还要有一个量是标识投资的钱数，如果我们定义 j 为当前项目（阶段）i 投入的钱数，那么状态<br>d<br>[<br>i<br>,<br>j<br>]<br>d[i,j] 就表示项目 i 投入 j 万元获取的最大收益。现在考虑一下这个状态的定义是否满足无后向性，我们假设给第 2 个项目投入 2 百万元时获取的最大收益为<br>d<br>[<br>2<br>,<br>2<br>]<br>d[2,2]，这个<br>d<br>[<br>2<br>,<br>2<br>]<br>d[2,2] 包含两部分收益，一部分是第 2 个项目投 2 百万元获得的 85 万元固定收益，另一部分是给另两个项目投入剩下的（M − 2）百万元获取的收益。很显然，这（M − 2）百万元在第 1 个项目中有很多种投资方法，每种方法获取的收益都不一样，这会使得通过不同的 d[1,x] 计算出来的<br>d<br>[<br>2<br>,<br>2<br>]<br>d[2,2] 各不相同，后续依赖<br>d<br>[<br>2<br>,<br>2<br>]<br>d[2,2] 的决策就如同建立在浮沙之上，因此不满足无后向性要求。</p>\n<p>单独对第 i 个项目定义状态不能满足无后向性要求，现在换个思路，我们将前 i 个项目合在一起考虑，即定义状态<br>d<br>[<br>i<br>,<br>j<br>]<br>d[i,j] 为给前 i 个项目投入 j 万元时能获得的最大收益。前 i 个项目无论怎么分配这 j 万元投资，总能得到一个确定的最大收益，并且这个最大收益在到达<br>d<br>[<br>i<br>,<br>j<br>]<br>d[i,j] 状态后不会因为之前的分配方式不同而变化，后续做决策时也不会变化，因此满足无后向性要求。</p>\n"},{"title":"如何理解动态规划法","_content":"\n动态规划需要明确的三个问题：\n    \n    子问题与决策阶段状态的定义\n    状态递推关系式\n    边界条件\n\n动态规划\n    \n    带备忘录的穷举 + 分治\n\n上楼梯的备忘录升级\n题目来源：小米OJ第10题\n```python\nimport sys\n\nd = [0, 1, 2]\n\nN = 0\n\n\ndef dp():\n    for _ in range(2, N-len(d)+3):\n        d.append(d[-1] + d[-2])\n\n\nfor line in sys.stdin:\n    line = int(line.strip())\n    if N < line:\n        N = line\n        dp()\n    print(d[line])\n```","source":"_posts/训练营/动态规划法01.md","raw":"---\ntitle: 如何理解动态规划法\n---\n\n动态规划需要明确的三个问题：\n    \n    子问题与决策阶段状态的定义\n    状态递推关系式\n    边界条件\n\n动态规划\n    \n    带备忘录的穷举 + 分治\n\n上楼梯的备忘录升级\n题目来源：小米OJ第10题\n```python\nimport sys\n\nd = [0, 1, 2]\n\nN = 0\n\n\ndef dp():\n    for _ in range(2, N-len(d)+3):\n        d.append(d[-1] + d[-2])\n\n\nfor line in sys.stdin:\n    line = int(line.strip())\n    if N < line:\n        N = line\n        dp()\n    print(d[line])\n```","slug":"训练营/动态规划法01","published":1,"date":"2019-04-11T14:14:56.056Z","updated":"2019-04-11T14:14:56.057Z","_id":"cjwd4bmop000fsv72cfnlwehf","comments":1,"layout":"post","photos":[],"link":"","content":"<p>动态规划需要明确的三个问题：</p>\n<pre><code>子问题与决策阶段状态的定义\n状态递推关系式\n边界条件\n</code></pre><p>动态规划</p>\n<pre><code>带备忘录的穷举 + 分治\n</code></pre><p>上楼梯的备忘录升级<br>题目来源：小米OJ第10题<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"></span><br><span class=\"line\">d = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">N = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dp</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, N-len(d)+<span class=\"number\">3</span>):</span><br><span class=\"line\">        d.append(d[<span class=\"number\">-1</span>] + d[<span class=\"number\">-2</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> sys.stdin:</span><br><span class=\"line\">    line = int(line.strip())</span><br><span class=\"line\">    <span class=\"keyword\">if</span> N &lt; line:</span><br><span class=\"line\">        N = line</span><br><span class=\"line\">        dp()</span><br><span class=\"line\">    print(d[line])</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>动态规划需要明确的三个问题：</p>\n<pre><code>子问题与决策阶段状态的定义\n状态递推关系式\n边界条件\n</code></pre><p>动态规划</p>\n<pre><code>带备忘录的穷举 + 分治\n</code></pre><p>上楼梯的备忘录升级<br>题目来源：小米OJ第10题<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"></span><br><span class=\"line\">d = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">N = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dp</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, N-len(d)+<span class=\"number\">3</span>):</span><br><span class=\"line\">        d.append(d[<span class=\"number\">-1</span>] + d[<span class=\"number\">-2</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> sys.stdin:</span><br><span class=\"line\">    line = int(line.strip())</span><br><span class=\"line\">    <span class=\"keyword\">if</span> N &lt; line:</span><br><span class=\"line\">        N = line</span><br><span class=\"line\">        dp()</span><br><span class=\"line\">    print(d[line])</span><br></pre></td></tr></table></figure></p>\n"},{"title":"算法设计常用思想之贪婪法","_content":"\n介绍\n    \n    贪婪法(Greedy Alogorithm), 又称贪心算法，\n    是寻找最优解的常用方法，\n    但是只有在很少的情况下可以得到真正的最优解，\n    如最短路径问题、图的最小生成树问题。\n    \n特点\n    \n    贪婪法简单、高效、省去了为找最优解可能需要的穷举操作，\n    可以得到与最优解比较接近的最优解，\n    通常作为其他算法的辅助算法来使用。\n    \n步骤\n    \n    1. 建立对问题精确描述的数学模型，\n       包括定义最优解的模型；\n    2. 将问题分解为一系列的子问题，\n       同时定义子问题的最优解结构；\n    3. 应用贪心原则确定每个子问题的局部最优解，\n       并根据最优解的模型，\n       用子问题的局部最优解来堆叠出全局最优解。\n    \n0-1背包问题 使用Python语言实现\n```python\n\"\"\"\n    思路\n    目标：在背包容量范围内，装入更多价值的物品\n    原则：p/w -> 价值质量密度\n         优先取出密度大的物品\n         已操作并可存放背包设置密度为 -1\n         已操作但不能放入背包的设置密度为 -2\n\"\"\"\nW_Max = 150\n\nWi = [35, 30, 60, 50, 40, 10, 25]\nPi = [10, 40, 30, 50, 35, 40, 30]\ndensity = [p / w for w, p in zip(Wi, Pi)]\n\nindex_list = []\nwhile 0 < max(density) <= W_Max:\n\n    Max = max(density)\n    index = density.index(Max)\n    if W_Max >= Wi[index]:\n        W_Max -= Wi[index]\n        density[index] = -1\n        index_list.append(index + 1)\n    else:\n        density[index] = -2\n\nprint(index_list)\n```\n\n需要刻意学习的算法\n    \n    Prim\n    Kruskal\n    Dijkstra ","source":"_posts/训练营/基础卡01-贪婪法.md","raw":"---\ntitle: 算法设计常用思想之贪婪法\n---\n\n介绍\n    \n    贪婪法(Greedy Alogorithm), 又称贪心算法，\n    是寻找最优解的常用方法，\n    但是只有在很少的情况下可以得到真正的最优解，\n    如最短路径问题、图的最小生成树问题。\n    \n特点\n    \n    贪婪法简单、高效、省去了为找最优解可能需要的穷举操作，\n    可以得到与最优解比较接近的最优解，\n    通常作为其他算法的辅助算法来使用。\n    \n步骤\n    \n    1. 建立对问题精确描述的数学模型，\n       包括定义最优解的模型；\n    2. 将问题分解为一系列的子问题，\n       同时定义子问题的最优解结构；\n    3. 应用贪心原则确定每个子问题的局部最优解，\n       并根据最优解的模型，\n       用子问题的局部最优解来堆叠出全局最优解。\n    \n0-1背包问题 使用Python语言实现\n```python\n\"\"\"\n    思路\n    目标：在背包容量范围内，装入更多价值的物品\n    原则：p/w -> 价值质量密度\n         优先取出密度大的物品\n         已操作并可存放背包设置密度为 -1\n         已操作但不能放入背包的设置密度为 -2\n\"\"\"\nW_Max = 150\n\nWi = [35, 30, 60, 50, 40, 10, 25]\nPi = [10, 40, 30, 50, 35, 40, 30]\ndensity = [p / w for w, p in zip(Wi, Pi)]\n\nindex_list = []\nwhile 0 < max(density) <= W_Max:\n\n    Max = max(density)\n    index = density.index(Max)\n    if W_Max >= Wi[index]:\n        W_Max -= Wi[index]\n        density[index] = -1\n        index_list.append(index + 1)\n    else:\n        density[index] = -2\n\nprint(index_list)\n```\n\n需要刻意学习的算法\n    \n    Prim\n    Kruskal\n    Dijkstra ","slug":"训练营/基础卡01-贪婪法","published":1,"date":"2019-04-03T04:46:50.040Z","updated":"2019-04-03T04:46:50.040Z","_id":"cjwd4bmoq000gsv7223rxz8mk","comments":1,"layout":"post","photos":[],"link":"","content":"<p>介绍</p>\n<pre><code>贪婪法(Greedy Alogorithm), 又称贪心算法，\n是寻找最优解的常用方法，\n但是只有在很少的情况下可以得到真正的最优解，\n如最短路径问题、图的最小生成树问题。\n</code></pre><p>特点</p>\n<pre><code>贪婪法简单、高效、省去了为找最优解可能需要的穷举操作，\n可以得到与最优解比较接近的最优解，\n通常作为其他算法的辅助算法来使用。\n</code></pre><p>步骤</p>\n<pre><code>1. 建立对问题精确描述的数学模型，\n   包括定义最优解的模型；\n2. 将问题分解为一系列的子问题，\n   同时定义子问题的最优解结构；\n3. 应用贪心原则确定每个子问题的局部最优解，\n   并根据最优解的模型，\n   用子问题的局部最优解来堆叠出全局最优解。\n</code></pre><p>0-1背包问题 使用Python语言实现<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    思路</span></span><br><span class=\"line\"><span class=\"string\">    目标：在背包容量范围内，装入更多价值的物品</span></span><br><span class=\"line\"><span class=\"string\">    原则：p/w -&gt; 价值质量密度</span></span><br><span class=\"line\"><span class=\"string\">         优先取出密度大的物品</span></span><br><span class=\"line\"><span class=\"string\">         已操作并可存放背包设置密度为 -1</span></span><br><span class=\"line\"><span class=\"string\">         已操作但不能放入背包的设置密度为 -2</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\">W_Max = <span class=\"number\">150</span></span><br><span class=\"line\"></span><br><span class=\"line\">Wi = [<span class=\"number\">35</span>, <span class=\"number\">30</span>, <span class=\"number\">60</span>, <span class=\"number\">50</span>, <span class=\"number\">40</span>, <span class=\"number\">10</span>, <span class=\"number\">25</span>]</span><br><span class=\"line\">Pi = [<span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>, <span class=\"number\">50</span>, <span class=\"number\">35</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>]</span><br><span class=\"line\">density = [p / w <span class=\"keyword\">for</span> w, p <span class=\"keyword\">in</span> zip(Wi, Pi)]</span><br><span class=\"line\"></span><br><span class=\"line\">index_list = []</span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"number\">0</span> &lt; max(density) &lt;= W_Max:</span><br><span class=\"line\"></span><br><span class=\"line\">    Max = max(density)</span><br><span class=\"line\">    index = density.index(Max)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> W_Max &gt;= Wi[index]:</span><br><span class=\"line\">        W_Max -= Wi[index]</span><br><span class=\"line\">        density[index] = <span class=\"number\">-1</span></span><br><span class=\"line\">        index_list.append(index + <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        density[index] = <span class=\"number\">-2</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(index_list)</span><br></pre></td></tr></table></figure></p>\n<p>需要刻意学习的算法</p>\n<pre><code>Prim\nKruskal\nDijkstra \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>介绍</p>\n<pre><code>贪婪法(Greedy Alogorithm), 又称贪心算法，\n是寻找最优解的常用方法，\n但是只有在很少的情况下可以得到真正的最优解，\n如最短路径问题、图的最小生成树问题。\n</code></pre><p>特点</p>\n<pre><code>贪婪法简单、高效、省去了为找最优解可能需要的穷举操作，\n可以得到与最优解比较接近的最优解，\n通常作为其他算法的辅助算法来使用。\n</code></pre><p>步骤</p>\n<pre><code>1. 建立对问题精确描述的数学模型，\n   包括定义最优解的模型；\n2. 将问题分解为一系列的子问题，\n   同时定义子问题的最优解结构；\n3. 应用贪心原则确定每个子问题的局部最优解，\n   并根据最优解的模型，\n   用子问题的局部最优解来堆叠出全局最优解。\n</code></pre><p>0-1背包问题 使用Python语言实现<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    思路</span></span><br><span class=\"line\"><span class=\"string\">    目标：在背包容量范围内，装入更多价值的物品</span></span><br><span class=\"line\"><span class=\"string\">    原则：p/w -&gt; 价值质量密度</span></span><br><span class=\"line\"><span class=\"string\">         优先取出密度大的物品</span></span><br><span class=\"line\"><span class=\"string\">         已操作并可存放背包设置密度为 -1</span></span><br><span class=\"line\"><span class=\"string\">         已操作但不能放入背包的设置密度为 -2</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\">W_Max = <span class=\"number\">150</span></span><br><span class=\"line\"></span><br><span class=\"line\">Wi = [<span class=\"number\">35</span>, <span class=\"number\">30</span>, <span class=\"number\">60</span>, <span class=\"number\">50</span>, <span class=\"number\">40</span>, <span class=\"number\">10</span>, <span class=\"number\">25</span>]</span><br><span class=\"line\">Pi = [<span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>, <span class=\"number\">50</span>, <span class=\"number\">35</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>]</span><br><span class=\"line\">density = [p / w <span class=\"keyword\">for</span> w, p <span class=\"keyword\">in</span> zip(Wi, Pi)]</span><br><span class=\"line\"></span><br><span class=\"line\">index_list = []</span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"number\">0</span> &lt; max(density) &lt;= W_Max:</span><br><span class=\"line\"></span><br><span class=\"line\">    Max = max(density)</span><br><span class=\"line\">    index = density.index(Max)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> W_Max &gt;= Wi[index]:</span><br><span class=\"line\">        W_Max -= Wi[index]</span><br><span class=\"line\">        density[index] = <span class=\"number\">-1</span></span><br><span class=\"line\">        index_list.append(index + <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        density[index] = <span class=\"number\">-2</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(index_list)</span><br></pre></td></tr></table></figure></p>\n<p>需要刻意学习的算法</p>\n<pre><code>Prim\nKruskal\nDijkstra \n</code></pre>"},{"title":"算法设计常用思想之分治法","_content":"\n介绍\n    \n    分治，顾名思义，分而治之。\n    将无法着手解决的大问题分解为一系列规模较小的相同问题，\n    然后逐个解决小问题。\n    \n    只要是数学归纳法可以证明的问题，一般也可以应用分治法解决，\n    这是一个应用分治法的强烈信号。\n\n\n作用\n    \n    1. 通过分解问题，使得无法着手解决的大问题变成容易解决的小问题。\n    2. 通过减小问题的规模，降低解决问题的复杂度。\n    \n\n步骤\n    \n    1. 分解：将问题分解为若干个规模较小，\n            相互独立且与原问题形式相同的子问题，\n            确保各个子问题的解具有相同的子结构。\n    2. 解决：如果上一步分解得到的子问题可以解决，\n            则解决这些子问题，否则，\n            对每个子问题使用和上一步相同的方法再次分解，\n            然后求解分解后的子问题，\n            这个过程可能是个递归的过程。\n    3. 合并：将上一步解决的各个子问题的解通过某种规则合并起来，\n            得到原问题的解。\n    \n    分治法伪代码\n    T DivideAndConquer(P)\n    {\n        if(P 可以直接解决)\n        {\n            T <- P 的结果;\n            return T;\n        }\n    \n        将 P 分解为子问题{P1, P2,..., Pn};\n        for_each(Pi : {P1, P2,..., Pn})\n        {\n            ti <- DivideAndConquer(Pi); //递归解决子问题 Pi\n        }\n        T <- Merge(t1, t2,...,tn); //合并子问题的解\n    \n        return T;\n    }\n\n\n递归实现和分治法\n    \n    分解问题肯定不是一步到位，往往需要反复使用分治手段，\n    在多个层次上层层分解，这种分解的方法很自然地导致了递归方式的使用。\n    从算法的角度看，分治法得到的子问题和原问题是相同的，\n    当然可以使用相同的函数来解决，区别在于问题的规模和范围不同。\n    而通过特定的函数参数安排，使得同一函数可以解决不同规模的相同问题，\n    这是递归方法的基础。\n    \n使用Python语言实现 快速排序\n```python\ndef quick_sort(array, left, right):\n    if left < right:\n        mid = partition(array, left, right)\n        quick_sort(array, left,  mid-1)\n        quick_sort(array, mid+1, right)\n\ndef partition(array, left, right):\n    tmp = array[left]\n    while left < right:\n        while left < right and array[right] >= tmp:\n            right -= 1\n        array[left] = array[right]\n        while left < right and array[left] <= tmp:\n            left += 1\n        array[right] = array[left]\n    array[left] = tmp\n    return left\n```\n\n作业之 二分查找实现\n```python\n\"\"\"\n    二分查找\n\n    首先，假设表中元素是按升序排列，\n    将表中间位置记录的关键字与查找关键字比较，\n    如果两者相等，则查找成功；\n    否则利用中间位置记录将表分成前、后两个子表，\n    如果中间位置记录的关键字大于查找关键字，\n    则进一步查找前一子表，否则进一步查找后一子表。\n    重复以上过程，直到找到满足条件的记录，\n    使查找成功，或直到子表不存在为止，此时查找不成功。\n\"\"\"\n\ndef bin_search(data_list, val):\n    low = 0  # 最小数下标\n    high = len(data_list) - 1  # 最大数下标\n    while low <= high:\n        mid = (low + high) // 2  # 中间数下标\n        if data_list[mid] == val:  # 如果中间数下标等于val, 返回\n            return mid\n        elif data_list[mid] > val:  # 如果val在中间数左边, 移动high下标\n            high = mid - 1\n        else:  # 如果val在中间数右边, 移动low下标\n            low = mid + 1\n    return -1   # val不存在, 返回 -1\n     \n```\n    ","source":"_posts/训练营/基础卡02-分治法.md","raw":"---\ntitle: 算法设计常用思想之分治法\n---\n\n介绍\n    \n    分治，顾名思义，分而治之。\n    将无法着手解决的大问题分解为一系列规模较小的相同问题，\n    然后逐个解决小问题。\n    \n    只要是数学归纳法可以证明的问题，一般也可以应用分治法解决，\n    这是一个应用分治法的强烈信号。\n\n\n作用\n    \n    1. 通过分解问题，使得无法着手解决的大问题变成容易解决的小问题。\n    2. 通过减小问题的规模，降低解决问题的复杂度。\n    \n\n步骤\n    \n    1. 分解：将问题分解为若干个规模较小，\n            相互独立且与原问题形式相同的子问题，\n            确保各个子问题的解具有相同的子结构。\n    2. 解决：如果上一步分解得到的子问题可以解决，\n            则解决这些子问题，否则，\n            对每个子问题使用和上一步相同的方法再次分解，\n            然后求解分解后的子问题，\n            这个过程可能是个递归的过程。\n    3. 合并：将上一步解决的各个子问题的解通过某种规则合并起来，\n            得到原问题的解。\n    \n    分治法伪代码\n    T DivideAndConquer(P)\n    {\n        if(P 可以直接解决)\n        {\n            T <- P 的结果;\n            return T;\n        }\n    \n        将 P 分解为子问题{P1, P2,..., Pn};\n        for_each(Pi : {P1, P2,..., Pn})\n        {\n            ti <- DivideAndConquer(Pi); //递归解决子问题 Pi\n        }\n        T <- Merge(t1, t2,...,tn); //合并子问题的解\n    \n        return T;\n    }\n\n\n递归实现和分治法\n    \n    分解问题肯定不是一步到位，往往需要反复使用分治手段，\n    在多个层次上层层分解，这种分解的方法很自然地导致了递归方式的使用。\n    从算法的角度看，分治法得到的子问题和原问题是相同的，\n    当然可以使用相同的函数来解决，区别在于问题的规模和范围不同。\n    而通过特定的函数参数安排，使得同一函数可以解决不同规模的相同问题，\n    这是递归方法的基础。\n    \n使用Python语言实现 快速排序\n```python\ndef quick_sort(array, left, right):\n    if left < right:\n        mid = partition(array, left, right)\n        quick_sort(array, left,  mid-1)\n        quick_sort(array, mid+1, right)\n\ndef partition(array, left, right):\n    tmp = array[left]\n    while left < right:\n        while left < right and array[right] >= tmp:\n            right -= 1\n        array[left] = array[right]\n        while left < right and array[left] <= tmp:\n            left += 1\n        array[right] = array[left]\n    array[left] = tmp\n    return left\n```\n\n作业之 二分查找实现\n```python\n\"\"\"\n    二分查找\n\n    首先，假设表中元素是按升序排列，\n    将表中间位置记录的关键字与查找关键字比较，\n    如果两者相等，则查找成功；\n    否则利用中间位置记录将表分成前、后两个子表，\n    如果中间位置记录的关键字大于查找关键字，\n    则进一步查找前一子表，否则进一步查找后一子表。\n    重复以上过程，直到找到满足条件的记录，\n    使查找成功，或直到子表不存在为止，此时查找不成功。\n\"\"\"\n\ndef bin_search(data_list, val):\n    low = 0  # 最小数下标\n    high = len(data_list) - 1  # 最大数下标\n    while low <= high:\n        mid = (low + high) // 2  # 中间数下标\n        if data_list[mid] == val:  # 如果中间数下标等于val, 返回\n            return mid\n        elif data_list[mid] > val:  # 如果val在中间数左边, 移动high下标\n            high = mid - 1\n        else:  # 如果val在中间数右边, 移动low下标\n            low = mid + 1\n    return -1   # val不存在, 返回 -1\n     \n```\n    ","slug":"训练营/基础卡02-分治法","published":1,"date":"2019-04-01T14:12:59.024Z","updated":"2019-04-01T14:12:59.024Z","_id":"cjwd4bmor000hsv72ho0jhbe4","comments":1,"layout":"post","photos":[],"link":"","content":"<p>介绍</p>\n<pre><code>分治，顾名思义，分而治之。\n将无法着手解决的大问题分解为一系列规模较小的相同问题，\n然后逐个解决小问题。\n\n只要是数学归纳法可以证明的问题，一般也可以应用分治法解决，\n这是一个应用分治法的强烈信号。\n</code></pre><p>作用</p>\n<pre><code>1. 通过分解问题，使得无法着手解决的大问题变成容易解决的小问题。\n2. 通过减小问题的规模，降低解决问题的复杂度。\n</code></pre><p>步骤</p>\n<pre><code>1. 分解：将问题分解为若干个规模较小，\n        相互独立且与原问题形式相同的子问题，\n        确保各个子问题的解具有相同的子结构。\n2. 解决：如果上一步分解得到的子问题可以解决，\n        则解决这些子问题，否则，\n        对每个子问题使用和上一步相同的方法再次分解，\n        然后求解分解后的子问题，\n        这个过程可能是个递归的过程。\n3. 合并：将上一步解决的各个子问题的解通过某种规则合并起来，\n        得到原问题的解。\n\n分治法伪代码\nT DivideAndConquer(P)\n{\n    if(P 可以直接解决)\n    {\n        T &lt;- P 的结果;\n        return T;\n    }\n\n    将 P 分解为子问题{P1, P2,..., Pn};\n    for_each(Pi : {P1, P2,..., Pn})\n    {\n        ti &lt;- DivideAndConquer(Pi); //递归解决子问题 Pi\n    }\n    T &lt;- Merge(t1, t2,...,tn); //合并子问题的解\n\n    return T;\n}\n</code></pre><p>递归实现和分治法</p>\n<pre><code>分解问题肯定不是一步到位，往往需要反复使用分治手段，\n在多个层次上层层分解，这种分解的方法很自然地导致了递归方式的使用。\n从算法的角度看，分治法得到的子问题和原问题是相同的，\n当然可以使用相同的函数来解决，区别在于问题的规模和范围不同。\n而通过特定的函数参数安排，使得同一函数可以解决不同规模的相同问题，\n这是递归方法的基础。\n</code></pre><p>使用Python语言实现 快速排序<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">quick_sort</span><span class=\"params\">(array, left, right)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> left &lt; right:</span><br><span class=\"line\">        mid = partition(array, left, right)</span><br><span class=\"line\">        quick_sort(array, left,  mid<span class=\"number\">-1</span>)</span><br><span class=\"line\">        quick_sort(array, mid+<span class=\"number\">1</span>, right)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">partition</span><span class=\"params\">(array, left, right)</span>:</span></span><br><span class=\"line\">    tmp = array[left]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> left &lt; right:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt; right <span class=\"keyword\">and</span> array[right] &gt;= tmp:</span><br><span class=\"line\">            right -= <span class=\"number\">1</span></span><br><span class=\"line\">        array[left] = array[right]</span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt; right <span class=\"keyword\">and</span> array[left] &lt;= tmp:</span><br><span class=\"line\">            left += <span class=\"number\">1</span></span><br><span class=\"line\">        array[right] = array[left]</span><br><span class=\"line\">    array[left] = tmp</span><br><span class=\"line\">    <span class=\"keyword\">return</span> left</span><br></pre></td></tr></table></figure></p>\n<p>作业之 二分查找实现<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    二分查找</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    首先，假设表中元素是按升序排列，</span></span><br><span class=\"line\"><span class=\"string\">    将表中间位置记录的关键字与查找关键字比较，</span></span><br><span class=\"line\"><span class=\"string\">    如果两者相等，则查找成功；</span></span><br><span class=\"line\"><span class=\"string\">    否则利用中间位置记录将表分成前、后两个子表，</span></span><br><span class=\"line\"><span class=\"string\">    如果中间位置记录的关键字大于查找关键字，</span></span><br><span class=\"line\"><span class=\"string\">    则进一步查找前一子表，否则进一步查找后一子表。</span></span><br><span class=\"line\"><span class=\"string\">    重复以上过程，直到找到满足条件的记录，</span></span><br><span class=\"line\"><span class=\"string\">    使查找成功，或直到子表不存在为止，此时查找不成功。</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bin_search</span><span class=\"params\">(data_list, val)</span>:</span></span><br><span class=\"line\">    low = <span class=\"number\">0</span>  <span class=\"comment\"># 最小数下标</span></span><br><span class=\"line\">    high = len(data_list) - <span class=\"number\">1</span>  <span class=\"comment\"># 最大数下标</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> low &lt;= high:</span><br><span class=\"line\">        mid = (low + high) // <span class=\"number\">2</span>  <span class=\"comment\"># 中间数下标</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> data_list[mid] == val:  <span class=\"comment\"># 如果中间数下标等于val, 返回</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> data_list[mid] &gt; val:  <span class=\"comment\"># 如果val在中间数左边, 移动high下标</span></span><br><span class=\"line\">            high = mid - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:  <span class=\"comment\"># 如果val在中间数右边, 移动low下标</span></span><br><span class=\"line\">            low = mid + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>   <span class=\"comment\"># val不存在, 返回 -1</span></span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>介绍</p>\n<pre><code>分治，顾名思义，分而治之。\n将无法着手解决的大问题分解为一系列规模较小的相同问题，\n然后逐个解决小问题。\n\n只要是数学归纳法可以证明的问题，一般也可以应用分治法解决，\n这是一个应用分治法的强烈信号。\n</code></pre><p>作用</p>\n<pre><code>1. 通过分解问题，使得无法着手解决的大问题变成容易解决的小问题。\n2. 通过减小问题的规模，降低解决问题的复杂度。\n</code></pre><p>步骤</p>\n<pre><code>1. 分解：将问题分解为若干个规模较小，\n        相互独立且与原问题形式相同的子问题，\n        确保各个子问题的解具有相同的子结构。\n2. 解决：如果上一步分解得到的子问题可以解决，\n        则解决这些子问题，否则，\n        对每个子问题使用和上一步相同的方法再次分解，\n        然后求解分解后的子问题，\n        这个过程可能是个递归的过程。\n3. 合并：将上一步解决的各个子问题的解通过某种规则合并起来，\n        得到原问题的解。\n\n分治法伪代码\nT DivideAndConquer(P)\n{\n    if(P 可以直接解决)\n    {\n        T &lt;- P 的结果;\n        return T;\n    }\n\n    将 P 分解为子问题{P1, P2,..., Pn};\n    for_each(Pi : {P1, P2,..., Pn})\n    {\n        ti &lt;- DivideAndConquer(Pi); //递归解决子问题 Pi\n    }\n    T &lt;- Merge(t1, t2,...,tn); //合并子问题的解\n\n    return T;\n}\n</code></pre><p>递归实现和分治法</p>\n<pre><code>分解问题肯定不是一步到位，往往需要反复使用分治手段，\n在多个层次上层层分解，这种分解的方法很自然地导致了递归方式的使用。\n从算法的角度看，分治法得到的子问题和原问题是相同的，\n当然可以使用相同的函数来解决，区别在于问题的规模和范围不同。\n而通过特定的函数参数安排，使得同一函数可以解决不同规模的相同问题，\n这是递归方法的基础。\n</code></pre><p>使用Python语言实现 快速排序<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">quick_sort</span><span class=\"params\">(array, left, right)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> left &lt; right:</span><br><span class=\"line\">        mid = partition(array, left, right)</span><br><span class=\"line\">        quick_sort(array, left,  mid<span class=\"number\">-1</span>)</span><br><span class=\"line\">        quick_sort(array, mid+<span class=\"number\">1</span>, right)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">partition</span><span class=\"params\">(array, left, right)</span>:</span></span><br><span class=\"line\">    tmp = array[left]</span><br><span class=\"line\">    <span class=\"keyword\">while</span> left &lt; right:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt; right <span class=\"keyword\">and</span> array[right] &gt;= tmp:</span><br><span class=\"line\">            right -= <span class=\"number\">1</span></span><br><span class=\"line\">        array[left] = array[right]</span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt; right <span class=\"keyword\">and</span> array[left] &lt;= tmp:</span><br><span class=\"line\">            left += <span class=\"number\">1</span></span><br><span class=\"line\">        array[right] = array[left]</span><br><span class=\"line\">    array[left] = tmp</span><br><span class=\"line\">    <span class=\"keyword\">return</span> left</span><br></pre></td></tr></table></figure></p>\n<p>作业之 二分查找实现<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    二分查找</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    首先，假设表中元素是按升序排列，</span></span><br><span class=\"line\"><span class=\"string\">    将表中间位置记录的关键字与查找关键字比较，</span></span><br><span class=\"line\"><span class=\"string\">    如果两者相等，则查找成功；</span></span><br><span class=\"line\"><span class=\"string\">    否则利用中间位置记录将表分成前、后两个子表，</span></span><br><span class=\"line\"><span class=\"string\">    如果中间位置记录的关键字大于查找关键字，</span></span><br><span class=\"line\"><span class=\"string\">    则进一步查找前一子表，否则进一步查找后一子表。</span></span><br><span class=\"line\"><span class=\"string\">    重复以上过程，直到找到满足条件的记录，</span></span><br><span class=\"line\"><span class=\"string\">    使查找成功，或直到子表不存在为止，此时查找不成功。</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bin_search</span><span class=\"params\">(data_list, val)</span>:</span></span><br><span class=\"line\">    low = <span class=\"number\">0</span>  <span class=\"comment\"># 最小数下标</span></span><br><span class=\"line\">    high = len(data_list) - <span class=\"number\">1</span>  <span class=\"comment\"># 最大数下标</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> low &lt;= high:</span><br><span class=\"line\">        mid = (low + high) // <span class=\"number\">2</span>  <span class=\"comment\"># 中间数下标</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> data_list[mid] == val:  <span class=\"comment\"># 如果中间数下标等于val, 返回</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> data_list[mid] &gt; val:  <span class=\"comment\"># 如果val在中间数左边, 移动high下标</span></span><br><span class=\"line\">            high = mid - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:  <span class=\"comment\"># 如果val在中间数右边, 移动low下标</span></span><br><span class=\"line\">            low = mid + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>   <span class=\"comment\"># val不存在, 返回 -1</span></span><br></pre></td></tr></table></figure></p>\n"},{"title":"算法设计常用思想之动态规划法","_content":"\n动态规划\n\n    是解决多阶段决策问题常用的最优化理论\n    想法简单，落地困难，\n    需要经由大量实践\n    积累对子问题的分解和\n    决策状态的定义的经验。\n    比穷举法高效，\n    但效率在很大程度上还是取决于问题本身\n    内在机制为广域搜索\n    需要满足条件：\n        1. 最优化原理\n        2. 子问题的\"无后向性\"\n\n最优化原理：\n\n    最优化原理其实就是问题的最优子结构的性质，\n    如果一个问题的最优子结构是不论过去状态和决策如何，\n    对前面的决策所形成的状态而言，\n    其后的决策必须构成最优策略。也就是说，\n    不管之前的决策是否是最优决策，\n    都必须保证从现在开始的决策是在之前决策基础上的最优决策，\n    则这样的最优子结构就符合最优化原理。\n\n无后向性：\n\n    所谓“无后向性”，就是当各个阶段的子问题确定以后，\n    对于某个特定阶段的子问题来说，\n    它之前各个阶段的子问题的决策只影响该阶段的决策，\n    对该阶段之后的决策不产生影响。\n    即前面的不被后面的影响。\n    \n\n步骤\n    \n    定义最优子问题（最优解的子结构）\n    定义状态（最优解的值）\n    定义决策和状态转换方程（定义计算最优解的值的方法）\n    确定边界条件\n    \n难点\n    \n    状态如何描述\n    状态转移方程如何定义\n\n最长公共子序列（LCS）问题 使用Python实现\n```python\ndef lcs(str1, str2):\n    length_1 = len(str1)\n    length_2 = len(str2)\n\n    dp = [[0] * (length_2 + 1) for _ in range(length_1 + 1)]\n\n    for i in range(1, length_1 + 1):\n\n        for j in range(1, length_2 + 1):\n\n            if str1[i - 1] == str2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[length_1][length_2]\n```","source":"_posts/训练营/基础卡03-动态规划.md","raw":"---\ntitle: 算法设计常用思想之动态规划法\n---\n\n动态规划\n\n    是解决多阶段决策问题常用的最优化理论\n    想法简单，落地困难，\n    需要经由大量实践\n    积累对子问题的分解和\n    决策状态的定义的经验。\n    比穷举法高效，\n    但效率在很大程度上还是取决于问题本身\n    内在机制为广域搜索\n    需要满足条件：\n        1. 最优化原理\n        2. 子问题的\"无后向性\"\n\n最优化原理：\n\n    最优化原理其实就是问题的最优子结构的性质，\n    如果一个问题的最优子结构是不论过去状态和决策如何，\n    对前面的决策所形成的状态而言，\n    其后的决策必须构成最优策略。也就是说，\n    不管之前的决策是否是最优决策，\n    都必须保证从现在开始的决策是在之前决策基础上的最优决策，\n    则这样的最优子结构就符合最优化原理。\n\n无后向性：\n\n    所谓“无后向性”，就是当各个阶段的子问题确定以后，\n    对于某个特定阶段的子问题来说，\n    它之前各个阶段的子问题的决策只影响该阶段的决策，\n    对该阶段之后的决策不产生影响。\n    即前面的不被后面的影响。\n    \n\n步骤\n    \n    定义最优子问题（最优解的子结构）\n    定义状态（最优解的值）\n    定义决策和状态转换方程（定义计算最优解的值的方法）\n    确定边界条件\n    \n难点\n    \n    状态如何描述\n    状态转移方程如何定义\n\n最长公共子序列（LCS）问题 使用Python实现\n```python\ndef lcs(str1, str2):\n    length_1 = len(str1)\n    length_2 = len(str2)\n\n    dp = [[0] * (length_2 + 1) for _ in range(length_1 + 1)]\n\n    for i in range(1, length_1 + 1):\n\n        for j in range(1, length_2 + 1):\n\n            if str1[i - 1] == str2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[length_1][length_2]\n```","slug":"训练营/基础卡03-动态规划","published":1,"date":"2019-04-03T07:17:37.311Z","updated":"2019-04-03T07:17:37.311Z","_id":"cjwd4bmot000isv72f4nbh7bx","comments":1,"layout":"post","photos":[],"link":"","content":"<p>动态规划</p>\n<pre><code>是解决多阶段决策问题常用的最优化理论\n想法简单，落地困难，\n需要经由大量实践\n积累对子问题的分解和\n决策状态的定义的经验。\n比穷举法高效，\n但效率在很大程度上还是取决于问题本身\n内在机制为广域搜索\n需要满足条件：\n    1. 最优化原理\n    2. 子问题的&quot;无后向性&quot;\n</code></pre><p>最优化原理：</p>\n<pre><code>最优化原理其实就是问题的最优子结构的性质，\n如果一个问题的最优子结构是不论过去状态和决策如何，\n对前面的决策所形成的状态而言，\n其后的决策必须构成最优策略。也就是说，\n不管之前的决策是否是最优决策，\n都必须保证从现在开始的决策是在之前决策基础上的最优决策，\n则这样的最优子结构就符合最优化原理。\n</code></pre><p>无后向性：</p>\n<pre><code>所谓“无后向性”，就是当各个阶段的子问题确定以后，\n对于某个特定阶段的子问题来说，\n它之前各个阶段的子问题的决策只影响该阶段的决策，\n对该阶段之后的决策不产生影响。\n即前面的不被后面的影响。\n</code></pre><p>步骤</p>\n<pre><code>定义最优子问题（最优解的子结构）\n定义状态（最优解的值）\n定义决策和状态转换方程（定义计算最优解的值的方法）\n确定边界条件\n</code></pre><p>难点</p>\n<pre><code>状态如何描述\n状态转移方程如何定义\n</code></pre><p>最长公共子序列（LCS）问题 使用Python实现<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lcs</span><span class=\"params\">(str1, str2)</span>:</span></span><br><span class=\"line\">    length_1 = len(str1)</span><br><span class=\"line\">    length_2 = len(str2)</span><br><span class=\"line\"></span><br><span class=\"line\">    dp = [[<span class=\"number\">0</span>] * (length_2 + <span class=\"number\">1</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(length_1 + <span class=\"number\">1</span>)]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, length_1 + <span class=\"number\">1</span>):</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, length_2 + <span class=\"number\">1</span>):</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> str1[i - <span class=\"number\">1</span>] == str2[j - <span class=\"number\">1</span>]:</span><br><span class=\"line\">                dp[i][j] = dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                dp[i][j] = max(dp[i - <span class=\"number\">1</span>][j], dp[i][j - <span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[length_1][length_2]</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>动态规划</p>\n<pre><code>是解决多阶段决策问题常用的最优化理论\n想法简单，落地困难，\n需要经由大量实践\n积累对子问题的分解和\n决策状态的定义的经验。\n比穷举法高效，\n但效率在很大程度上还是取决于问题本身\n内在机制为广域搜索\n需要满足条件：\n    1. 最优化原理\n    2. 子问题的&quot;无后向性&quot;\n</code></pre><p>最优化原理：</p>\n<pre><code>最优化原理其实就是问题的最优子结构的性质，\n如果一个问题的最优子结构是不论过去状态和决策如何，\n对前面的决策所形成的状态而言，\n其后的决策必须构成最优策略。也就是说，\n不管之前的决策是否是最优决策，\n都必须保证从现在开始的决策是在之前决策基础上的最优决策，\n则这样的最优子结构就符合最优化原理。\n</code></pre><p>无后向性：</p>\n<pre><code>所谓“无后向性”，就是当各个阶段的子问题确定以后，\n对于某个特定阶段的子问题来说，\n它之前各个阶段的子问题的决策只影响该阶段的决策，\n对该阶段之后的决策不产生影响。\n即前面的不被后面的影响。\n</code></pre><p>步骤</p>\n<pre><code>定义最优子问题（最优解的子结构）\n定义状态（最优解的值）\n定义决策和状态转换方程（定义计算最优解的值的方法）\n确定边界条件\n</code></pre><p>难点</p>\n<pre><code>状态如何描述\n状态转移方程如何定义\n</code></pre><p>最长公共子序列（LCS）问题 使用Python实现<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lcs</span><span class=\"params\">(str1, str2)</span>:</span></span><br><span class=\"line\">    length_1 = len(str1)</span><br><span class=\"line\">    length_2 = len(str2)</span><br><span class=\"line\"></span><br><span class=\"line\">    dp = [[<span class=\"number\">0</span>] * (length_2 + <span class=\"number\">1</span>) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(length_1 + <span class=\"number\">1</span>)]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, length_1 + <span class=\"number\">1</span>):</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, length_2 + <span class=\"number\">1</span>):</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> str1[i - <span class=\"number\">1</span>] == str2[j - <span class=\"number\">1</span>]:</span><br><span class=\"line\">                dp[i][j] = dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                dp[i][j] = max(dp[i - <span class=\"number\">1</span>][j], dp[i][j - <span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[length_1][length_2]</span><br></pre></td></tr></table></figure></p>\n"},{"title":"算法设计常用思想之穷举法","_content":"\n穷举法\n    \n    是一种在问题域的解空间中对所有可能的解穷举搜索，\n    并根据条件选择最优解的方法的总称。\n    \n    穷举法作为计算机算法使用时，\n    就是依赖计算机不知疲倦的计算能力。\n    \n    穷举法作为一种算法模式，\n    也常常与其他模式配合使用，\n    成为某个具体算法中的一部分。\n\n\n难点\n    \n    1. 解空间或状态空间的定义没有具体的模式，\n       不同问题的解空间形式上也差异巨大\n    2. 针对不同问题要选择不同的搜索算法，\n       有很多问题的搜索算法并不直观，\n       需要对问题做细致的分析并且依靠丰富的经验才能设计出来。\n    3. 在问题的规模大到一定范围时，穷举法只是理论可行。\n       在这种不能对解空间进行完全搜索时，\n       需要对搜索算法进行评估，\n       并确定一些收敛原则。   \n       \n步骤\n\n    1. 确定问题的解（或状态）的定义、\n       解空间的范围以及正确解的判定条件。\n    2. 根据解空间的特点来选择搜索策略，\n       逐个检验解空间中的候选解是否正确。\n    \n\n解空间的定义\n    \n    解空间就是全部可能的候选解的一个约束范围，\n    确定问题的解就在这个约束范围内，\n    将搜索策略应用到这个约束范围就可以找到问题的解。\n\n\n穷举解空间的策略\n    \n    1. 盲目搜索\n        不带任何假设的穷举搜索，\n        把所有可能的解都检查一遍。\n        -- 广度优先\n            需要额外的存储空间，则应考虑额外空间的规模\n        -- 深度优先\n            容易陷入死循环，则要做状态循环的判断和避免\n    \n    2. 启发式搜索\n        由启发函数策动有目的的搜索行为，\n        这些策略和依据通常能够加快算法的收敛速度，\n        或能够划定一个更小的、最有可能出现解的空间上搜索。\n        -- 假设解空间符合正态分布\n            可以从分布中间值开始向两边搜索。\n     \n    3. 剪枝策略\n        在对解空间穷举搜索时，\n        如果有一些状态节点可以根据问题所提供的信息，\n        明确地判定为不可能演化出最优解，\n        则可以跳过此状态节点的遍历。\n        \n\n剪枝和启发\n\n    剪枝是对已产生的结果，根据最优解的判断条件，\n        确定在该方向上不可能存在最优解，\n        从而放弃对这个方向的搜素。\n        \n    启发是根据启发函数给出的评估值，\n        在结果出来之前就朝着最优解方向搜索\n    \n\n评估与收敛\n    \n    收敛原则是只要能找到一个比较好的解就返回，\n    根据解的评估判断是否需要继续下一次搜索。  \n\n\n百钱买百鸡 Python语言实现\n```python\np_m = 5\np_w = 3\np_x = 1 / 3\n\nn = 100\nfor i in range(0, n // p_m):\n\n    for j in range(0, n // p_w):\n\n        if i * p_m + j * p_w + (100 - i - j) * p_x == 100:\n            print(i, j, 100 - i - j)\n\n```\n\n作业之 鸡兔同笼\n```python\nt = 50\nj = 120\nji = 2\ntu = 4\n\nfor tu_num in range(j // tu):\n\n    if tu_num * tu + (t - tu_num) * ji == j:\n        print(tu_num, t - tu_num)\n\n```","source":"_posts/训练营/基础卡04-穷举法.md","raw":"---\ntitle: 算法设计常用思想之穷举法\n---\n\n穷举法\n    \n    是一种在问题域的解空间中对所有可能的解穷举搜索，\n    并根据条件选择最优解的方法的总称。\n    \n    穷举法作为计算机算法使用时，\n    就是依赖计算机不知疲倦的计算能力。\n    \n    穷举法作为一种算法模式，\n    也常常与其他模式配合使用，\n    成为某个具体算法中的一部分。\n\n\n难点\n    \n    1. 解空间或状态空间的定义没有具体的模式，\n       不同问题的解空间形式上也差异巨大\n    2. 针对不同问题要选择不同的搜索算法，\n       有很多问题的搜索算法并不直观，\n       需要对问题做细致的分析并且依靠丰富的经验才能设计出来。\n    3. 在问题的规模大到一定范围时，穷举法只是理论可行。\n       在这种不能对解空间进行完全搜索时，\n       需要对搜索算法进行评估，\n       并确定一些收敛原则。   \n       \n步骤\n\n    1. 确定问题的解（或状态）的定义、\n       解空间的范围以及正确解的判定条件。\n    2. 根据解空间的特点来选择搜索策略，\n       逐个检验解空间中的候选解是否正确。\n    \n\n解空间的定义\n    \n    解空间就是全部可能的候选解的一个约束范围，\n    确定问题的解就在这个约束范围内，\n    将搜索策略应用到这个约束范围就可以找到问题的解。\n\n\n穷举解空间的策略\n    \n    1. 盲目搜索\n        不带任何假设的穷举搜索，\n        把所有可能的解都检查一遍。\n        -- 广度优先\n            需要额外的存储空间，则应考虑额外空间的规模\n        -- 深度优先\n            容易陷入死循环，则要做状态循环的判断和避免\n    \n    2. 启发式搜索\n        由启发函数策动有目的的搜索行为，\n        这些策略和依据通常能够加快算法的收敛速度，\n        或能够划定一个更小的、最有可能出现解的空间上搜索。\n        -- 假设解空间符合正态分布\n            可以从分布中间值开始向两边搜索。\n     \n    3. 剪枝策略\n        在对解空间穷举搜索时，\n        如果有一些状态节点可以根据问题所提供的信息，\n        明确地判定为不可能演化出最优解，\n        则可以跳过此状态节点的遍历。\n        \n\n剪枝和启发\n\n    剪枝是对已产生的结果，根据最优解的判断条件，\n        确定在该方向上不可能存在最优解，\n        从而放弃对这个方向的搜素。\n        \n    启发是根据启发函数给出的评估值，\n        在结果出来之前就朝着最优解方向搜索\n    \n\n评估与收敛\n    \n    收敛原则是只要能找到一个比较好的解就返回，\n    根据解的评估判断是否需要继续下一次搜索。  \n\n\n百钱买百鸡 Python语言实现\n```python\np_m = 5\np_w = 3\np_x = 1 / 3\n\nn = 100\nfor i in range(0, n // p_m):\n\n    for j in range(0, n // p_w):\n\n        if i * p_m + j * p_w + (100 - i - j) * p_x == 100:\n            print(i, j, 100 - i - j)\n\n```\n\n作业之 鸡兔同笼\n```python\nt = 50\nj = 120\nji = 2\ntu = 4\n\nfor tu_num in range(j // tu):\n\n    if tu_num * tu + (t - tu_num) * ji == j:\n        print(tu_num, t - tu_num)\n\n```","slug":"训练营/基础卡04-穷举法","published":1,"date":"2019-04-03T06:15:56.590Z","updated":"2019-04-03T06:15:56.591Z","_id":"cjwd4bmot000jsv72bpwwslt1","comments":1,"layout":"post","photos":[],"link":"","content":"<p>穷举法</p>\n<pre><code>是一种在问题域的解空间中对所有可能的解穷举搜索，\n并根据条件选择最优解的方法的总称。\n\n穷举法作为计算机算法使用时，\n就是依赖计算机不知疲倦的计算能力。\n\n穷举法作为一种算法模式，\n也常常与其他模式配合使用，\n成为某个具体算法中的一部分。\n</code></pre><p>难点</p>\n<pre><code>1. 解空间或状态空间的定义没有具体的模式，\n   不同问题的解空间形式上也差异巨大\n2. 针对不同问题要选择不同的搜索算法，\n   有很多问题的搜索算法并不直观，\n   需要对问题做细致的分析并且依靠丰富的经验才能设计出来。\n3. 在问题的规模大到一定范围时，穷举法只是理论可行。\n   在这种不能对解空间进行完全搜索时，\n   需要对搜索算法进行评估，\n   并确定一些收敛原则。   \n</code></pre><p>步骤</p>\n<pre><code>1. 确定问题的解（或状态）的定义、\n   解空间的范围以及正确解的判定条件。\n2. 根据解空间的特点来选择搜索策略，\n   逐个检验解空间中的候选解是否正确。\n</code></pre><p>解空间的定义</p>\n<pre><code>解空间就是全部可能的候选解的一个约束范围，\n确定问题的解就在这个约束范围内，\n将搜索策略应用到这个约束范围就可以找到问题的解。\n</code></pre><p>穷举解空间的策略</p>\n<pre><code>1. 盲目搜索\n    不带任何假设的穷举搜索，\n    把所有可能的解都检查一遍。\n    -- 广度优先\n        需要额外的存储空间，则应考虑额外空间的规模\n    -- 深度优先\n        容易陷入死循环，则要做状态循环的判断和避免\n\n2. 启发式搜索\n    由启发函数策动有目的的搜索行为，\n    这些策略和依据通常能够加快算法的收敛速度，\n    或能够划定一个更小的、最有可能出现解的空间上搜索。\n    -- 假设解空间符合正态分布\n        可以从分布中间值开始向两边搜索。\n\n3. 剪枝策略\n    在对解空间穷举搜索时，\n    如果有一些状态节点可以根据问题所提供的信息，\n    明确地判定为不可能演化出最优解，\n    则可以跳过此状态节点的遍历。\n</code></pre><p>剪枝和启发</p>\n<pre><code>剪枝是对已产生的结果，根据最优解的判断条件，\n    确定在该方向上不可能存在最优解，\n    从而放弃对这个方向的搜素。\n\n启发是根据启发函数给出的评估值，\n    在结果出来之前就朝着最优解方向搜索\n</code></pre><p>评估与收敛</p>\n<pre><code>收敛原则是只要能找到一个比较好的解就返回，\n根据解的评估判断是否需要继续下一次搜索。  \n</code></pre><p>百钱买百鸡 Python语言实现<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p_m = <span class=\"number\">5</span></span><br><span class=\"line\">p_w = <span class=\"number\">3</span></span><br><span class=\"line\">p_x = <span class=\"number\">1</span> / <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">n = <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, n // p_m):</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, n // p_w):</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i * p_m + j * p_w + (<span class=\"number\">100</span> - i - j) * p_x == <span class=\"number\">100</span>:</span><br><span class=\"line\">            print(i, j, <span class=\"number\">100</span> - i - j)</span><br></pre></td></tr></table></figure></p>\n<p>作业之 鸡兔同笼<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t = <span class=\"number\">50</span></span><br><span class=\"line\">j = <span class=\"number\">120</span></span><br><span class=\"line\">ji = <span class=\"number\">2</span></span><br><span class=\"line\">tu = <span class=\"number\">4</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> tu_num <span class=\"keyword\">in</span> range(j // tu):</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> tu_num * tu + (t - tu_num) * ji == j:</span><br><span class=\"line\">        print(tu_num, t - tu_num)</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>穷举法</p>\n<pre><code>是一种在问题域的解空间中对所有可能的解穷举搜索，\n并根据条件选择最优解的方法的总称。\n\n穷举法作为计算机算法使用时，\n就是依赖计算机不知疲倦的计算能力。\n\n穷举法作为一种算法模式，\n也常常与其他模式配合使用，\n成为某个具体算法中的一部分。\n</code></pre><p>难点</p>\n<pre><code>1. 解空间或状态空间的定义没有具体的模式，\n   不同问题的解空间形式上也差异巨大\n2. 针对不同问题要选择不同的搜索算法，\n   有很多问题的搜索算法并不直观，\n   需要对问题做细致的分析并且依靠丰富的经验才能设计出来。\n3. 在问题的规模大到一定范围时，穷举法只是理论可行。\n   在这种不能对解空间进行完全搜索时，\n   需要对搜索算法进行评估，\n   并确定一些收敛原则。   \n</code></pre><p>步骤</p>\n<pre><code>1. 确定问题的解（或状态）的定义、\n   解空间的范围以及正确解的判定条件。\n2. 根据解空间的特点来选择搜索策略，\n   逐个检验解空间中的候选解是否正确。\n</code></pre><p>解空间的定义</p>\n<pre><code>解空间就是全部可能的候选解的一个约束范围，\n确定问题的解就在这个约束范围内，\n将搜索策略应用到这个约束范围就可以找到问题的解。\n</code></pre><p>穷举解空间的策略</p>\n<pre><code>1. 盲目搜索\n    不带任何假设的穷举搜索，\n    把所有可能的解都检查一遍。\n    -- 广度优先\n        需要额外的存储空间，则应考虑额外空间的规模\n    -- 深度优先\n        容易陷入死循环，则要做状态循环的判断和避免\n\n2. 启发式搜索\n    由启发函数策动有目的的搜索行为，\n    这些策略和依据通常能够加快算法的收敛速度，\n    或能够划定一个更小的、最有可能出现解的空间上搜索。\n    -- 假设解空间符合正态分布\n        可以从分布中间值开始向两边搜索。\n\n3. 剪枝策略\n    在对解空间穷举搜索时，\n    如果有一些状态节点可以根据问题所提供的信息，\n    明确地判定为不可能演化出最优解，\n    则可以跳过此状态节点的遍历。\n</code></pre><p>剪枝和启发</p>\n<pre><code>剪枝是对已产生的结果，根据最优解的判断条件，\n    确定在该方向上不可能存在最优解，\n    从而放弃对这个方向的搜素。\n\n启发是根据启发函数给出的评估值，\n    在结果出来之前就朝着最优解方向搜索\n</code></pre><p>评估与收敛</p>\n<pre><code>收敛原则是只要能找到一个比较好的解就返回，\n根据解的评估判断是否需要继续下一次搜索。  \n</code></pre><p>百钱买百鸡 Python语言实现<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p_m = <span class=\"number\">5</span></span><br><span class=\"line\">p_w = <span class=\"number\">3</span></span><br><span class=\"line\">p_x = <span class=\"number\">1</span> / <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">n = <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, n // p_m):</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, n // p_w):</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i * p_m + j * p_w + (<span class=\"number\">100</span> - i - j) * p_x == <span class=\"number\">100</span>:</span><br><span class=\"line\">            print(i, j, <span class=\"number\">100</span> - i - j)</span><br></pre></td></tr></table></figure></p>\n<p>作业之 鸡兔同笼<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t = <span class=\"number\">50</span></span><br><span class=\"line\">j = <span class=\"number\">120</span></span><br><span class=\"line\">ji = <span class=\"number\">2</span></span><br><span class=\"line\">tu = <span class=\"number\">4</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> tu_num <span class=\"keyword\">in</span> range(j // tu):</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> tu_num * tu + (t - tu_num) * ji == j:</span><br><span class=\"line\">        print(tu_num, t - tu_num)</span><br></pre></td></tr></table></figure></p>\n"},{"title":"算法设计常用思想之迭代法","_content":"\n迭代法\n\n    数字意义上是一种不断用变量的旧值递推新值的过程，\n    其相应的迭代算法也是用计算机解决问题的一种基本方法。\n    \n    迭代法，还有一种更广泛的观点，\n    就是所有使用了迭代思想的算法实现，\n    都可以理解为是使用了迭代法。\n    从这个角度理解，\n    除了线性动态规划算法、\n    遗传算法、退火算法等算法\n    也可归入迭代法的范畴。\n    \n迭代法的实现\n\n    确定迭代变量：\n        迭代变量一般就是要求解的问题的解，\n        利用迭代递推公式可以不断地由旧值递推出新值。\n        根据问题的不同，迭代变量可以是一个，也可以是多个。\n        确定迭代变量，通常还要根据迭代递推关系给出迭代变量的初始值，\n        这一点也很重要。\n    \n    确定迭代递推关系：\n        迭代递推关系是根据旧值计算新值的关系或公式，\n        这是迭代法实现的关键，如果不能确定迭代关系，\n        则无法用迭代法实现算法。\n    \n    确定迭代终止条件：\n        迭代终止条件是控制迭代过程退出的关键条件。\n        迭代不可能无休止地进行，必须设置迭代终止条件，\n        在适当的时候退出迭代。\n        \n        迭代终止条件一般有三种假设：\n        其一是迭代变量已经求得问题的精确值；\n        其二是迭代变量无法得到精确值，\n        但是某个迭代的值的精度已经满足要求；\n        其三是指定明确的迭代计算次数。\n        \n        迭代算法的具体实现，可根据问题的类型选择迭代终止条件。\n        一般情况下，为了防止迭代关系在某个区间上发散（不收敛）\n        使得算法进入死循环，都会把第三个条件作为异常退出条件\n        和其他迭代终止条件配合使用，也就是说，\n        即使无法得到符合条件的解，\n        只要迭代计算次数达到某个限制值，\n        也退出迭代过程。\n\n    \n常见的迭代法\n    \n    梯度法\n    最小二乘法\n    牛顿迭代法\n\n迭代法和递推法\n\n    迭代法作为很多数学问题的求解算法，\n    是解决数学问题的一种常用的算法模式，\n    可以独立构成解决问题的算法。\n    \n    递推法作为一种设计算法的常用思想，\n    没有固定的算法实现模式，\n    通常是与其他算法模式配合形成算法实现。\n    比如线性动态规划问题，\n    一般都有明确的子问题最优解递推公式，\n    递推思想常常作为算法实现的一部分\n    融入到动态规划算法的实现中。\n\n使用Python实现 求根函数 并与内置求根函数对比\n```python\nimport math\n\n\ndef like_sqrt(num: int):\n    xi = num / 2\n    xt = xi\n    xi = (xt + num / xt) / 2\n    count = 1\n    eps = 0.1 ** 6\n\n    while abs(xi - xt) > eps:\n        xt = xi\n        xi = (xt + num / xt) / 2\n\n        count += 1\n    print(xi)\n\n\nprint(math.sqrt(3))\nlike_sqrt(3)\n```","source":"_posts/训练营/基础卡05-迭代法.md","raw":"---\ntitle: 算法设计常用思想之迭代法\n---\n\n迭代法\n\n    数字意义上是一种不断用变量的旧值递推新值的过程，\n    其相应的迭代算法也是用计算机解决问题的一种基本方法。\n    \n    迭代法，还有一种更广泛的观点，\n    就是所有使用了迭代思想的算法实现，\n    都可以理解为是使用了迭代法。\n    从这个角度理解，\n    除了线性动态规划算法、\n    遗传算法、退火算法等算法\n    也可归入迭代法的范畴。\n    \n迭代法的实现\n\n    确定迭代变量：\n        迭代变量一般就是要求解的问题的解，\n        利用迭代递推公式可以不断地由旧值递推出新值。\n        根据问题的不同，迭代变量可以是一个，也可以是多个。\n        确定迭代变量，通常还要根据迭代递推关系给出迭代变量的初始值，\n        这一点也很重要。\n    \n    确定迭代递推关系：\n        迭代递推关系是根据旧值计算新值的关系或公式，\n        这是迭代法实现的关键，如果不能确定迭代关系，\n        则无法用迭代法实现算法。\n    \n    确定迭代终止条件：\n        迭代终止条件是控制迭代过程退出的关键条件。\n        迭代不可能无休止地进行，必须设置迭代终止条件，\n        在适当的时候退出迭代。\n        \n        迭代终止条件一般有三种假设：\n        其一是迭代变量已经求得问题的精确值；\n        其二是迭代变量无法得到精确值，\n        但是某个迭代的值的精度已经满足要求；\n        其三是指定明确的迭代计算次数。\n        \n        迭代算法的具体实现，可根据问题的类型选择迭代终止条件。\n        一般情况下，为了防止迭代关系在某个区间上发散（不收敛）\n        使得算法进入死循环，都会把第三个条件作为异常退出条件\n        和其他迭代终止条件配合使用，也就是说，\n        即使无法得到符合条件的解，\n        只要迭代计算次数达到某个限制值，\n        也退出迭代过程。\n\n    \n常见的迭代法\n    \n    梯度法\n    最小二乘法\n    牛顿迭代法\n\n迭代法和递推法\n\n    迭代法作为很多数学问题的求解算法，\n    是解决数学问题的一种常用的算法模式，\n    可以独立构成解决问题的算法。\n    \n    递推法作为一种设计算法的常用思想，\n    没有固定的算法实现模式，\n    通常是与其他算法模式配合形成算法实现。\n    比如线性动态规划问题，\n    一般都有明确的子问题最优解递推公式，\n    递推思想常常作为算法实现的一部分\n    融入到动态规划算法的实现中。\n\n使用Python实现 求根函数 并与内置求根函数对比\n```python\nimport math\n\n\ndef like_sqrt(num: int):\n    xi = num / 2\n    xt = xi\n    xi = (xt + num / xt) / 2\n    count = 1\n    eps = 0.1 ** 6\n\n    while abs(xi - xt) > eps:\n        xt = xi\n        xi = (xt + num / xt) / 2\n\n        count += 1\n    print(xi)\n\n\nprint(math.sqrt(3))\nlike_sqrt(3)\n```","slug":"训练营/基础卡05-迭代法","published":1,"date":"2019-04-05T10:12:00.664Z","updated":"2019-04-05T10:12:00.665Z","_id":"cjwd4bmov000ksv72s4d7jsby","comments":1,"layout":"post","photos":[],"link":"","content":"<p>迭代法</p>\n<pre><code>数字意义上是一种不断用变量的旧值递推新值的过程，\n其相应的迭代算法也是用计算机解决问题的一种基本方法。\n\n迭代法，还有一种更广泛的观点，\n就是所有使用了迭代思想的算法实现，\n都可以理解为是使用了迭代法。\n从这个角度理解，\n除了线性动态规划算法、\n遗传算法、退火算法等算法\n也可归入迭代法的范畴。\n</code></pre><p>迭代法的实现</p>\n<pre><code>确定迭代变量：\n    迭代变量一般就是要求解的问题的解，\n    利用迭代递推公式可以不断地由旧值递推出新值。\n    根据问题的不同，迭代变量可以是一个，也可以是多个。\n    确定迭代变量，通常还要根据迭代递推关系给出迭代变量的初始值，\n    这一点也很重要。\n\n确定迭代递推关系：\n    迭代递推关系是根据旧值计算新值的关系或公式，\n    这是迭代法实现的关键，如果不能确定迭代关系，\n    则无法用迭代法实现算法。\n\n确定迭代终止条件：\n    迭代终止条件是控制迭代过程退出的关键条件。\n    迭代不可能无休止地进行，必须设置迭代终止条件，\n    在适当的时候退出迭代。\n\n    迭代终止条件一般有三种假设：\n    其一是迭代变量已经求得问题的精确值；\n    其二是迭代变量无法得到精确值，\n    但是某个迭代的值的精度已经满足要求；\n    其三是指定明确的迭代计算次数。\n\n    迭代算法的具体实现，可根据问题的类型选择迭代终止条件。\n    一般情况下，为了防止迭代关系在某个区间上发散（不收敛）\n    使得算法进入死循环，都会把第三个条件作为异常退出条件\n    和其他迭代终止条件配合使用，也就是说，\n    即使无法得到符合条件的解，\n    只要迭代计算次数达到某个限制值，\n    也退出迭代过程。\n</code></pre><p>常见的迭代法</p>\n<pre><code>梯度法\n最小二乘法\n牛顿迭代法\n</code></pre><p>迭代法和递推法</p>\n<pre><code>迭代法作为很多数学问题的求解算法，\n是解决数学问题的一种常用的算法模式，\n可以独立构成解决问题的算法。\n\n递推法作为一种设计算法的常用思想，\n没有固定的算法实现模式，\n通常是与其他算法模式配合形成算法实现。\n比如线性动态规划问题，\n一般都有明确的子问题最优解递推公式，\n递推思想常常作为算法实现的一部分\n融入到动态规划算法的实现中。\n</code></pre><p>使用Python实现 求根函数 并与内置求根函数对比<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">like_sqrt</span><span class=\"params\">(num: int)</span>:</span></span><br><span class=\"line\">    xi = num / <span class=\"number\">2</span></span><br><span class=\"line\">    xt = xi</span><br><span class=\"line\">    xi = (xt + num / xt) / <span class=\"number\">2</span></span><br><span class=\"line\">    count = <span class=\"number\">1</span></span><br><span class=\"line\">    eps = <span class=\"number\">0.1</span> ** <span class=\"number\">6</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> abs(xi - xt) &gt; eps:</span><br><span class=\"line\">        xt = xi</span><br><span class=\"line\">        xi = (xt + num / xt) / <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">        count += <span class=\"number\">1</span></span><br><span class=\"line\">    print(xi)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">print(math.sqrt(<span class=\"number\">3</span>))</span><br><span class=\"line\">like_sqrt(<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>迭代法</p>\n<pre><code>数字意义上是一种不断用变量的旧值递推新值的过程，\n其相应的迭代算法也是用计算机解决问题的一种基本方法。\n\n迭代法，还有一种更广泛的观点，\n就是所有使用了迭代思想的算法实现，\n都可以理解为是使用了迭代法。\n从这个角度理解，\n除了线性动态规划算法、\n遗传算法、退火算法等算法\n也可归入迭代法的范畴。\n</code></pre><p>迭代法的实现</p>\n<pre><code>确定迭代变量：\n    迭代变量一般就是要求解的问题的解，\n    利用迭代递推公式可以不断地由旧值递推出新值。\n    根据问题的不同，迭代变量可以是一个，也可以是多个。\n    确定迭代变量，通常还要根据迭代递推关系给出迭代变量的初始值，\n    这一点也很重要。\n\n确定迭代递推关系：\n    迭代递推关系是根据旧值计算新值的关系或公式，\n    这是迭代法实现的关键，如果不能确定迭代关系，\n    则无法用迭代法实现算法。\n\n确定迭代终止条件：\n    迭代终止条件是控制迭代过程退出的关键条件。\n    迭代不可能无休止地进行，必须设置迭代终止条件，\n    在适当的时候退出迭代。\n\n    迭代终止条件一般有三种假设：\n    其一是迭代变量已经求得问题的精确值；\n    其二是迭代变量无法得到精确值，\n    但是某个迭代的值的精度已经满足要求；\n    其三是指定明确的迭代计算次数。\n\n    迭代算法的具体实现，可根据问题的类型选择迭代终止条件。\n    一般情况下，为了防止迭代关系在某个区间上发散（不收敛）\n    使得算法进入死循环，都会把第三个条件作为异常退出条件\n    和其他迭代终止条件配合使用，也就是说，\n    即使无法得到符合条件的解，\n    只要迭代计算次数达到某个限制值，\n    也退出迭代过程。\n</code></pre><p>常见的迭代法</p>\n<pre><code>梯度法\n最小二乘法\n牛顿迭代法\n</code></pre><p>迭代法和递推法</p>\n<pre><code>迭代法作为很多数学问题的求解算法，\n是解决数学问题的一种常用的算法模式，\n可以独立构成解决问题的算法。\n\n递推法作为一种设计算法的常用思想，\n没有固定的算法实现模式，\n通常是与其他算法模式配合形成算法实现。\n比如线性动态规划问题，\n一般都有明确的子问题最优解递推公式，\n递推思想常常作为算法实现的一部分\n融入到动态规划算法的实现中。\n</code></pre><p>使用Python实现 求根函数 并与内置求根函数对比<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">like_sqrt</span><span class=\"params\">(num: int)</span>:</span></span><br><span class=\"line\">    xi = num / <span class=\"number\">2</span></span><br><span class=\"line\">    xt = xi</span><br><span class=\"line\">    xi = (xt + num / xt) / <span class=\"number\">2</span></span><br><span class=\"line\">    count = <span class=\"number\">1</span></span><br><span class=\"line\">    eps = <span class=\"number\">0.1</span> ** <span class=\"number\">6</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> abs(xi - xt) &gt; eps:</span><br><span class=\"line\">        xt = xi</span><br><span class=\"line\">        xi = (xt + num / xt) / <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">        count += <span class=\"number\">1</span></span><br><span class=\"line\">    print(xi)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">print(math.sqrt(<span class=\"number\">3</span>))</span><br><span class=\"line\">like_sqrt(<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure></p>\n"},{"title":"基础开胃菜","_content":"\n常用技巧\n\n    哨兵位\n        \n        通常起到两个作用，\n        一个是作为一个临时存储空间使用，\n        另一个是减少不必要的越界判断，\n        简化算法代码复杂度。\n    \n    \n    巧用数组下标\n        \n        数组的下标是一个隐含的很有用的属性，\n        巧妙地使用这个属性，\n        对简化算法实现有很大的帮助。\n        \n    \n    取余的用法\n    \n        取余运算基本上还是一个除法运算，\n        如果仅仅是判断奇偶数，\n        判断（number & 1）是否等于 0 是更好的方法。\n        \n        更一般的情况，当取余运算的除数是 2 的 n 次方的时候，\n        用 & 运算符代替取余会更高效。比如当 x=2n 的时候，\n        a % x 的结果与 a & (x - 1) 的结果是等价的。\n        \n    使用双指针来判断链表是否有环\n    \n    \n    数组链表\n        \n        数组的特点是存储空间固定，数据存取高效，\n        但是缺点是数据插入和删除需要移动数组元素，\n        不适合插入和删除比较频繁的场合。\n        链表的特点恰恰是插入和删除比较高效，\n        但是缺点是需要动态申请存储空间，在一些系统上，\n        内存申请和释放的开销比较大，使用链表存在性能问题。\n    \n    \n    topN 问题和最小堆\n        \n    常用的 hash 算法 作字符串比较\n    \n    以空间换时间的策略\n","source":"_posts/训练营/基础卡06-基础开胃菜.md","raw":"---\ntitle: 基础开胃菜\n---\n\n常用技巧\n\n    哨兵位\n        \n        通常起到两个作用，\n        一个是作为一个临时存储空间使用，\n        另一个是减少不必要的越界判断，\n        简化算法代码复杂度。\n    \n    \n    巧用数组下标\n        \n        数组的下标是一个隐含的很有用的属性，\n        巧妙地使用这个属性，\n        对简化算法实现有很大的帮助。\n        \n    \n    取余的用法\n    \n        取余运算基本上还是一个除法运算，\n        如果仅仅是判断奇偶数，\n        判断（number & 1）是否等于 0 是更好的方法。\n        \n        更一般的情况，当取余运算的除数是 2 的 n 次方的时候，\n        用 & 运算符代替取余会更高效。比如当 x=2n 的时候，\n        a % x 的结果与 a & (x - 1) 的结果是等价的。\n        \n    使用双指针来判断链表是否有环\n    \n    \n    数组链表\n        \n        数组的特点是存储空间固定，数据存取高效，\n        但是缺点是数据插入和删除需要移动数组元素，\n        不适合插入和删除比较频繁的场合。\n        链表的特点恰恰是插入和删除比较高效，\n        但是缺点是需要动态申请存储空间，在一些系统上，\n        内存申请和释放的开销比较大，使用链表存在性能问题。\n    \n    \n    topN 问题和最小堆\n        \n    常用的 hash 算法 作字符串比较\n    \n    以空间换时间的策略\n","slug":"训练营/基础卡06-基础开胃菜","published":1,"date":"2019-04-04T15:23:44.593Z","updated":"2019-04-04T15:23:44.593Z","_id":"cjwd4bmow000lsv72rexyzxji","comments":1,"layout":"post","photos":[],"link":"","content":"<p>常用技巧</p>\n<pre><code>哨兵位\n\n    通常起到两个作用，\n    一个是作为一个临时存储空间使用，\n    另一个是减少不必要的越界判断，\n    简化算法代码复杂度。\n\n\n巧用数组下标\n\n    数组的下标是一个隐含的很有用的属性，\n    巧妙地使用这个属性，\n    对简化算法实现有很大的帮助。\n\n\n取余的用法\n\n    取余运算基本上还是一个除法运算，\n    如果仅仅是判断奇偶数，\n    判断（number &amp; 1）是否等于 0 是更好的方法。\n\n    更一般的情况，当取余运算的除数是 2 的 n 次方的时候，\n    用 &amp; 运算符代替取余会更高效。比如当 x=2n 的时候，\n    a % x 的结果与 a &amp; (x - 1) 的结果是等价的。\n\n使用双指针来判断链表是否有环\n\n\n数组链表\n\n    数组的特点是存储空间固定，数据存取高效，\n    但是缺点是数据插入和删除需要移动数组元素，\n    不适合插入和删除比较频繁的场合。\n    链表的特点恰恰是插入和删除比较高效，\n    但是缺点是需要动态申请存储空间，在一些系统上，\n    内存申请和释放的开销比较大，使用链表存在性能问题。\n\n\ntopN 问题和最小堆\n\n常用的 hash 算法 作字符串比较\n\n以空间换时间的策略\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>常用技巧</p>\n<pre><code>哨兵位\n\n    通常起到两个作用，\n    一个是作为一个临时存储空间使用，\n    另一个是减少不必要的越界判断，\n    简化算法代码复杂度。\n\n\n巧用数组下标\n\n    数组的下标是一个隐含的很有用的属性，\n    巧妙地使用这个属性，\n    对简化算法实现有很大的帮助。\n\n\n取余的用法\n\n    取余运算基本上还是一个除法运算，\n    如果仅仅是判断奇偶数，\n    判断（number &amp; 1）是否等于 0 是更好的方法。\n\n    更一般的情况，当取余运算的除数是 2 的 n 次方的时候，\n    用 &amp; 运算符代替取余会更高效。比如当 x=2n 的时候，\n    a % x 的结果与 a &amp; (x - 1) 的结果是等价的。\n\n使用双指针来判断链表是否有环\n\n\n数组链表\n\n    数组的特点是存储空间固定，数据存取高效，\n    但是缺点是数据插入和删除需要移动数组元素，\n    不适合插入和删除比较频繁的场合。\n    链表的特点恰恰是插入和删除比较高效，\n    但是缺点是需要动态申请存储空间，在一些系统上，\n    内存申请和释放的开销比较大，使用链表存在性能问题。\n\n\ntopN 问题和最小堆\n\n常用的 hash 算法 作字符串比较\n\n以空间换时间的策略\n</code></pre>"},{"title":"开营仪式","_content":"\n什么是算法\n    \n    任何一个解决问题的方法都不会凭空出现，\n    而在计算机中解决问题的方法统称为算法。\n    \n    一系列的数学计算或解题步骤，\n    算法存在的意义是解决问题，\n    软件开发工作着的日常就是开发各种能够解决问题的算法。\n    \n    算法并非不食人间烟火之物，\n    更不是ACM竞赛选手的特权，\n    大部分人在工作中遇到的问题并非像ACM竞赛那样的难题。\n    \n\n算法的作用：\n\n    编程能力大致体现在，\n    逻辑思维能力、\n    抽象建模能力、\n    编程方法和技巧，\n    都需要通过实践获得。\n    \n    时间复杂度，\n    空间复杂度，\n    计算效率，\n    计算过程对其他模块的影响。\n\n\n开营的目的：\n    \n    掌握设计算法的方法与技巧\n    \n    也是软件开发人员必备的条件\n        \n    掌握常用设计模式\n    \n    在练习中积累经验\n    \n分类：\n    \n    1. 已知的并有成熟或高效的实现方法\n    2. 只有理论但是没有具体实现的算法，\n       需要掌握算法原理，翻译成代码实现。\n        遗传算法，基本思想 迭代法，\n        根据迭代中的遗传和变异，\n        淘汰掉不符合的个体，\n        得到优良的种群。\n        不同的问题针对基因有不同的建模，\n        需要根据算法的原理，基因的不同，方法的实现进行调整。\n    3. 工作中遇见的实际问题，\n       或竞赛中具有针对性的问题\n        需要掌握常用的算法模式。\n        文字信息数字化。\n    \n课后练习：\n    \n    针对知识点设计的练习题，要按时按量完成。\n\n\n学习强度高，跟着走，坚持\n\n    长风破浪会有时，直挂云帆济沧海\n    动手能力\n    解决问题的能力","source":"_posts/训练营/开营仪式.md","raw":"---\ntitle: 开营仪式\n---\n\n什么是算法\n    \n    任何一个解决问题的方法都不会凭空出现，\n    而在计算机中解决问题的方法统称为算法。\n    \n    一系列的数学计算或解题步骤，\n    算法存在的意义是解决问题，\n    软件开发工作着的日常就是开发各种能够解决问题的算法。\n    \n    算法并非不食人间烟火之物，\n    更不是ACM竞赛选手的特权，\n    大部分人在工作中遇到的问题并非像ACM竞赛那样的难题。\n    \n\n算法的作用：\n\n    编程能力大致体现在，\n    逻辑思维能力、\n    抽象建模能力、\n    编程方法和技巧，\n    都需要通过实践获得。\n    \n    时间复杂度，\n    空间复杂度，\n    计算效率，\n    计算过程对其他模块的影响。\n\n\n开营的目的：\n    \n    掌握设计算法的方法与技巧\n    \n    也是软件开发人员必备的条件\n        \n    掌握常用设计模式\n    \n    在练习中积累经验\n    \n分类：\n    \n    1. 已知的并有成熟或高效的实现方法\n    2. 只有理论但是没有具体实现的算法，\n       需要掌握算法原理，翻译成代码实现。\n        遗传算法，基本思想 迭代法，\n        根据迭代中的遗传和变异，\n        淘汰掉不符合的个体，\n        得到优良的种群。\n        不同的问题针对基因有不同的建模，\n        需要根据算法的原理，基因的不同，方法的实现进行调整。\n    3. 工作中遇见的实际问题，\n       或竞赛中具有针对性的问题\n        需要掌握常用的算法模式。\n        文字信息数字化。\n    \n课后练习：\n    \n    针对知识点设计的练习题，要按时按量完成。\n\n\n学习强度高，跟着走，坚持\n\n    长风破浪会有时，直挂云帆济沧海\n    动手能力\n    解决问题的能力","slug":"训练营/开营仪式","published":1,"date":"2019-04-01T13:59:00.284Z","updated":"2019-04-01T13:59:00.284Z","_id":"cjwd4bvbn000msv72ji46pkzh","comments":1,"layout":"post","photos":[],"link":"","content":"<p>什么是算法</p>\n<pre><code>任何一个解决问题的方法都不会凭空出现，\n而在计算机中解决问题的方法统称为算法。\n\n一系列的数学计算或解题步骤，\n算法存在的意义是解决问题，\n软件开发工作着的日常就是开发各种能够解决问题的算法。\n\n算法并非不食人间烟火之物，\n更不是ACM竞赛选手的特权，\n大部分人在工作中遇到的问题并非像ACM竞赛那样的难题。\n</code></pre><p>算法的作用：</p>\n<pre><code>编程能力大致体现在，\n逻辑思维能力、\n抽象建模能力、\n编程方法和技巧，\n都需要通过实践获得。\n\n时间复杂度，\n空间复杂度，\n计算效率，\n计算过程对其他模块的影响。\n</code></pre><p>开营的目的：</p>\n<pre><code>掌握设计算法的方法与技巧\n\n也是软件开发人员必备的条件\n\n掌握常用设计模式\n\n在练习中积累经验\n</code></pre><p>分类：</p>\n<pre><code>1. 已知的并有成熟或高效的实现方法\n2. 只有理论但是没有具体实现的算法，\n   需要掌握算法原理，翻译成代码实现。\n    遗传算法，基本思想 迭代法，\n    根据迭代中的遗传和变异，\n    淘汰掉不符合的个体，\n    得到优良的种群。\n    不同的问题针对基因有不同的建模，\n    需要根据算法的原理，基因的不同，方法的实现进行调整。\n3. 工作中遇见的实际问题，\n   或竞赛中具有针对性的问题\n    需要掌握常用的算法模式。\n    文字信息数字化。\n</code></pre><p>课后练习：</p>\n<pre><code>针对知识点设计的练习题，要按时按量完成。\n</code></pre><p>学习强度高，跟着走，坚持</p>\n<pre><code>长风破浪会有时，直挂云帆济沧海\n动手能力\n解决问题的能力\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>什么是算法</p>\n<pre><code>任何一个解决问题的方法都不会凭空出现，\n而在计算机中解决问题的方法统称为算法。\n\n一系列的数学计算或解题步骤，\n算法存在的意义是解决问题，\n软件开发工作着的日常就是开发各种能够解决问题的算法。\n\n算法并非不食人间烟火之物，\n更不是ACM竞赛选手的特权，\n大部分人在工作中遇到的问题并非像ACM竞赛那样的难题。\n</code></pre><p>算法的作用：</p>\n<pre><code>编程能力大致体现在，\n逻辑思维能力、\n抽象建模能力、\n编程方法和技巧，\n都需要通过实践获得。\n\n时间复杂度，\n空间复杂度，\n计算效率，\n计算过程对其他模块的影响。\n</code></pre><p>开营的目的：</p>\n<pre><code>掌握设计算法的方法与技巧\n\n也是软件开发人员必备的条件\n\n掌握常用设计模式\n\n在练习中积累经验\n</code></pre><p>分类：</p>\n<pre><code>1. 已知的并有成熟或高效的实现方法\n2. 只有理论但是没有具体实现的算法，\n   需要掌握算法原理，翻译成代码实现。\n    遗传算法，基本思想 迭代法，\n    根据迭代中的遗传和变异，\n    淘汰掉不符合的个体，\n    得到优良的种群。\n    不同的问题针对基因有不同的建模，\n    需要根据算法的原理，基因的不同，方法的实现进行调整。\n3. 工作中遇见的实际问题，\n   或竞赛中具有针对性的问题\n    需要掌握常用的算法模式。\n    文字信息数字化。\n</code></pre><p>课后练习：</p>\n<pre><code>针对知识点设计的练习题，要按时按量完成。\n</code></pre><p>学习强度高，跟着走，坚持</p>\n<pre><code>长风破浪会有时，直挂云帆济沧海\n动手能力\n解决问题的能力\n</code></pre>"},{"title":"算法是程序的\"灵魂\"","_content":"\n目标\n    \n    通过学习各算法的实现，掌握算法设计方法，在面对实际问题的时候，具备设计并实现解决问题的算法\n\n\n算法的两大特点\n    \n    纷繁复杂、知识多广。\n    设计数学模型并不会因为设计模式的完善而变得简单。\n\n常见的算法设计方法\n    \n    迭代法\n    穷举搜索法\n    分界界限法(剪枝法)\n    递推法\n    递归法\n    回溯法\n    分治法\n    贪婪法\n    动态规划法\n    \n注意\n    \n    尽管算法设计的常用方法很多，但是这些放法之间并不是孤立的。\n    如牛顿迭代法，还有些递推关系需要通过广域搜索来实现，比如常见的动态规划算法。\n    贪婪法很少单独用于解决最优解问题，但是贪婪法的思想体现在很多算法中，\n    比如著名的“Dijkstra 算法”，在确定某个顶点的下一个最短路径点时，\n    就使用了贪婪法的思想，每次选择距离最近的那个点作为下一个顶点。","source":"_posts/训练营/热身卡01-开篇词：算法是程序的灵魂.md","raw":"---\ntitle: 算法是程序的\"灵魂\"\n---\n\n目标\n    \n    通过学习各算法的实现，掌握算法设计方法，在面对实际问题的时候，具备设计并实现解决问题的算法\n\n\n算法的两大特点\n    \n    纷繁复杂、知识多广。\n    设计数学模型并不会因为设计模式的完善而变得简单。\n\n常见的算法设计方法\n    \n    迭代法\n    穷举搜索法\n    分界界限法(剪枝法)\n    递推法\n    递归法\n    回溯法\n    分治法\n    贪婪法\n    动态规划法\n    \n注意\n    \n    尽管算法设计的常用方法很多，但是这些放法之间并不是孤立的。\n    如牛顿迭代法，还有些递推关系需要通过广域搜索来实现，比如常见的动态规划算法。\n    贪婪法很少单独用于解决最优解问题，但是贪婪法的思想体现在很多算法中，\n    比如著名的“Dijkstra 算法”，在确定某个顶点的下一个最短路径点时，\n    就使用了贪婪法的思想，每次选择距离最近的那个点作为下一个顶点。","slug":"训练营/热身卡01-开篇词：算法是程序的灵魂","published":1,"date":"2019-04-01T09:59:49.338Z","updated":"2019-04-01T09:59:49.338Z","_id":"cjwd4c78d000nsv72822yuam0","comments":1,"layout":"post","photos":[],"link":"","content":"<p>目标</p>\n<pre><code>通过学习各算法的实现，掌握算法设计方法，在面对实际问题的时候，具备设计并实现解决问题的算法\n</code></pre><p>算法的两大特点</p>\n<pre><code>纷繁复杂、知识多广。\n设计数学模型并不会因为设计模式的完善而变得简单。\n</code></pre><p>常见的算法设计方法</p>\n<pre><code>迭代法\n穷举搜索法\n分界界限法(剪枝法)\n递推法\n递归法\n回溯法\n分治法\n贪婪法\n动态规划法\n</code></pre><p>注意</p>\n<pre><code>尽管算法设计的常用方法很多，但是这些放法之间并不是孤立的。\n如牛顿迭代法，还有些递推关系需要通过广域搜索来实现，比如常见的动态规划算法。\n贪婪法很少单独用于解决最优解问题，但是贪婪法的思想体现在很多算法中，\n比如著名的“Dijkstra 算法”，在确定某个顶点的下一个最短路径点时，\n就使用了贪婪法的思想，每次选择距离最近的那个点作为下一个顶点。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>目标</p>\n<pre><code>通过学习各算法的实现，掌握算法设计方法，在面对实际问题的时候，具备设计并实现解决问题的算法\n</code></pre><p>算法的两大特点</p>\n<pre><code>纷繁复杂、知识多广。\n设计数学模型并不会因为设计模式的完善而变得简单。\n</code></pre><p>常见的算法设计方法</p>\n<pre><code>迭代法\n穷举搜索法\n分界界限法(剪枝法)\n递推法\n递归法\n回溯法\n分治法\n贪婪法\n动态规划法\n</code></pre><p>注意</p>\n<pre><code>尽管算法设计的常用方法很多，但是这些放法之间并不是孤立的。\n如牛顿迭代法，还有些递推关系需要通过广域搜索来实现，比如常见的动态规划算法。\n贪婪法很少单独用于解决最优解问题，但是贪婪法的思想体现在很多算法中，\n比如著名的“Dijkstra 算法”，在确定某个顶点的下一个最短路径点时，\n就使用了贪婪法的思想，每次选择距离最近的那个点作为下一个顶点。\n</code></pre>"},{"title":"入门测试题","_content":"\n目标\n    \n    定位自我\n    \n\n思考点1 [只是了解一般不用 == 判断浮点数相等，对于能够判断的浮点数集认识不深刻]\n    \n    在诸如Java、C++或Python语言中，一般不用 \"==\" 判断两个浮点数相等。\n    浮点数在计算机内的表达有误差，直接使用 \"==\" 来判断两个浮点数是否相等是不安全的。\n    只有部分能够精确表达的浮点数，如0.0, 0.5(1/2)，0.25(1/4)等浮点数，使用 \"==\" 判断\n    浮点数值相等是没问题的，其他情况则会产生意想不到的结果。\n    \n\n思考点2 [动态规划和分治法的区别，增加例子来理解]\n    \n    动态规划区别于分治法是其子问题具备\"无后向性\"，在各阶段的子问题确定后，\n    对于特定阶段的子问题来说，它之前各个阶段的子问题的决策只影响该阶段的决策，\n    对该阶段之后的决策不产生影响。\n    \n\n思考点3 [对诸如Dijkstra、A*等经典算法生疏，对图结构生疏]\n\n\n思考点4 [由排序算法时间复杂度引出的讨论]\n\n>@5年-余努力-成都-杂家 \n\n    桶排序的平均时间复杂度为线性的O(N+C)，其中C=N*(logN-logM)。\n    如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。\n    当N=M时，就是计数排序。\n    \n   \n>@应届-乌凌-c++    \n```c++\nvoid radix_sort(int *num, int n) {\n#define MAX 65536\n\tint *temp = (int*)calloc(n, sizeof(int));\n\tint *cnt = (int*)calloc(MAX + 5, sizeof(int));\n\tfor (int i = 0; i < n; i++) {\n\t\tcnt[(num[i] & 65535) + 1] += 1;\n\t}\n\tfor (int i = 0; i < MAX; i++) cnt[i] += cnt[i - 1];\n\tfor (int i = 0; i < n; i++) {\n\t\ttemp[cnt[num[i] & 65535]++] = num[i];\n\t}\n\tmemset(cnt, 0, sizeof(int) * MAX);\n\tint *p = temp;\n\ttemp = num;\n\tnum = p;\n\tfor (int i = 0; i < n; i++) {\n\t\tcnt[((num[i] >> 16) & 65535) + 1] += 1;\n\t}\n\tfor (int i = 0; i < MAX; i++) cnt[i] += cnt[i - 1];\n\tfor (int i = 0; i < n; i++) {\n\t\ttemp[cnt[(num[i] >> 16) & 65535]++] = num[i];\n\t}\n\tfree(num);\n\tnum = temp;\n\tfree(cnt);\n#undef MAX\n}\n\n```\n\n>个人对排序的补充\n    \n    快速排序\n    归并排序\n    堆排序","source":"_posts/训练营/热身卡02-入门测试题.md","raw":"---\ntitle: 入门测试题\n---\n\n目标\n    \n    定位自我\n    \n\n思考点1 [只是了解一般不用 == 判断浮点数相等，对于能够判断的浮点数集认识不深刻]\n    \n    在诸如Java、C++或Python语言中，一般不用 \"==\" 判断两个浮点数相等。\n    浮点数在计算机内的表达有误差，直接使用 \"==\" 来判断两个浮点数是否相等是不安全的。\n    只有部分能够精确表达的浮点数，如0.0, 0.5(1/2)，0.25(1/4)等浮点数，使用 \"==\" 判断\n    浮点数值相等是没问题的，其他情况则会产生意想不到的结果。\n    \n\n思考点2 [动态规划和分治法的区别，增加例子来理解]\n    \n    动态规划区别于分治法是其子问题具备\"无后向性\"，在各阶段的子问题确定后，\n    对于特定阶段的子问题来说，它之前各个阶段的子问题的决策只影响该阶段的决策，\n    对该阶段之后的决策不产生影响。\n    \n\n思考点3 [对诸如Dijkstra、A*等经典算法生疏，对图结构生疏]\n\n\n思考点4 [由排序算法时间复杂度引出的讨论]\n\n>@5年-余努力-成都-杂家 \n\n    桶排序的平均时间复杂度为线性的O(N+C)，其中C=N*(logN-logM)。\n    如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。\n    当N=M时，就是计数排序。\n    \n   \n>@应届-乌凌-c++    \n```c++\nvoid radix_sort(int *num, int n) {\n#define MAX 65536\n\tint *temp = (int*)calloc(n, sizeof(int));\n\tint *cnt = (int*)calloc(MAX + 5, sizeof(int));\n\tfor (int i = 0; i < n; i++) {\n\t\tcnt[(num[i] & 65535) + 1] += 1;\n\t}\n\tfor (int i = 0; i < MAX; i++) cnt[i] += cnt[i - 1];\n\tfor (int i = 0; i < n; i++) {\n\t\ttemp[cnt[num[i] & 65535]++] = num[i];\n\t}\n\tmemset(cnt, 0, sizeof(int) * MAX);\n\tint *p = temp;\n\ttemp = num;\n\tnum = p;\n\tfor (int i = 0; i < n; i++) {\n\t\tcnt[((num[i] >> 16) & 65535) + 1] += 1;\n\t}\n\tfor (int i = 0; i < MAX; i++) cnt[i] += cnt[i - 1];\n\tfor (int i = 0; i < n; i++) {\n\t\ttemp[cnt[(num[i] >> 16) & 65535]++] = num[i];\n\t}\n\tfree(num);\n\tnum = temp;\n\tfree(cnt);\n#undef MAX\n}\n\n```\n\n>个人对排序的补充\n    \n    快速排序\n    归并排序\n    堆排序","slug":"训练营/热身卡02-入门测试题","published":1,"date":"2019-04-01T09:59:49.330Z","updated":"2019-04-01T09:59:49.330Z","_id":"cjwd4c78e000osv72wfla2yc5","comments":1,"layout":"post","photos":[],"link":"","content":"<p>目标</p>\n<pre><code>定位自我\n</code></pre><p>思考点1 [只是了解一般不用 == 判断浮点数相等，对于能够判断的浮点数集认识不深刻]</p>\n<pre><code>在诸如Java、C++或Python语言中，一般不用 &quot;==&quot; 判断两个浮点数相等。\n浮点数在计算机内的表达有误差，直接使用 &quot;==&quot; 来判断两个浮点数是否相等是不安全的。\n只有部分能够精确表达的浮点数，如0.0, 0.5(1/2)，0.25(1/4)等浮点数，使用 &quot;==&quot; 判断\n浮点数值相等是没问题的，其他情况则会产生意想不到的结果。\n</code></pre><p>思考点2 [动态规划和分治法的区别，增加例子来理解]</p>\n<pre><code>动态规划区别于分治法是其子问题具备&quot;无后向性&quot;，在各阶段的子问题确定后，\n对于特定阶段的子问题来说，它之前各个阶段的子问题的决策只影响该阶段的决策，\n对该阶段之后的决策不产生影响。\n</code></pre><p>思考点3 [对诸如Dijkstra、A*等经典算法生疏，对图结构生疏]</p>\n<p>思考点4 [由排序算法时间复杂度引出的讨论]</p>\n<blockquote>\n<p>@5年-余努力-成都-杂家 </p>\n</blockquote>\n<pre><code>桶排序的平均时间复杂度为线性的O(N+C)，其中C=N*(logN-logM)。\n如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。\n当N=M时，就是计数排序。\n</code></pre><blockquote>\n<p>@应届-乌凌-c++<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">radix_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> *num, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX 65536</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *temp = (<span class=\"keyword\">int</span>*)<span class=\"built_in\">calloc</span>(n, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *cnt = (<span class=\"keyword\">int</span>*)<span class=\"built_in\">calloc</span>(MAX + <span class=\"number\">5</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">\t\tcnt[(num[i] &amp; <span class=\"number\">65535</span>) + <span class=\"number\">1</span>] += <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; MAX; i++) cnt[i] += cnt[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">\t\ttemp[cnt[num[i] &amp; <span class=\"number\">65535</span>]++] = num[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(cnt, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * MAX);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *p = temp;</span><br><span class=\"line\">\ttemp = num;</span><br><span class=\"line\">\tnum = p;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">\t\tcnt[((num[i] &gt;&gt; <span class=\"number\">16</span>) &amp; <span class=\"number\">65535</span>) + <span class=\"number\">1</span>] += <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; MAX; i++) cnt[i] += cnt[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">\t\ttemp[cnt[(num[i] &gt;&gt; <span class=\"number\">16</span>) &amp; <span class=\"number\">65535</span>]++] = num[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(num);</span><br><span class=\"line\">\tnum = temp;</span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(cnt);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">undef</span> MAX</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>个人对排序的补充</p>\n</blockquote>\n<pre><code>快速排序\n归并排序\n堆排序\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>目标</p>\n<pre><code>定位自我\n</code></pre><p>思考点1 [只是了解一般不用 == 判断浮点数相等，对于能够判断的浮点数集认识不深刻]</p>\n<pre><code>在诸如Java、C++或Python语言中，一般不用 &quot;==&quot; 判断两个浮点数相等。\n浮点数在计算机内的表达有误差，直接使用 &quot;==&quot; 来判断两个浮点数是否相等是不安全的。\n只有部分能够精确表达的浮点数，如0.0, 0.5(1/2)，0.25(1/4)等浮点数，使用 &quot;==&quot; 判断\n浮点数值相等是没问题的，其他情况则会产生意想不到的结果。\n</code></pre><p>思考点2 [动态规划和分治法的区别，增加例子来理解]</p>\n<pre><code>动态规划区别于分治法是其子问题具备&quot;无后向性&quot;，在各阶段的子问题确定后，\n对于特定阶段的子问题来说，它之前各个阶段的子问题的决策只影响该阶段的决策，\n对该阶段之后的决策不产生影响。\n</code></pre><p>思考点3 [对诸如Dijkstra、A*等经典算法生疏，对图结构生疏]</p>\n<p>思考点4 [由排序算法时间复杂度引出的讨论]</p>\n<blockquote>\n<p>@5年-余努力-成都-杂家 </p>\n</blockquote>\n<pre><code>桶排序的平均时间复杂度为线性的O(N+C)，其中C=N*(logN-logM)。\n如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。\n当N=M时，就是计数排序。\n</code></pre><blockquote>\n<p>@应届-乌凌-c++<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">radix_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> *num, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX 65536</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *temp = (<span class=\"keyword\">int</span>*)<span class=\"built_in\">calloc</span>(n, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *cnt = (<span class=\"keyword\">int</span>*)<span class=\"built_in\">calloc</span>(MAX + <span class=\"number\">5</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">\t\tcnt[(num[i] &amp; <span class=\"number\">65535</span>) + <span class=\"number\">1</span>] += <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; MAX; i++) cnt[i] += cnt[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">\t\ttemp[cnt[num[i] &amp; <span class=\"number\">65535</span>]++] = num[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(cnt, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * MAX);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *p = temp;</span><br><span class=\"line\">\ttemp = num;</span><br><span class=\"line\">\tnum = p;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">\t\tcnt[((num[i] &gt;&gt; <span class=\"number\">16</span>) &amp; <span class=\"number\">65535</span>) + <span class=\"number\">1</span>] += <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; MAX; i++) cnt[i] += cnt[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">\t\ttemp[cnt[(num[i] &gt;&gt; <span class=\"number\">16</span>) &amp; <span class=\"number\">65535</span>]++] = num[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(num);</span><br><span class=\"line\">\tnum = temp;</span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(cnt);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">undef</span> MAX</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>个人对排序的补充</p>\n</blockquote>\n<pre><code>快速排序\n归并排序\n堆排序\n</code></pre>"},{"title":"A*算法","_content":"\n","source":"_posts/训练营/游戏算法卡01-A*算法.md","raw":"---\ntitle: A*算法\n---\n\n","slug":"训练营/游戏算法卡01-A*算法","published":1,"date":"2019-04-19T04:49:01.314Z","updated":"2019-04-19T04:49:01.314Z","_id":"cjwd4c78e000psv72xkf8xe18","comments":1,"layout":"post","photos":[],"link":"","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"如何\"玩\"算法","_content":"\n目标\n    \n    1. 对遇到的特殊的问题要能够设计出算法实现\n    2. 对原理公开的知名算法，要能够翻译成具体的算法代码\n    3. 对已有具体实现的算法，要能够设计出合适的数学模型，将算法应用到实际问题中。\n\n条件\n\n    1. 了解算法设计的常用思想和模式，并将题目转换成数据模型\n    2. 进一步用数据结构实现数据模型的一般方法。\n\n\n将问题抽象成数据模型\n\n    信息数据化：把自然语言描述转换成方便代码数据模型表达的数字化信息。\n    类比和转化：像使用模式一样使用那些经典的或常用的模型，\n              或者根据不同对象的某些相似性，借用已知领域的模型。\n\n\n堆[深有体会。某游戏公司有考察]\n    \n    在问题规模比较大的时候，每次查找dist数组中的最小值可能会成为效率的瓶颈，\n    可以用最小的堆来维护dist的结果，使得每次取出最小值的操作为O(1)时间复杂度，\n    因为堆顶即为最小值。\n    \n    \n穷举法[想法简单, 遗漏情况]\n    \n    尽管部分人看不起穷举法，但是不可否认，有些人却连基本的穷举算法都设计不出来。\n\n\n需要刻意补充的知识点\n    \n    区间树\n    有向图\n    \n    \n需要刻意练习的算法\n    \n    图论\n","source":"_posts/训练营/热身卡03-如何\"玩\"算法.md","raw":"---\ntitle: 如何\"玩\"算法\n---\n\n目标\n    \n    1. 对遇到的特殊的问题要能够设计出算法实现\n    2. 对原理公开的知名算法，要能够翻译成具体的算法代码\n    3. 对已有具体实现的算法，要能够设计出合适的数学模型，将算法应用到实际问题中。\n\n条件\n\n    1. 了解算法设计的常用思想和模式，并将题目转换成数据模型\n    2. 进一步用数据结构实现数据模型的一般方法。\n\n\n将问题抽象成数据模型\n\n    信息数据化：把自然语言描述转换成方便代码数据模型表达的数字化信息。\n    类比和转化：像使用模式一样使用那些经典的或常用的模型，\n              或者根据不同对象的某些相似性，借用已知领域的模型。\n\n\n堆[深有体会。某游戏公司有考察]\n    \n    在问题规模比较大的时候，每次查找dist数组中的最小值可能会成为效率的瓶颈，\n    可以用最小的堆来维护dist的结果，使得每次取出最小值的操作为O(1)时间复杂度，\n    因为堆顶即为最小值。\n    \n    \n穷举法[想法简单, 遗漏情况]\n    \n    尽管部分人看不起穷举法，但是不可否认，有些人却连基本的穷举算法都设计不出来。\n\n\n需要刻意补充的知识点\n    \n    区间树\n    有向图\n    \n    \n需要刻意练习的算法\n    \n    图论\n","slug":"训练营/热身卡03-如何\"玩\"算法","published":1,"date":"2019-04-01T09:59:49.335Z","updated":"2019-04-01T09:59:49.335Z","_id":"cjwd4c78f000qsv72gmaeiizg","comments":1,"layout":"post","photos":[],"link":"","content":"<p>目标</p>\n<pre><code>1. 对遇到的特殊的问题要能够设计出算法实现\n2. 对原理公开的知名算法，要能够翻译成具体的算法代码\n3. 对已有具体实现的算法，要能够设计出合适的数学模型，将算法应用到实际问题中。\n</code></pre><p>条件</p>\n<pre><code>1. 了解算法设计的常用思想和模式，并将题目转换成数据模型\n2. 进一步用数据结构实现数据模型的一般方法。\n</code></pre><p>将问题抽象成数据模型</p>\n<pre><code>信息数据化：把自然语言描述转换成方便代码数据模型表达的数字化信息。\n类比和转化：像使用模式一样使用那些经典的或常用的模型，\n          或者根据不同对象的某些相似性，借用已知领域的模型。\n</code></pre><p>堆[深有体会。某游戏公司有考察]</p>\n<pre><code>在问题规模比较大的时候，每次查找dist数组中的最小值可能会成为效率的瓶颈，\n可以用最小的堆来维护dist的结果，使得每次取出最小值的操作为O(1)时间复杂度，\n因为堆顶即为最小值。\n</code></pre><p>穷举法[想法简单, 遗漏情况]</p>\n<pre><code>尽管部分人看不起穷举法，但是不可否认，有些人却连基本的穷举算法都设计不出来。\n</code></pre><p>需要刻意补充的知识点</p>\n<pre><code>区间树\n有向图\n</code></pre><p>需要刻意练习的算法</p>\n<pre><code>图论\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>目标</p>\n<pre><code>1. 对遇到的特殊的问题要能够设计出算法实现\n2. 对原理公开的知名算法，要能够翻译成具体的算法代码\n3. 对已有具体实现的算法，要能够设计出合适的数学模型，将算法应用到实际问题中。\n</code></pre><p>条件</p>\n<pre><code>1. 了解算法设计的常用思想和模式，并将题目转换成数据模型\n2. 进一步用数据结构实现数据模型的一般方法。\n</code></pre><p>将问题抽象成数据模型</p>\n<pre><code>信息数据化：把自然语言描述转换成方便代码数据模型表达的数字化信息。\n类比和转化：像使用模式一样使用那些经典的或常用的模型，\n          或者根据不同对象的某些相似性，借用已知领域的模型。\n</code></pre><p>堆[深有体会。某游戏公司有考察]</p>\n<pre><code>在问题规模比较大的时候，每次查找dist数组中的最小值可能会成为效率的瓶颈，\n可以用最小的堆来维护dist的结果，使得每次取出最小值的操作为O(1)时间复杂度，\n因为堆顶即为最小值。\n</code></pre><p>穷举法[想法简单, 遗漏情况]</p>\n<pre><code>尽管部分人看不起穷举法，但是不可否认，有些人却连基本的穷举算法都设计不出来。\n</code></pre><p>需要刻意补充的知识点</p>\n<pre><code>区间树\n有向图\n</code></pre><p>需要刻意练习的算法</p>\n<pre><code>图论\n</code></pre>"},{"title":"装配线与工作站问题","_content":"","source":"_posts/训练营/穷举搜索卡01.md","raw":"---\ntitle: 装配线与工作站问题\n---\n","slug":"训练营/穷举搜索卡01","published":1,"date":"2019-04-06T12:51:21.328Z","updated":"2019-04-06T12:51:21.328Z","_id":"cjwd4c78f000rsv72mfl2n575","comments":1,"layout":"post","photos":[],"link":"","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"3个桶等分8升水","_content":"\n给出容量分别为8、5和3升的桶，需要等分成2个4升水。\n    \n    [8,0,0]\n    [3,5,0] [5,0,3] [3,5,0]\n    [3,2,3] [0,5,3] [0,5,3]\n    [6,2,0] [3,5,0]\n    [6,0,2] [3,2,3]\n    [1,5,2]\n    [1,4,3]\n    [4,4,0]\n    \n    \n```python\nfrom collections import deque\n\n\nclass WaterStatus(object):\n    def __init__(self, limit, water):\n        self.limit = limit  # 最大容量\n        self.water = water  # 装水容量\n\n\ndef change_water(src: WaterStatus, dst: WaterStatus):\n    if src.water == 0 or dst.water == dst.limit:\n        water = 0\n    if src.water >= dst.limit - dst.water:\n        water = dst.limit - dst.water\n    else:\n        water = src.water\n    src.water -= water\n    dst.water += water\n\n\nif __name__ == '__main__':\n    a = WaterStatus(8, 8)\n    b = WaterStatus(5, 0)\n    c = WaterStatus(3, 0)\n    water_list = [a, b, c]\n    # 队列\n    water_queue = deque()\n    water_queue.append([8, 0, 0])\n\n    cur_status = []\n    cnt = 1\n    while True:\n        print('***第 %d 次循环***' % cnt)\n        cnt += 1\n        if [4, 4, 0] == cur_status:\n            print('find it!')\n            break\n        for water1 in water_list:\n            for water2 in water_list:\n                # 记录当前状态，深拷贝deepcopy，创建新的对象\n                cur_status = list(water_queue[-1])\n                water_list[0].water = cur_status[0]\n                water_list[1].water = cur_status[1]\n                water_list[2].water = cur_status[2]\n                # print water_list[0].water, water_list[1].water, water_list[2].water\n                # 计算一次迁移\n                if water1.limit != water2.limit:\n                    change_water(water1, water2)\n                    next_status = [water_list[0].water, water_list[1].water, water_list[2].water]\n                    # print 'next_status' , next_status\n                    if next_status in water_queue:\n                        # print '迁移后的状态在记录中存在，将当前状态转到迁移之前的状态'\n                        pass\n                    else:\n                        # print '记录迁移后的状态,一定要用list()来新建一个对象'\n                        cur_status = next_status\n                        water_queue.append(list(next_status))\n                    # print water1.limit , water2.limit, cur_status\n                    print('---', water_queue)\n\n```","source":"_posts/训练营/穷举搜索卡02.md","raw":"---\ntitle: 3个桶等分8升水\n---\n\n给出容量分别为8、5和3升的桶，需要等分成2个4升水。\n    \n    [8,0,0]\n    [3,5,0] [5,0,3] [3,5,0]\n    [3,2,3] [0,5,3] [0,5,3]\n    [6,2,0] [3,5,0]\n    [6,0,2] [3,2,3]\n    [1,5,2]\n    [1,4,3]\n    [4,4,0]\n    \n    \n```python\nfrom collections import deque\n\n\nclass WaterStatus(object):\n    def __init__(self, limit, water):\n        self.limit = limit  # 最大容量\n        self.water = water  # 装水容量\n\n\ndef change_water(src: WaterStatus, dst: WaterStatus):\n    if src.water == 0 or dst.water == dst.limit:\n        water = 0\n    if src.water >= dst.limit - dst.water:\n        water = dst.limit - dst.water\n    else:\n        water = src.water\n    src.water -= water\n    dst.water += water\n\n\nif __name__ == '__main__':\n    a = WaterStatus(8, 8)\n    b = WaterStatus(5, 0)\n    c = WaterStatus(3, 0)\n    water_list = [a, b, c]\n    # 队列\n    water_queue = deque()\n    water_queue.append([8, 0, 0])\n\n    cur_status = []\n    cnt = 1\n    while True:\n        print('***第 %d 次循环***' % cnt)\n        cnt += 1\n        if [4, 4, 0] == cur_status:\n            print('find it!')\n            break\n        for water1 in water_list:\n            for water2 in water_list:\n                # 记录当前状态，深拷贝deepcopy，创建新的对象\n                cur_status = list(water_queue[-1])\n                water_list[0].water = cur_status[0]\n                water_list[1].water = cur_status[1]\n                water_list[2].water = cur_status[2]\n                # print water_list[0].water, water_list[1].water, water_list[2].water\n                # 计算一次迁移\n                if water1.limit != water2.limit:\n                    change_water(water1, water2)\n                    next_status = [water_list[0].water, water_list[1].water, water_list[2].water]\n                    # print 'next_status' , next_status\n                    if next_status in water_queue:\n                        # print '迁移后的状态在记录中存在，将当前状态转到迁移之前的状态'\n                        pass\n                    else:\n                        # print '记录迁移后的状态,一定要用list()来新建一个对象'\n                        cur_status = next_status\n                        water_queue.append(list(next_status))\n                    # print water1.limit , water2.limit, cur_status\n                    print('---', water_queue)\n\n```","slug":"训练营/穷举搜索卡02","published":1,"date":"2019-04-06T14:09:12.518Z","updated":"2019-04-06T14:09:12.518Z","_id":"cjwd4c78i000ssv72h3k6gqju","comments":1,"layout":"post","photos":[],"link":"","content":"<p>给出容量分别为8、5和3升的桶，需要等分成2个4升水。</p>\n<pre><code>[8,0,0]\n[3,5,0] [5,0,3] [3,5,0]\n[3,2,3] [0,5,3] [0,5,3]\n[6,2,0] [3,5,0]\n[6,0,2] [3,2,3]\n[1,5,2]\n[1,4,3]\n[4,4,0]\n</code></pre><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> deque</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WaterStatus</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, limit, water)</span>:</span></span><br><span class=\"line\">        self.limit = limit  <span class=\"comment\"># 最大容量</span></span><br><span class=\"line\">        self.water = water  <span class=\"comment\"># 装水容量</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">change_water</span><span class=\"params\">(src: WaterStatus, dst: WaterStatus)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> src.water == <span class=\"number\">0</span> <span class=\"keyword\">or</span> dst.water == dst.limit:</span><br><span class=\"line\">        water = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> src.water &gt;= dst.limit - dst.water:</span><br><span class=\"line\">        water = dst.limit - dst.water</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        water = src.water</span><br><span class=\"line\">    src.water -= water</span><br><span class=\"line\">    dst.water += water</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    a = WaterStatus(<span class=\"number\">8</span>, <span class=\"number\">8</span>)</span><br><span class=\"line\">    b = WaterStatus(<span class=\"number\">5</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    c = WaterStatus(<span class=\"number\">3</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    water_list = [a, b, c]</span><br><span class=\"line\">    <span class=\"comment\"># 队列</span></span><br><span class=\"line\">    water_queue = deque()</span><br><span class=\"line\">    water_queue.append([<span class=\"number\">8</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    cur_status = []</span><br><span class=\"line\">    cnt = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">        print(<span class=\"string\">'***第 %d 次循环***'</span> % cnt)</span><br><span class=\"line\">        cnt += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> [<span class=\"number\">4</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>] == cur_status:</span><br><span class=\"line\">            print(<span class=\"string\">'find it!'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> water1 <span class=\"keyword\">in</span> water_list:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> water2 <span class=\"keyword\">in</span> water_list:</span><br><span class=\"line\">                <span class=\"comment\"># 记录当前状态，深拷贝deepcopy，创建新的对象</span></span><br><span class=\"line\">                cur_status = list(water_queue[<span class=\"number\">-1</span>])</span><br><span class=\"line\">                water_list[<span class=\"number\">0</span>].water = cur_status[<span class=\"number\">0</span>]</span><br><span class=\"line\">                water_list[<span class=\"number\">1</span>].water = cur_status[<span class=\"number\">1</span>]</span><br><span class=\"line\">                water_list[<span class=\"number\">2</span>].water = cur_status[<span class=\"number\">2</span>]</span><br><span class=\"line\">                <span class=\"comment\"># print water_list[0].water, water_list[1].water, water_list[2].water</span></span><br><span class=\"line\">                <span class=\"comment\"># 计算一次迁移</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> water1.limit != water2.limit:</span><br><span class=\"line\">                    change_water(water1, water2)</span><br><span class=\"line\">                    next_status = [water_list[<span class=\"number\">0</span>].water, water_list[<span class=\"number\">1</span>].water, water_list[<span class=\"number\">2</span>].water]</span><br><span class=\"line\">                    <span class=\"comment\"># print 'next_status' , next_status</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> next_status <span class=\"keyword\">in</span> water_queue:</span><br><span class=\"line\">                        <span class=\"comment\"># print '迁移后的状态在记录中存在，将当前状态转到迁移之前的状态'</span></span><br><span class=\"line\">                        <span class=\"keyword\">pass</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                        <span class=\"comment\"># print '记录迁移后的状态,一定要用list()来新建一个对象'</span></span><br><span class=\"line\">                        cur_status = next_status</span><br><span class=\"line\">                        water_queue.append(list(next_status))</span><br><span class=\"line\">                    <span class=\"comment\"># print water1.limit , water2.limit, cur_status</span></span><br><span class=\"line\">                    print(<span class=\"string\">'---'</span>, water_queue)</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>给出容量分别为8、5和3升的桶，需要等分成2个4升水。</p>\n<pre><code>[8,0,0]\n[3,5,0] [5,0,3] [3,5,0]\n[3,2,3] [0,5,3] [0,5,3]\n[6,2,0] [3,5,0]\n[6,0,2] [3,2,3]\n[1,5,2]\n[1,4,3]\n[4,4,0]\n</code></pre><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> deque</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WaterStatus</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, limit, water)</span>:</span></span><br><span class=\"line\">        self.limit = limit  <span class=\"comment\"># 最大容量</span></span><br><span class=\"line\">        self.water = water  <span class=\"comment\"># 装水容量</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">change_water</span><span class=\"params\">(src: WaterStatus, dst: WaterStatus)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> src.water == <span class=\"number\">0</span> <span class=\"keyword\">or</span> dst.water == dst.limit:</span><br><span class=\"line\">        water = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> src.water &gt;= dst.limit - dst.water:</span><br><span class=\"line\">        water = dst.limit - dst.water</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        water = src.water</span><br><span class=\"line\">    src.water -= water</span><br><span class=\"line\">    dst.water += water</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    a = WaterStatus(<span class=\"number\">8</span>, <span class=\"number\">8</span>)</span><br><span class=\"line\">    b = WaterStatus(<span class=\"number\">5</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    c = WaterStatus(<span class=\"number\">3</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    water_list = [a, b, c]</span><br><span class=\"line\">    <span class=\"comment\"># 队列</span></span><br><span class=\"line\">    water_queue = deque()</span><br><span class=\"line\">    water_queue.append([<span class=\"number\">8</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    cur_status = []</span><br><span class=\"line\">    cnt = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">        print(<span class=\"string\">'***第 %d 次循环***'</span> % cnt)</span><br><span class=\"line\">        cnt += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> [<span class=\"number\">4</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>] == cur_status:</span><br><span class=\"line\">            print(<span class=\"string\">'find it!'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> water1 <span class=\"keyword\">in</span> water_list:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> water2 <span class=\"keyword\">in</span> water_list:</span><br><span class=\"line\">                <span class=\"comment\"># 记录当前状态，深拷贝deepcopy，创建新的对象</span></span><br><span class=\"line\">                cur_status = list(water_queue[<span class=\"number\">-1</span>])</span><br><span class=\"line\">                water_list[<span class=\"number\">0</span>].water = cur_status[<span class=\"number\">0</span>]</span><br><span class=\"line\">                water_list[<span class=\"number\">1</span>].water = cur_status[<span class=\"number\">1</span>]</span><br><span class=\"line\">                water_list[<span class=\"number\">2</span>].water = cur_status[<span class=\"number\">2</span>]</span><br><span class=\"line\">                <span class=\"comment\"># print water_list[0].water, water_list[1].water, water_list[2].water</span></span><br><span class=\"line\">                <span class=\"comment\"># 计算一次迁移</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> water1.limit != water2.limit:</span><br><span class=\"line\">                    change_water(water1, water2)</span><br><span class=\"line\">                    next_status = [water_list[<span class=\"number\">0</span>].water, water_list[<span class=\"number\">1</span>].water, water_list[<span class=\"number\">2</span>].water]</span><br><span class=\"line\">                    <span class=\"comment\"># print 'next_status' , next_status</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> next_status <span class=\"keyword\">in</span> water_queue:</span><br><span class=\"line\">                        <span class=\"comment\"># print '迁移后的状态在记录中存在，将当前状态转到迁移之前的状态'</span></span><br><span class=\"line\">                        <span class=\"keyword\">pass</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                        <span class=\"comment\"># print '记录迁移后的状态,一定要用list()来新建一个对象'</span></span><br><span class=\"line\">                        cur_status = next_status</span><br><span class=\"line\">                        water_queue.append(list(next_status))</span><br><span class=\"line\">                    <span class=\"comment\"># print water1.limit , water2.limit, cur_status</span></span><br><span class=\"line\">                    print(<span class=\"string\">'---'</span>, water_queue)</span><br></pre></td></tr></table></figure>"},{"title":"过河","_content":"\n问题描述：\n\n    农夫需要把狼、羊、菜和自己运到河对岸去，\n    只有农夫能够划船，而且船比较小，\n    除农夫之外每次只能运一种东西，\n    还有一个棘手的问题，就是如果没有农夫看着，\n    羊会偷吃菜，狼会吃羊。\n    请考虑一种方法，\n    让农夫能够安全地安排这些东西和他自己过河。\n    \n\n主要思路：\n    \n    在狼、羊和菜这个食物链上，\n    关键是中间的羊，因为狼不吃菜，\n    所以要安全过河，\n    农夫的第一件事就是带羊走，\n    拆开这个食物链。\n    \n目标：\n    \n    [0,0,0,0] -> [1,1,1,1]\n\n过程：\n\n    [0,0,0,0]\n    [1,0,1,0]\n    [0,0,1,0]\n    [1,1,1,0]\n    [0,1,0,0]\n    [1,1,0,1]\n    [0,1,0,1]\n    [1,1,1,1]\n","source":"_posts/训练营/穷举搜索卡03.md","raw":"---\ntitle: 过河\n---\n\n问题描述：\n\n    农夫需要把狼、羊、菜和自己运到河对岸去，\n    只有农夫能够划船，而且船比较小，\n    除农夫之外每次只能运一种东西，\n    还有一个棘手的问题，就是如果没有农夫看着，\n    羊会偷吃菜，狼会吃羊。\n    请考虑一种方法，\n    让农夫能够安全地安排这些东西和他自己过河。\n    \n\n主要思路：\n    \n    在狼、羊和菜这个食物链上，\n    关键是中间的羊，因为狼不吃菜，\n    所以要安全过河，\n    农夫的第一件事就是带羊走，\n    拆开这个食物链。\n    \n目标：\n    \n    [0,0,0,0] -> [1,1,1,1]\n\n过程：\n\n    [0,0,0,0]\n    [1,0,1,0]\n    [0,0,1,0]\n    [1,1,1,0]\n    [0,1,0,0]\n    [1,1,0,1]\n    [0,1,0,1]\n    [1,1,1,1]\n","slug":"训练营/穷举搜索卡03","published":1,"date":"2019-04-07T13:13:35.552Z","updated":"2019-04-07T13:13:35.552Z","_id":"cjwd4c78j000tsv72lt6xp7pj","comments":1,"layout":"post","photos":[],"link":"","content":"<p>问题描述：</p>\n<pre><code>农夫需要把狼、羊、菜和自己运到河对岸去，\n只有农夫能够划船，而且船比较小，\n除农夫之外每次只能运一种东西，\n还有一个棘手的问题，就是如果没有农夫看着，\n羊会偷吃菜，狼会吃羊。\n请考虑一种方法，\n让农夫能够安全地安排这些东西和他自己过河。\n</code></pre><p>主要思路：</p>\n<pre><code>在狼、羊和菜这个食物链上，\n关键是中间的羊，因为狼不吃菜，\n所以要安全过河，\n农夫的第一件事就是带羊走，\n拆开这个食物链。\n</code></pre><p>目标：</p>\n<pre><code>[0,0,0,0] -&gt; [1,1,1,1]\n</code></pre><p>过程：</p>\n<pre><code>[0,0,0,0]\n[1,0,1,0]\n[0,0,1,0]\n[1,1,1,0]\n[0,1,0,0]\n[1,1,0,1]\n[0,1,0,1]\n[1,1,1,1]\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>问题描述：</p>\n<pre><code>农夫需要把狼、羊、菜和自己运到河对岸去，\n只有农夫能够划船，而且船比较小，\n除农夫之外每次只能运一种东西，\n还有一个棘手的问题，就是如果没有农夫看着，\n羊会偷吃菜，狼会吃羊。\n请考虑一种方法，\n让农夫能够安全地安排这些东西和他自己过河。\n</code></pre><p>主要思路：</p>\n<pre><code>在狼、羊和菜这个食物链上，\n关键是中间的羊，因为狼不吃菜，\n所以要安全过河，\n农夫的第一件事就是带羊走，\n拆开这个食物链。\n</code></pre><p>目标：</p>\n<pre><code>[0,0,0,0] -&gt; [1,1,1,1]\n</code></pre><p>过程：</p>\n<pre><code>[0,0,0,0]\n[1,0,1,0]\n[0,0,1,0]\n[1,1,1,0]\n[0,1,0,0]\n[1,1,0,1]\n[0,1,0,1]\n[1,1,1,1]\n</code></pre>"},{"title":"24点计数器","_content":"\n问题描述：\n    \n    任给四个小于10的数，\n    对四个数字用各种组合\n    进行加、减、乘、除四则运算，\n    看看结果是否能等于 24？\n\n\n\n策略：\n    \n    穷举法+分治法\n\n分治：\n    \n    原始问题的规模是 4 个数字计算 24 点，\n    那么分解子问题可以从两个方向考虑：\n    一种是只考虑减少问题的规模，\n    对于这个问题来说，\n    减少规模不就是变成 3 个数字计算 24 点吗？\n    然后再减少为两个数字计算 24 点，\n    以此类推，直到问题能够直接求解为止；\n    另一种是在减少问题规模的同时，\n    调整结果的范围，同样，对这个问题来说，\n    假如说我将问题规模从 4 个变成 3 个，\n    被排除的数字是 3，那么子问题就应该变成\n    “3 个数字计算 21 点”。\n    进一步将问题规模减少成两个数字时，\n    假如被排除的数字是 7，\n    则子问题就变成“2 个数字计算 14 点”，\n    以此类推，直到问题能直接解决为止。\n\n\n以空间换时间","source":"_posts/训练营/穷举搜索卡04.md","raw":"---\ntitle: 24点计数器\n---\n\n问题描述：\n    \n    任给四个小于10的数，\n    对四个数字用各种组合\n    进行加、减、乘、除四则运算，\n    看看结果是否能等于 24？\n\n\n\n策略：\n    \n    穷举法+分治法\n\n分治：\n    \n    原始问题的规模是 4 个数字计算 24 点，\n    那么分解子问题可以从两个方向考虑：\n    一种是只考虑减少问题的规模，\n    对于这个问题来说，\n    减少规模不就是变成 3 个数字计算 24 点吗？\n    然后再减少为两个数字计算 24 点，\n    以此类推，直到问题能够直接求解为止；\n    另一种是在减少问题规模的同时，\n    调整结果的范围，同样，对这个问题来说，\n    假如说我将问题规模从 4 个变成 3 个，\n    被排除的数字是 3，那么子问题就应该变成\n    “3 个数字计算 21 点”。\n    进一步将问题规模减少成两个数字时，\n    假如被排除的数字是 7，\n    则子问题就变成“2 个数字计算 14 点”，\n    以此类推，直到问题能直接解决为止。\n\n\n以空间换时间","slug":"训练营/穷举搜索卡04","published":1,"date":"2019-04-07T13:25:09.670Z","updated":"2019-04-07T13:25:09.670Z","_id":"cjwd4c7az000usv723h5gcdzt","comments":1,"layout":"post","photos":[],"link":"","content":"<p>问题描述：</p>\n<pre><code>任给四个小于10的数，\n对四个数字用各种组合\n进行加、减、乘、除四则运算，\n看看结果是否能等于 24？\n</code></pre><p>策略：</p>\n<pre><code>穷举法+分治法\n</code></pre><p>分治：</p>\n<pre><code>原始问题的规模是 4 个数字计算 24 点，\n那么分解子问题可以从两个方向考虑：\n一种是只考虑减少问题的规模，\n对于这个问题来说，\n减少规模不就是变成 3 个数字计算 24 点吗？\n然后再减少为两个数字计算 24 点，\n以此类推，直到问题能够直接求解为止；\n另一种是在减少问题规模的同时，\n调整结果的范围，同样，对这个问题来说，\n假如说我将问题规模从 4 个变成 3 个，\n被排除的数字是 3，那么子问题就应该变成\n“3 个数字计算 21 点”。\n进一步将问题规模减少成两个数字时，\n假如被排除的数字是 7，\n则子问题就变成“2 个数字计算 14 点”，\n以此类推，直到问题能直接解决为止。\n</code></pre><p>以空间换时间</p>\n","site":{"data":{}},"excerpt":"","more":"<p>问题描述：</p>\n<pre><code>任给四个小于10的数，\n对四个数字用各种组合\n进行加、减、乘、除四则运算，\n看看结果是否能等于 24？\n</code></pre><p>策略：</p>\n<pre><code>穷举法+分治法\n</code></pre><p>分治：</p>\n<pre><code>原始问题的规模是 4 个数字计算 24 点，\n那么分解子问题可以从两个方向考虑：\n一种是只考虑减少问题的规模，\n对于这个问题来说，\n减少规模不就是变成 3 个数字计算 24 点吗？\n然后再减少为两个数字计算 24 点，\n以此类推，直到问题能够直接求解为止；\n另一种是在减少问题规模的同时，\n调整结果的范围，同样，对这个问题来说，\n假如说我将问题规模从 4 个变成 3 个，\n被排除的数字是 3，那么子问题就应该变成\n“3 个数字计算 21 点”。\n进一步将问题规模减少成两个数字时，\n假如被排除的数字是 7，\n则子问题就变成“2 个数字计算 14 点”，\n以此类推，直到问题能直接解决为止。\n</code></pre><p>以空间换时间</p>\n"},{"title":"爱因斯坦的思考题 上","_content":"\n题目描述：\n    \n    据说有五个不同颜色的房间排成一排，\n    每个房间里分别住着一个不同国籍的人，\n    每个人都喝一种特定品牌的饮料，\n    抽一种特定品牌的烟，养一种宠物，\n    没有任意两个人抽相同品牌的香烟，\n    或喝相同品牌的饮料，或养相同的宠物，\n    问题是谁在养鱼作为宠物？\n    \n线索：\n\n    （1）英国人住在红色的房子里\n    （2）瑞典人养狗作为宠物\n    （3）丹麦人喝茶\n    （4）绿房子紧挨着白房子，在白房子的左边\n    （5）绿房子的主人喝咖啡\n    （6）抽 Pall Mall 牌香烟的人养鸟\n    （7）黄色房子里的人抽 Dunhill 牌香烟\n    （8）住在中间那个房子里的人喝牛奶\n    （9）挪威人住在第一个房子里面\n    （10）抽 Blends 牌香烟的人和养猫的人相邻\n    （11）养马的人和抽 Dunhill 牌香烟的人相邻\n    （12）抽 BlueMaster 牌香烟的人喝啤酒\n    （13）德国人抽 Prince 牌香烟\n    （14）挪威人和住在蓝房子的人相邻\n    （15）抽 Blends 牌香烟的人和喝矿泉水的人相邻\n\n状态描述[也是答案的一种]\n    \n    房子      国籍\t    饮料\t    宠物\t    烟\n    黄色      挪威\t    水\t    猫\t    Dunhill\n    蓝色      丹麦\t    茶\t    马\t    Blends\n    红色      英国\t    牛奶\t    鸟\t    PallMall\n    绿色      德国\t    咖啡\t    鱼\t    Prince\n    白色      瑞典\t    啤酒\t    狗\t    BlueMaster\n    \n根据线索得到的状态分布\n    \n    房子      国籍      饮料      宠物      烟\n    住蓝房邻   挪威\n    蓝色\n    红色      英国      \n             瑞典                狗\n             丹麦      茶\n    绿色               咖啡\n    白色\n                                鸟       PallMall\n    黄色                                 Dunhill\n                      啤酒               BlueMaster\n             德国                        Prince\n    中间              牛奶         \n                     邻矿泉水  和养猫的人相邻  Blends \n                                马        和Dunhill相邻\n                                \n分析\n\n    从状态分布来看，所提供的线索完整。并且可以固定部分位置\n    [0][1] = 挪威\n    [1][0] = 蓝色\n    [2][2] = 牛奶\n    多数线索提供 状态绑定关系。\n    Blends 无绑定关系，但相邻关系多，或许是个入手点。","source":"_posts/训练营/穷举搜索法05.md","raw":"---\ntitle: 爱因斯坦的思考题 上\n---\n\n题目描述：\n    \n    据说有五个不同颜色的房间排成一排，\n    每个房间里分别住着一个不同国籍的人，\n    每个人都喝一种特定品牌的饮料，\n    抽一种特定品牌的烟，养一种宠物，\n    没有任意两个人抽相同品牌的香烟，\n    或喝相同品牌的饮料，或养相同的宠物，\n    问题是谁在养鱼作为宠物？\n    \n线索：\n\n    （1）英国人住在红色的房子里\n    （2）瑞典人养狗作为宠物\n    （3）丹麦人喝茶\n    （4）绿房子紧挨着白房子，在白房子的左边\n    （5）绿房子的主人喝咖啡\n    （6）抽 Pall Mall 牌香烟的人养鸟\n    （7）黄色房子里的人抽 Dunhill 牌香烟\n    （8）住在中间那个房子里的人喝牛奶\n    （9）挪威人住在第一个房子里面\n    （10）抽 Blends 牌香烟的人和养猫的人相邻\n    （11）养马的人和抽 Dunhill 牌香烟的人相邻\n    （12）抽 BlueMaster 牌香烟的人喝啤酒\n    （13）德国人抽 Prince 牌香烟\n    （14）挪威人和住在蓝房子的人相邻\n    （15）抽 Blends 牌香烟的人和喝矿泉水的人相邻\n\n状态描述[也是答案的一种]\n    \n    房子      国籍\t    饮料\t    宠物\t    烟\n    黄色      挪威\t    水\t    猫\t    Dunhill\n    蓝色      丹麦\t    茶\t    马\t    Blends\n    红色      英国\t    牛奶\t    鸟\t    PallMall\n    绿色      德国\t    咖啡\t    鱼\t    Prince\n    白色      瑞典\t    啤酒\t    狗\t    BlueMaster\n    \n根据线索得到的状态分布\n    \n    房子      国籍      饮料      宠物      烟\n    住蓝房邻   挪威\n    蓝色\n    红色      英国      \n             瑞典                狗\n             丹麦      茶\n    绿色               咖啡\n    白色\n                                鸟       PallMall\n    黄色                                 Dunhill\n                      啤酒               BlueMaster\n             德国                        Prince\n    中间              牛奶         \n                     邻矿泉水  和养猫的人相邻  Blends \n                                马        和Dunhill相邻\n                                \n分析\n\n    从状态分布来看，所提供的线索完整。并且可以固定部分位置\n    [0][1] = 挪威\n    [1][0] = 蓝色\n    [2][2] = 牛奶\n    多数线索提供 状态绑定关系。\n    Blends 无绑定关系，但相邻关系多，或许是个入手点。","slug":"训练营/穷举搜索法05","published":1,"date":"2019-04-08T14:08:14.224Z","updated":"2019-04-08T14:08:14.224Z","_id":"cjwd4c7b0000vsv72392663vb","comments":1,"layout":"post","photos":[],"link":"","content":"<p>题目描述：</p>\n<pre><code>据说有五个不同颜色的房间排成一排，\n每个房间里分别住着一个不同国籍的人，\n每个人都喝一种特定品牌的饮料，\n抽一种特定品牌的烟，养一种宠物，\n没有任意两个人抽相同品牌的香烟，\n或喝相同品牌的饮料，或养相同的宠物，\n问题是谁在养鱼作为宠物？\n</code></pre><p>线索：</p>\n<pre><code>（1）英国人住在红色的房子里\n（2）瑞典人养狗作为宠物\n（3）丹麦人喝茶\n（4）绿房子紧挨着白房子，在白房子的左边\n（5）绿房子的主人喝咖啡\n（6）抽 Pall Mall 牌香烟的人养鸟\n（7）黄色房子里的人抽 Dunhill 牌香烟\n（8）住在中间那个房子里的人喝牛奶\n（9）挪威人住在第一个房子里面\n（10）抽 Blends 牌香烟的人和养猫的人相邻\n（11）养马的人和抽 Dunhill 牌香烟的人相邻\n（12）抽 BlueMaster 牌香烟的人喝啤酒\n（13）德国人抽 Prince 牌香烟\n（14）挪威人和住在蓝房子的人相邻\n（15）抽 Blends 牌香烟的人和喝矿泉水的人相邻\n</code></pre><p>状态描述[也是答案的一种]</p>\n<pre><code>房子      国籍        饮料        宠物        烟\n黄色      挪威        水        猫        Dunhill\n蓝色      丹麦        茶        马        Blends\n红色      英国        牛奶        鸟        PallMall\n绿色      德国        咖啡        鱼        Prince\n白色      瑞典        啤酒        狗        BlueMaster\n</code></pre><p>根据线索得到的状态分布</p>\n<pre><code>房子      国籍      饮料      宠物      烟\n住蓝房邻   挪威\n蓝色\n红色      英国      \n         瑞典                狗\n         丹麦      茶\n绿色               咖啡\n白色\n                            鸟       PallMall\n黄色                                 Dunhill\n                  啤酒               BlueMaster\n         德国                        Prince\n中间              牛奶         \n                 邻矿泉水  和养猫的人相邻  Blends \n                            马        和Dunhill相邻\n</code></pre><p>分析</p>\n<pre><code>从状态分布来看，所提供的线索完整。并且可以固定部分位置\n[0][1] = 挪威\n[1][0] = 蓝色\n[2][2] = 牛奶\n多数线索提供 状态绑定关系。\nBlends 无绑定关系，但相邻关系多，或许是个入手点。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>题目描述：</p>\n<pre><code>据说有五个不同颜色的房间排成一排，\n每个房间里分别住着一个不同国籍的人，\n每个人都喝一种特定品牌的饮料，\n抽一种特定品牌的烟，养一种宠物，\n没有任意两个人抽相同品牌的香烟，\n或喝相同品牌的饮料，或养相同的宠物，\n问题是谁在养鱼作为宠物？\n</code></pre><p>线索：</p>\n<pre><code>（1）英国人住在红色的房子里\n（2）瑞典人养狗作为宠物\n（3）丹麦人喝茶\n（4）绿房子紧挨着白房子，在白房子的左边\n（5）绿房子的主人喝咖啡\n（6）抽 Pall Mall 牌香烟的人养鸟\n（7）黄色房子里的人抽 Dunhill 牌香烟\n（8）住在中间那个房子里的人喝牛奶\n（9）挪威人住在第一个房子里面\n（10）抽 Blends 牌香烟的人和养猫的人相邻\n（11）养马的人和抽 Dunhill 牌香烟的人相邻\n（12）抽 BlueMaster 牌香烟的人喝啤酒\n（13）德国人抽 Prince 牌香烟\n（14）挪威人和住在蓝房子的人相邻\n（15）抽 Blends 牌香烟的人和喝矿泉水的人相邻\n</code></pre><p>状态描述[也是答案的一种]</p>\n<pre><code>房子      国籍        饮料        宠物        烟\n黄色      挪威        水        猫        Dunhill\n蓝色      丹麦        茶        马        Blends\n红色      英国        牛奶        鸟        PallMall\n绿色      德国        咖啡        鱼        Prince\n白色      瑞典        啤酒        狗        BlueMaster\n</code></pre><p>根据线索得到的状态分布</p>\n<pre><code>房子      国籍      饮料      宠物      烟\n住蓝房邻   挪威\n蓝色\n红色      英国      \n         瑞典                狗\n         丹麦      茶\n绿色               咖啡\n白色\n                            鸟       PallMall\n黄色                                 Dunhill\n                  啤酒               BlueMaster\n         德国                        Prince\n中间              牛奶         \n                 邻矿泉水  和养猫的人相邻  Blends \n                            马        和Dunhill相邻\n</code></pre><p>分析</p>\n<pre><code>从状态分布来看，所提供的线索完整。并且可以固定部分位置\n[0][1] = 挪威\n[1][0] = 蓝色\n[2][2] = 牛奶\n多数线索提供 状态绑定关系。\nBlends 无绑定关系，但相邻关系多，或许是个入手点。\n</code></pre>"},{"title":"爱因斯坦的思考题 下","_content":"\n穷举来源\n    \n    每个状态有 5 个类型\n    每个类型又要对 5 个值进行排列组合\n\n穷举实现\n    \n    根据状态分布，有3个类型是有值在固定位置的\n    则对于国籍需要对4个位置进行排列\n    对于颜色 由于5间房子排成一排\n    所以 蓝色固定在第二间房 \n    而 绿和白存在绑定关系 则对3个位置进行排列\n    对于饮料 住中间位置的人 喝牛奶\n    则需要对 4 个位置进行排列\n    \n    剪枝操作 --。感觉智商不够用\n\n\n使用Python语言实现 \n```python\nfrom itertools import permutations\nfrom copy import deepcopy\n\n#  房子      国籍     饮料     宠物     烟\n# 初始化5个组 用以代表5个人以及5个属性\nmap_info = [\n    [''] * 5 for _ in range(5)\n]\n\n# 根据线索9 得到\nmap_info[0][1] = '挪威'\n\n# 根据 房间排成一排 与线索14 得到\nmap_info[1][0] = '蓝色'\n\n# 根据 线索8 得到\nmap_info[2][2] = '牛奶'\n\n# 线索绑定 s4 得到 绿色白色为一体\n# 并且只能在2，3 或3，4位置，0开始\n# s1 = ['红色', '英国', '', '', '']\n# s2 = ['', '瑞典', '', '狗', '']\n# s3 = ['', '丹麦', '茶', '', '']\n# s5 = ['绿色', '', '咖啡', '', '']\n# s6 = ['', '', '', '鸟', 'PallMall']\n# s7 = ['黄色', '', '', '', 'Dunhill']\n# s12 = ['', '', '啤酒', '', 'BlueMaster']\n# s13 = ['', '德国', '', '', 'Prince']\n\n#    # s11 10, 15\n\n# 从颜色开始，绿白只能或3，4位置 绿房 喝 咖啡\n# 2位置已经固定为牛奶了 s5\nmap_info[3][0] = '绿色'\nmap_info[3][2] = '咖啡'\nmap_info[4][0] = '白色'\n\n# 结合国籍看 那么剩下颜色中间位置\nmap_info[2][0] = '红色'\nmap_info[2][1] = '英国'\nmap_info[0][0] = '黄色'\n# print(map_info)\n# todo ---以上 颜色排列完整\n\n# s7 绑定 Dunhill\nmap_info[0][4] = 'Dunhill'\n# s11 养马的人和抽 Dunhill 牌香烟的人相邻\nmap_info[1][3] = '马'\n# print(map_info)\n\n\n# 对剩下的7个线索做为消费数据对象\n# 对剩下的4个类型作为排列对象生产数据\n\n\n# 消费数据\ndef check(map_info_test):\n    for i in range(5):\n\n        if map_info_test[i][1] == '瑞典' and map_info_test[i][3] != '狗':\n            return False\n        if map_info_test[i][1] == '丹麦' and map_info_test[i][2] != '茶':\n            return False\n        if map_info_test[i][3] == '鸟' and map_info_test[i][4] != 'PallMall':\n            return False\n        if map_info_test[i][2] == '啤酒' and map_info_test[i][4] != 'BlueMaster':\n            return False\n        if map_info_test[i][1] == '德国' and map_info_test[i][4] != 'Prince':\n            return False\n        if map_info_test[i][4] == 'Blends':\n            status = False\n            try:\n                if map_info_test[i - 1][3] == '猫':\n                    status = True\n            except:\n                pass\n            try:\n                if map_info_test[i + 1][3] == '猫':\n                    status = True\n            except:\n                pass\n            if status is False:\n                return False\n\n        if map_info_test[i][4] == 'Blends':\n\n            status = False\n            try:\n                if map_info_test[i - 1][2] == '水':\n                    status = True\n            except:\n                pass\n            try:\n                if map_info_test[i + 1][2] == '水':\n                    status = True\n            except:\n                pass\n            if status is False:\n                return False\n    # 通过校验\n    return True\n\n\n# 生产数据\n\"\"\"\n1. 国籍 1，3，4 -- 丹麦、德国、瑞典\n2. 饮料 0，1，4 -- 水、茶、啤酒\n3. 宠物 0，2，3，4 -- 猫、鸟、鱼、狗\n4. 烟 1，2，3，4 -- Blends、PallMall、Prince、BlueMaster\n\"\"\"\n\nres = []\nfor g in permutations({'丹麦', '德国', '瑞典'}, 3):\n    map_info[1][1], map_info[3][1], map_info[4][1] = g\n    # print(map_info)\n\n    for yl in permutations({'水', '茶', ' 啤酒'}, 3):\n        map_info[0][2], map_info[1][2], map_info[4][2] = yl\n\n        for c in permutations({'猫', '鸟', '鱼', '狗'}, 4):\n            map_info[0][3], map_info[2][3], map_info[3][3], map_info[4][3] = c\n\n            for y in permutations({'Blends', 'PallMall', 'Prince', 'BlueMaster'}, 4):\n                map_info[1][4], map_info[2][4], map_info[3][4], map_info[4][4] = y\n\n                if check(map_info):\n                    res.append(deepcopy(map_info))\n\nfor r in res:\n    print(r)\n\n```","source":"_posts/训练营/穷举搜索法06.md","raw":"---\ntitle: 爱因斯坦的思考题 下\n---\n\n穷举来源\n    \n    每个状态有 5 个类型\n    每个类型又要对 5 个值进行排列组合\n\n穷举实现\n    \n    根据状态分布，有3个类型是有值在固定位置的\n    则对于国籍需要对4个位置进行排列\n    对于颜色 由于5间房子排成一排\n    所以 蓝色固定在第二间房 \n    而 绿和白存在绑定关系 则对3个位置进行排列\n    对于饮料 住中间位置的人 喝牛奶\n    则需要对 4 个位置进行排列\n    \n    剪枝操作 --。感觉智商不够用\n\n\n使用Python语言实现 \n```python\nfrom itertools import permutations\nfrom copy import deepcopy\n\n#  房子      国籍     饮料     宠物     烟\n# 初始化5个组 用以代表5个人以及5个属性\nmap_info = [\n    [''] * 5 for _ in range(5)\n]\n\n# 根据线索9 得到\nmap_info[0][1] = '挪威'\n\n# 根据 房间排成一排 与线索14 得到\nmap_info[1][0] = '蓝色'\n\n# 根据 线索8 得到\nmap_info[2][2] = '牛奶'\n\n# 线索绑定 s4 得到 绿色白色为一体\n# 并且只能在2，3 或3，4位置，0开始\n# s1 = ['红色', '英国', '', '', '']\n# s2 = ['', '瑞典', '', '狗', '']\n# s3 = ['', '丹麦', '茶', '', '']\n# s5 = ['绿色', '', '咖啡', '', '']\n# s6 = ['', '', '', '鸟', 'PallMall']\n# s7 = ['黄色', '', '', '', 'Dunhill']\n# s12 = ['', '', '啤酒', '', 'BlueMaster']\n# s13 = ['', '德国', '', '', 'Prince']\n\n#    # s11 10, 15\n\n# 从颜色开始，绿白只能或3，4位置 绿房 喝 咖啡\n# 2位置已经固定为牛奶了 s5\nmap_info[3][0] = '绿色'\nmap_info[3][2] = '咖啡'\nmap_info[4][0] = '白色'\n\n# 结合国籍看 那么剩下颜色中间位置\nmap_info[2][0] = '红色'\nmap_info[2][1] = '英国'\nmap_info[0][0] = '黄色'\n# print(map_info)\n# todo ---以上 颜色排列完整\n\n# s7 绑定 Dunhill\nmap_info[0][4] = 'Dunhill'\n# s11 养马的人和抽 Dunhill 牌香烟的人相邻\nmap_info[1][3] = '马'\n# print(map_info)\n\n\n# 对剩下的7个线索做为消费数据对象\n# 对剩下的4个类型作为排列对象生产数据\n\n\n# 消费数据\ndef check(map_info_test):\n    for i in range(5):\n\n        if map_info_test[i][1] == '瑞典' and map_info_test[i][3] != '狗':\n            return False\n        if map_info_test[i][1] == '丹麦' and map_info_test[i][2] != '茶':\n            return False\n        if map_info_test[i][3] == '鸟' and map_info_test[i][4] != 'PallMall':\n            return False\n        if map_info_test[i][2] == '啤酒' and map_info_test[i][4] != 'BlueMaster':\n            return False\n        if map_info_test[i][1] == '德国' and map_info_test[i][4] != 'Prince':\n            return False\n        if map_info_test[i][4] == 'Blends':\n            status = False\n            try:\n                if map_info_test[i - 1][3] == '猫':\n                    status = True\n            except:\n                pass\n            try:\n                if map_info_test[i + 1][3] == '猫':\n                    status = True\n            except:\n                pass\n            if status is False:\n                return False\n\n        if map_info_test[i][4] == 'Blends':\n\n            status = False\n            try:\n                if map_info_test[i - 1][2] == '水':\n                    status = True\n            except:\n                pass\n            try:\n                if map_info_test[i + 1][2] == '水':\n                    status = True\n            except:\n                pass\n            if status is False:\n                return False\n    # 通过校验\n    return True\n\n\n# 生产数据\n\"\"\"\n1. 国籍 1，3，4 -- 丹麦、德国、瑞典\n2. 饮料 0，1，4 -- 水、茶、啤酒\n3. 宠物 0，2，3，4 -- 猫、鸟、鱼、狗\n4. 烟 1，2，3，4 -- Blends、PallMall、Prince、BlueMaster\n\"\"\"\n\nres = []\nfor g in permutations({'丹麦', '德国', '瑞典'}, 3):\n    map_info[1][1], map_info[3][1], map_info[4][1] = g\n    # print(map_info)\n\n    for yl in permutations({'水', '茶', ' 啤酒'}, 3):\n        map_info[0][2], map_info[1][2], map_info[4][2] = yl\n\n        for c in permutations({'猫', '鸟', '鱼', '狗'}, 4):\n            map_info[0][3], map_info[2][3], map_info[3][3], map_info[4][3] = c\n\n            for y in permutations({'Blends', 'PallMall', 'Prince', 'BlueMaster'}, 4):\n                map_info[1][4], map_info[2][4], map_info[3][4], map_info[4][4] = y\n\n                if check(map_info):\n                    res.append(deepcopy(map_info))\n\nfor r in res:\n    print(r)\n\n```","slug":"训练营/穷举搜索法06","published":1,"date":"2019-04-08T16:45:49.390Z","updated":"2019-04-08T16:45:49.390Z","_id":"cjwd4c7b1000wsv72iiqavkvm","comments":1,"layout":"post","photos":[],"link":"","content":"<p>穷举来源</p>\n<pre><code>每个状态有 5 个类型\n每个类型又要对 5 个值进行排列组合\n</code></pre><p>穷举实现</p>\n<pre><code>根据状态分布，有3个类型是有值在固定位置的\n则对于国籍需要对4个位置进行排列\n对于颜色 由于5间房子排成一排\n所以 蓝色固定在第二间房 \n而 绿和白存在绑定关系 则对3个位置进行排列\n对于饮料 住中间位置的人 喝牛奶\n则需要对 4 个位置进行排列\n\n剪枝操作 --。感觉智商不够用\n</code></pre><p>使用Python语言实现<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> itertools <span class=\"keyword\">import</span> permutations</span><br><span class=\"line\"><span class=\"keyword\">from</span> copy <span class=\"keyword\">import</span> deepcopy</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#  房子      国籍     饮料     宠物     烟</span></span><br><span class=\"line\"><span class=\"comment\"># 初始化5个组 用以代表5个人以及5个属性</span></span><br><span class=\"line\">map_info = [</span><br><span class=\"line\">    [<span class=\"string\">''</span>] * <span class=\"number\">5</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>)</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 根据线索9 得到</span></span><br><span class=\"line\">map_info[<span class=\"number\">0</span>][<span class=\"number\">1</span>] = <span class=\"string\">'挪威'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 根据 房间排成一排 与线索14 得到</span></span><br><span class=\"line\">map_info[<span class=\"number\">1</span>][<span class=\"number\">0</span>] = <span class=\"string\">'蓝色'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 根据 线索8 得到</span></span><br><span class=\"line\">map_info[<span class=\"number\">2</span>][<span class=\"number\">2</span>] = <span class=\"string\">'牛奶'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 线索绑定 s4 得到 绿色白色为一体</span></span><br><span class=\"line\"><span class=\"comment\"># 并且只能在2，3 或3，4位置，0开始</span></span><br><span class=\"line\"><span class=\"comment\"># s1 = ['红色', '英国', '', '', '']</span></span><br><span class=\"line\"><span class=\"comment\"># s2 = ['', '瑞典', '', '狗', '']</span></span><br><span class=\"line\"><span class=\"comment\"># s3 = ['', '丹麦', '茶', '', '']</span></span><br><span class=\"line\"><span class=\"comment\"># s5 = ['绿色', '', '咖啡', '', '']</span></span><br><span class=\"line\"><span class=\"comment\"># s6 = ['', '', '', '鸟', 'PallMall']</span></span><br><span class=\"line\"><span class=\"comment\"># s7 = ['黄色', '', '', '', 'Dunhill']</span></span><br><span class=\"line\"><span class=\"comment\"># s12 = ['', '', '啤酒', '', 'BlueMaster']</span></span><br><span class=\"line\"><span class=\"comment\"># s13 = ['', '德国', '', '', 'Prince']</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#    # s11 10, 15</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从颜色开始，绿白只能或3，4位置 绿房 喝 咖啡</span></span><br><span class=\"line\"><span class=\"comment\"># 2位置已经固定为牛奶了 s5</span></span><br><span class=\"line\">map_info[<span class=\"number\">3</span>][<span class=\"number\">0</span>] = <span class=\"string\">'绿色'</span></span><br><span class=\"line\">map_info[<span class=\"number\">3</span>][<span class=\"number\">2</span>] = <span class=\"string\">'咖啡'</span></span><br><span class=\"line\">map_info[<span class=\"number\">4</span>][<span class=\"number\">0</span>] = <span class=\"string\">'白色'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 结合国籍看 那么剩下颜色中间位置</span></span><br><span class=\"line\">map_info[<span class=\"number\">2</span>][<span class=\"number\">0</span>] = <span class=\"string\">'红色'</span></span><br><span class=\"line\">map_info[<span class=\"number\">2</span>][<span class=\"number\">1</span>] = <span class=\"string\">'英国'</span></span><br><span class=\"line\">map_info[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"string\">'黄色'</span></span><br><span class=\"line\"><span class=\"comment\"># print(map_info)</span></span><br><span class=\"line\"><span class=\"comment\"># todo ---以上 颜色排列完整</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># s7 绑定 Dunhill</span></span><br><span class=\"line\">map_info[<span class=\"number\">0</span>][<span class=\"number\">4</span>] = <span class=\"string\">'Dunhill'</span></span><br><span class=\"line\"><span class=\"comment\"># s11 养马的人和抽 Dunhill 牌香烟的人相邻</span></span><br><span class=\"line\">map_info[<span class=\"number\">1</span>][<span class=\"number\">3</span>] = <span class=\"string\">'马'</span></span><br><span class=\"line\"><span class=\"comment\"># print(map_info)</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 对剩下的7个线索做为消费数据对象</span></span><br><span class=\"line\"><span class=\"comment\"># 对剩下的4个类型作为排列对象生产数据</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 消费数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check</span><span class=\"params\">(map_info_test)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>):</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> map_info_test[i][<span class=\"number\">1</span>] == <span class=\"string\">'瑞典'</span> <span class=\"keyword\">and</span> map_info_test[i][<span class=\"number\">3</span>] != <span class=\"string\">'狗'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> map_info_test[i][<span class=\"number\">1</span>] == <span class=\"string\">'丹麦'</span> <span class=\"keyword\">and</span> map_info_test[i][<span class=\"number\">2</span>] != <span class=\"string\">'茶'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> map_info_test[i][<span class=\"number\">3</span>] == <span class=\"string\">'鸟'</span> <span class=\"keyword\">and</span> map_info_test[i][<span class=\"number\">4</span>] != <span class=\"string\">'PallMall'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> map_info_test[i][<span class=\"number\">2</span>] == <span class=\"string\">'啤酒'</span> <span class=\"keyword\">and</span> map_info_test[i][<span class=\"number\">4</span>] != <span class=\"string\">'BlueMaster'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> map_info_test[i][<span class=\"number\">1</span>] == <span class=\"string\">'德国'</span> <span class=\"keyword\">and</span> map_info_test[i][<span class=\"number\">4</span>] != <span class=\"string\">'Prince'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> map_info_test[i][<span class=\"number\">4</span>] == <span class=\"string\">'Blends'</span>:</span><br><span class=\"line\">            status = <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> map_info_test[i - <span class=\"number\">1</span>][<span class=\"number\">3</span>] == <span class=\"string\">'猫'</span>:</span><br><span class=\"line\">                    status = <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"keyword\">except</span>:</span><br><span class=\"line\">                <span class=\"keyword\">pass</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> map_info_test[i + <span class=\"number\">1</span>][<span class=\"number\">3</span>] == <span class=\"string\">'猫'</span>:</span><br><span class=\"line\">                    status = <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"keyword\">except</span>:</span><br><span class=\"line\">                <span class=\"keyword\">pass</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> status <span class=\"keyword\">is</span> <span class=\"literal\">False</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> map_info_test[i][<span class=\"number\">4</span>] == <span class=\"string\">'Blends'</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">            status = <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> map_info_test[i - <span class=\"number\">1</span>][<span class=\"number\">2</span>] == <span class=\"string\">'水'</span>:</span><br><span class=\"line\">                    status = <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"keyword\">except</span>:</span><br><span class=\"line\">                <span class=\"keyword\">pass</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> map_info_test[i + <span class=\"number\">1</span>][<span class=\"number\">2</span>] == <span class=\"string\">'水'</span>:</span><br><span class=\"line\">                    status = <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"keyword\">except</span>:</span><br><span class=\"line\">                <span class=\"keyword\">pass</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> status <span class=\"keyword\">is</span> <span class=\"literal\">False</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"comment\"># 通过校验</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 生产数据</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">1. 国籍 1，3，4 -- 丹麦、德国、瑞典</span></span><br><span class=\"line\"><span class=\"string\">2. 饮料 0，1，4 -- 水、茶、啤酒</span></span><br><span class=\"line\"><span class=\"string\">3. 宠物 0，2，3，4 -- 猫、鸟、鱼、狗</span></span><br><span class=\"line\"><span class=\"string\">4. 烟 1，2，3，4 -- Blends、PallMall、Prince、BlueMaster</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">res = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> g <span class=\"keyword\">in</span> permutations(&#123;<span class=\"string\">'丹麦'</span>, <span class=\"string\">'德国'</span>, <span class=\"string\">'瑞典'</span>&#125;, <span class=\"number\">3</span>):</span><br><span class=\"line\">    map_info[<span class=\"number\">1</span>][<span class=\"number\">1</span>], map_info[<span class=\"number\">3</span>][<span class=\"number\">1</span>], map_info[<span class=\"number\">4</span>][<span class=\"number\">1</span>] = g</span><br><span class=\"line\">    <span class=\"comment\"># print(map_info)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> yl <span class=\"keyword\">in</span> permutations(&#123;<span class=\"string\">'水'</span>, <span class=\"string\">'茶'</span>, <span class=\"string\">' 啤酒'</span>&#125;, <span class=\"number\">3</span>):</span><br><span class=\"line\">        map_info[<span class=\"number\">0</span>][<span class=\"number\">2</span>], map_info[<span class=\"number\">1</span>][<span class=\"number\">2</span>], map_info[<span class=\"number\">4</span>][<span class=\"number\">2</span>] = yl</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> permutations(&#123;<span class=\"string\">'猫'</span>, <span class=\"string\">'鸟'</span>, <span class=\"string\">'鱼'</span>, <span class=\"string\">'狗'</span>&#125;, <span class=\"number\">4</span>):</span><br><span class=\"line\">            map_info[<span class=\"number\">0</span>][<span class=\"number\">3</span>], map_info[<span class=\"number\">2</span>][<span class=\"number\">3</span>], map_info[<span class=\"number\">3</span>][<span class=\"number\">3</span>], map_info[<span class=\"number\">4</span>][<span class=\"number\">3</span>] = c</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> permutations(&#123;<span class=\"string\">'Blends'</span>, <span class=\"string\">'PallMall'</span>, <span class=\"string\">'Prince'</span>, <span class=\"string\">'BlueMaster'</span>&#125;, <span class=\"number\">4</span>):</span><br><span class=\"line\">                map_info[<span class=\"number\">1</span>][<span class=\"number\">4</span>], map_info[<span class=\"number\">2</span>][<span class=\"number\">4</span>], map_info[<span class=\"number\">3</span>][<span class=\"number\">4</span>], map_info[<span class=\"number\">4</span>][<span class=\"number\">4</span>] = y</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> check(map_info):</span><br><span class=\"line\">                    res.append(deepcopy(map_info))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> r <span class=\"keyword\">in</span> res:</span><br><span class=\"line\">    print(r)</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>穷举来源</p>\n<pre><code>每个状态有 5 个类型\n每个类型又要对 5 个值进行排列组合\n</code></pre><p>穷举实现</p>\n<pre><code>根据状态分布，有3个类型是有值在固定位置的\n则对于国籍需要对4个位置进行排列\n对于颜色 由于5间房子排成一排\n所以 蓝色固定在第二间房 \n而 绿和白存在绑定关系 则对3个位置进行排列\n对于饮料 住中间位置的人 喝牛奶\n则需要对 4 个位置进行排列\n\n剪枝操作 --。感觉智商不够用\n</code></pre><p>使用Python语言实现<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> itertools <span class=\"keyword\">import</span> permutations</span><br><span class=\"line\"><span class=\"keyword\">from</span> copy <span class=\"keyword\">import</span> deepcopy</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#  房子      国籍     饮料     宠物     烟</span></span><br><span class=\"line\"><span class=\"comment\"># 初始化5个组 用以代表5个人以及5个属性</span></span><br><span class=\"line\">map_info = [</span><br><span class=\"line\">    [<span class=\"string\">''</span>] * <span class=\"number\">5</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>)</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 根据线索9 得到</span></span><br><span class=\"line\">map_info[<span class=\"number\">0</span>][<span class=\"number\">1</span>] = <span class=\"string\">'挪威'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 根据 房间排成一排 与线索14 得到</span></span><br><span class=\"line\">map_info[<span class=\"number\">1</span>][<span class=\"number\">0</span>] = <span class=\"string\">'蓝色'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 根据 线索8 得到</span></span><br><span class=\"line\">map_info[<span class=\"number\">2</span>][<span class=\"number\">2</span>] = <span class=\"string\">'牛奶'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 线索绑定 s4 得到 绿色白色为一体</span></span><br><span class=\"line\"><span class=\"comment\"># 并且只能在2，3 或3，4位置，0开始</span></span><br><span class=\"line\"><span class=\"comment\"># s1 = ['红色', '英国', '', '', '']</span></span><br><span class=\"line\"><span class=\"comment\"># s2 = ['', '瑞典', '', '狗', '']</span></span><br><span class=\"line\"><span class=\"comment\"># s3 = ['', '丹麦', '茶', '', '']</span></span><br><span class=\"line\"><span class=\"comment\"># s5 = ['绿色', '', '咖啡', '', '']</span></span><br><span class=\"line\"><span class=\"comment\"># s6 = ['', '', '', '鸟', 'PallMall']</span></span><br><span class=\"line\"><span class=\"comment\"># s7 = ['黄色', '', '', '', 'Dunhill']</span></span><br><span class=\"line\"><span class=\"comment\"># s12 = ['', '', '啤酒', '', 'BlueMaster']</span></span><br><span class=\"line\"><span class=\"comment\"># s13 = ['', '德国', '', '', 'Prince']</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#    # s11 10, 15</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从颜色开始，绿白只能或3，4位置 绿房 喝 咖啡</span></span><br><span class=\"line\"><span class=\"comment\"># 2位置已经固定为牛奶了 s5</span></span><br><span class=\"line\">map_info[<span class=\"number\">3</span>][<span class=\"number\">0</span>] = <span class=\"string\">'绿色'</span></span><br><span class=\"line\">map_info[<span class=\"number\">3</span>][<span class=\"number\">2</span>] = <span class=\"string\">'咖啡'</span></span><br><span class=\"line\">map_info[<span class=\"number\">4</span>][<span class=\"number\">0</span>] = <span class=\"string\">'白色'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 结合国籍看 那么剩下颜色中间位置</span></span><br><span class=\"line\">map_info[<span class=\"number\">2</span>][<span class=\"number\">0</span>] = <span class=\"string\">'红色'</span></span><br><span class=\"line\">map_info[<span class=\"number\">2</span>][<span class=\"number\">1</span>] = <span class=\"string\">'英国'</span></span><br><span class=\"line\">map_info[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"string\">'黄色'</span></span><br><span class=\"line\"><span class=\"comment\"># print(map_info)</span></span><br><span class=\"line\"><span class=\"comment\"># todo ---以上 颜色排列完整</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># s7 绑定 Dunhill</span></span><br><span class=\"line\">map_info[<span class=\"number\">0</span>][<span class=\"number\">4</span>] = <span class=\"string\">'Dunhill'</span></span><br><span class=\"line\"><span class=\"comment\"># s11 养马的人和抽 Dunhill 牌香烟的人相邻</span></span><br><span class=\"line\">map_info[<span class=\"number\">1</span>][<span class=\"number\">3</span>] = <span class=\"string\">'马'</span></span><br><span class=\"line\"><span class=\"comment\"># print(map_info)</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 对剩下的7个线索做为消费数据对象</span></span><br><span class=\"line\"><span class=\"comment\"># 对剩下的4个类型作为排列对象生产数据</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 消费数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check</span><span class=\"params\">(map_info_test)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>):</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> map_info_test[i][<span class=\"number\">1</span>] == <span class=\"string\">'瑞典'</span> <span class=\"keyword\">and</span> map_info_test[i][<span class=\"number\">3</span>] != <span class=\"string\">'狗'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> map_info_test[i][<span class=\"number\">1</span>] == <span class=\"string\">'丹麦'</span> <span class=\"keyword\">and</span> map_info_test[i][<span class=\"number\">2</span>] != <span class=\"string\">'茶'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> map_info_test[i][<span class=\"number\">3</span>] == <span class=\"string\">'鸟'</span> <span class=\"keyword\">and</span> map_info_test[i][<span class=\"number\">4</span>] != <span class=\"string\">'PallMall'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> map_info_test[i][<span class=\"number\">2</span>] == <span class=\"string\">'啤酒'</span> <span class=\"keyword\">and</span> map_info_test[i][<span class=\"number\">4</span>] != <span class=\"string\">'BlueMaster'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> map_info_test[i][<span class=\"number\">1</span>] == <span class=\"string\">'德国'</span> <span class=\"keyword\">and</span> map_info_test[i][<span class=\"number\">4</span>] != <span class=\"string\">'Prince'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> map_info_test[i][<span class=\"number\">4</span>] == <span class=\"string\">'Blends'</span>:</span><br><span class=\"line\">            status = <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> map_info_test[i - <span class=\"number\">1</span>][<span class=\"number\">3</span>] == <span class=\"string\">'猫'</span>:</span><br><span class=\"line\">                    status = <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"keyword\">except</span>:</span><br><span class=\"line\">                <span class=\"keyword\">pass</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> map_info_test[i + <span class=\"number\">1</span>][<span class=\"number\">3</span>] == <span class=\"string\">'猫'</span>:</span><br><span class=\"line\">                    status = <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"keyword\">except</span>:</span><br><span class=\"line\">                <span class=\"keyword\">pass</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> status <span class=\"keyword\">is</span> <span class=\"literal\">False</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> map_info_test[i][<span class=\"number\">4</span>] == <span class=\"string\">'Blends'</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">            status = <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> map_info_test[i - <span class=\"number\">1</span>][<span class=\"number\">2</span>] == <span class=\"string\">'水'</span>:</span><br><span class=\"line\">                    status = <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"keyword\">except</span>:</span><br><span class=\"line\">                <span class=\"keyword\">pass</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> map_info_test[i + <span class=\"number\">1</span>][<span class=\"number\">2</span>] == <span class=\"string\">'水'</span>:</span><br><span class=\"line\">                    status = <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"keyword\">except</span>:</span><br><span class=\"line\">                <span class=\"keyword\">pass</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> status <span class=\"keyword\">is</span> <span class=\"literal\">False</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"comment\"># 通过校验</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 生产数据</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">1. 国籍 1，3，4 -- 丹麦、德国、瑞典</span></span><br><span class=\"line\"><span class=\"string\">2. 饮料 0，1，4 -- 水、茶、啤酒</span></span><br><span class=\"line\"><span class=\"string\">3. 宠物 0，2，3，4 -- 猫、鸟、鱼、狗</span></span><br><span class=\"line\"><span class=\"string\">4. 烟 1，2，3，4 -- Blends、PallMall、Prince、BlueMaster</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">res = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> g <span class=\"keyword\">in</span> permutations(&#123;<span class=\"string\">'丹麦'</span>, <span class=\"string\">'德国'</span>, <span class=\"string\">'瑞典'</span>&#125;, <span class=\"number\">3</span>):</span><br><span class=\"line\">    map_info[<span class=\"number\">1</span>][<span class=\"number\">1</span>], map_info[<span class=\"number\">3</span>][<span class=\"number\">1</span>], map_info[<span class=\"number\">4</span>][<span class=\"number\">1</span>] = g</span><br><span class=\"line\">    <span class=\"comment\"># print(map_info)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> yl <span class=\"keyword\">in</span> permutations(&#123;<span class=\"string\">'水'</span>, <span class=\"string\">'茶'</span>, <span class=\"string\">' 啤酒'</span>&#125;, <span class=\"number\">3</span>):</span><br><span class=\"line\">        map_info[<span class=\"number\">0</span>][<span class=\"number\">2</span>], map_info[<span class=\"number\">1</span>][<span class=\"number\">2</span>], map_info[<span class=\"number\">4</span>][<span class=\"number\">2</span>] = yl</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> permutations(&#123;<span class=\"string\">'猫'</span>, <span class=\"string\">'鸟'</span>, <span class=\"string\">'鱼'</span>, <span class=\"string\">'狗'</span>&#125;, <span class=\"number\">4</span>):</span><br><span class=\"line\">            map_info[<span class=\"number\">0</span>][<span class=\"number\">3</span>], map_info[<span class=\"number\">2</span>][<span class=\"number\">3</span>], map_info[<span class=\"number\">3</span>][<span class=\"number\">3</span>], map_info[<span class=\"number\">4</span>][<span class=\"number\">3</span>] = c</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> permutations(&#123;<span class=\"string\">'Blends'</span>, <span class=\"string\">'PallMall'</span>, <span class=\"string\">'Prince'</span>, <span class=\"string\">'BlueMaster'</span>&#125;, <span class=\"number\">4</span>):</span><br><span class=\"line\">                map_info[<span class=\"number\">1</span>][<span class=\"number\">4</span>], map_info[<span class=\"number\">2</span>][<span class=\"number\">4</span>], map_info[<span class=\"number\">3</span>][<span class=\"number\">4</span>], map_info[<span class=\"number\">4</span>][<span class=\"number\">4</span>] = y</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> check(map_info):</span><br><span class=\"line\">                    res.append(deepcopy(map_info))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> r <span class=\"keyword\">in</span> res:</span><br><span class=\"line\">    print(r)</span><br></pre></td></tr></table></figure></p>\n"},{"title":"多点共线问题","_content":"\n问题提出\n    \n    一个几何平面上有 N 个点，\n    根据欧氏（欧几里得）几何原理，\n    每两个点可以连成一条直线，\n    N 个点可以连成很多条直线。\n    当然，也会有多个点共线的情况出现，\n    现在我们的问题是，在这 N 个点中，\n    找出哪两个点组成的直线上包含最多的点，\n    也就是找出含有最多点的那条直线。\n    \n注意浮点数不要直接比较值相等\n    \n解题思路\n    \n    确定一个点为原点\n    其他点过原点的斜率计算\n    统计出斜率频次并取最大，并记录\n    依次遍历点作为原点，重复上面操作\n    从记录的频次列表中\n    求得最大的即为含有最多点的那条直线。\n    \n使用Python实现\n```python\nfrom collections import Counter\n\n\ndef get_most_count(spot_list):\n    res = set()\n    for j in range(len(spot_list)):\n        tmp = list()\n        for i, spot in enumerate(spot_list):\n\n            if j == i:\n                continue\n            x, y = spot\n            x0, y0 = spot_list[j]\n            # 注意x==x0时的情况为斜率不存在\n            if (x - x0) != 0:\n                tmp.append(format((y - y0) / (x - x0), '.8f'))\n            else:\n                tmp.append(float(\"inf\"))\n        res.add(max(Counter(tmp).values()))\n    return max(res) + 1\n```\n    ","source":"_posts/训练营/穷举搜索法07.md","raw":"---\ntitle: 多点共线问题\n---\n\n问题提出\n    \n    一个几何平面上有 N 个点，\n    根据欧氏（欧几里得）几何原理，\n    每两个点可以连成一条直线，\n    N 个点可以连成很多条直线。\n    当然，也会有多个点共线的情况出现，\n    现在我们的问题是，在这 N 个点中，\n    找出哪两个点组成的直线上包含最多的点，\n    也就是找出含有最多点的那条直线。\n    \n注意浮点数不要直接比较值相等\n    \n解题思路\n    \n    确定一个点为原点\n    其他点过原点的斜率计算\n    统计出斜率频次并取最大，并记录\n    依次遍历点作为原点，重复上面操作\n    从记录的频次列表中\n    求得最大的即为含有最多点的那条直线。\n    \n使用Python实现\n```python\nfrom collections import Counter\n\n\ndef get_most_count(spot_list):\n    res = set()\n    for j in range(len(spot_list)):\n        tmp = list()\n        for i, spot in enumerate(spot_list):\n\n            if j == i:\n                continue\n            x, y = spot\n            x0, y0 = spot_list[j]\n            # 注意x==x0时的情况为斜率不存在\n            if (x - x0) != 0:\n                tmp.append(format((y - y0) / (x - x0), '.8f'))\n            else:\n                tmp.append(float(\"inf\"))\n        res.add(max(Counter(tmp).values()))\n    return max(res) + 1\n```\n    ","slug":"训练营/穷举搜索法07","published":1,"date":"2019-04-09T13:54:18.913Z","updated":"2019-04-09T13:54:18.913Z","_id":"cjwd4c7dz000xsv72vokm3wvc","comments":1,"layout":"post","photos":[],"link":"","content":"<p>问题提出</p>\n<pre><code>一个几何平面上有 N 个点，\n根据欧氏（欧几里得）几何原理，\n每两个点可以连成一条直线，\nN 个点可以连成很多条直线。\n当然，也会有多个点共线的情况出现，\n现在我们的问题是，在这 N 个点中，\n找出哪两个点组成的直线上包含最多的点，\n也就是找出含有最多点的那条直线。\n</code></pre><p>注意浮点数不要直接比较值相等</p>\n<p>解题思路</p>\n<pre><code>确定一个点为原点\n其他点过原点的斜率计算\n统计出斜率频次并取最大，并记录\n依次遍历点作为原点，重复上面操作\n从记录的频次列表中\n求得最大的即为含有最多点的那条直线。\n</code></pre><p>使用Python实现<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_most_count</span><span class=\"params\">(spot_list)</span>:</span></span><br><span class=\"line\">    res = set()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(spot_list)):</span><br><span class=\"line\">        tmp = list()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, spot <span class=\"keyword\">in</span> enumerate(spot_list):</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> j == i:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            x, y = spot</span><br><span class=\"line\">            x0, y0 = spot_list[j]</span><br><span class=\"line\">            <span class=\"comment\"># 注意x==x0时的情况为斜率不存在</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x - x0) != <span class=\"number\">0</span>:</span><br><span class=\"line\">                tmp.append(format((y - y0) / (x - x0), <span class=\"string\">'.8f'</span>))</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                tmp.append(float(<span class=\"string\">\"inf\"</span>))</span><br><span class=\"line\">        res.add(max(Counter(tmp).values()))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(res) + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>问题提出</p>\n<pre><code>一个几何平面上有 N 个点，\n根据欧氏（欧几里得）几何原理，\n每两个点可以连成一条直线，\nN 个点可以连成很多条直线。\n当然，也会有多个点共线的情况出现，\n现在我们的问题是，在这 N 个点中，\n找出哪两个点组成的直线上包含最多的点，\n也就是找出含有最多点的那条直线。\n</code></pre><p>注意浮点数不要直接比较值相等</p>\n<p>解题思路</p>\n<pre><code>确定一个点为原点\n其他点过原点的斜率计算\n统计出斜率频次并取最大，并记录\n依次遍历点作为原点，重复上面操作\n从记录的频次列表中\n求得最大的即为含有最多点的那条直线。\n</code></pre><p>使用Python实现<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_most_count</span><span class=\"params\">(spot_list)</span>:</span></span><br><span class=\"line\">    res = set()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(spot_list)):</span><br><span class=\"line\">        tmp = list()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, spot <span class=\"keyword\">in</span> enumerate(spot_list):</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> j == i:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            x, y = spot</span><br><span class=\"line\">            x0, y0 = spot_list[j]</span><br><span class=\"line\">            <span class=\"comment\"># 注意x==x0时的情况为斜率不存在</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x - x0) != <span class=\"number\">0</span>:</span><br><span class=\"line\">                tmp.append(format((y - y0) / (x - x0), <span class=\"string\">'.8f'</span>))</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                tmp.append(float(<span class=\"string\">\"inf\"</span>))</span><br><span class=\"line\">        res.add(max(Counter(tmp).values()))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(res) + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure></p>\n"},{"title":"如何设计递归函数","_content":"\n递归\n    \n    1. 确定递归子结构\n    2. 确定递归退出条件和退出处理\n    3. 递归的自我触发机制\n\n    基本原则是能不使用递归就不使用递归，\n    毕竟递归方法存在效率和栈的开销问题，\n    在搞不清楚问题规模的情况下，\n    很容易出现问题。\n\n\n二叉树的前序遍历\n    \n    根-->左-->右\n    \n    \n举个简单的例子\n```python\ndef fib(n):\n    \n    if n <= 1:\n        return 1\n    else:\n        return fib(n-1)+fib(n-2)\n\n```","source":"_posts/训练营/穷举搜索法08.md","raw":"---\ntitle: 如何设计递归函数\n---\n\n递归\n    \n    1. 确定递归子结构\n    2. 确定递归退出条件和退出处理\n    3. 递归的自我触发机制\n\n    基本原则是能不使用递归就不使用递归，\n    毕竟递归方法存在效率和栈的开销问题，\n    在搞不清楚问题规模的情况下，\n    很容易出现问题。\n\n\n二叉树的前序遍历\n    \n    根-->左-->右\n    \n    \n举个简单的例子\n```python\ndef fib(n):\n    \n    if n <= 1:\n        return 1\n    else:\n        return fib(n-1)+fib(n-2)\n\n```","slug":"训练营/穷举搜索法08","published":1,"date":"2019-04-09T15:05:30.183Z","updated":"2019-04-09T15:05:30.183Z","_id":"cjwd4c7e0000ysv72wfxtcp5c","comments":1,"layout":"post","photos":[],"link":"","content":"<p>递归</p>\n<pre><code>1. 确定递归子结构\n2. 确定递归退出条件和退出处理\n3. 递归的自我触发机制\n\n基本原则是能不使用递归就不使用递归，\n毕竟递归方法存在效率和栈的开销问题，\n在搞不清楚问题规模的情况下，\n很容易出现问题。\n</code></pre><p>二叉树的前序遍历</p>\n<pre><code>根--&gt;左--&gt;右\n</code></pre><p>举个简单的例子<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fib</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> n &lt;= <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fib(n<span class=\"number\">-1</span>)+fib(n<span class=\"number\">-2</span>)</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>递归</p>\n<pre><code>1. 确定递归子结构\n2. 确定递归退出条件和退出处理\n3. 递归的自我触发机制\n\n基本原则是能不使用递归就不使用递归，\n毕竟递归方法存在效率和栈的开销问题，\n在搞不清楚问题规模的情况下，\n很容易出现问题。\n</code></pre><p>二叉树的前序遍历</p>\n<pre><code>根--&gt;左--&gt;右\n</code></pre><p>举个简单的例子<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fib</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> n &lt;= <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fib(n<span class=\"number\">-1</span>)+fib(n<span class=\"number\">-2</span>)</span><br></pre></td></tr></table></figure></p>\n"},{"title":"推箱子游戏","_content":"\nGET\n\n    偏移量数组 { { -1,0 }、{ 0,1 }、{ 1,0 }、{ 0,-1 } } \n    分别表示“上”、“右”、“下”和“左”四个方向的偏移，\n    对这个数组遍历一遍，即可完成对某个位置四周的四个小格子的遍历。\n\n[回顾](https://leetcode-cn.com/contest/weekly-contest-125/problems/available-captures-for-rook/)\n    \n    在一个 8 x 8 的棋盘上，\n    有一个白色车（rook）。\n    也可能有空方块，白色的象（bishop）\n    和黑色的卒（pawn）。\n    它们分别以字符 “R”，“.”，“B” 和 “p” 给出。\n    大写字符表示白棋，小写字符表示黑棋。\n\n    车按国际象棋中的规则移动：\n    它选择四个基本方向中的一个（北，东，西和南），\n    然后朝那个方向移动，直到它选择停止、\n    到达棋盘的边缘或移动到同一方格\n    来捕获该方格上颜色相反的卒。\n    另外，车不能与其他友方（白色）象进入同一个方格。\n    返回车能够在一次移动中捕获到的卒的数量。\n    \n    ","source":"_posts/训练营/穷举搜索法09.md","raw":"---\ntitle: 推箱子游戏\n---\n\nGET\n\n    偏移量数组 { { -1,0 }、{ 0,1 }、{ 1,0 }、{ 0,-1 } } \n    分别表示“上”、“右”、“下”和“左”四个方向的偏移，\n    对这个数组遍历一遍，即可完成对某个位置四周的四个小格子的遍历。\n\n[回顾](https://leetcode-cn.com/contest/weekly-contest-125/problems/available-captures-for-rook/)\n    \n    在一个 8 x 8 的棋盘上，\n    有一个白色车（rook）。\n    也可能有空方块，白色的象（bishop）\n    和黑色的卒（pawn）。\n    它们分别以字符 “R”，“.”，“B” 和 “p” 给出。\n    大写字符表示白棋，小写字符表示黑棋。\n\n    车按国际象棋中的规则移动：\n    它选择四个基本方向中的一个（北，东，西和南），\n    然后朝那个方向移动，直到它选择停止、\n    到达棋盘的边缘或移动到同一方格\n    来捕获该方格上颜色相反的卒。\n    另外，车不能与其他友方（白色）象进入同一个方格。\n    返回车能够在一次移动中捕获到的卒的数量。\n    \n    ","slug":"训练营/穷举搜索法09","published":1,"date":"2019-04-10T13:26:13.369Z","updated":"2019-04-10T13:26:13.369Z","_id":"cjwd4c7e1000zsv72ldczaz1k","comments":1,"layout":"post","photos":[],"link":"","content":"<p>GET</p>\n<pre><code>偏移量数组 { { -1,0 }、{ 0,1 }、{ 1,0 }、{ 0,-1 } } \n分别表示“上”、“右”、“下”和“左”四个方向的偏移，\n对这个数组遍历一遍，即可完成对某个位置四周的四个小格子的遍历。\n</code></pre><p><a href=\"https://leetcode-cn.com/contest/weekly-contest-125/problems/available-captures-for-rook/\" target=\"_blank\" rel=\"noopener\">回顾</a></p>\n<pre><code>在一个 8 x 8 的棋盘上，\n有一个白色车（rook）。\n也可能有空方块，白色的象（bishop）\n和黑色的卒（pawn）。\n它们分别以字符 “R”，“.”，“B” 和 “p” 给出。\n大写字符表示白棋，小写字符表示黑棋。\n\n车按国际象棋中的规则移动：\n它选择四个基本方向中的一个（北，东，西和南），\n然后朝那个方向移动，直到它选择停止、\n到达棋盘的边缘或移动到同一方格\n来捕获该方格上颜色相反的卒。\n另外，车不能与其他友方（白色）象进入同一个方格。\n返回车能够在一次移动中捕获到的卒的数量。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>GET</p>\n<pre><code>偏移量数组 { { -1,0 }、{ 0,1 }、{ 1,0 }、{ 0,-1 } } \n分别表示“上”、“右”、“下”和“左”四个方向的偏移，\n对这个数组遍历一遍，即可完成对某个位置四周的四个小格子的遍历。\n</code></pre><p><a href=\"https://leetcode-cn.com/contest/weekly-contest-125/problems/available-captures-for-rook/\" target=\"_blank\" rel=\"noopener\">回顾</a></p>\n<pre><code>在一个 8 x 8 的棋盘上，\n有一个白色车（rook）。\n也可能有空方块，白色的象（bishop）\n和黑色的卒（pawn）。\n它们分别以字符 “R”，“.”，“B” 和 “p” 给出。\n大写字符表示白棋，小写字符表示黑棋。\n\n车按国际象棋中的规则移动：\n它选择四个基本方向中的一个（北，东，西和南），\n然后朝那个方向移动，直到它选择停止、\n到达棋盘的边缘或移动到同一方格\n来捕获该方格上颜色相反的卒。\n另外，车不能与其他友方（白色）象进入同一个方格。\n返回车能够在一次移动中捕获到的卒的数量。\n</code></pre>"},{"title":"整数的范围","_content":"\n    8 位有符号整数能表示的范围是 −128 到 127，\n    无符号时能表示的范围是 0 ~ 255。\n    \n    16 位的有符号整数能表示的范围是 −32768 到 32767，\n    无符号时能表示的范围是 0 ~ 65535。\n    \n    32 位的有符号整数能表示的范围是\n     −2,147,483,648 到 2,147,483,647，\n    无符号时能表示的范围是 0 ~ 4,294,967,295。\n    \n    64 位的有符号整数能表示的范围是\n     −9,223,372,036,854,775,808 到 9,223,372,036,854,775,807，\n     无符号时能表示的范围是 0 ~ 18,446,744,073,709,551,615。\n     \n","source":"_posts/训练营/穷举搜索法10.md","raw":"---\ntitle: 整数的范围\n---\n\n    8 位有符号整数能表示的范围是 −128 到 127，\n    无符号时能表示的范围是 0 ~ 255。\n    \n    16 位的有符号整数能表示的范围是 −32768 到 32767，\n    无符号时能表示的范围是 0 ~ 65535。\n    \n    32 位的有符号整数能表示的范围是\n     −2,147,483,648 到 2,147,483,647，\n    无符号时能表示的范围是 0 ~ 4,294,967,295。\n    \n    64 位的有符号整数能表示的范围是\n     −9,223,372,036,854,775,808 到 9,223,372,036,854,775,807，\n     无符号时能表示的范围是 0 ~ 18,446,744,073,709,551,615。\n     \n","slug":"训练营/穷举搜索法10","published":1,"date":"2019-04-10T13:28:01.068Z","updated":"2019-04-10T13:28:01.068Z","_id":"cjwd4c7e30010sv72037uxj0p","comments":1,"layout":"post","photos":[],"link":"","content":"<pre><code>8 位有符号整数能表示的范围是 −128 到 127，\n无符号时能表示的范围是 0 ~ 255。\n\n16 位的有符号整数能表示的范围是 −32768 到 32767，\n无符号时能表示的范围是 0 ~ 65535。\n\n32 位的有符号整数能表示的范围是\n −2,147,483,648 到 2,147,483,647，\n无符号时能表示的范围是 0 ~ 4,294,967,295。\n\n64 位的有符号整数能表示的范围是\n −9,223,372,036,854,775,808 到 9,223,372,036,854,775,807，\n 无符号时能表示的范围是 0 ~ 18,446,744,073,709,551,615。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<pre><code>8 位有符号整数能表示的范围是 −128 到 127，\n无符号时能表示的范围是 0 ~ 255。\n\n16 位的有符号整数能表示的范围是 −32768 到 32767，\n无符号时能表示的范围是 0 ~ 65535。\n\n32 位的有符号整数能表示的范围是\n −2,147,483,648 到 2,147,483,647，\n无符号时能表示的范围是 0 ~ 4,294,967,295。\n\n64 位的有符号整数能表示的范围是\n −9,223,372,036,854,775,808 到 9,223,372,036,854,775,807，\n 无符号时能表示的范围是 0 ~ 18,446,744,073,709,551,615。\n</code></pre>"},{"title":"非线性方程与牛顿迭代法","_content":"\n求解一元非线性方程的常用方法\n\n    二分逼近法\n    牛顿迭代法\n    \n二分逼近法\n\n    数学原理：对于实数域的函数 f(x)f(x)，\n    如果存在实数 kk，使得 f(k) = 0f(k)=0，\n    则 x = kx=k 就是函数 f(x)f(x) 的零点。\n    如果函数 f(x)f(x) 是连续函数，\n    且在区间 [a,b] 上是单调函数，\n    只要 f(a)和 f(b)异号，\n    就说明在区间 [a,b] 内一定有零点。\n\n使用Python语言实现 二分逼近法 求解方程\n```python\n\ndef func(x):\n    return 2.0 * x * x + 3.2 * x - 1.8\n\n\ndef dichotomy_equation(a, b, f):\n    esp = 0.1 ** 6\n    mid = (a + b) / 2\n    while abs(b - a) > esp:\n\n        # 说明零点[方程解]存在于（a, mid）\n        if f(a) * f(mid) < 0:\n            b = mid\n        else:\n            a = mid\n        mid = (a + b) / 2\n    return mid\n\n\n# 求 2.0 * x * x + 3.2 * x - 1.8 在 (-1,2)上的解\nres = dichotomy_equation(-1, 2, func)\n# 0.4409674406051636\nprint(res)\n\n```\n\n牛顿迭代法\n\n\n使用Python实现 牛顿迭代法\n```python\ndef calc_derivative(func, x):\n    a = 0.000001\n    b = a*5\n    return (func(x+b) - func(x-b))/a\n    \ndef newton_raphson(func, x0, invalid_value):\n    \n    esp = 0.1**6\n    x1 = x0 - func(x0)/calc_derivative(func, x0)\n    while abs(x1 - x0) > esp:\n        if invalid_value == x1:\n            break\n        x0 = x1\n    return x1\n\n```    \n","source":"_posts/训练营/迭代递推卡01.md","raw":"---\ntitle: 非线性方程与牛顿迭代法\n---\n\n求解一元非线性方程的常用方法\n\n    二分逼近法\n    牛顿迭代法\n    \n二分逼近法\n\n    数学原理：对于实数域的函数 f(x)f(x)，\n    如果存在实数 kk，使得 f(k) = 0f(k)=0，\n    则 x = kx=k 就是函数 f(x)f(x) 的零点。\n    如果函数 f(x)f(x) 是连续函数，\n    且在区间 [a,b] 上是单调函数，\n    只要 f(a)和 f(b)异号，\n    就说明在区间 [a,b] 内一定有零点。\n\n使用Python语言实现 二分逼近法 求解方程\n```python\n\ndef func(x):\n    return 2.0 * x * x + 3.2 * x - 1.8\n\n\ndef dichotomy_equation(a, b, f):\n    esp = 0.1 ** 6\n    mid = (a + b) / 2\n    while abs(b - a) > esp:\n\n        # 说明零点[方程解]存在于（a, mid）\n        if f(a) * f(mid) < 0:\n            b = mid\n        else:\n            a = mid\n        mid = (a + b) / 2\n    return mid\n\n\n# 求 2.0 * x * x + 3.2 * x - 1.8 在 (-1,2)上的解\nres = dichotomy_equation(-1, 2, func)\n# 0.4409674406051636\nprint(res)\n\n```\n\n牛顿迭代法\n\n\n使用Python实现 牛顿迭代法\n```python\ndef calc_derivative(func, x):\n    a = 0.000001\n    b = a*5\n    return (func(x+b) - func(x-b))/a\n    \ndef newton_raphson(func, x0, invalid_value):\n    \n    esp = 0.1**6\n    x1 = x0 - func(x0)/calc_derivative(func, x0)\n    while abs(x1 - x0) > esp:\n        if invalid_value == x1:\n            break\n        x0 = x1\n    return x1\n\n```    \n","slug":"训练营/迭代递推卡01","published":1,"date":"2019-04-05T11:55:56.750Z","updated":"2019-04-05T11:55:56.750Z","_id":"cjwd4c7e40011sv72991dqymg","comments":1,"layout":"post","photos":[],"link":"","content":"<p>求解一元非线性方程的常用方法</p>\n<pre><code>二分逼近法\n牛顿迭代法\n</code></pre><p>二分逼近法</p>\n<pre><code>数学原理：对于实数域的函数 f(x)f(x)，\n如果存在实数 kk，使得 f(k) = 0f(k)=0，\n则 x = kx=k 就是函数 f(x)f(x) 的零点。\n如果函数 f(x)f(x) 是连续函数，\n且在区间 [a,b] 上是单调函数，\n只要 f(a)和 f(b)异号，\n就说明在区间 [a,b] 内一定有零点。\n</code></pre><p>使用Python语言实现 二分逼近法 求解方程<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2.0</span> * x * x + <span class=\"number\">3.2</span> * x - <span class=\"number\">1.8</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dichotomy_equation</span><span class=\"params\">(a, b, f)</span>:</span></span><br><span class=\"line\">    esp = <span class=\"number\">0.1</span> ** <span class=\"number\">6</span></span><br><span class=\"line\">    mid = (a + b) / <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> abs(b - a) &gt; esp:</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 说明零点[方程解]存在于（a, mid）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> f(a) * f(mid) &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            b = mid</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            a = mid</span><br><span class=\"line\">        mid = (a + b) / <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> mid</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 求 2.0 * x * x + 3.2 * x - 1.8 在 (-1,2)上的解</span></span><br><span class=\"line\">res = dichotomy_equation(<span class=\"number\">-1</span>, <span class=\"number\">2</span>, func)</span><br><span class=\"line\"><span class=\"comment\"># 0.4409674406051636</span></span><br><span class=\"line\">print(res)</span><br></pre></td></tr></table></figure></p>\n<p>牛顿迭代法</p>\n<p>使用Python实现 牛顿迭代法</p>\n<pre><code class=\"python\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calc_derivative</span><span class=\"params\">(func, x)</span>:</span>\n    a = <span class=\"number\">0.000001</span>\n    b = a*<span class=\"number\">5</span>\n    <span class=\"keyword\">return</span> (func(x+b) - func(x-b))/a\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">newton_raphson</span><span class=\"params\">(func, x0, invalid_value)</span>:</span>\n\n    esp = <span class=\"number\">0.1</span>**<span class=\"number\">6</span>\n    x1 = x0 - func(x0)/calc_derivative(func, x0)\n    <span class=\"keyword\">while</span> abs(x1 - x0) &gt; esp:\n        <span class=\"keyword\">if</span> invalid_value == x1:\n            <span class=\"keyword\">break</span>\n        x0 = x1\n    <span class=\"keyword\">return</span> x1\n\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>求解一元非线性方程的常用方法</p>\n<pre><code>二分逼近法\n牛顿迭代法\n</code></pre><p>二分逼近法</p>\n<pre><code>数学原理：对于实数域的函数 f(x)f(x)，\n如果存在实数 kk，使得 f(k) = 0f(k)=0，\n则 x = kx=k 就是函数 f(x)f(x) 的零点。\n如果函数 f(x)f(x) 是连续函数，\n且在区间 [a,b] 上是单调函数，\n只要 f(a)和 f(b)异号，\n就说明在区间 [a,b] 内一定有零点。\n</code></pre><p>使用Python语言实现 二分逼近法 求解方程<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2.0</span> * x * x + <span class=\"number\">3.2</span> * x - <span class=\"number\">1.8</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dichotomy_equation</span><span class=\"params\">(a, b, f)</span>:</span></span><br><span class=\"line\">    esp = <span class=\"number\">0.1</span> ** <span class=\"number\">6</span></span><br><span class=\"line\">    mid = (a + b) / <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> abs(b - a) &gt; esp:</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 说明零点[方程解]存在于（a, mid）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> f(a) * f(mid) &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            b = mid</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            a = mid</span><br><span class=\"line\">        mid = (a + b) / <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> mid</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 求 2.0 * x * x + 3.2 * x - 1.8 在 (-1,2)上的解</span></span><br><span class=\"line\">res = dichotomy_equation(<span class=\"number\">-1</span>, <span class=\"number\">2</span>, func)</span><br><span class=\"line\"><span class=\"comment\"># 0.4409674406051636</span></span><br><span class=\"line\">print(res)</span><br></pre></td></tr></table></figure></p>\n<p>牛顿迭代法</p>\n<p>使用Python实现 牛顿迭代法</p>\n<pre><code class=\"python\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calc_derivative</span><span class=\"params\">(func, x)</span>:</span>\n    a = <span class=\"number\">0.000001</span>\n    b = a*<span class=\"number\">5</span>\n    <span class=\"keyword\">return</span> (func(x+b) - func(x-b))/a\n\n<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">newton_raphson</span><span class=\"params\">(func, x0, invalid_value)</span>:</span>\n\n    esp = <span class=\"number\">0.1</span>**<span class=\"number\">6</span>\n    x1 = x0 - func(x0)/calc_derivative(func, x0)\n    <span class=\"keyword\">while</span> abs(x1 - x0) &gt; esp:\n        <span class=\"keyword\">if</span> invalid_value == x1:\n            <span class=\"keyword\">break</span>\n        x0 = x1\n    <span class=\"keyword\">return</span> x1\n\n</code></pre>\n"},{"title":"线性代数方程组的求解","_content":"\n雅可比迭代法\n    \n    通过计算一次矩阵和向量的乘法，\n    且计算过程中原始矩阵 A 保持不变，\n    便于用多线程并行计算的方式优化效率。\n    对于 n 阶线性方程组 Ax=b，\n    假如其系数矩阵 A 是非奇异矩阵，\n    且对角线元素非 0，\n    就可以证明雅可比迭代过程是收敛的。\n    \n    雅可比迭代原理和算法实现都很简单，\n    但是雅可比迭代存在收敛速度慢的问题。\n    工程中一般不直接使用雅可比迭代法，\n    而是使用各种基于雅可比迭代法的改进方法。\n    \n    \n高斯-赛德尔迭代法\n    \n    雅可比迭代法每次迭代计算时，\n    将上一次的迭代变量整体带入到迭代关系式中，\n    计算新的迭代变量值，\n    也就是所谓的整体迭代。\n    在迭代收敛的前提下，\n    如果迭代变量中的每个分量 x 在计算出新的迭代值后，\n    直接带入迭代，\n    参与其他迭代分量的计算，\n    则能显著地提高迭代效果，\n    这种改进的方法就是高斯-赛德尔迭代法。\n    \n \n    ","source":"_posts/训练营/迭代递推卡02.md","raw":"---\ntitle: 线性代数方程组的求解 \n---\n\n雅可比迭代法\n    \n    通过计算一次矩阵和向量的乘法，\n    且计算过程中原始矩阵 A 保持不变，\n    便于用多线程并行计算的方式优化效率。\n    对于 n 阶线性方程组 Ax=b，\n    假如其系数矩阵 A 是非奇异矩阵，\n    且对角线元素非 0，\n    就可以证明雅可比迭代过程是收敛的。\n    \n    雅可比迭代原理和算法实现都很简单，\n    但是雅可比迭代存在收敛速度慢的问题。\n    工程中一般不直接使用雅可比迭代法，\n    而是使用各种基于雅可比迭代法的改进方法。\n    \n    \n高斯-赛德尔迭代法\n    \n    雅可比迭代法每次迭代计算时，\n    将上一次的迭代变量整体带入到迭代关系式中，\n    计算新的迭代变量值，\n    也就是所谓的整体迭代。\n    在迭代收敛的前提下，\n    如果迭代变量中的每个分量 x 在计算出新的迭代值后，\n    直接带入迭代，\n    参与其他迭代分量的计算，\n    则能显著地提高迭代效果，\n    这种改进的方法就是高斯-赛德尔迭代法。\n    \n \n    ","slug":"训练营/迭代递推卡02","published":1,"date":"2019-04-05T12:09:36.408Z","updated":"2019-04-05T12:09:36.409Z","_id":"cjwd4c7e50012sv72dha9cjfi","comments":1,"layout":"post","photos":[],"link":"","content":"<p>雅可比迭代法</p>\n<pre><code>通过计算一次矩阵和向量的乘法，\n且计算过程中原始矩阵 A 保持不变，\n便于用多线程并行计算的方式优化效率。\n对于 n 阶线性方程组 Ax=b，\n假如其系数矩阵 A 是非奇异矩阵，\n且对角线元素非 0，\n就可以证明雅可比迭代过程是收敛的。\n\n雅可比迭代原理和算法实现都很简单，\n但是雅可比迭代存在收敛速度慢的问题。\n工程中一般不直接使用雅可比迭代法，\n而是使用各种基于雅可比迭代法的改进方法。\n</code></pre><p>高斯-赛德尔迭代法</p>\n<pre><code>雅可比迭代法每次迭代计算时，\n将上一次的迭代变量整体带入到迭代关系式中，\n计算新的迭代变量值，\n也就是所谓的整体迭代。\n在迭代收敛的前提下，\n如果迭代变量中的每个分量 x 在计算出新的迭代值后，\n直接带入迭代，\n参与其他迭代分量的计算，\n则能显著地提高迭代效果，\n这种改进的方法就是高斯-赛德尔迭代法。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>雅可比迭代法</p>\n<pre><code>通过计算一次矩阵和向量的乘法，\n且计算过程中原始矩阵 A 保持不变，\n便于用多线程并行计算的方式优化效率。\n对于 n 阶线性方程组 Ax=b，\n假如其系数矩阵 A 是非奇异矩阵，\n且对角线元素非 0，\n就可以证明雅可比迭代过程是收敛的。\n\n雅可比迭代原理和算法实现都很简单，\n但是雅可比迭代存在收敛速度慢的问题。\n工程中一般不直接使用雅可比迭代法，\n而是使用各种基于雅可比迭代法的改进方法。\n</code></pre><p>高斯-赛德尔迭代法</p>\n<pre><code>雅可比迭代法每次迭代计算时，\n将上一次的迭代变量整体带入到迭代关系式中，\n计算新的迭代变量值，\n也就是所谓的整体迭代。\n在迭代收敛的前提下，\n如果迭代变量中的每个分量 x 在计算出新的迭代值后，\n直接带入迭代，\n参与其他迭代分量的计算，\n则能显著地提高迭代效果，\n这种改进的方法就是高斯-赛德尔迭代法。\n</code></pre>"},{"title":"迭代法计算定积分","_content":"\n计算数值积分的两种常用方法\n    \n    变步长梯形公式法\n    变步长辛普森公式法\n    \n![](../../img/梯型公式法.png)\n\n![](../../img/变长梯型公式法.png)\n\n![](../../img/辛普森公式法.png)\n\n可变长辛普森公式法\n    \n    和梯形公式一样，\n    复合辛普森公式也可以改造为变步长辛普森公式法。\n    改造的方法就是使用迭代法的思想，\n    通过改变区间个数 n 使得步长 step 也跟着变化，\n    当迭代差值符合精度要求时即可停止迭代。\n    算法的迭代变量仍然是每次分割后的小区间上\n    使用辛普森公式计算的插值曲线面积之和，\n    迭代关系则非常简单，\n    就是用本迭代的迭代变量代替上个迭代的迭代自变量的值，\n    迭代终止条件就是两个迭代的迭代变量之差小于精度值。\n    迭代变量的初始值就是在区间 [a,b] 上\n    应用辛普森公式计算最大的区间面积。\n    用一个变量 n 表示当前迭代分割小梯形的个数，\n    n 的值每个迭代增加一倍。\n    而每次分割后的小区间面积和的计算\n    可由第 2-2 课中给出的\n    复合辛普森公式算法 simpson() 函数计算，\n    迭代算法的整体结构与变步长梯形法类似。\n\n\n\n","source":"_posts/训练营/迭代递推卡03.md","raw":"---\ntitle: 迭代法计算定积分\n---\n\n计算数值积分的两种常用方法\n    \n    变步长梯形公式法\n    变步长辛普森公式法\n    \n![](../../img/梯型公式法.png)\n\n![](../../img/变长梯型公式法.png)\n\n![](../../img/辛普森公式法.png)\n\n可变长辛普森公式法\n    \n    和梯形公式一样，\n    复合辛普森公式也可以改造为变步长辛普森公式法。\n    改造的方法就是使用迭代法的思想，\n    通过改变区间个数 n 使得步长 step 也跟着变化，\n    当迭代差值符合精度要求时即可停止迭代。\n    算法的迭代变量仍然是每次分割后的小区间上\n    使用辛普森公式计算的插值曲线面积之和，\n    迭代关系则非常简单，\n    就是用本迭代的迭代变量代替上个迭代的迭代自变量的值，\n    迭代终止条件就是两个迭代的迭代变量之差小于精度值。\n    迭代变量的初始值就是在区间 [a,b] 上\n    应用辛普森公式计算最大的区间面积。\n    用一个变量 n 表示当前迭代分割小梯形的个数，\n    n 的值每个迭代增加一倍。\n    而每次分割后的小区间面积和的计算\n    可由第 2-2 课中给出的\n    复合辛普森公式算法 simpson() 函数计算，\n    迭代算法的整体结构与变步长梯形法类似。\n\n\n\n","slug":"训练营/迭代递推卡03","published":1,"date":"2019-06-01T06:12:07.162Z","updated":"2019-06-01T06:12:07.162Z","_id":"cjwd4c7e60013sv72aatjpw6n","comments":1,"layout":"post","photos":[],"link":"","content":"<p>计算数值积分的两种常用方法</p>\n<pre><code>变步长梯形公式法\n变步长辛普森公式法\n</code></pre><p><img src=\"../../img/梯型公式法.png\" alt></p>\n<p><img src=\"../../img/变长梯型公式法.png\" alt></p>\n<p><img src=\"../../img/辛普森公式法.png\" alt></p>\n<p>可变长辛普森公式法</p>\n<pre><code>和梯形公式一样，\n复合辛普森公式也可以改造为变步长辛普森公式法。\n改造的方法就是使用迭代法的思想，\n通过改变区间个数 n 使得步长 step 也跟着变化，\n当迭代差值符合精度要求时即可停止迭代。\n算法的迭代变量仍然是每次分割后的小区间上\n使用辛普森公式计算的插值曲线面积之和，\n迭代关系则非常简单，\n就是用本迭代的迭代变量代替上个迭代的迭代自变量的值，\n迭代终止条件就是两个迭代的迭代变量之差小于精度值。\n迭代变量的初始值就是在区间 [a,b] 上\n应用辛普森公式计算最大的区间面积。\n用一个变量 n 表示当前迭代分割小梯形的个数，\nn 的值每个迭代增加一倍。\n而每次分割后的小区间面积和的计算\n可由第 2-2 课中给出的\n复合辛普森公式算法 simpson() 函数计算，\n迭代算法的整体结构与变步长梯形法类似。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>计算数值积分的两种常用方法</p>\n<pre><code>变步长梯形公式法\n变步长辛普森公式法\n</code></pre><p><img src=\"../../img/梯型公式法.png\" alt></p>\n<p><img src=\"../../img/变长梯型公式法.png\" alt></p>\n<p><img src=\"../../img/辛普森公式法.png\" alt></p>\n<p>可变长辛普森公式法</p>\n<pre><code>和梯形公式一样，\n复合辛普森公式也可以改造为变步长辛普森公式法。\n改造的方法就是使用迭代法的思想，\n通过改变区间个数 n 使得步长 step 也跟着变化，\n当迭代差值符合精度要求时即可停止迭代。\n算法的迭代变量仍然是每次分割后的小区间上\n使用辛普森公式计算的插值曲线面积之和，\n迭代关系则非常简单，\n就是用本迭代的迭代变量代替上个迭代的迭代自变量的值，\n迭代终止条件就是两个迭代的迭代变量之差小于精度值。\n迭代变量的初始值就是在区间 [a,b] 上\n应用辛普森公式计算最大的区间面积。\n用一个变量 n 表示当前迭代分割小梯形的个数，\nn 的值每个迭代增加一倍。\n而每次分割后的小区间面积和的计算\n可由第 2-2 课中给出的\n复合辛普森公式算法 simpson() 函数计算，\n迭代算法的整体结构与变步长梯形法类似。\n</code></pre>"},{"title":"全连接层","_content":"\n定义\n    \n    输入节点与输出节点组合相连，参数庞大。\n\n优化方法\n\n    使用卷积等操作替代\n    使用Dropout","source":"_posts/Python3_TensorFlow_WechatApplet/全连接层.md","raw":"---\ntitle: 全连接层\n---\n\n定义\n    \n    输入节点与输出节点组合相连，参数庞大。\n\n优化方法\n\n    使用卷积等操作替代\n    使用Dropout","slug":"Python3_TensorFlow_WechatApplet/全连接层","published":1,"date":"2019-06-01T11:18:36.065Z","updated":"2019-06-01T11:18:36.065Z","_id":"cjwd6if0r0000w572zzsu2w9g","comments":1,"layout":"post","photos":[],"link":"","content":"<p>定义</p>\n<pre><code>输入节点与输出节点组合相连，参数庞大。\n</code></pre><p>优化方法</p>\n<pre><code>使用卷积等操作替代\n使用Dropout\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>定义</p>\n<pre><code>输入节点与输出节点组合相连，参数庞大。\n</code></pre><p>优化方法</p>\n<pre><code>使用卷积等操作替代\n使用Dropout\n</code></pre>"},{"title":"常考的内置数据结构与算法","_content":"\n[内置数据结构文档](https://docs.python.org/3.6/library/collections.html?highlight=coll#module-collections)\n\n![](../../img/Python常用内置数据结构与算法.jpg)\n\n### 常用内置数据结构\n```python\nimport collections\n\n# 具名元祖\nPoint = collections.namedtuple('Point', 'x, y')\np = Point(1, 2)\nprint(p.x)\nprint(p.y)\nprint(p[0])\nprint(p[1])\n\n# 双端队列\nde = collections.deque()\nde.append(1)\nde.appendleft(0)\nprint(de)\nde.pop()\nprint(de)\nde.append(22)\nde.popleft()\nprint(de)\n\n# 计数器\nc = collections.Counter('aabbccdeef')\nprint(c)\nprint(c.get('a'))\nprint(c.most_common()) # 从大到小的顺序来获取信息\n\n# 按Key插入先后有序的OrderDict\nod = collections.OrderedDict()\nod['c'] = 'c'\nod['a'] = 'a'\nod['b'] = 'b'\nprint(od.keys())\n\n# 带默认值的字典 \ndd = collections.defaultdict()\ndd['a']\ndd['b'] += 1\nprint(dd)\n\n# list和tuple\n# 都是线性结构，支持下标访问\n# list是可变对象, tuple保存的引用不可变\nt = ([1], 2, 3)\ntry:\n    t[2] = 33\nexcept Exception as e:\n    print(e)\nt[0].append(11)\nprint(t)\n# 保存的引用不可变指的是你没法替换掉这个对象，\n# 但是如果被操作的子对象本身是一个可变对象，\n# 这个引用所指向的可变对象是可以修改的\n\n# list不能用作dict的key, 而tuple可以, 原因是可变对象不可hash\n\n```\n\n### Python Dict 底层结构\n```python\n# 底层使用哈希表，支持快速查找，平均复杂度为O(1), Cython解释器使用二次探查解决哈希冲突问题\n# 常考哈希冲突和扩容\n\n```\n\n### LRUCache\n```python\n# 是一种缓存剔除策略，缓存剔除则是指当缓存空间不够用的时候需要一种方式剔除key\n# 常见策略有LRU、LFU\n\n# LRU通过使用一个循环双端队列不断把最新访问的key放在表头实现，这样最远使用的就在后面。\n# 字典来做缓存，循环双端列表用来记录访问顺序\n# 利用Python内置的dict、collections.OrderDict实现\n# dict用来当作k/v键值对的缓存\n# 使用OrderDict用来更新最近访问的key\nfrom collections import OrderedDict\n\n\nclass LRUCache(object):\n    \n    def __init__(self, capacity=128):\n        self.od = OrderedDict()\n        self.capacity = capacity\n    \n    # 每次访问更新最新使用的key    \n    def get(self, key):\n        if key in self.od:\n            val = self.od[key]\n            self.od.move_to_end(key=key)\n            return val\n        else:\n            return -1\n    \n    # 更新k/v\n    def put(self, key, value):\n        if key in self.od:\n            del  self.od[key]\n            self.od[key] = value    # 更新key到表头\n        else:\n            self.od[key] = value    # 直接将key插入表头\n            # 判断当前容量是否已满\n            if len(self.od) > self.capacity:\n                # 删除最早的元素\n                self.od.popitem(last=False)\n```\n","source":"_posts/Python服务端面试/常考的内置结构与算法.md","raw":"---\ntitle: 常考的内置数据结构与算法\n---\n\n[内置数据结构文档](https://docs.python.org/3.6/library/collections.html?highlight=coll#module-collections)\n\n![](../../img/Python常用内置数据结构与算法.jpg)\n\n### 常用内置数据结构\n```python\nimport collections\n\n# 具名元祖\nPoint = collections.namedtuple('Point', 'x, y')\np = Point(1, 2)\nprint(p.x)\nprint(p.y)\nprint(p[0])\nprint(p[1])\n\n# 双端队列\nde = collections.deque()\nde.append(1)\nde.appendleft(0)\nprint(de)\nde.pop()\nprint(de)\nde.append(22)\nde.popleft()\nprint(de)\n\n# 计数器\nc = collections.Counter('aabbccdeef')\nprint(c)\nprint(c.get('a'))\nprint(c.most_common()) # 从大到小的顺序来获取信息\n\n# 按Key插入先后有序的OrderDict\nod = collections.OrderedDict()\nod['c'] = 'c'\nod['a'] = 'a'\nod['b'] = 'b'\nprint(od.keys())\n\n# 带默认值的字典 \ndd = collections.defaultdict()\ndd['a']\ndd['b'] += 1\nprint(dd)\n\n# list和tuple\n# 都是线性结构，支持下标访问\n# list是可变对象, tuple保存的引用不可变\nt = ([1], 2, 3)\ntry:\n    t[2] = 33\nexcept Exception as e:\n    print(e)\nt[0].append(11)\nprint(t)\n# 保存的引用不可变指的是你没法替换掉这个对象，\n# 但是如果被操作的子对象本身是一个可变对象，\n# 这个引用所指向的可变对象是可以修改的\n\n# list不能用作dict的key, 而tuple可以, 原因是可变对象不可hash\n\n```\n\n### Python Dict 底层结构\n```python\n# 底层使用哈希表，支持快速查找，平均复杂度为O(1), Cython解释器使用二次探查解决哈希冲突问题\n# 常考哈希冲突和扩容\n\n```\n\n### LRUCache\n```python\n# 是一种缓存剔除策略，缓存剔除则是指当缓存空间不够用的时候需要一种方式剔除key\n# 常见策略有LRU、LFU\n\n# LRU通过使用一个循环双端队列不断把最新访问的key放在表头实现，这样最远使用的就在后面。\n# 字典来做缓存，循环双端列表用来记录访问顺序\n# 利用Python内置的dict、collections.OrderDict实现\n# dict用来当作k/v键值对的缓存\n# 使用OrderDict用来更新最近访问的key\nfrom collections import OrderedDict\n\n\nclass LRUCache(object):\n    \n    def __init__(self, capacity=128):\n        self.od = OrderedDict()\n        self.capacity = capacity\n    \n    # 每次访问更新最新使用的key    \n    def get(self, key):\n        if key in self.od:\n            val = self.od[key]\n            self.od.move_to_end(key=key)\n            return val\n        else:\n            return -1\n    \n    # 更新k/v\n    def put(self, key, value):\n        if key in self.od:\n            del  self.od[key]\n            self.od[key] = value    # 更新key到表头\n        else:\n            self.od[key] = value    # 直接将key插入表头\n            # 判断当前容量是否已满\n            if len(self.od) > self.capacity:\n                # 删除最早的元素\n                self.od.popitem(last=False)\n```\n","slug":"Python服务端面试/常考的内置结构与算法","published":1,"date":"2019-06-02T13:07:54.237Z","updated":"2019-06-02T13:07:54.237Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwfo73nn0000idh7249apdd5","content":"<p><a href=\"https://docs.python.org/3.6/library/collections.html?highlight=coll#module-collections\" target=\"_blank\" rel=\"noopener\">内置数据结构文档</a></p>\n<p><img src=\"../../img/Python常用内置数据结构与算法.jpg\" alt></p>\n<h3 id=\"常用内置数据结构\"><a href=\"#常用内置数据结构\" class=\"headerlink\" title=\"常用内置数据结构\"></a>常用内置数据结构</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> collections</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 具名元祖</span></span><br><span class=\"line\">Point = collections.namedtuple(<span class=\"string\">'Point'</span>, <span class=\"string\">'x, y'</span>)</span><br><span class=\"line\">p = Point(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">print(p.x)</span><br><span class=\"line\">print(p.y)</span><br><span class=\"line\">print(p[<span class=\"number\">0</span>])</span><br><span class=\"line\">print(p[<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 双端队列</span></span><br><span class=\"line\">de = collections.deque()</span><br><span class=\"line\">de.append(<span class=\"number\">1</span>)</span><br><span class=\"line\">de.appendleft(<span class=\"number\">0</span>)</span><br><span class=\"line\">print(de)</span><br><span class=\"line\">de.pop()</span><br><span class=\"line\">print(de)</span><br><span class=\"line\">de.append(<span class=\"number\">22</span>)</span><br><span class=\"line\">de.popleft()</span><br><span class=\"line\">print(de)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 计数器</span></span><br><span class=\"line\">c = collections.Counter(<span class=\"string\">'aabbccdeef'</span>)</span><br><span class=\"line\">print(c)</span><br><span class=\"line\">print(c.get(<span class=\"string\">'a'</span>))</span><br><span class=\"line\">print(c.most_common()) <span class=\"comment\"># 从大到小的顺序来获取信息</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 按Key插入先后有序的OrderDict</span></span><br><span class=\"line\">od = collections.OrderedDict()</span><br><span class=\"line\">od[<span class=\"string\">'c'</span>] = <span class=\"string\">'c'</span></span><br><span class=\"line\">od[<span class=\"string\">'a'</span>] = <span class=\"string\">'a'</span></span><br><span class=\"line\">od[<span class=\"string\">'b'</span>] = <span class=\"string\">'b'</span></span><br><span class=\"line\">print(od.keys())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 带默认值的字典 </span></span><br><span class=\"line\">dd = collections.defaultdict()</span><br><span class=\"line\">dd[<span class=\"string\">'a'</span>]</span><br><span class=\"line\">dd[<span class=\"string\">'b'</span>] += <span class=\"number\">1</span></span><br><span class=\"line\">print(dd)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># list和tuple</span></span><br><span class=\"line\"><span class=\"comment\"># 都是线性结构，支持下标访问</span></span><br><span class=\"line\"><span class=\"comment\"># list是可变对象, tuple保存的引用不可变</span></span><br><span class=\"line\">t = ([<span class=\"number\">1</span>], <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    t[<span class=\"number\">2</span>] = <span class=\"number\">33</span></span><br><span class=\"line\"><span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">    print(e)</span><br><span class=\"line\">t[<span class=\"number\">0</span>].append(<span class=\"number\">11</span>)</span><br><span class=\"line\">print(t)</span><br><span class=\"line\"><span class=\"comment\"># 保存的引用不可变指的是你没法替换掉这个对象，</span></span><br><span class=\"line\"><span class=\"comment\"># 但是如果被操作的子对象本身是一个可变对象，</span></span><br><span class=\"line\"><span class=\"comment\"># 这个引用所指向的可变对象是可以修改的</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># list不能用作dict的key, 而tuple可以, 原因是可变对象不可hash</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Python-Dict-底层结构\"><a href=\"#Python-Dict-底层结构\" class=\"headerlink\" title=\"Python Dict 底层结构\"></a>Python Dict 底层结构</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 底层使用哈希表，支持快速查找，平均复杂度为O(1), Cython解释器使用二次探查解决哈希冲突问题</span></span><br><span class=\"line\"><span class=\"comment\"># 常考哈希冲突和扩容</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"LRUCache\"><a href=\"#LRUCache\" class=\"headerlink\" title=\"LRUCache\"></a>LRUCache</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 是一种缓存剔除策略，缓存剔除则是指当缓存空间不够用的时候需要一种方式剔除key</span></span><br><span class=\"line\"><span class=\"comment\"># 常见策略有LRU、LFU</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># LRU通过使用一个循环双端队列不断把最新访问的key放在表头实现，这样最远使用的就在后面。</span></span><br><span class=\"line\"><span class=\"comment\"># 字典来做缓存，循环双端列表用来记录访问顺序</span></span><br><span class=\"line\"><span class=\"comment\"># 利用Python内置的dict、collections.OrderDict实现</span></span><br><span class=\"line\"><span class=\"comment\"># dict用来当作k/v键值对的缓存</span></span><br><span class=\"line\"><span class=\"comment\"># 使用OrderDict用来更新最近访问的key</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> OrderedDict</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LRUCache</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, capacity=<span class=\"number\">128</span>)</span>:</span></span><br><span class=\"line\">        self.od = OrderedDict()</span><br><span class=\"line\">        self.capacity = capacity</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 每次访问更新最新使用的key    </span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span><span class=\"params\">(self, key)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> key <span class=\"keyword\">in</span> self.od:</span><br><span class=\"line\">            val = self.od[key]</span><br><span class=\"line\">            self.od.move_to_end(key=key)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> val</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 更新k/v</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">put</span><span class=\"params\">(self, key, value)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> key <span class=\"keyword\">in</span> self.od:</span><br><span class=\"line\">            <span class=\"keyword\">del</span>  self.od[key]</span><br><span class=\"line\">            self.od[key] = value    <span class=\"comment\"># 更新key到表头</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            self.od[key] = value    <span class=\"comment\"># 直接将key插入表头</span></span><br><span class=\"line\">            <span class=\"comment\"># 判断当前容量是否已满</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(self.od) &gt; self.capacity:</span><br><span class=\"line\">                <span class=\"comment\"># 删除最早的元素</span></span><br><span class=\"line\">                self.od.popitem(last=<span class=\"literal\">False</span>)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://docs.python.org/3.6/library/collections.html?highlight=coll#module-collections\" target=\"_blank\" rel=\"noopener\">内置数据结构文档</a></p>\n<p><img src=\"../../img/Python常用内置数据结构与算法.jpg\" alt></p>\n<h3 id=\"常用内置数据结构\"><a href=\"#常用内置数据结构\" class=\"headerlink\" title=\"常用内置数据结构\"></a>常用内置数据结构</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> collections</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 具名元祖</span></span><br><span class=\"line\">Point = collections.namedtuple(<span class=\"string\">'Point'</span>, <span class=\"string\">'x, y'</span>)</span><br><span class=\"line\">p = Point(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">print(p.x)</span><br><span class=\"line\">print(p.y)</span><br><span class=\"line\">print(p[<span class=\"number\">0</span>])</span><br><span class=\"line\">print(p[<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 双端队列</span></span><br><span class=\"line\">de = collections.deque()</span><br><span class=\"line\">de.append(<span class=\"number\">1</span>)</span><br><span class=\"line\">de.appendleft(<span class=\"number\">0</span>)</span><br><span class=\"line\">print(de)</span><br><span class=\"line\">de.pop()</span><br><span class=\"line\">print(de)</span><br><span class=\"line\">de.append(<span class=\"number\">22</span>)</span><br><span class=\"line\">de.popleft()</span><br><span class=\"line\">print(de)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 计数器</span></span><br><span class=\"line\">c = collections.Counter(<span class=\"string\">'aabbccdeef'</span>)</span><br><span class=\"line\">print(c)</span><br><span class=\"line\">print(c.get(<span class=\"string\">'a'</span>))</span><br><span class=\"line\">print(c.most_common()) <span class=\"comment\"># 从大到小的顺序来获取信息</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 按Key插入先后有序的OrderDict</span></span><br><span class=\"line\">od = collections.OrderedDict()</span><br><span class=\"line\">od[<span class=\"string\">'c'</span>] = <span class=\"string\">'c'</span></span><br><span class=\"line\">od[<span class=\"string\">'a'</span>] = <span class=\"string\">'a'</span></span><br><span class=\"line\">od[<span class=\"string\">'b'</span>] = <span class=\"string\">'b'</span></span><br><span class=\"line\">print(od.keys())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 带默认值的字典 </span></span><br><span class=\"line\">dd = collections.defaultdict()</span><br><span class=\"line\">dd[<span class=\"string\">'a'</span>]</span><br><span class=\"line\">dd[<span class=\"string\">'b'</span>] += <span class=\"number\">1</span></span><br><span class=\"line\">print(dd)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># list和tuple</span></span><br><span class=\"line\"><span class=\"comment\"># 都是线性结构，支持下标访问</span></span><br><span class=\"line\"><span class=\"comment\"># list是可变对象, tuple保存的引用不可变</span></span><br><span class=\"line\">t = ([<span class=\"number\">1</span>], <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    t[<span class=\"number\">2</span>] = <span class=\"number\">33</span></span><br><span class=\"line\"><span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">    print(e)</span><br><span class=\"line\">t[<span class=\"number\">0</span>].append(<span class=\"number\">11</span>)</span><br><span class=\"line\">print(t)</span><br><span class=\"line\"><span class=\"comment\"># 保存的引用不可变指的是你没法替换掉这个对象，</span></span><br><span class=\"line\"><span class=\"comment\"># 但是如果被操作的子对象本身是一个可变对象，</span></span><br><span class=\"line\"><span class=\"comment\"># 这个引用所指向的可变对象是可以修改的</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># list不能用作dict的key, 而tuple可以, 原因是可变对象不可hash</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Python-Dict-底层结构\"><a href=\"#Python-Dict-底层结构\" class=\"headerlink\" title=\"Python Dict 底层结构\"></a>Python Dict 底层结构</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 底层使用哈希表，支持快速查找，平均复杂度为O(1), Cython解释器使用二次探查解决哈希冲突问题</span></span><br><span class=\"line\"><span class=\"comment\"># 常考哈希冲突和扩容</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"LRUCache\"><a href=\"#LRUCache\" class=\"headerlink\" title=\"LRUCache\"></a>LRUCache</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 是一种缓存剔除策略，缓存剔除则是指当缓存空间不够用的时候需要一种方式剔除key</span></span><br><span class=\"line\"><span class=\"comment\"># 常见策略有LRU、LFU</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># LRU通过使用一个循环双端队列不断把最新访问的key放在表头实现，这样最远使用的就在后面。</span></span><br><span class=\"line\"><span class=\"comment\"># 字典来做缓存，循环双端列表用来记录访问顺序</span></span><br><span class=\"line\"><span class=\"comment\"># 利用Python内置的dict、collections.OrderDict实现</span></span><br><span class=\"line\"><span class=\"comment\"># dict用来当作k/v键值对的缓存</span></span><br><span class=\"line\"><span class=\"comment\"># 使用OrderDict用来更新最近访问的key</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> OrderedDict</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LRUCache</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, capacity=<span class=\"number\">128</span>)</span>:</span></span><br><span class=\"line\">        self.od = OrderedDict()</span><br><span class=\"line\">        self.capacity = capacity</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 每次访问更新最新使用的key    </span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span><span class=\"params\">(self, key)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> key <span class=\"keyword\">in</span> self.od:</span><br><span class=\"line\">            val = self.od[key]</span><br><span class=\"line\">            self.od.move_to_end(key=key)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> val</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 更新k/v</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">put</span><span class=\"params\">(self, key, value)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> key <span class=\"keyword\">in</span> self.od:</span><br><span class=\"line\">            <span class=\"keyword\">del</span>  self.od[key]</span><br><span class=\"line\">            self.od[key] = value    <span class=\"comment\"># 更新key到表头</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            self.od[key] = value    <span class=\"comment\"># 直接将key插入表头</span></span><br><span class=\"line\">            <span class=\"comment\"># 判断当前容量是否已满</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> len(self.od) &gt; self.capacity:</span><br><span class=\"line\">                <span class=\"comment\"># 删除最早的元素</span></span><br><span class=\"line\">                self.od.popitem(last=<span class=\"literal\">False</span>)</span><br></pre></td></tr></table></figure>\n"},{"title":"0602工作周报","_content":"\n### 携程国内供应商疑似错误\n    \n    确保源数据获取准确\n    等待携程售卖房型删除完毕，重启定时任务\n    \n### 床型分类功能调整\n    \n    简化以床型描述优先的功能代码\n    剔除相似度计算相关功能\n    调整床型更新定时任务对于供应商携程只更新Bedtype为0的\n    修复本地功能与服务器功能效果不一致的Bug\n    整理测试用例与单测工具\n    \n### RoomAuto接口功能调整\n    \n    兼容供应商携程额外拼接的属性, 代码调整完毕并初步测试了功能\n    针对供应商美团添加若干中文关键词，在匹配过程中发现了一些比较难问题 hao hua da chuang\n    RoomAuto测试工具的编写\n    \n### 问题\n\n    供应商携程房型数据a, 他的Bedtype开始为0，机器刷出BedType为x, 而后发现BedType实际应为y，如何快速解决。\n    答：开发以根据supplier_id、rate_id或supplier_id、roomtype_code来获得BedType(以及相关房型信息)并更新\n    数据部反映房型疑似错误没有有效找出 \"错误房型\"\n    答: 开发工具给数据部 设置supplier_id,  疑似错误阈值等属性跑疑似错误","source":"_posts/work_coding/work0602.md","raw":"---\ntitle: 0602工作周报\n---\n\n### 携程国内供应商疑似错误\n    \n    确保源数据获取准确\n    等待携程售卖房型删除完毕，重启定时任务\n    \n### 床型分类功能调整\n    \n    简化以床型描述优先的功能代码\n    剔除相似度计算相关功能\n    调整床型更新定时任务对于供应商携程只更新Bedtype为0的\n    修复本地功能与服务器功能效果不一致的Bug\n    整理测试用例与单测工具\n    \n### RoomAuto接口功能调整\n    \n    兼容供应商携程额外拼接的属性, 代码调整完毕并初步测试了功能\n    针对供应商美团添加若干中文关键词，在匹配过程中发现了一些比较难问题 hao hua da chuang\n    RoomAuto测试工具的编写\n    \n### 问题\n\n    供应商携程房型数据a, 他的Bedtype开始为0，机器刷出BedType为x, 而后发现BedType实际应为y，如何快速解决。\n    答：开发以根据supplier_id、rate_id或supplier_id、roomtype_code来获得BedType(以及相关房型信息)并更新\n    数据部反映房型疑似错误没有有效找出 \"错误房型\"\n    答: 开发工具给数据部 设置supplier_id,  疑似错误阈值等属性跑疑似错误","slug":"work_coding/work0602","published":1,"date":"2019-06-02T13:47:39.221Z","updated":"2019-06-02T13:47:39.222Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwfo73no0001idh7ylvjlm4g","content":"<h3 id=\"携程国内供应商疑似错误\"><a href=\"#携程国内供应商疑似错误\" class=\"headerlink\" title=\"携程国内供应商疑似错误\"></a>携程国内供应商疑似错误</h3><pre><code>确保源数据获取准确\n等待携程售卖房型删除完毕，重启定时任务\n</code></pre><h3 id=\"床型分类功能调整\"><a href=\"#床型分类功能调整\" class=\"headerlink\" title=\"床型分类功能调整\"></a>床型分类功能调整</h3><pre><code>简化以床型描述优先的功能代码\n剔除相似度计算相关功能\n调整床型更新定时任务对于供应商携程只更新Bedtype为0的\n修复本地功能与服务器功能效果不一致的Bug\n整理测试用例与单测工具\n</code></pre><h3 id=\"RoomAuto接口功能调整\"><a href=\"#RoomAuto接口功能调整\" class=\"headerlink\" title=\"RoomAuto接口功能调整\"></a>RoomAuto接口功能调整</h3><pre><code>兼容供应商携程额外拼接的属性, 代码调整完毕并初步测试了功能\n针对供应商美团添加若干中文关键词，在匹配过程中发现了一些比较难问题 hao hua da chuang\nRoomAuto测试工具的编写\n</code></pre><h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><pre><code>供应商携程房型数据a, 他的Bedtype开始为0，机器刷出BedType为x, 而后发现BedType实际应为y，如何快速解决。\n答：开发以根据supplier_id、rate_id或supplier_id、roomtype_code来获得BedType(以及相关房型信息)并更新\n数据部反映房型疑似错误没有有效找出 &quot;错误房型&quot;\n答: 开发工具给数据部 设置supplier_id,  疑似错误阈值等属性跑疑似错误\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"携程国内供应商疑似错误\"><a href=\"#携程国内供应商疑似错误\" class=\"headerlink\" title=\"携程国内供应商疑似错误\"></a>携程国内供应商疑似错误</h3><pre><code>确保源数据获取准确\n等待携程售卖房型删除完毕，重启定时任务\n</code></pre><h3 id=\"床型分类功能调整\"><a href=\"#床型分类功能调整\" class=\"headerlink\" title=\"床型分类功能调整\"></a>床型分类功能调整</h3><pre><code>简化以床型描述优先的功能代码\n剔除相似度计算相关功能\n调整床型更新定时任务对于供应商携程只更新Bedtype为0的\n修复本地功能与服务器功能效果不一致的Bug\n整理测试用例与单测工具\n</code></pre><h3 id=\"RoomAuto接口功能调整\"><a href=\"#RoomAuto接口功能调整\" class=\"headerlink\" title=\"RoomAuto接口功能调整\"></a>RoomAuto接口功能调整</h3><pre><code>兼容供应商携程额外拼接的属性, 代码调整完毕并初步测试了功能\n针对供应商美团添加若干中文关键词，在匹配过程中发现了一些比较难问题 hao hua da chuang\nRoomAuto测试工具的编写\n</code></pre><h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><pre><code>供应商携程房型数据a, 他的Bedtype开始为0，机器刷出BedType为x, 而后发现BedType实际应为y，如何快速解决。\n答：开发以根据supplier_id、rate_id或supplier_id、roomtype_code来获得BedType(以及相关房型信息)并更新\n数据部反映房型疑似错误没有有效找出 &quot;错误房型&quot;\n答: 开发工具给数据部 设置supplier_id,  疑似错误阈值等属性跑疑似错误\n</code></pre>"},{"title":"容器","_content":"\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>容器</title>\n</head>\n<body>\n<article id=\"articleDiv\"><div class=\"mazi-article-content dont-break-out\"><p></p><div class=\"toc\">\n<ul>\n<li><ul>\n<li><ul>\n<li><a href=\"#51\">5.1　方法</a></li>\n<li><a href=\"#52\">5.2　列表</a></li>\n<li><a href=\"#53\">5.3　元组</a></li>\n<li><a href=\"#54\">5.4　字典</a></li>\n<li><a href=\"#55\">5.5　容器嵌套容器</a></li>\n<li><a href=\"#56\">5.6　术语表</a></li>\n<li><a href=\"#57\">5.7　挑战练习</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>\n<p></p>\n<blockquote>\n  <p><span style=\"font-family: Times New Roman,楷体_GB2312\">“愚者困惑，智者提问。”</span></p>\n  <p><span style=\"font-family: Times New Roman,楷体_GB2312\">——本杰明 · 迪斯雷利（Benjamin Disraeli）</span></p>\n</blockquote>\n<p>在第 3 章中，我们学习了如何用变量保存对象。本章将讨论如何用容器保存对象。容器就像是文件柜，可有效整理数据。这里将学习 3 个常用的容器：列表、元组和字典。</p>\n<h3 id=\"51\">5.1　方法</h3>\n<p>第 4 章介绍了函数。Python 中有一个类似的概念，叫<strong>方法</strong>（method）。方法是与指定数据类型紧密相关的函数。方法与函数一样，可执行代码并返回结果。不同的是，只有在对象上才能调用方法。同样也可以传递参数给方法。调用字符串的 <code>upper</code> 和 <code>replace</code> 方法的示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zdllght</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"Hello\"</span>.upper()\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'HELLO'</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hfgpst5</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"Hello\"</span>.replace(<span class=\"hljs-string\">\"o\"</span>, <span class=\"hljs-string\">\"@\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'Hell@'</span>\n</code></pre>\n<p>本书第二部分将详细介绍方法。</p>\n<h3 id=\"52\">5.2　列表</h3>\n<p><strong>列表</strong>（list）是以固定顺序保存对象的容器（如图 5-1 所示）。</p>\n<p><img src=\"https://images.gitbook.cn/aab3b280-6fc3-11e9-9e1b-5b6158413fa5\" alt=\"enter image description here\"></p>\n<p>图 5-1　列表</p>\n<p>列表用方括号表示。我们可使用两种语法创建列表，一种是使用 <code>list</code> 函数创建空列表，示例如下：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/h4go6kg</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  fruit = <span class=\"hljs-built_in\">list</span>()\n<span class=\"hljs-number\">5</span>  fruit\n\n&gt;&gt; []\n</code></pre>\n<p>或者直接使用方括号：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jft8p7x</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  fruit = []\n<span class=\"hljs-number\">5</span>  fruit\n\n<span class=\"hljs-meta\">&gt;&gt;</span> []\n</code></pre>\n<p>使用第二种语法，并将你希望放在列表中的所有对象填入方括号中，用逗号分隔，即可创建一个包含所有对象的列表。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h2y8nos</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  fruit = [<span class=\"hljs-string\">\"Apple\"</span>, <span class=\"hljs-string\">\"Orange\"</span>, <span class=\"hljs-string\">\"Pear\"</span>]\n<span class=\"hljs-number\">5</span>  fruit\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'Apple'</span>, <span class=\"hljs-string\">'Orange'</span>, <span class=\"hljs-string\">'Pear'</span>]\n</code></pre>\n<p>上述示例中的列表有 3 个元素：<code>\"Apple\"</code>、<code>\"Orange\"</code> 和 <code>\"Pear\"</code>。列表中的元素是有序的。除非你重新调整列表中元素的顺序，否则 <code>\"Apple\"</code> 永远是第一个元素，<code>\"Orange\"</code> 是第二个元素，<code>\"Pear\"</code> 则是第三个元素。<code>\"Apple\"</code> 位于列表的开头，末尾则是 <code>\"Pear\"</code>。这里可使用 <code>append</code> 方法向列表中添加一个新元素。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h9w3z2m</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  fruit = [<span class=\"hljs-string\">\"Apple\"</span>, <span class=\"hljs-string\">\"Orange\"</span>, <span class=\"hljs-string\">\"Pear\"</span>]\n<span class=\"hljs-number\">5</span>  fruit.append(<span class=\"hljs-string\">\"Banana\"</span>)\n<span class=\"hljs-number\">6</span>  fruit.append(<span class=\"hljs-string\">\"Peach\"</span>)\n<span class=\"hljs-number\">7</span>  fruit\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'Apple'</span>, <span class=\"hljs-string\">'Orange'</span>, <span class=\"hljs-string\">'Pear'</span>, <span class=\"hljs-string\">'Banana'</span>, <span class=\"hljs-string\">'Peach'</span>]\n</code></pre>\n<p>传递给 <code>append</code> 方法的两个对象现在都加入了列表。但 <code>append</code> 方法永远是将新元素添加至列表的末尾。</p>\n<p>列表不仅可以保存字符串，它还可以保存任意数据类型。示例如下：</p>\n<pre><code class=\"hljs php\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zhpntsr</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  random = []\n<span class=\"hljs-number\">5</span>  random.append(<span class=\"hljs-keyword\">True</span>)\n<span class=\"hljs-number\">6</span>  random.append(<span class=\"hljs-number\">100</span>)\n<span class=\"hljs-number\">7</span>  random.append(<span class=\"hljs-number\">1.1</span>)\n<span class=\"hljs-number\">8</span>  random.append(<span class=\"hljs-string\">\"Hello\"</span>)\n<span class=\"hljs-number\">9</span>  random\n\n&gt;&gt; [<span class=\"hljs-keyword\">True</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">1.1</span>, <span class=\"hljs-string\">'Hello'</span>]\n</code></pre>\n<p>字符串、列表和元组都是<strong>可迭代的</strong>（iterable）。如果可以使用循环访问对象中的每一个元素，那么该对象是可迭代的，被称为<strong>可迭代对象</strong>。可迭代对象中的每一个元素都有一个<strong>索引</strong>（index），即表示元素在可迭代对象中位置的数字。列表中第一个元素的索引是 0，而不是 1。</p>\n<p>在如下示例中，<code>\"Apple\"</code> 的索引是 0，<code>\"Orange\"</code> 的索引是 1，<code>\"Pear\"</code> 的索引是 2：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/z8zzk8d</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  fruit = [<span class=\"hljs-string\">\"Apple\"</span>, <span class=\"hljs-string\">\"Orange\"</span>, <span class=\"hljs-string\">\"Pear\"</span>]\n</code></pre>\n<p>你可以使用语法[列表名][[索引]]获取一个元素：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jqtlwpf</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  fruit = [<span class=\"hljs-string\">\"Apple\"</span>, <span class=\"hljs-string\">\"Orange\"</span>, <span class=\"hljs-string\">\"Pear\"</span>]\n<span class=\"hljs-number\">5</span>  fruit[<span class=\"hljs-number\">0</span>]\n<span class=\"hljs-number\">6</span>  fruit[<span class=\"hljs-number\">1</span>]\n<span class=\"hljs-number\">7</span>  fruit[<span class=\"hljs-number\">2</span>]\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'Apple'</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'Orange'</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'Pear'</span>\n</code></pre>\n<p>如果获取的是不存在的索引，Python 会报告异常：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/za3rv95</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  colors = [<span class=\"hljs-string\">\"blue\"</span>, <span class=\"hljs-string\">\"green\"</span>, <span class=\"hljs-string\">\"yellow\"</span>]\n<span class=\"hljs-number\">5</span>  colors[<span class=\"hljs-number\">4</span>]\n\n&gt;&gt; IndexError: <span class=\"hljs-built_in\">list</span> index out of range\n</code></pre>\n<p>列表是<strong>可变的</strong>（mutable）。如果一个容器是可变的，则可以向该容器中增删对象。将列表中某个元素的索引赋给一个新的对象，即可改变该元素：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h4ahvf9</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  colors = [<span class=\"hljs-string\">\"blue\"</span>, <span class=\"hljs-string\">\"green\"</span>, <span class=\"hljs-string\">\"yellow\"</span>]\n<span class=\"hljs-number\">5</span>  colors\n<span class=\"hljs-number\">6</span>  colors[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-string\">\"red\"</span>\n<span class=\"hljs-number\">7</span>  colors\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'blue'</span>, <span class=\"hljs-string\">'green'</span>, <span class=\"hljs-string\">'yellow'</span>]\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'blue'</span>, <span class=\"hljs-string\">'green'</span>, <span class=\"hljs-string\">'red'</span>]\n</code></pre>\n<p>也可使用 <code>pop</code> 方法移除列表中的最后一个元素：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/j52uvmq</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  colors = [<span class=\"hljs-string\">\"blue\"</span>, <span class=\"hljs-string\">\"green\"</span>, <span class=\"hljs-string\">\"yellow\"</span>]\n<span class=\"hljs-number\">5</span>  colors\n<span class=\"hljs-number\">6</span>  item = colors.pop()\n<span class=\"hljs-number\">7</span>  item\n<span class=\"hljs-number\">8</span>  colors\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'blue'</span>, <span class=\"hljs-string\">'green'</span>, <span class=\"hljs-string\">'yellow'</span>]\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'yellow'</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'blue'</span>, <span class=\"hljs-string\">'green'</span>]\n</code></pre>\n<p>不能对空列表使用 <code>pop</code> 方法。否则，Python 则会报告异常。</p>\n<p>你可以使用加法操作符来合并两个列表：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jjxnk4z</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  colors1 = [<span class=\"hljs-string\">\"blue\"</span>, <span class=\"hljs-string\">\"green\"</span>, <span class=\"hljs-string\">\"yellow\"</span>]\n<span class=\"hljs-number\">5</span>  colors2 = [<span class=\"hljs-string\">\"orange\"</span>, <span class=\"hljs-string\">\"pink\"</span>, <span class=\"hljs-string\">\"black\"</span>]\n<span class=\"hljs-number\">6</span>  colors1 + colors2\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'blue'</span>, <span class=\"hljs-string\">'green'</span>, <span class=\"hljs-string\">'yellow'</span>, <span class=\"hljs-string\">'orange'</span>, <span class=\"hljs-string\">'pink'</span>, <span class=\"hljs-string\">'black'</span>]\n</code></pre>\n<p>也可以使用关键字 <code>in</code> 检查某个元素是否在列表中：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z4fnv39</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  colors = [<span class=\"hljs-string\">\"blue\"</span>, <span class=\"hljs-string\">\"green\"</span>, <span class=\"hljs-string\">\"yellow\"</span>]\n<span class=\"hljs-number\">5</span>  <span class=\"hljs-string\">\"green\"</span> <strong><span class=\"hljs-keyword\">in</span></strong> colors\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<p>使用关键字 <code>not</code> 检查某个元素是否不在列表中：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jqzk8pj</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  colors = [<span class=\"hljs-string\">\"blue\"</span>, <span class=\"hljs-string\">\"green\"</span>, <span class=\"hljs-string\">\"yellow\"</span>]\n<span class=\"hljs-number\">5</span>  <span class=\"hljs-string\">\"black\"</span> <strong><span class=\"hljs-keyword\">not</span></strong> <strong><span class=\"hljs-keyword\">in</span></strong> colors\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<p>使用函数 <code>len</code> 可获得列表的大小（包含元素的个数）：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hhx6rx4</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  len(colors)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">3</span>\n</code></pre>\n<p>下面是一个在实践中使用列表的例子：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">01  <span class=\"hljs-comment\"># http://tinyurl.com/gq7yjr7</span>\n02\n03\n04  colors = [<span class=\"hljs-string\">\"purple\"</span>,\n05            <span class=\"hljs-string\">\"orange\"</span>,\n06            <span class=\"hljs-string\">\"green\"</span>]\n07\n08\n09  guess = input(<span class=\"hljs-string\">\"Guess a color:\"</span>)\n10\n11\n12<strong><span class=\"hljs-keyword\">if</span></strong> guess <strong><span class=\"hljs-keyword\">in</span></strong> colors:\n13      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"You guessed correctly!\"</span>)\n14<strong><span class=\"hljs-keyword\">else</span></strong>:\n15      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Wrong! Try again.\"</span>)\n\n&gt;&gt; Guess a color:</code></pre>\n<p>列表 <code>colors</code> 包含了代表颜色的不同字符串。程序使用内置函数 <code>input</code> 来让用户猜测是什么颜色，并将用户的答案保存至变量。如果答案在 <code>colors</code> 列表中，则告知用户猜测正确。反之，让用户再次尝试。</p>\n<h3 id=\"53\">5.3　元组</h3>\n<p><strong>元组</strong>（tuple）是存储有序对象的一种容器。与列表不同，元组是<strong>不可变的</strong>（immutable），这意味着其内容不会变化。创建元组后，无法修改其中任何元组的值，也无法添加或修改元素。用圆括号表示元组，且必须用逗号分隔元组中的元素。有两种语法可以创建元组，第一种如下所示：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zo88eal</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  my_tuple = tuple()\n<span class=\"hljs-number\">5</span>  my_tuple\n\n<span class=\"hljs-meta\">&gt;&gt;</span> ()\n</code></pre>\n<p>以及第二种语法：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zm3y26j</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  my_tuple = ()\n<span class=\"hljs-number\">5</span>  my_tuple\n\n<span class=\"hljs-meta\">&gt;&gt;</span> ()\n</code></pre>\n<p>如果要向元组中新增对象，可用第二种语法创建一个新的元组，并在其中加入你希望增加的每个元素，用逗号分隔：</p>\n<pre><code class=\"hljs php\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zlwwfe3</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  rndm = (<span class=\"hljs-string\">\"M. Jackson\"</span>, <span class=\"hljs-number\">1958</span>, <span class=\"hljs-keyword\">True</span>)\n<span class=\"hljs-number\">5</span>  rndm\n\n&gt;&gt; (<span class=\"hljs-string\">'M. Jackson'</span>, <span class=\"hljs-number\">1958</span>, <span class=\"hljs-keyword\">True</span>)\n</code></pre>\n<p>即使元组中只有一个元素，也需要在该元素的后面加上逗号。只有这样，Python 才能将其与其他为了表示运算顺序而放在圆括号中的数字标记进行区分。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/j8mca8o</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-comment\"># 这是元组</span>\n<span class=\"hljs-number\">5</span>  (<span class=\"hljs-string\">\"self_taught\"</span>, )\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  <span class=\"hljs-comment\"># 这不是元组</span>\n<span class=\"hljs-number\">9</span>  (<span class=\"hljs-number\">9</span>) + <span class=\"hljs-number\">1</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> (<span class=\"hljs-string\">'self_taught'</span>, )\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">10</span>\n</code></pre>\n<p>创建元组之后，不能再新增元素或修改已有元素。如果在创建元组后这样做，Python 会报告异常：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z3x34nk</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  dys = (<span class=\"hljs-string\">\"1984\"</span>,\n<span class=\"hljs-number\">5</span>         <span class=\"hljs-string\">\"Brave New World\"</span>,\n<span class=\"hljs-number\">6</span>         <span class=\"hljs-string\">\"Fahrenheit 451\"</span>)\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>\n<span class=\"hljs-number\">9</span>  dys[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-string\">\"Handmaid's Tale\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-symbol\">TypeError:</span> <span class=\"hljs-string\">'tuple'</span> object does not support item assignment\n</code></pre>\n<p>可使用与列表一样的方法来获取元组的元素，即引用其索引：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z9dc6lo</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  dys = (<span class=\"hljs-string\">\"1984\"</span>,\n<span class=\"hljs-number\">5</span>         <span class=\"hljs-string\">\"Brave New World\"</span>,\n<span class=\"hljs-number\">6</span>         <span class=\"hljs-string\">\"Fahrenheit 451\"</span>)\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>\n<span class=\"hljs-number\">9</span>  dys[<span class=\"hljs-number\">2</span>]\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'Fahrenheit 451'</span>\n</code></pre>\n<p>可使用关键字 <code>in</code> 来检查某个元素是否在元组中：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/j3bsel7</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  dys = (<span class=\"hljs-string\">\"1984\"</span>,\n<span class=\"hljs-number\">5</span>         <span class=\"hljs-string\">\"Brave New World\"</span>,\n<span class=\"hljs-number\">6</span>         <span class=\"hljs-string\">\"Fahrenheit 451\"</span>)\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>\n<span class=\"hljs-number\">9</span>  <span class=\"hljs-string\">\"1984\"</span> <strong><span class=\"hljs-keyword\">in</span></strong> dys\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<p>在 <code>in</code> 前加上关键字 <code>not</code> 即可检查元素是否不在元组中：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jpdjjv9</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  dys = (<span class=\"hljs-string\">\"1984\"</span>,\n<span class=\"hljs-number\">5</span>         <span class=\"hljs-string\">\"Brave New World\"</span>,\n<span class=\"hljs-number\">6</span>         <span class=\"hljs-string\">\"Fahrenheit 451\"</span>)\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>\n<span class=\"hljs-number\">9</span>  <span class=\"hljs-string\">\"Handmaid's Tale\"</span> <strong><span class=\"hljs-keyword\">not</span></strong> <strong><span class=\"hljs-keyword\">in</span></strong> dys\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<p>你可能会疑惑为什么要使用一个看上去没有列表灵活的数据结构。因为在处理明确永远不会改变的，并且也不希望其他程序对其进行修改的值时，元组是非常有用的。地理坐标就是适合使用元组存储的一种数据。城市的经纬度应保存在元组中，因为这些值永远不会改变，保存为元组意味着程序不会意外对其进行修改。元组不像列表那样可以用作字典的键，这个知识点会在下一节介绍。</p>\n<h3 id=\"54\">5.4　字典</h3>\n<p><strong>字典</strong>（dictionary）是另一种用于存储对象的内置容器。它们被用来链接<strong>键</strong>（key）和<strong>值</strong>（value）这两个对象（如图 5-2 所示）。将一个对象链接至另一个对象，也被称为<strong>映射</strong>（mapping），结果为产生一个<strong>键值对</strong>（key-value pair）。可将键值对添加到字典，然后使用键在字典中查询，可获得其对应的值。但是无法使用值来查询键。</p>\n<p><img src=\"https://images.gitbook.cn/38d2e810-6fc4-11e9-9e1b-5b6158413fa5\" alt=\"enter image description here\"></p>\n<p>图 5-2　字典</p>\n<p>字典是可变的，因此可以向字典中新增键值对。与列表和元组不同，字典中存储的对象是无序的。字典的价值在于键与值之间的关联。需要成对存储数据的场景很多。例如，可以将关于某个人的信息存储在字典中，将名为 height 的键，映射至代表这个人身高的值；将名为 eyecolor 的键映射至代表这个人眼睛颜色的值；将名为 nationality 的键映射至代表这个人国籍的值。</p>\n<p>字典用花括号表示。有两种创建字典的语法，其一如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zfn6jmw</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  my_dict = dict()\n<span class=\"hljs-number\">5</span>  my_dict\n\n<span class=\"hljs-meta\">&gt;&gt;</span> {}\n</code></pre>\n<p>另一种方法如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jfgemf2</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  my_dict = {}\n<span class=\"hljs-number\">5</span>  my_dict\n\n<span class=\"hljs-meta\">&gt;&gt;</span> {}\n</code></pre>\n<p>可以在创建字典时直接添加键值对。上述两种语法都要求用冒号分隔键与值，每个键值对之间用逗号分隔。与元组不同的是，如果只有一个键值对，不需要在其后添加逗号。如下示例介绍了创建字典时如何添加键值对：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hplqc4u</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  fruits = {<span class=\"hljs-string\">\"Apple\"</span>:\n<span class=\"hljs-number\">5</span>            <span class=\"hljs-string\">\"Red\"</span>,\n<span class=\"hljs-number\">6</span>            <span class=\"hljs-string\">\"Banana\"</span>:\n<span class=\"hljs-number\">7</span>            <span class=\"hljs-string\">\"Yellow\"</span>}\n<span class=\"hljs-number\">8</span>  fruits\n\n<span class=\"hljs-meta\">&gt;&gt;</span> {<span class=\"hljs-string\">'Apple'</span>: <span class=\"hljs-string\">'Red'</span>, <span class=\"hljs-string\">'Banana'</span>: <span class=\"hljs-string\">'Yellow'</span>}\n</code></pre>\n<p>读者在 shell 中看到的字典元素顺序可能与上例中有所不同，因为字典的键是无序的，Python 会随机打印其元素（本节中所有示例均适用该情况）。</p>\n<p>字典是可变的。创建字典后，可通过语法“<code>[字典名][[键]] = [值]</code>”添加新的键值对，并通过语法“<code>[字典名][[键]]</code>”查找值。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/grc28lh</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  facts = dict()\n<span class=\"hljs-number\">05</span>\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>  <span class=\"hljs-comment\"># 添加键-值对</span>\n08  facts[<span class=\"hljs-string\">\"code\"</span>] = <span class=\"hljs-string\">\"fun\"</span>\n09  <span class=\"hljs-comment\"># 查找键对应的值</span>\n<span class=\"hljs-number\">10</span>  facts[<span class=\"hljs-string\">\"code\"</span>]\n<span class=\"hljs-number\">11</span>\n<span class=\"hljs-number\">12</span>\n<span class=\"hljs-number\">13</span>  <span class=\"hljs-comment\"># 添加键-值对</span>\n<span class=\"hljs-number\">14</span>  facts[<span class=\"hljs-string\">\"Bill\"</span>] = <span class=\"hljs-string\">\"Gates\"</span>\n<span class=\"hljs-number\">15</span>  <span class=\"hljs-comment\"># 查找键对应的值</span>\n<span class=\"hljs-number\">16</span>  facts[<span class=\"hljs-string\">\"Bill\"</span>]\n<span class=\"hljs-number\">17</span>\n<span class=\"hljs-number\">18</span>\n<span class=\"hljs-number\">19</span>  <span class=\"hljs-comment\"># 添加键-值对</span>\n<span class=\"hljs-number\">20</span>  facts[<span class=\"hljs-string\">\"founded\"</span>] = <span class=\"hljs-number\">1776</span>\n<span class=\"hljs-number\">21</span>  <span class=\"hljs-comment\"># 查找键对应的值</span>\n<span class=\"hljs-number\">22</span>  facts[<span class=\"hljs-string\">\"founded\"</span>]\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'fun'</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> Gates\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">1776</span>\n</code></pre>\n<p>字典的值可以是任意对象。在上例中，前两个值是字符串，最后一个值 1776 是整数。但是字典的键必须是不可变的。字符串或元组可以用作字典的键，但是列表或字典不可以。</p>\n<p>可以使用关键字 <code>in</code> 检查某个键是否在字典中，但不能用其检查某个值是否在字典中。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hgf9vmp</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  bill = dict({<span class=\"hljs-string\">\"Bill Gates\"</span>:\n<span class=\"hljs-number\">5</span>               <span class=\"hljs-string\">\"charitable\"</span>})\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  <span class=\"hljs-string\">\"Bill Gates\"</span> <strong><span class=\"hljs-keyword\">in</span></strong> bill\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<p>如果访问一个不在字典中的键，Python 将报告异常。</p>\n<p>在关键字 <code>in</code> 之前加上关键字 <code>not</code>，可检查键是否不在字典中。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/he3g993</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  bill = dict({<span class=\"hljs-string\">\"Bill Gates\"</span>:\n<span class=\"hljs-number\">5</span>                   <span class=\"hljs-string\">\"charitable\"</span>})\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  <span class=\"hljs-string\">\"Bill Doors\"</span> <strong><span class=\"hljs-keyword\">not</span></strong> <strong><span class=\"hljs-keyword\">in</span></strong> bill\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<p>可使用关键字 <code>del</code> 删除字典中的键值对。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/htrd9lj</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  books = {<span class=\"hljs-string\">\"Dracula\"</span>: <span class=\"hljs-string\">\"Stoker\"</span>,\n<span class=\"hljs-number\">5</span>           <span class=\"hljs-string\">\"1984\"</span>: <span class=\"hljs-string\">\"Orwell\"</span>,\n<span class=\"hljs-number\">6</span>           <span class=\"hljs-string\">\"The Trial\"</span>: <span class=\"hljs-string\">\"Kafka\"</span>}\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>\n<span class=\"hljs-number\">9</span> <strong>del</strong> books[<span class=\"hljs-string\">\"The Trial\"</span>]\n<span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">11</span>  books\n\n<span class=\"hljs-meta\">&gt;&gt;</span> {<span class=\"hljs-string\">'Dracula'</span>: <span class=\"hljs-string\">'Stoker'</span>, <span class=\"hljs-string\">'1984'</span>: <span class=\"hljs-string\">'Orwell'</span>}</code></pre>\n<p>一个使用字典的程序示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">01  <span class=\"hljs-comment\"># http://tinyurl.com/gnjvep7</span>\n02\n03\n04  rhymes = {<span class=\"hljs-string\">\"1\"</span>: <span class=\"hljs-string\">\"fun\"</span>,\n05            <span class=\"hljs-string\">\"2\"</span>: <span class=\"hljs-string\">\"blue\"</span>\n06            <span class=\"hljs-string\">\"3\"</span>: <span class=\"hljs-string\">\"me\"</span>,\n07            <span class=\"hljs-string\">\"4\"</span>: <span class=\"hljs-string\">\"floor\"</span>,\n08            <span class=\"hljs-string\">\"5\"</span>: <span class=\"hljs-string\">\"live\"</span>\n09            }\n10\n11\n12  n = input(<span class=\"hljs-string\">\"Type a number:\"</span>)\n13 <strong><span class=\"hljs-keyword\">if</span></strong> n <strong><span class=\"hljs-keyword\">in</span></strong> rhymes:\n14      rhyme = rhymes[n]\n15      <span class=\"hljs-built_in\">print</span>(rhyme)\n16 <strong><span class=\"hljs-keyword\">else</span></strong>:\n17      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"Not found.\"</span>)\n\nType a number:</code></pre>\n<p>字典 <code>rhymes</code> 中有 6 个数字（键），分别映射至 6 个单词（值）。程序让用户输入数字，并保存在变量中。在从字典中查找单词之前，记得先用 <code>in</code> 关键字检查字典中是否存在对应的键。如果存在，则查找字典中对应的单词并打印出来。否则会打印消息告诉用户未查找到。</p>\n<h3 id=\"55\">5.5　容器嵌套容器</h3>\n<p>可以在容器中存储容器。例如，你可以在列表中保存列表：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gops9fz</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  lists = []\n<span class=\"hljs-number\">05</span>  rap = [<span class=\"hljs-string\">\"Kanye West\"</span>,\n<span class=\"hljs-number\">06</span>         <span class=\"hljs-string\">\"Jay Z\"</span>,\n<span class=\"hljs-number\">07</span>         <span class=\"hljs-string\">\"Eminem\"</span>,\n08         <span class=\"hljs-string\">\"Nas\"</span>]\n09\n<span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">11</span>  rock = [<span class=\"hljs-string\">\"Bob Dylan\"</span>,\n<span class=\"hljs-number\">12</span>          <span class=\"hljs-string\">\"The Beatles\"</span>,\n<span class=\"hljs-number\">13</span>          <span class=\"hljs-string\">\"Led Zeppelin\"</span>]\n<span class=\"hljs-number\">14</span>\n<span class=\"hljs-number\">15</span>\n<span class=\"hljs-number\">16</span>  djs = [<span class=\"hljs-string\">\"Zeds Dead\"</span>,\n<span class=\"hljs-number\">17</span>         <span class=\"hljs-string\">\"Tiesto\"</span>]\n<span class=\"hljs-number\">18</span>\n<span class=\"hljs-number\">19</span>\n<span class=\"hljs-number\">20</span>  lists.append(rap)\n<span class=\"hljs-number\">21</span>  lists.append(rock)\n<span class=\"hljs-number\">22</span>  lists.append(djs)\n<span class=\"hljs-number\">23</span>\n<span class=\"hljs-number\">24</span>\n<span class=\"hljs-number\">25</span>  print(lists)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [[<span class=\"hljs-string\">'Kanye West'</span>, <span class=\"hljs-string\">'Jay Z'</span>, <span class=\"hljs-string\">'Eminem'</span>, <span class=\"hljs-string\">'Nas'</span>], [<span class=\"hljs-string\">'Bob Dylan'</span>, <span class=\"hljs-string\">'The Beatles'</span>, <span class=\"hljs-string\">'Led Zeppelin'</span>], [<span class=\"hljs-string\">'Zeds Dead'</span>, <span class=\"hljs-string\">'Tiesto'</span>]]\n</code></pre>\n<p>在上述例中，<code>lists</code> 有 3 个元素。每个元素都是一个列表：第一个元素是嘻哈歌手列表，第二个元素是摇滚歌手列表，第三个元素是 DJ 列表。可通过元素对应的索引访问这些列表：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gu4mudk</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-comment\"># 接上例</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>  rap = lists[<span class=\"hljs-number\">0</span>]\n<span class=\"hljs-number\">8</span>  print(rap)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'Kanye West'</span>, <span class=\"hljs-string\">'Jay Z'</span>, <span class=\"hljs-string\">'Eminem'</span>, <span class=\"hljs-string\">'Nas'</span>]\n</code></pre>\n<p>如果向列表 <code>rap</code> 中添加一个新元素，该修改也会体现在 <code>lists</code> 列表中：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hdtosm2</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-comment\"># 接上例</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n08  rap = lists[<span class=\"hljs-number\">0</span>]\n09  rap.append(<span class=\"hljs-string\">\"Kendrick Lamar\"</span>)\n<span class=\"hljs-number\">10</span>  print(rap)\n<span class=\"hljs-number\">11</span>  print(lists)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'Kanye West'</span>, <span class=\"hljs-string\">'Jay Z'</span>, <span class=\"hljs-string\">'Eminem'</span>, <span class=\"hljs-string\">'Nas'</span>, <span class=\"hljs-string\">'Kendrick Lamar'</span>]\n<span class=\"hljs-meta\">&gt;&gt;</span> [[<span class=\"hljs-string\">'Kanye West'</span>, <span class=\"hljs-string\">'Jay Z'</span>, <span class=\"hljs-string\">'Eminem'</span>, <span class=\"hljs-string\">'Nas'</span>, <span class=\"hljs-string\">'Kendrick Lamar'</span>],\n[<span class=\"hljs-string\">'Bob Dylan'</span>, <span class=\"hljs-string\">'The Beatles'</span>, <span class=\"hljs-string\">'Led Zeppelin'</span>], [<span class=\"hljs-string\">'Zeds Dead'</span>, <span class=\"hljs-string\">'Tiesto'</span>]]\n</code></pre>\n<p>也可以在列表中存储元素，在元组中存储列表，还可以在列表或元组中存储字典：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z9dhema</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  locations = []\n<span class=\"hljs-number\">05</span>\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>  la = (<span class=\"hljs-number\">34.0522</span>, <span class=\"hljs-number\">188.2437</span>)\n08  chicago = (<span class=\"hljs-number\">41.8781</span>, <span class=\"hljs-number\">87.6298</span>)\n09\n<span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">11</span>  locations.append(la)\n<span class=\"hljs-number\">12</span>  locations.append(chicago)\n<span class=\"hljs-number\">13</span>\n<span class=\"hljs-number\">14</span>\n<span class=\"hljs-number\">15</span>  print(locations)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [(<span class=\"hljs-number\">34.0522</span>, <span class=\"hljs-number\">188.2437</span>), (<span class=\"hljs-number\">41.8781</span>, <span class=\"hljs-number\">87.6298</span>)]\n\n<span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/ht7gpsd</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  eights = [<span class=\"hljs-string\">\"Edgar Allan Poe\"</span>,\n<span class=\"hljs-number\">05</span>            <span class=\"hljs-string\">\"Charles Dickens\"</span>]\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>\n08  nines = [<span class=\"hljs-string\">\"Hemingway\"</span>,\n09           <span class=\"hljs-string\">\"Fitzgerald\"</span>,\n<span class=\"hljs-number\">10</span>          <span class=\"hljs-string\">\"Orwell\"</span>]\n<span class=\"hljs-number\">11</span>\n<span class=\"hljs-number\">12</span>\n<span class=\"hljs-number\">13</span>  authors = (eights, nines)\n<span class=\"hljs-number\">14</span>  print(authors)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> ([<span class=\"hljs-string\">'Edgar Allan Poe'</span>, <span class=\"hljs-string\">'Charles Dickens'</span>], [<span class=\"hljs-string\">'Hemingway'</span>, <span class=\"hljs-string\">'Fitzgerald'</span>, <span class=\"hljs-string\">'Orwell'</span>])\n\n<span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h8ck5er</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  bday = {<span class=\"hljs-string\">\"Hemingway\"</span>:\n<span class=\"hljs-number\">05</span>          <span class=\"hljs-string\">\"7.21.1899\"</span>,\n<span class=\"hljs-number\">06</span>          <span class=\"hljs-string\">\"Fitzgerald\"</span>:\n<span class=\"hljs-number\">07</span>          <span class=\"hljs-string\">\"9.24.1896\"</span>}\n08\n09\n<span class=\"hljs-number\">10</span>  my_list = [bday]\n<span class=\"hljs-number\">11</span>  print(my_list)\n<span class=\"hljs-number\">12</span>  my_tuple = (bday,)\n<span class=\"hljs-number\">13</span>  print(my_tuple)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [{<span class=\"hljs-string\">'Hemingway'</span>: <span class=\"hljs-string\">'7.21.1899'</span>, <span class=\"hljs-string\">'Fitzgerald'</span>: <span class=\"hljs-string\">'9.24.1896'</span>}]\n<span class=\"hljs-meta\">&gt;&gt;</span> ({<span class=\"hljs-string\">'Hemingway'</span>: <span class=\"hljs-string\">'7.21.1899'</span>, <span class=\"hljs-string\">'Fitzgerald'</span>: <span class=\"hljs-string\">'9.24.1896'</span>},)\n</code></pre>\n<p>列表、字典或元组都可以成为字典中的值：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/zqupwx4</span></span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  ny = {<span class=\"hljs-string\">\"locations\"</span>:\n<span class=\"hljs-number\">05</span>        (<span class=\"hljs-number\">40.7128</span>,\n<span class=\"hljs-number\">06</span>         <span class=\"hljs-number\">74.0059</span>),\n<span class=\"hljs-number\">07</span>\n<span class=\"hljs-number\">08</span>\n<span class=\"hljs-number\">09</span>        <span class=\"hljs-string\">\"celebs\"</span>:\n<span class=\"hljs-number\">10</span>        [<span class=\"hljs-string\">\"W. Allen\"</span>,\n<span class=\"hljs-number\">11</span>         <span class=\"hljs-string\">\"Jay Z\"</span>,\n<span class=\"hljs-number\">12</span>         <span class=\"hljs-string\">\"K. Bacon\"</span>],\n<span class=\"hljs-number\">13</span>\n<span class=\"hljs-number\">14</span>         <span class=\"hljs-string\">\"facts\"</span>:\n<span class=\"hljs-number\">15</span>         {<span class=\"hljs-string\">\"state\"</span>:\n<span class=\"hljs-number\">16</span>          <span class=\"hljs-string\">\"NY\"</span>,\n<span class=\"hljs-number\">17</span>          <span class=\"hljs-string\">\"country\"</span>:\n<span class=\"hljs-number\">18</span>          <span class=\"hljs-string\">\"America\"</span>}\n<span class=\"hljs-number\">19</span>  }\n</code></pre>\n<p>本例中，字典 <code>ny</code> 有 3 个键：<code>\"locations\"</code>、<code>\"celebs\"</code> 和 <code>\"facts\"</code>。第一个键的值是一个元组，因为地理坐标永远不会变。第二个键的值是生活在纽约的名人列表，因为可能会变化所以使用列表。第三个键的值是一个字典，因为键值对是表示纽约有关联事实的最好方式。</p>\n<h3 id=\"56\">5.6　术语表</h3>\n<p><strong>方法</strong>：与指定数据类型紧密相关的函数。</p>\n<p><strong>列表</strong>：存储有序对象的一种容器。</p>\n<p><strong>可迭代的</strong>：如果可使用循环访问对象中的每一个元素，则该对象是可迭代的。</p>\n<p><strong>可迭代对象</strong>：可迭代的对象，如字符串、列表和元素。</p>\n<p><strong>索引</strong>：代表元素在可迭代对象中位置的数字。</p>\n<p><strong>可变的</strong>：容器中的内容可以发生变化。</p>\n<p><strong>不可变的</strong>：容器中的内容不能改变。</p>\n<p><strong>字典</strong>：存储对象的一种内置容器，将一个称为键的对象，映射至一个称为值的对象。</p>\n<p><strong>键</strong>：用来查找字典中对应的值。</p>\n<p><strong>值</strong>：字典中映射至键的值。</p>\n<p><strong>映射</strong>：将一个对象链接至另一个对象。</p>\n<p><strong>键值对</strong>：字典中键映射至值。</p>\n<h3 id=\"57\">5.7　挑战练习</h3>\n<p>1．创建一个你最喜欢歌手的列表。</p>\n<p>2．创建一个由元组构成的列表，每个元组包含居住过或旅游过的城市的经纬度。</p>\n<p>3．创建一个包含你的不同属性的字典：身高、最喜欢的颜色和最喜欢的作者等。</p>\n<p>4．编写一个程序，让用户询问你的身高、最喜欢的颜色或最喜欢的作者，并返回上一个挑战中创建的字典。</p>\n<p>5．创建一个字典，将最喜欢的歌手映射至你最喜欢的歌曲。</p>\n<p>6．列表、元组和容器只是 Python 中内置容器的一部分。自行研究 Python 中的集合（也是一种容器）在什么情况下可以使用集合？</p>\n<p>答案可从异步社区（www.epubit.com）本书详情页的配套资源中下载。</p></div></article>\n</body>\n</html>","source":"_posts/Python无师自通/5_container.html","raw":"---\ntitle: 容器\n---\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>容器</title>\n</head>\n<body>\n<article id=\"articleDiv\"><div class=\"mazi-article-content dont-break-out\"><p></p><div class=\"toc\">\n<ul>\n<li><ul>\n<li><ul>\n<li><a href=\"#51\">5.1　方法</a></li>\n<li><a href=\"#52\">5.2　列表</a></li>\n<li><a href=\"#53\">5.3　元组</a></li>\n<li><a href=\"#54\">5.4　字典</a></li>\n<li><a href=\"#55\">5.5　容器嵌套容器</a></li>\n<li><a href=\"#56\">5.6　术语表</a></li>\n<li><a href=\"#57\">5.7　挑战练习</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>\n<p></p>\n<blockquote>\n  <p><span style=\"font-family: Times New Roman,楷体_GB2312\">“愚者困惑，智者提问。”</span></p>\n  <p><span style=\"font-family: Times New Roman,楷体_GB2312\">——本杰明 · 迪斯雷利（Benjamin Disraeli）</span></p>\n</blockquote>\n<p>在第 3 章中，我们学习了如何用变量保存对象。本章将讨论如何用容器保存对象。容器就像是文件柜，可有效整理数据。这里将学习 3 个常用的容器：列表、元组和字典。</p>\n<h3 id=\"51\">5.1　方法</h3>\n<p>第 4 章介绍了函数。Python 中有一个类似的概念，叫<strong>方法</strong>（method）。方法是与指定数据类型紧密相关的函数。方法与函数一样，可执行代码并返回结果。不同的是，只有在对象上才能调用方法。同样也可以传递参数给方法。调用字符串的 <code>upper</code> 和 <code>replace</code> 方法的示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zdllght</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"Hello\"</span>.upper()\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'HELLO'</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hfgpst5</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"Hello\"</span>.replace(<span class=\"hljs-string\">\"o\"</span>, <span class=\"hljs-string\">\"@\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'Hell@'</span>\n</code></pre>\n<p>本书第二部分将详细介绍方法。</p>\n<h3 id=\"52\">5.2　列表</h3>\n<p><strong>列表</strong>（list）是以固定顺序保存对象的容器（如图 5-1 所示）。</p>\n<p><img src=\"https://images.gitbook.cn/aab3b280-6fc3-11e9-9e1b-5b6158413fa5\" alt=\"enter image description here\"></p>\n<p>图 5-1　列表</p>\n<p>列表用方括号表示。我们可使用两种语法创建列表，一种是使用 <code>list</code> 函数创建空列表，示例如下：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/h4go6kg</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  fruit = <span class=\"hljs-built_in\">list</span>()\n<span class=\"hljs-number\">5</span>  fruit\n\n&gt;&gt; []\n</code></pre>\n<p>或者直接使用方括号：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jft8p7x</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  fruit = []\n<span class=\"hljs-number\">5</span>  fruit\n\n<span class=\"hljs-meta\">&gt;&gt;</span> []\n</code></pre>\n<p>使用第二种语法，并将你希望放在列表中的所有对象填入方括号中，用逗号分隔，即可创建一个包含所有对象的列表。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h2y8nos</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  fruit = [<span class=\"hljs-string\">\"Apple\"</span>, <span class=\"hljs-string\">\"Orange\"</span>, <span class=\"hljs-string\">\"Pear\"</span>]\n<span class=\"hljs-number\">5</span>  fruit\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'Apple'</span>, <span class=\"hljs-string\">'Orange'</span>, <span class=\"hljs-string\">'Pear'</span>]\n</code></pre>\n<p>上述示例中的列表有 3 个元素：<code>\"Apple\"</code>、<code>\"Orange\"</code> 和 <code>\"Pear\"</code>。列表中的元素是有序的。除非你重新调整列表中元素的顺序，否则 <code>\"Apple\"</code> 永远是第一个元素，<code>\"Orange\"</code> 是第二个元素，<code>\"Pear\"</code> 则是第三个元素。<code>\"Apple\"</code> 位于列表的开头，末尾则是 <code>\"Pear\"</code>。这里可使用 <code>append</code> 方法向列表中添加一个新元素。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h9w3z2m</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  fruit = [<span class=\"hljs-string\">\"Apple\"</span>, <span class=\"hljs-string\">\"Orange\"</span>, <span class=\"hljs-string\">\"Pear\"</span>]\n<span class=\"hljs-number\">5</span>  fruit.append(<span class=\"hljs-string\">\"Banana\"</span>)\n<span class=\"hljs-number\">6</span>  fruit.append(<span class=\"hljs-string\">\"Peach\"</span>)\n<span class=\"hljs-number\">7</span>  fruit\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'Apple'</span>, <span class=\"hljs-string\">'Orange'</span>, <span class=\"hljs-string\">'Pear'</span>, <span class=\"hljs-string\">'Banana'</span>, <span class=\"hljs-string\">'Peach'</span>]\n</code></pre>\n<p>传递给 <code>append</code> 方法的两个对象现在都加入了列表。但 <code>append</code> 方法永远是将新元素添加至列表的末尾。</p>\n<p>列表不仅可以保存字符串，它还可以保存任意数据类型。示例如下：</p>\n<pre><code class=\"hljs php\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zhpntsr</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  random = []\n<span class=\"hljs-number\">5</span>  random.append(<span class=\"hljs-keyword\">True</span>)\n<span class=\"hljs-number\">6</span>  random.append(<span class=\"hljs-number\">100</span>)\n<span class=\"hljs-number\">7</span>  random.append(<span class=\"hljs-number\">1.1</span>)\n<span class=\"hljs-number\">8</span>  random.append(<span class=\"hljs-string\">\"Hello\"</span>)\n<span class=\"hljs-number\">9</span>  random\n\n&gt;&gt; [<span class=\"hljs-keyword\">True</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">1.1</span>, <span class=\"hljs-string\">'Hello'</span>]\n</code></pre>\n<p>字符串、列表和元组都是<strong>可迭代的</strong>（iterable）。如果可以使用循环访问对象中的每一个元素，那么该对象是可迭代的，被称为<strong>可迭代对象</strong>。可迭代对象中的每一个元素都有一个<strong>索引</strong>（index），即表示元素在可迭代对象中位置的数字。列表中第一个元素的索引是 0，而不是 1。</p>\n<p>在如下示例中，<code>\"Apple\"</code> 的索引是 0，<code>\"Orange\"</code> 的索引是 1，<code>\"Pear\"</code> 的索引是 2：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/z8zzk8d</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  fruit = [<span class=\"hljs-string\">\"Apple\"</span>, <span class=\"hljs-string\">\"Orange\"</span>, <span class=\"hljs-string\">\"Pear\"</span>]\n</code></pre>\n<p>你可以使用语法[列表名][[索引]]获取一个元素：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jqtlwpf</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  fruit = [<span class=\"hljs-string\">\"Apple\"</span>, <span class=\"hljs-string\">\"Orange\"</span>, <span class=\"hljs-string\">\"Pear\"</span>]\n<span class=\"hljs-number\">5</span>  fruit[<span class=\"hljs-number\">0</span>]\n<span class=\"hljs-number\">6</span>  fruit[<span class=\"hljs-number\">1</span>]\n<span class=\"hljs-number\">7</span>  fruit[<span class=\"hljs-number\">2</span>]\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'Apple'</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'Orange'</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'Pear'</span>\n</code></pre>\n<p>如果获取的是不存在的索引，Python 会报告异常：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/za3rv95</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  colors = [<span class=\"hljs-string\">\"blue\"</span>, <span class=\"hljs-string\">\"green\"</span>, <span class=\"hljs-string\">\"yellow\"</span>]\n<span class=\"hljs-number\">5</span>  colors[<span class=\"hljs-number\">4</span>]\n\n&gt;&gt; IndexError: <span class=\"hljs-built_in\">list</span> index out of range\n</code></pre>\n<p>列表是<strong>可变的</strong>（mutable）。如果一个容器是可变的，则可以向该容器中增删对象。将列表中某个元素的索引赋给一个新的对象，即可改变该元素：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h4ahvf9</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  colors = [<span class=\"hljs-string\">\"blue\"</span>, <span class=\"hljs-string\">\"green\"</span>, <span class=\"hljs-string\">\"yellow\"</span>]\n<span class=\"hljs-number\">5</span>  colors\n<span class=\"hljs-number\">6</span>  colors[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-string\">\"red\"</span>\n<span class=\"hljs-number\">7</span>  colors\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'blue'</span>, <span class=\"hljs-string\">'green'</span>, <span class=\"hljs-string\">'yellow'</span>]\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'blue'</span>, <span class=\"hljs-string\">'green'</span>, <span class=\"hljs-string\">'red'</span>]\n</code></pre>\n<p>也可使用 <code>pop</code> 方法移除列表中的最后一个元素：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/j52uvmq</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  colors = [<span class=\"hljs-string\">\"blue\"</span>, <span class=\"hljs-string\">\"green\"</span>, <span class=\"hljs-string\">\"yellow\"</span>]\n<span class=\"hljs-number\">5</span>  colors\n<span class=\"hljs-number\">6</span>  item = colors.pop()\n<span class=\"hljs-number\">7</span>  item\n<span class=\"hljs-number\">8</span>  colors\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'blue'</span>, <span class=\"hljs-string\">'green'</span>, <span class=\"hljs-string\">'yellow'</span>]\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'yellow'</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'blue'</span>, <span class=\"hljs-string\">'green'</span>]\n</code></pre>\n<p>不能对空列表使用 <code>pop</code> 方法。否则，Python 则会报告异常。</p>\n<p>你可以使用加法操作符来合并两个列表：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jjxnk4z</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  colors1 = [<span class=\"hljs-string\">\"blue\"</span>, <span class=\"hljs-string\">\"green\"</span>, <span class=\"hljs-string\">\"yellow\"</span>]\n<span class=\"hljs-number\">5</span>  colors2 = [<span class=\"hljs-string\">\"orange\"</span>, <span class=\"hljs-string\">\"pink\"</span>, <span class=\"hljs-string\">\"black\"</span>]\n<span class=\"hljs-number\">6</span>  colors1 + colors2\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'blue'</span>, <span class=\"hljs-string\">'green'</span>, <span class=\"hljs-string\">'yellow'</span>, <span class=\"hljs-string\">'orange'</span>, <span class=\"hljs-string\">'pink'</span>, <span class=\"hljs-string\">'black'</span>]\n</code></pre>\n<p>也可以使用关键字 <code>in</code> 检查某个元素是否在列表中：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z4fnv39</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  colors = [<span class=\"hljs-string\">\"blue\"</span>, <span class=\"hljs-string\">\"green\"</span>, <span class=\"hljs-string\">\"yellow\"</span>]\n<span class=\"hljs-number\">5</span>  <span class=\"hljs-string\">\"green\"</span> <strong><span class=\"hljs-keyword\">in</span></strong> colors\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<p>使用关键字 <code>not</code> 检查某个元素是否不在列表中：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jqzk8pj</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  colors = [<span class=\"hljs-string\">\"blue\"</span>, <span class=\"hljs-string\">\"green\"</span>, <span class=\"hljs-string\">\"yellow\"</span>]\n<span class=\"hljs-number\">5</span>  <span class=\"hljs-string\">\"black\"</span> <strong><span class=\"hljs-keyword\">not</span></strong> <strong><span class=\"hljs-keyword\">in</span></strong> colors\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<p>使用函数 <code>len</code> 可获得列表的大小（包含元素的个数）：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hhx6rx4</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  len(colors)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">3</span>\n</code></pre>\n<p>下面是一个在实践中使用列表的例子：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">01  <span class=\"hljs-comment\"># http://tinyurl.com/gq7yjr7</span>\n02\n03\n04  colors = [<span class=\"hljs-string\">\"purple\"</span>,\n05            <span class=\"hljs-string\">\"orange\"</span>,\n06            <span class=\"hljs-string\">\"green\"</span>]\n07\n08\n09  guess = input(<span class=\"hljs-string\">\"Guess a color:\"</span>)\n10\n11\n12<strong><span class=\"hljs-keyword\">if</span></strong> guess <strong><span class=\"hljs-keyword\">in</span></strong> colors:\n13      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"You guessed correctly!\"</span>)\n14<strong><span class=\"hljs-keyword\">else</span></strong>:\n15      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Wrong! Try again.\"</span>)\n\n&gt;&gt; Guess a color:</code></pre>\n<p>列表 <code>colors</code> 包含了代表颜色的不同字符串。程序使用内置函数 <code>input</code> 来让用户猜测是什么颜色，并将用户的答案保存至变量。如果答案在 <code>colors</code> 列表中，则告知用户猜测正确。反之，让用户再次尝试。</p>\n<h3 id=\"53\">5.3　元组</h3>\n<p><strong>元组</strong>（tuple）是存储有序对象的一种容器。与列表不同，元组是<strong>不可变的</strong>（immutable），这意味着其内容不会变化。创建元组后，无法修改其中任何元组的值，也无法添加或修改元素。用圆括号表示元组，且必须用逗号分隔元组中的元素。有两种语法可以创建元组，第一种如下所示：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zo88eal</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  my_tuple = tuple()\n<span class=\"hljs-number\">5</span>  my_tuple\n\n<span class=\"hljs-meta\">&gt;&gt;</span> ()\n</code></pre>\n<p>以及第二种语法：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zm3y26j</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  my_tuple = ()\n<span class=\"hljs-number\">5</span>  my_tuple\n\n<span class=\"hljs-meta\">&gt;&gt;</span> ()\n</code></pre>\n<p>如果要向元组中新增对象，可用第二种语法创建一个新的元组，并在其中加入你希望增加的每个元素，用逗号分隔：</p>\n<pre><code class=\"hljs php\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zlwwfe3</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  rndm = (<span class=\"hljs-string\">\"M. Jackson\"</span>, <span class=\"hljs-number\">1958</span>, <span class=\"hljs-keyword\">True</span>)\n<span class=\"hljs-number\">5</span>  rndm\n\n&gt;&gt; (<span class=\"hljs-string\">'M. Jackson'</span>, <span class=\"hljs-number\">1958</span>, <span class=\"hljs-keyword\">True</span>)\n</code></pre>\n<p>即使元组中只有一个元素，也需要在该元素的后面加上逗号。只有这样，Python 才能将其与其他为了表示运算顺序而放在圆括号中的数字标记进行区分。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/j8mca8o</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-comment\"># 这是元组</span>\n<span class=\"hljs-number\">5</span>  (<span class=\"hljs-string\">\"self_taught\"</span>, )\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  <span class=\"hljs-comment\"># 这不是元组</span>\n<span class=\"hljs-number\">9</span>  (<span class=\"hljs-number\">9</span>) + <span class=\"hljs-number\">1</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> (<span class=\"hljs-string\">'self_taught'</span>, )\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">10</span>\n</code></pre>\n<p>创建元组之后，不能再新增元素或修改已有元素。如果在创建元组后这样做，Python 会报告异常：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z3x34nk</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  dys = (<span class=\"hljs-string\">\"1984\"</span>,\n<span class=\"hljs-number\">5</span>         <span class=\"hljs-string\">\"Brave New World\"</span>,\n<span class=\"hljs-number\">6</span>         <span class=\"hljs-string\">\"Fahrenheit 451\"</span>)\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>\n<span class=\"hljs-number\">9</span>  dys[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-string\">\"Handmaid's Tale\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-symbol\">TypeError:</span> <span class=\"hljs-string\">'tuple'</span> object does not support item assignment\n</code></pre>\n<p>可使用与列表一样的方法来获取元组的元素，即引用其索引：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z9dc6lo</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  dys = (<span class=\"hljs-string\">\"1984\"</span>,\n<span class=\"hljs-number\">5</span>         <span class=\"hljs-string\">\"Brave New World\"</span>,\n<span class=\"hljs-number\">6</span>         <span class=\"hljs-string\">\"Fahrenheit 451\"</span>)\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>\n<span class=\"hljs-number\">9</span>  dys[<span class=\"hljs-number\">2</span>]\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'Fahrenheit 451'</span>\n</code></pre>\n<p>可使用关键字 <code>in</code> 来检查某个元素是否在元组中：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/j3bsel7</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  dys = (<span class=\"hljs-string\">\"1984\"</span>,\n<span class=\"hljs-number\">5</span>         <span class=\"hljs-string\">\"Brave New World\"</span>,\n<span class=\"hljs-number\">6</span>         <span class=\"hljs-string\">\"Fahrenheit 451\"</span>)\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>\n<span class=\"hljs-number\">9</span>  <span class=\"hljs-string\">\"1984\"</span> <strong><span class=\"hljs-keyword\">in</span></strong> dys\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<p>在 <code>in</code> 前加上关键字 <code>not</code> 即可检查元素是否不在元组中：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jpdjjv9</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  dys = (<span class=\"hljs-string\">\"1984\"</span>,\n<span class=\"hljs-number\">5</span>         <span class=\"hljs-string\">\"Brave New World\"</span>,\n<span class=\"hljs-number\">6</span>         <span class=\"hljs-string\">\"Fahrenheit 451\"</span>)\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>\n<span class=\"hljs-number\">9</span>  <span class=\"hljs-string\">\"Handmaid's Tale\"</span> <strong><span class=\"hljs-keyword\">not</span></strong> <strong><span class=\"hljs-keyword\">in</span></strong> dys\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<p>你可能会疑惑为什么要使用一个看上去没有列表灵活的数据结构。因为在处理明确永远不会改变的，并且也不希望其他程序对其进行修改的值时，元组是非常有用的。地理坐标就是适合使用元组存储的一种数据。城市的经纬度应保存在元组中，因为这些值永远不会改变，保存为元组意味着程序不会意外对其进行修改。元组不像列表那样可以用作字典的键，这个知识点会在下一节介绍。</p>\n<h3 id=\"54\">5.4　字典</h3>\n<p><strong>字典</strong>（dictionary）是另一种用于存储对象的内置容器。它们被用来链接<strong>键</strong>（key）和<strong>值</strong>（value）这两个对象（如图 5-2 所示）。将一个对象链接至另一个对象，也被称为<strong>映射</strong>（mapping），结果为产生一个<strong>键值对</strong>（key-value pair）。可将键值对添加到字典，然后使用键在字典中查询，可获得其对应的值。但是无法使用值来查询键。</p>\n<p><img src=\"https://images.gitbook.cn/38d2e810-6fc4-11e9-9e1b-5b6158413fa5\" alt=\"enter image description here\"></p>\n<p>图 5-2　字典</p>\n<p>字典是可变的，因此可以向字典中新增键值对。与列表和元组不同，字典中存储的对象是无序的。字典的价值在于键与值之间的关联。需要成对存储数据的场景很多。例如，可以将关于某个人的信息存储在字典中，将名为 height 的键，映射至代表这个人身高的值；将名为 eyecolor 的键映射至代表这个人眼睛颜色的值；将名为 nationality 的键映射至代表这个人国籍的值。</p>\n<p>字典用花括号表示。有两种创建字典的语法，其一如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zfn6jmw</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  my_dict = dict()\n<span class=\"hljs-number\">5</span>  my_dict\n\n<span class=\"hljs-meta\">&gt;&gt;</span> {}\n</code></pre>\n<p>另一种方法如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jfgemf2</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  my_dict = {}\n<span class=\"hljs-number\">5</span>  my_dict\n\n<span class=\"hljs-meta\">&gt;&gt;</span> {}\n</code></pre>\n<p>可以在创建字典时直接添加键值对。上述两种语法都要求用冒号分隔键与值，每个键值对之间用逗号分隔。与元组不同的是，如果只有一个键值对，不需要在其后添加逗号。如下示例介绍了创建字典时如何添加键值对：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hplqc4u</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  fruits = {<span class=\"hljs-string\">\"Apple\"</span>:\n<span class=\"hljs-number\">5</span>            <span class=\"hljs-string\">\"Red\"</span>,\n<span class=\"hljs-number\">6</span>            <span class=\"hljs-string\">\"Banana\"</span>:\n<span class=\"hljs-number\">7</span>            <span class=\"hljs-string\">\"Yellow\"</span>}\n<span class=\"hljs-number\">8</span>  fruits\n\n<span class=\"hljs-meta\">&gt;&gt;</span> {<span class=\"hljs-string\">'Apple'</span>: <span class=\"hljs-string\">'Red'</span>, <span class=\"hljs-string\">'Banana'</span>: <span class=\"hljs-string\">'Yellow'</span>}\n</code></pre>\n<p>读者在 shell 中看到的字典元素顺序可能与上例中有所不同，因为字典的键是无序的，Python 会随机打印其元素（本节中所有示例均适用该情况）。</p>\n<p>字典是可变的。创建字典后，可通过语法“<code>[字典名][[键]] = [值]</code>”添加新的键值对，并通过语法“<code>[字典名][[键]]</code>”查找值。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/grc28lh</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  facts = dict()\n<span class=\"hljs-number\">05</span>\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>  <span class=\"hljs-comment\"># 添加键-值对</span>\n08  facts[<span class=\"hljs-string\">\"code\"</span>] = <span class=\"hljs-string\">\"fun\"</span>\n09  <span class=\"hljs-comment\"># 查找键对应的值</span>\n<span class=\"hljs-number\">10</span>  facts[<span class=\"hljs-string\">\"code\"</span>]\n<span class=\"hljs-number\">11</span>\n<span class=\"hljs-number\">12</span>\n<span class=\"hljs-number\">13</span>  <span class=\"hljs-comment\"># 添加键-值对</span>\n<span class=\"hljs-number\">14</span>  facts[<span class=\"hljs-string\">\"Bill\"</span>] = <span class=\"hljs-string\">\"Gates\"</span>\n<span class=\"hljs-number\">15</span>  <span class=\"hljs-comment\"># 查找键对应的值</span>\n<span class=\"hljs-number\">16</span>  facts[<span class=\"hljs-string\">\"Bill\"</span>]\n<span class=\"hljs-number\">17</span>\n<span class=\"hljs-number\">18</span>\n<span class=\"hljs-number\">19</span>  <span class=\"hljs-comment\"># 添加键-值对</span>\n<span class=\"hljs-number\">20</span>  facts[<span class=\"hljs-string\">\"founded\"</span>] = <span class=\"hljs-number\">1776</span>\n<span class=\"hljs-number\">21</span>  <span class=\"hljs-comment\"># 查找键对应的值</span>\n<span class=\"hljs-number\">22</span>  facts[<span class=\"hljs-string\">\"founded\"</span>]\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'fun'</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> Gates\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">1776</span>\n</code></pre>\n<p>字典的值可以是任意对象。在上例中，前两个值是字符串，最后一个值 1776 是整数。但是字典的键必须是不可变的。字符串或元组可以用作字典的键，但是列表或字典不可以。</p>\n<p>可以使用关键字 <code>in</code> 检查某个键是否在字典中，但不能用其检查某个值是否在字典中。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hgf9vmp</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  bill = dict({<span class=\"hljs-string\">\"Bill Gates\"</span>:\n<span class=\"hljs-number\">5</span>               <span class=\"hljs-string\">\"charitable\"</span>})\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  <span class=\"hljs-string\">\"Bill Gates\"</span> <strong><span class=\"hljs-keyword\">in</span></strong> bill\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<p>如果访问一个不在字典中的键，Python 将报告异常。</p>\n<p>在关键字 <code>in</code> 之前加上关键字 <code>not</code>，可检查键是否不在字典中。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/he3g993</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  bill = dict({<span class=\"hljs-string\">\"Bill Gates\"</span>:\n<span class=\"hljs-number\">5</span>                   <span class=\"hljs-string\">\"charitable\"</span>})\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  <span class=\"hljs-string\">\"Bill Doors\"</span> <strong><span class=\"hljs-keyword\">not</span></strong> <strong><span class=\"hljs-keyword\">in</span></strong> bill\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<p>可使用关键字 <code>del</code> 删除字典中的键值对。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/htrd9lj</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  books = {<span class=\"hljs-string\">\"Dracula\"</span>: <span class=\"hljs-string\">\"Stoker\"</span>,\n<span class=\"hljs-number\">5</span>           <span class=\"hljs-string\">\"1984\"</span>: <span class=\"hljs-string\">\"Orwell\"</span>,\n<span class=\"hljs-number\">6</span>           <span class=\"hljs-string\">\"The Trial\"</span>: <span class=\"hljs-string\">\"Kafka\"</span>}\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>\n<span class=\"hljs-number\">9</span> <strong>del</strong> books[<span class=\"hljs-string\">\"The Trial\"</span>]\n<span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">11</span>  books\n\n<span class=\"hljs-meta\">&gt;&gt;</span> {<span class=\"hljs-string\">'Dracula'</span>: <span class=\"hljs-string\">'Stoker'</span>, <span class=\"hljs-string\">'1984'</span>: <span class=\"hljs-string\">'Orwell'</span>}</code></pre>\n<p>一个使用字典的程序示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">01  <span class=\"hljs-comment\"># http://tinyurl.com/gnjvep7</span>\n02\n03\n04  rhymes = {<span class=\"hljs-string\">\"1\"</span>: <span class=\"hljs-string\">\"fun\"</span>,\n05            <span class=\"hljs-string\">\"2\"</span>: <span class=\"hljs-string\">\"blue\"</span>\n06            <span class=\"hljs-string\">\"3\"</span>: <span class=\"hljs-string\">\"me\"</span>,\n07            <span class=\"hljs-string\">\"4\"</span>: <span class=\"hljs-string\">\"floor\"</span>,\n08            <span class=\"hljs-string\">\"5\"</span>: <span class=\"hljs-string\">\"live\"</span>\n09            }\n10\n11\n12  n = input(<span class=\"hljs-string\">\"Type a number:\"</span>)\n13 <strong><span class=\"hljs-keyword\">if</span></strong> n <strong><span class=\"hljs-keyword\">in</span></strong> rhymes:\n14      rhyme = rhymes[n]\n15      <span class=\"hljs-built_in\">print</span>(rhyme)\n16 <strong><span class=\"hljs-keyword\">else</span></strong>:\n17      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"Not found.\"</span>)\n\nType a number:</code></pre>\n<p>字典 <code>rhymes</code> 中有 6 个数字（键），分别映射至 6 个单词（值）。程序让用户输入数字，并保存在变量中。在从字典中查找单词之前，记得先用 <code>in</code> 关键字检查字典中是否存在对应的键。如果存在，则查找字典中对应的单词并打印出来。否则会打印消息告诉用户未查找到。</p>\n<h3 id=\"55\">5.5　容器嵌套容器</h3>\n<p>可以在容器中存储容器。例如，你可以在列表中保存列表：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gops9fz</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  lists = []\n<span class=\"hljs-number\">05</span>  rap = [<span class=\"hljs-string\">\"Kanye West\"</span>,\n<span class=\"hljs-number\">06</span>         <span class=\"hljs-string\">\"Jay Z\"</span>,\n<span class=\"hljs-number\">07</span>         <span class=\"hljs-string\">\"Eminem\"</span>,\n08         <span class=\"hljs-string\">\"Nas\"</span>]\n09\n<span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">11</span>  rock = [<span class=\"hljs-string\">\"Bob Dylan\"</span>,\n<span class=\"hljs-number\">12</span>          <span class=\"hljs-string\">\"The Beatles\"</span>,\n<span class=\"hljs-number\">13</span>          <span class=\"hljs-string\">\"Led Zeppelin\"</span>]\n<span class=\"hljs-number\">14</span>\n<span class=\"hljs-number\">15</span>\n<span class=\"hljs-number\">16</span>  djs = [<span class=\"hljs-string\">\"Zeds Dead\"</span>,\n<span class=\"hljs-number\">17</span>         <span class=\"hljs-string\">\"Tiesto\"</span>]\n<span class=\"hljs-number\">18</span>\n<span class=\"hljs-number\">19</span>\n<span class=\"hljs-number\">20</span>  lists.append(rap)\n<span class=\"hljs-number\">21</span>  lists.append(rock)\n<span class=\"hljs-number\">22</span>  lists.append(djs)\n<span class=\"hljs-number\">23</span>\n<span class=\"hljs-number\">24</span>\n<span class=\"hljs-number\">25</span>  print(lists)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [[<span class=\"hljs-string\">'Kanye West'</span>, <span class=\"hljs-string\">'Jay Z'</span>, <span class=\"hljs-string\">'Eminem'</span>, <span class=\"hljs-string\">'Nas'</span>], [<span class=\"hljs-string\">'Bob Dylan'</span>, <span class=\"hljs-string\">'The Beatles'</span>, <span class=\"hljs-string\">'Led Zeppelin'</span>], [<span class=\"hljs-string\">'Zeds Dead'</span>, <span class=\"hljs-string\">'Tiesto'</span>]]\n</code></pre>\n<p>在上述例中，<code>lists</code> 有 3 个元素。每个元素都是一个列表：第一个元素是嘻哈歌手列表，第二个元素是摇滚歌手列表，第三个元素是 DJ 列表。可通过元素对应的索引访问这些列表：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gu4mudk</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-comment\"># 接上例</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>  rap = lists[<span class=\"hljs-number\">0</span>]\n<span class=\"hljs-number\">8</span>  print(rap)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'Kanye West'</span>, <span class=\"hljs-string\">'Jay Z'</span>, <span class=\"hljs-string\">'Eminem'</span>, <span class=\"hljs-string\">'Nas'</span>]\n</code></pre>\n<p>如果向列表 <code>rap</code> 中添加一个新元素，该修改也会体现在 <code>lists</code> 列表中：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hdtosm2</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-comment\"># 接上例</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n08  rap = lists[<span class=\"hljs-number\">0</span>]\n09  rap.append(<span class=\"hljs-string\">\"Kendrick Lamar\"</span>)\n<span class=\"hljs-number\">10</span>  print(rap)\n<span class=\"hljs-number\">11</span>  print(lists)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'Kanye West'</span>, <span class=\"hljs-string\">'Jay Z'</span>, <span class=\"hljs-string\">'Eminem'</span>, <span class=\"hljs-string\">'Nas'</span>, <span class=\"hljs-string\">'Kendrick Lamar'</span>]\n<span class=\"hljs-meta\">&gt;&gt;</span> [[<span class=\"hljs-string\">'Kanye West'</span>, <span class=\"hljs-string\">'Jay Z'</span>, <span class=\"hljs-string\">'Eminem'</span>, <span class=\"hljs-string\">'Nas'</span>, <span class=\"hljs-string\">'Kendrick Lamar'</span>],\n[<span class=\"hljs-string\">'Bob Dylan'</span>, <span class=\"hljs-string\">'The Beatles'</span>, <span class=\"hljs-string\">'Led Zeppelin'</span>], [<span class=\"hljs-string\">'Zeds Dead'</span>, <span class=\"hljs-string\">'Tiesto'</span>]]\n</code></pre>\n<p>也可以在列表中存储元素，在元组中存储列表，还可以在列表或元组中存储字典：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z9dhema</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  locations = []\n<span class=\"hljs-number\">05</span>\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>  la = (<span class=\"hljs-number\">34.0522</span>, <span class=\"hljs-number\">188.2437</span>)\n08  chicago = (<span class=\"hljs-number\">41.8781</span>, <span class=\"hljs-number\">87.6298</span>)\n09\n<span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">11</span>  locations.append(la)\n<span class=\"hljs-number\">12</span>  locations.append(chicago)\n<span class=\"hljs-number\">13</span>\n<span class=\"hljs-number\">14</span>\n<span class=\"hljs-number\">15</span>  print(locations)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [(<span class=\"hljs-number\">34.0522</span>, <span class=\"hljs-number\">188.2437</span>), (<span class=\"hljs-number\">41.8781</span>, <span class=\"hljs-number\">87.6298</span>)]\n\n<span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/ht7gpsd</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  eights = [<span class=\"hljs-string\">\"Edgar Allan Poe\"</span>,\n<span class=\"hljs-number\">05</span>            <span class=\"hljs-string\">\"Charles Dickens\"</span>]\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>\n08  nines = [<span class=\"hljs-string\">\"Hemingway\"</span>,\n09           <span class=\"hljs-string\">\"Fitzgerald\"</span>,\n<span class=\"hljs-number\">10</span>          <span class=\"hljs-string\">\"Orwell\"</span>]\n<span class=\"hljs-number\">11</span>\n<span class=\"hljs-number\">12</span>\n<span class=\"hljs-number\">13</span>  authors = (eights, nines)\n<span class=\"hljs-number\">14</span>  print(authors)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> ([<span class=\"hljs-string\">'Edgar Allan Poe'</span>, <span class=\"hljs-string\">'Charles Dickens'</span>], [<span class=\"hljs-string\">'Hemingway'</span>, <span class=\"hljs-string\">'Fitzgerald'</span>, <span class=\"hljs-string\">'Orwell'</span>])\n\n<span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h8ck5er</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  bday = {<span class=\"hljs-string\">\"Hemingway\"</span>:\n<span class=\"hljs-number\">05</span>          <span class=\"hljs-string\">\"7.21.1899\"</span>,\n<span class=\"hljs-number\">06</span>          <span class=\"hljs-string\">\"Fitzgerald\"</span>:\n<span class=\"hljs-number\">07</span>          <span class=\"hljs-string\">\"9.24.1896\"</span>}\n08\n09\n<span class=\"hljs-number\">10</span>  my_list = [bday]\n<span class=\"hljs-number\">11</span>  print(my_list)\n<span class=\"hljs-number\">12</span>  my_tuple = (bday,)\n<span class=\"hljs-number\">13</span>  print(my_tuple)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [{<span class=\"hljs-string\">'Hemingway'</span>: <span class=\"hljs-string\">'7.21.1899'</span>, <span class=\"hljs-string\">'Fitzgerald'</span>: <span class=\"hljs-string\">'9.24.1896'</span>}]\n<span class=\"hljs-meta\">&gt;&gt;</span> ({<span class=\"hljs-string\">'Hemingway'</span>: <span class=\"hljs-string\">'7.21.1899'</span>, <span class=\"hljs-string\">'Fitzgerald'</span>: <span class=\"hljs-string\">'9.24.1896'</span>},)\n</code></pre>\n<p>列表、字典或元组都可以成为字典中的值：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/zqupwx4</span></span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  ny = {<span class=\"hljs-string\">\"locations\"</span>:\n<span class=\"hljs-number\">05</span>        (<span class=\"hljs-number\">40.7128</span>,\n<span class=\"hljs-number\">06</span>         <span class=\"hljs-number\">74.0059</span>),\n<span class=\"hljs-number\">07</span>\n<span class=\"hljs-number\">08</span>\n<span class=\"hljs-number\">09</span>        <span class=\"hljs-string\">\"celebs\"</span>:\n<span class=\"hljs-number\">10</span>        [<span class=\"hljs-string\">\"W. Allen\"</span>,\n<span class=\"hljs-number\">11</span>         <span class=\"hljs-string\">\"Jay Z\"</span>,\n<span class=\"hljs-number\">12</span>         <span class=\"hljs-string\">\"K. Bacon\"</span>],\n<span class=\"hljs-number\">13</span>\n<span class=\"hljs-number\">14</span>         <span class=\"hljs-string\">\"facts\"</span>:\n<span class=\"hljs-number\">15</span>         {<span class=\"hljs-string\">\"state\"</span>:\n<span class=\"hljs-number\">16</span>          <span class=\"hljs-string\">\"NY\"</span>,\n<span class=\"hljs-number\">17</span>          <span class=\"hljs-string\">\"country\"</span>:\n<span class=\"hljs-number\">18</span>          <span class=\"hljs-string\">\"America\"</span>}\n<span class=\"hljs-number\">19</span>  }\n</code></pre>\n<p>本例中，字典 <code>ny</code> 有 3 个键：<code>\"locations\"</code>、<code>\"celebs\"</code> 和 <code>\"facts\"</code>。第一个键的值是一个元组，因为地理坐标永远不会变。第二个键的值是生活在纽约的名人列表，因为可能会变化所以使用列表。第三个键的值是一个字典，因为键值对是表示纽约有关联事实的最好方式。</p>\n<h3 id=\"56\">5.6　术语表</h3>\n<p><strong>方法</strong>：与指定数据类型紧密相关的函数。</p>\n<p><strong>列表</strong>：存储有序对象的一种容器。</p>\n<p><strong>可迭代的</strong>：如果可使用循环访问对象中的每一个元素，则该对象是可迭代的。</p>\n<p><strong>可迭代对象</strong>：可迭代的对象，如字符串、列表和元素。</p>\n<p><strong>索引</strong>：代表元素在可迭代对象中位置的数字。</p>\n<p><strong>可变的</strong>：容器中的内容可以发生变化。</p>\n<p><strong>不可变的</strong>：容器中的内容不能改变。</p>\n<p><strong>字典</strong>：存储对象的一种内置容器，将一个称为键的对象，映射至一个称为值的对象。</p>\n<p><strong>键</strong>：用来查找字典中对应的值。</p>\n<p><strong>值</strong>：字典中映射至键的值。</p>\n<p><strong>映射</strong>：将一个对象链接至另一个对象。</p>\n<p><strong>键值对</strong>：字典中键映射至值。</p>\n<h3 id=\"57\">5.7　挑战练习</h3>\n<p>1．创建一个你最喜欢歌手的列表。</p>\n<p>2．创建一个由元组构成的列表，每个元组包含居住过或旅游过的城市的经纬度。</p>\n<p>3．创建一个包含你的不同属性的字典：身高、最喜欢的颜色和最喜欢的作者等。</p>\n<p>4．编写一个程序，让用户询问你的身高、最喜欢的颜色或最喜欢的作者，并返回上一个挑战中创建的字典。</p>\n<p>5．创建一个字典，将最喜欢的歌手映射至你最喜欢的歌曲。</p>\n<p>6．列表、元组和容器只是 Python 中内置容器的一部分。自行研究 Python 中的集合（也是一种容器）在什么情况下可以使用集合？</p>\n<p>答案可从异步社区（www.epubit.com）本书详情页的配套资源中下载。</p></div></article>\n</body>\n</html>","slug":"Python无师自通/5_container","published":1,"date":"2019-06-03T03:53:04.178Z","updated":"2019-06-03T03:53:04.178Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwfu9rtq0000ezh7sgzyis9t","content":"\n<!DOCTYPE html>\n<html lang=\"en\">\n<head><meta name=\"generator\" content=\"Hexo 3.8.0\">\n    <meta charset=\"UTF-8\">\n    <title>容器</title>\n</head>\n<body>\n<article id=\"articleDiv\"><div class=\"mazi-article-content dont-break-out\"><p></p><div class=\"toc\">\n<ul>\n<li><ul>\n<li><ul>\n<li><a href=\"#51\">5.1　方法</a></li>\n<li><a href=\"#52\">5.2　列表</a></li>\n<li><a href=\"#53\">5.3　元组</a></li>\n<li><a href=\"#54\">5.4　字典</a></li>\n<li><a href=\"#55\">5.5　容器嵌套容器</a></li>\n<li><a href=\"#56\">5.6　术语表</a></li>\n<li><a href=\"#57\">5.7　挑战练习</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>\n<p></p>\n<blockquote>\n  <p><span style=\"font-family: Times New Roman,楷体_GB2312\">“愚者困惑，智者提问。”</span></p>\n  <p><span style=\"font-family: Times New Roman,楷体_GB2312\">——本杰明 · 迪斯雷利（Benjamin Disraeli）</span></p>\n</blockquote>\n<p>在第 3 章中，我们学习了如何用变量保存对象。本章将讨论如何用容器保存对象。容器就像是文件柜，可有效整理数据。这里将学习 3 个常用的容器：列表、元组和字典。</p>\n<h3 id=\"51\">5.1　方法</h3>\n<p>第 4 章介绍了函数。Python 中有一个类似的概念，叫<strong>方法</strong>（method）。方法是与指定数据类型紧密相关的函数。方法与函数一样，可执行代码并返回结果。不同的是，只有在对象上才能调用方法。同样也可以传递参数给方法。调用字符串的 <code>upper</code> 和 <code>replace</code> 方法的示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zdllght</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"Hello\"</span>.upper()\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'HELLO'</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hfgpst5</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"Hello\"</span>.replace(<span class=\"hljs-string\">\"o\"</span>, <span class=\"hljs-string\">\"@\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'Hell@'</span>\n</code></pre>\n<p>本书第二部分将详细介绍方法。</p>\n<h3 id=\"52\">5.2　列表</h3>\n<p><strong>列表</strong>（list）是以固定顺序保存对象的容器（如图 5-1 所示）。</p>\n<p><img src=\"https://images.gitbook.cn/aab3b280-6fc3-11e9-9e1b-5b6158413fa5\" alt=\"enter image description here\"></p>\n<p>图 5-1　列表</p>\n<p>列表用方括号表示。我们可使用两种语法创建列表，一种是使用 <code>list</code> 函数创建空列表，示例如下：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/h4go6kg</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  fruit = <span class=\"hljs-built_in\">list</span>()\n<span class=\"hljs-number\">5</span>  fruit\n\n&gt;&gt; []\n</code></pre>\n<p>或者直接使用方括号：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jft8p7x</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  fruit = []\n<span class=\"hljs-number\">5</span>  fruit\n\n<span class=\"hljs-meta\">&gt;&gt;</span> []\n</code></pre>\n<p>使用第二种语法，并将你希望放在列表中的所有对象填入方括号中，用逗号分隔，即可创建一个包含所有对象的列表。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h2y8nos</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  fruit = [<span class=\"hljs-string\">\"Apple\"</span>, <span class=\"hljs-string\">\"Orange\"</span>, <span class=\"hljs-string\">\"Pear\"</span>]\n<span class=\"hljs-number\">5</span>  fruit\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'Apple'</span>, <span class=\"hljs-string\">'Orange'</span>, <span class=\"hljs-string\">'Pear'</span>]\n</code></pre>\n<p>上述示例中的列表有 3 个元素：<code>\"Apple\"</code>、<code>\"Orange\"</code> 和 <code>\"Pear\"</code>。列表中的元素是有序的。除非你重新调整列表中元素的顺序，否则 <code>\"Apple\"</code> 永远是第一个元素，<code>\"Orange\"</code> 是第二个元素，<code>\"Pear\"</code> 则是第三个元素。<code>\"Apple\"</code> 位于列表的开头，末尾则是 <code>\"Pear\"</code>。这里可使用 <code>append</code> 方法向列表中添加一个新元素。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h9w3z2m</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  fruit = [<span class=\"hljs-string\">\"Apple\"</span>, <span class=\"hljs-string\">\"Orange\"</span>, <span class=\"hljs-string\">\"Pear\"</span>]\n<span class=\"hljs-number\">5</span>  fruit.append(<span class=\"hljs-string\">\"Banana\"</span>)\n<span class=\"hljs-number\">6</span>  fruit.append(<span class=\"hljs-string\">\"Peach\"</span>)\n<span class=\"hljs-number\">7</span>  fruit\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'Apple'</span>, <span class=\"hljs-string\">'Orange'</span>, <span class=\"hljs-string\">'Pear'</span>, <span class=\"hljs-string\">'Banana'</span>, <span class=\"hljs-string\">'Peach'</span>]\n</code></pre>\n<p>传递给 <code>append</code> 方法的两个对象现在都加入了列表。但 <code>append</code> 方法永远是将新元素添加至列表的末尾。</p>\n<p>列表不仅可以保存字符串，它还可以保存任意数据类型。示例如下：</p>\n<pre><code class=\"hljs php\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zhpntsr</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  random = []\n<span class=\"hljs-number\">5</span>  random.append(<span class=\"hljs-keyword\">True</span>)\n<span class=\"hljs-number\">6</span>  random.append(<span class=\"hljs-number\">100</span>)\n<span class=\"hljs-number\">7</span>  random.append(<span class=\"hljs-number\">1.1</span>)\n<span class=\"hljs-number\">8</span>  random.append(<span class=\"hljs-string\">\"Hello\"</span>)\n<span class=\"hljs-number\">9</span>  random\n\n&gt;&gt; [<span class=\"hljs-keyword\">True</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">1.1</span>, <span class=\"hljs-string\">'Hello'</span>]\n</code></pre>\n<p>字符串、列表和元组都是<strong>可迭代的</strong>（iterable）。如果可以使用循环访问对象中的每一个元素，那么该对象是可迭代的，被称为<strong>可迭代对象</strong>。可迭代对象中的每一个元素都有一个<strong>索引</strong>（index），即表示元素在可迭代对象中位置的数字。列表中第一个元素的索引是 0，而不是 1。</p>\n<p>在如下示例中，<code>\"Apple\"</code> 的索引是 0，<code>\"Orange\"</code> 的索引是 1，<code>\"Pear\"</code> 的索引是 2：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/z8zzk8d</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  fruit = [<span class=\"hljs-string\">\"Apple\"</span>, <span class=\"hljs-string\">\"Orange\"</span>, <span class=\"hljs-string\">\"Pear\"</span>]\n</code></pre>\n<p>你可以使用语法[列表名][[索引]]获取一个元素：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jqtlwpf</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  fruit = [<span class=\"hljs-string\">\"Apple\"</span>, <span class=\"hljs-string\">\"Orange\"</span>, <span class=\"hljs-string\">\"Pear\"</span>]\n<span class=\"hljs-number\">5</span>  fruit[<span class=\"hljs-number\">0</span>]\n<span class=\"hljs-number\">6</span>  fruit[<span class=\"hljs-number\">1</span>]\n<span class=\"hljs-number\">7</span>  fruit[<span class=\"hljs-number\">2</span>]\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'Apple'</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'Orange'</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'Pear'</span>\n</code></pre>\n<p>如果获取的是不存在的索引，Python 会报告异常：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/za3rv95</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  colors = [<span class=\"hljs-string\">\"blue\"</span>, <span class=\"hljs-string\">\"green\"</span>, <span class=\"hljs-string\">\"yellow\"</span>]\n<span class=\"hljs-number\">5</span>  colors[<span class=\"hljs-number\">4</span>]\n\n&gt;&gt; IndexError: <span class=\"hljs-built_in\">list</span> index out of range\n</code></pre>\n<p>列表是<strong>可变的</strong>（mutable）。如果一个容器是可变的，则可以向该容器中增删对象。将列表中某个元素的索引赋给一个新的对象，即可改变该元素：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h4ahvf9</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  colors = [<span class=\"hljs-string\">\"blue\"</span>, <span class=\"hljs-string\">\"green\"</span>, <span class=\"hljs-string\">\"yellow\"</span>]\n<span class=\"hljs-number\">5</span>  colors\n<span class=\"hljs-number\">6</span>  colors[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-string\">\"red\"</span>\n<span class=\"hljs-number\">7</span>  colors\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'blue'</span>, <span class=\"hljs-string\">'green'</span>, <span class=\"hljs-string\">'yellow'</span>]\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'blue'</span>, <span class=\"hljs-string\">'green'</span>, <span class=\"hljs-string\">'red'</span>]\n</code></pre>\n<p>也可使用 <code>pop</code> 方法移除列表中的最后一个元素：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/j52uvmq</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  colors = [<span class=\"hljs-string\">\"blue\"</span>, <span class=\"hljs-string\">\"green\"</span>, <span class=\"hljs-string\">\"yellow\"</span>]\n<span class=\"hljs-number\">5</span>  colors\n<span class=\"hljs-number\">6</span>  item = colors.pop()\n<span class=\"hljs-number\">7</span>  item\n<span class=\"hljs-number\">8</span>  colors\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'blue'</span>, <span class=\"hljs-string\">'green'</span>, <span class=\"hljs-string\">'yellow'</span>]\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'yellow'</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'blue'</span>, <span class=\"hljs-string\">'green'</span>]\n</code></pre>\n<p>不能对空列表使用 <code>pop</code> 方法。否则，Python 则会报告异常。</p>\n<p>你可以使用加法操作符来合并两个列表：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jjxnk4z</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  colors1 = [<span class=\"hljs-string\">\"blue\"</span>, <span class=\"hljs-string\">\"green\"</span>, <span class=\"hljs-string\">\"yellow\"</span>]\n<span class=\"hljs-number\">5</span>  colors2 = [<span class=\"hljs-string\">\"orange\"</span>, <span class=\"hljs-string\">\"pink\"</span>, <span class=\"hljs-string\">\"black\"</span>]\n<span class=\"hljs-number\">6</span>  colors1 + colors2\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'blue'</span>, <span class=\"hljs-string\">'green'</span>, <span class=\"hljs-string\">'yellow'</span>, <span class=\"hljs-string\">'orange'</span>, <span class=\"hljs-string\">'pink'</span>, <span class=\"hljs-string\">'black'</span>]\n</code></pre>\n<p>也可以使用关键字 <code>in</code> 检查某个元素是否在列表中：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z4fnv39</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  colors = [<span class=\"hljs-string\">\"blue\"</span>, <span class=\"hljs-string\">\"green\"</span>, <span class=\"hljs-string\">\"yellow\"</span>]\n<span class=\"hljs-number\">5</span>  <span class=\"hljs-string\">\"green\"</span> <strong><span class=\"hljs-keyword\">in</span></strong> colors\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<p>使用关键字 <code>not</code> 检查某个元素是否不在列表中：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jqzk8pj</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  colors = [<span class=\"hljs-string\">\"blue\"</span>, <span class=\"hljs-string\">\"green\"</span>, <span class=\"hljs-string\">\"yellow\"</span>]\n<span class=\"hljs-number\">5</span>  <span class=\"hljs-string\">\"black\"</span> <strong><span class=\"hljs-keyword\">not</span></strong> <strong><span class=\"hljs-keyword\">in</span></strong> colors\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<p>使用函数 <code>len</code> 可获得列表的大小（包含元素的个数）：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hhx6rx4</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  len(colors)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">3</span>\n</code></pre>\n<p>下面是一个在实践中使用列表的例子：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">01  <span class=\"hljs-comment\"># http://tinyurl.com/gq7yjr7</span>\n02\n03\n04  colors = [<span class=\"hljs-string\">\"purple\"</span>,\n05            <span class=\"hljs-string\">\"orange\"</span>,\n06            <span class=\"hljs-string\">\"green\"</span>]\n07\n08\n09  guess = input(<span class=\"hljs-string\">\"Guess a color:\"</span>)\n10\n11\n12<strong><span class=\"hljs-keyword\">if</span></strong> guess <strong><span class=\"hljs-keyword\">in</span></strong> colors:\n13      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"You guessed correctly!\"</span>)\n14<strong><span class=\"hljs-keyword\">else</span></strong>:\n15      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Wrong! Try again.\"</span>)\n\n&gt;&gt; Guess a color:</code></pre>\n<p>列表 <code>colors</code> 包含了代表颜色的不同字符串。程序使用内置函数 <code>input</code> 来让用户猜测是什么颜色，并将用户的答案保存至变量。如果答案在 <code>colors</code> 列表中，则告知用户猜测正确。反之，让用户再次尝试。</p>\n<h3 id=\"53\">5.3　元组</h3>\n<p><strong>元组</strong>（tuple）是存储有序对象的一种容器。与列表不同，元组是<strong>不可变的</strong>（immutable），这意味着其内容不会变化。创建元组后，无法修改其中任何元组的值，也无法添加或修改元素。用圆括号表示元组，且必须用逗号分隔元组中的元素。有两种语法可以创建元组，第一种如下所示：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zo88eal</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  my_tuple = tuple()\n<span class=\"hljs-number\">5</span>  my_tuple\n\n<span class=\"hljs-meta\">&gt;&gt;</span> ()\n</code></pre>\n<p>以及第二种语法：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zm3y26j</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  my_tuple = ()\n<span class=\"hljs-number\">5</span>  my_tuple\n\n<span class=\"hljs-meta\">&gt;&gt;</span> ()\n</code></pre>\n<p>如果要向元组中新增对象，可用第二种语法创建一个新的元组，并在其中加入你希望增加的每个元素，用逗号分隔：</p>\n<pre><code class=\"hljs php\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zlwwfe3</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  rndm = (<span class=\"hljs-string\">\"M. Jackson\"</span>, <span class=\"hljs-number\">1958</span>, <span class=\"hljs-keyword\">True</span>)\n<span class=\"hljs-number\">5</span>  rndm\n\n&gt;&gt; (<span class=\"hljs-string\">'M. Jackson'</span>, <span class=\"hljs-number\">1958</span>, <span class=\"hljs-keyword\">True</span>)\n</code></pre>\n<p>即使元组中只有一个元素，也需要在该元素的后面加上逗号。只有这样，Python 才能将其与其他为了表示运算顺序而放在圆括号中的数字标记进行区分。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/j8mca8o</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-comment\"># 这是元组</span>\n<span class=\"hljs-number\">5</span>  (<span class=\"hljs-string\">\"self_taught\"</span>, )\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  <span class=\"hljs-comment\"># 这不是元组</span>\n<span class=\"hljs-number\">9</span>  (<span class=\"hljs-number\">9</span>) + <span class=\"hljs-number\">1</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> (<span class=\"hljs-string\">'self_taught'</span>, )\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">10</span>\n</code></pre>\n<p>创建元组之后，不能再新增元素或修改已有元素。如果在创建元组后这样做，Python 会报告异常：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z3x34nk</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  dys = (<span class=\"hljs-string\">\"1984\"</span>,\n<span class=\"hljs-number\">5</span>         <span class=\"hljs-string\">\"Brave New World\"</span>,\n<span class=\"hljs-number\">6</span>         <span class=\"hljs-string\">\"Fahrenheit 451\"</span>)\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>\n<span class=\"hljs-number\">9</span>  dys[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-string\">\"Handmaid's Tale\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-symbol\">TypeError:</span> <span class=\"hljs-string\">'tuple'</span> object does not support item assignment\n</code></pre>\n<p>可使用与列表一样的方法来获取元组的元素，即引用其索引：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z9dc6lo</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  dys = (<span class=\"hljs-string\">\"1984\"</span>,\n<span class=\"hljs-number\">5</span>         <span class=\"hljs-string\">\"Brave New World\"</span>,\n<span class=\"hljs-number\">6</span>         <span class=\"hljs-string\">\"Fahrenheit 451\"</span>)\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>\n<span class=\"hljs-number\">9</span>  dys[<span class=\"hljs-number\">2</span>]\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'Fahrenheit 451'</span>\n</code></pre>\n<p>可使用关键字 <code>in</code> 来检查某个元素是否在元组中：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/j3bsel7</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  dys = (<span class=\"hljs-string\">\"1984\"</span>,\n<span class=\"hljs-number\">5</span>         <span class=\"hljs-string\">\"Brave New World\"</span>,\n<span class=\"hljs-number\">6</span>         <span class=\"hljs-string\">\"Fahrenheit 451\"</span>)\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>\n<span class=\"hljs-number\">9</span>  <span class=\"hljs-string\">\"1984\"</span> <strong><span class=\"hljs-keyword\">in</span></strong> dys\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<p>在 <code>in</code> 前加上关键字 <code>not</code> 即可检查元素是否不在元组中：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jpdjjv9</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  dys = (<span class=\"hljs-string\">\"1984\"</span>,\n<span class=\"hljs-number\">5</span>         <span class=\"hljs-string\">\"Brave New World\"</span>,\n<span class=\"hljs-number\">6</span>         <span class=\"hljs-string\">\"Fahrenheit 451\"</span>)\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>\n<span class=\"hljs-number\">9</span>  <span class=\"hljs-string\">\"Handmaid's Tale\"</span> <strong><span class=\"hljs-keyword\">not</span></strong> <strong><span class=\"hljs-keyword\">in</span></strong> dys\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<p>你可能会疑惑为什么要使用一个看上去没有列表灵活的数据结构。因为在处理明确永远不会改变的，并且也不希望其他程序对其进行修改的值时，元组是非常有用的。地理坐标就是适合使用元组存储的一种数据。城市的经纬度应保存在元组中，因为这些值永远不会改变，保存为元组意味着程序不会意外对其进行修改。元组不像列表那样可以用作字典的键，这个知识点会在下一节介绍。</p>\n<h3 id=\"54\">5.4　字典</h3>\n<p><strong>字典</strong>（dictionary）是另一种用于存储对象的内置容器。它们被用来链接<strong>键</strong>（key）和<strong>值</strong>（value）这两个对象（如图 5-2 所示）。将一个对象链接至另一个对象，也被称为<strong>映射</strong>（mapping），结果为产生一个<strong>键值对</strong>（key-value pair）。可将键值对添加到字典，然后使用键在字典中查询，可获得其对应的值。但是无法使用值来查询键。</p>\n<p><img src=\"https://images.gitbook.cn/38d2e810-6fc4-11e9-9e1b-5b6158413fa5\" alt=\"enter image description here\"></p>\n<p>图 5-2　字典</p>\n<p>字典是可变的，因此可以向字典中新增键值对。与列表和元组不同，字典中存储的对象是无序的。字典的价值在于键与值之间的关联。需要成对存储数据的场景很多。例如，可以将关于某个人的信息存储在字典中，将名为 height 的键，映射至代表这个人身高的值；将名为 eyecolor 的键映射至代表这个人眼睛颜色的值；将名为 nationality 的键映射至代表这个人国籍的值。</p>\n<p>字典用花括号表示。有两种创建字典的语法，其一如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zfn6jmw</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  my_dict = dict()\n<span class=\"hljs-number\">5</span>  my_dict\n\n<span class=\"hljs-meta\">&gt;&gt;</span> {}\n</code></pre>\n<p>另一种方法如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jfgemf2</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  my_dict = {}\n<span class=\"hljs-number\">5</span>  my_dict\n\n<span class=\"hljs-meta\">&gt;&gt;</span> {}\n</code></pre>\n<p>可以在创建字典时直接添加键值对。上述两种语法都要求用冒号分隔键与值，每个键值对之间用逗号分隔。与元组不同的是，如果只有一个键值对，不需要在其后添加逗号。如下示例介绍了创建字典时如何添加键值对：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hplqc4u</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  fruits = {<span class=\"hljs-string\">\"Apple\"</span>:\n<span class=\"hljs-number\">5</span>            <span class=\"hljs-string\">\"Red\"</span>,\n<span class=\"hljs-number\">6</span>            <span class=\"hljs-string\">\"Banana\"</span>:\n<span class=\"hljs-number\">7</span>            <span class=\"hljs-string\">\"Yellow\"</span>}\n<span class=\"hljs-number\">8</span>  fruits\n\n<span class=\"hljs-meta\">&gt;&gt;</span> {<span class=\"hljs-string\">'Apple'</span>: <span class=\"hljs-string\">'Red'</span>, <span class=\"hljs-string\">'Banana'</span>: <span class=\"hljs-string\">'Yellow'</span>}\n</code></pre>\n<p>读者在 shell 中看到的字典元素顺序可能与上例中有所不同，因为字典的键是无序的，Python 会随机打印其元素（本节中所有示例均适用该情况）。</p>\n<p>字典是可变的。创建字典后，可通过语法“<code>[字典名][[键]] = [值]</code>”添加新的键值对，并通过语法“<code>[字典名][[键]]</code>”查找值。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/grc28lh</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  facts = dict()\n<span class=\"hljs-number\">05</span>\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>  <span class=\"hljs-comment\"># 添加键-值对</span>\n08  facts[<span class=\"hljs-string\">\"code\"</span>] = <span class=\"hljs-string\">\"fun\"</span>\n09  <span class=\"hljs-comment\"># 查找键对应的值</span>\n<span class=\"hljs-number\">10</span>  facts[<span class=\"hljs-string\">\"code\"</span>]\n<span class=\"hljs-number\">11</span>\n<span class=\"hljs-number\">12</span>\n<span class=\"hljs-number\">13</span>  <span class=\"hljs-comment\"># 添加键-值对</span>\n<span class=\"hljs-number\">14</span>  facts[<span class=\"hljs-string\">\"Bill\"</span>] = <span class=\"hljs-string\">\"Gates\"</span>\n<span class=\"hljs-number\">15</span>  <span class=\"hljs-comment\"># 查找键对应的值</span>\n<span class=\"hljs-number\">16</span>  facts[<span class=\"hljs-string\">\"Bill\"</span>]\n<span class=\"hljs-number\">17</span>\n<span class=\"hljs-number\">18</span>\n<span class=\"hljs-number\">19</span>  <span class=\"hljs-comment\"># 添加键-值对</span>\n<span class=\"hljs-number\">20</span>  facts[<span class=\"hljs-string\">\"founded\"</span>] = <span class=\"hljs-number\">1776</span>\n<span class=\"hljs-number\">21</span>  <span class=\"hljs-comment\"># 查找键对应的值</span>\n<span class=\"hljs-number\">22</span>  facts[<span class=\"hljs-string\">\"founded\"</span>]\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'fun'</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> Gates\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">1776</span>\n</code></pre>\n<p>字典的值可以是任意对象。在上例中，前两个值是字符串，最后一个值 1776 是整数。但是字典的键必须是不可变的。字符串或元组可以用作字典的键，但是列表或字典不可以。</p>\n<p>可以使用关键字 <code>in</code> 检查某个键是否在字典中，但不能用其检查某个值是否在字典中。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hgf9vmp</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  bill = dict({<span class=\"hljs-string\">\"Bill Gates\"</span>:\n<span class=\"hljs-number\">5</span>               <span class=\"hljs-string\">\"charitable\"</span>})\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  <span class=\"hljs-string\">\"Bill Gates\"</span> <strong><span class=\"hljs-keyword\">in</span></strong> bill\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<p>如果访问一个不在字典中的键，Python 将报告异常。</p>\n<p>在关键字 <code>in</code> 之前加上关键字 <code>not</code>，可检查键是否不在字典中。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/he3g993</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  bill = dict({<span class=\"hljs-string\">\"Bill Gates\"</span>:\n<span class=\"hljs-number\">5</span>                   <span class=\"hljs-string\">\"charitable\"</span>})\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  <span class=\"hljs-string\">\"Bill Doors\"</span> <strong><span class=\"hljs-keyword\">not</span></strong> <strong><span class=\"hljs-keyword\">in</span></strong> bill\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<p>可使用关键字 <code>del</code> 删除字典中的键值对。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/htrd9lj</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  books = {<span class=\"hljs-string\">\"Dracula\"</span>: <span class=\"hljs-string\">\"Stoker\"</span>,\n<span class=\"hljs-number\">5</span>           <span class=\"hljs-string\">\"1984\"</span>: <span class=\"hljs-string\">\"Orwell\"</span>,\n<span class=\"hljs-number\">6</span>           <span class=\"hljs-string\">\"The Trial\"</span>: <span class=\"hljs-string\">\"Kafka\"</span>}\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>\n<span class=\"hljs-number\">9</span> <strong>del</strong> books[<span class=\"hljs-string\">\"The Trial\"</span>]\n<span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">11</span>  books\n\n<span class=\"hljs-meta\">&gt;&gt;</span> {<span class=\"hljs-string\">'Dracula'</span>: <span class=\"hljs-string\">'Stoker'</span>, <span class=\"hljs-string\">'1984'</span>: <span class=\"hljs-string\">'Orwell'</span>}</code></pre>\n<p>一个使用字典的程序示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">01  <span class=\"hljs-comment\"># http://tinyurl.com/gnjvep7</span>\n02\n03\n04  rhymes = {<span class=\"hljs-string\">\"1\"</span>: <span class=\"hljs-string\">\"fun\"</span>,\n05            <span class=\"hljs-string\">\"2\"</span>: <span class=\"hljs-string\">\"blue\"</span>\n06            <span class=\"hljs-string\">\"3\"</span>: <span class=\"hljs-string\">\"me\"</span>,\n07            <span class=\"hljs-string\">\"4\"</span>: <span class=\"hljs-string\">\"floor\"</span>,\n08            <span class=\"hljs-string\">\"5\"</span>: <span class=\"hljs-string\">\"live\"</span>\n09            }\n10\n11\n12  n = input(<span class=\"hljs-string\">\"Type a number:\"</span>)\n13 <strong><span class=\"hljs-keyword\">if</span></strong> n <strong><span class=\"hljs-keyword\">in</span></strong> rhymes:\n14      rhyme = rhymes[n]\n15      <span class=\"hljs-built_in\">print</span>(rhyme)\n16 <strong><span class=\"hljs-keyword\">else</span></strong>:\n17      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"Not found.\"</span>)\n\nType a number:</code></pre>\n<p>字典 <code>rhymes</code> 中有 6 个数字（键），分别映射至 6 个单词（值）。程序让用户输入数字，并保存在变量中。在从字典中查找单词之前，记得先用 <code>in</code> 关键字检查字典中是否存在对应的键。如果存在，则查找字典中对应的单词并打印出来。否则会打印消息告诉用户未查找到。</p>\n<h3 id=\"55\">5.5　容器嵌套容器</h3>\n<p>可以在容器中存储容器。例如，你可以在列表中保存列表：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gops9fz</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  lists = []\n<span class=\"hljs-number\">05</span>  rap = [<span class=\"hljs-string\">\"Kanye West\"</span>,\n<span class=\"hljs-number\">06</span>         <span class=\"hljs-string\">\"Jay Z\"</span>,\n<span class=\"hljs-number\">07</span>         <span class=\"hljs-string\">\"Eminem\"</span>,\n08         <span class=\"hljs-string\">\"Nas\"</span>]\n09\n<span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">11</span>  rock = [<span class=\"hljs-string\">\"Bob Dylan\"</span>,\n<span class=\"hljs-number\">12</span>          <span class=\"hljs-string\">\"The Beatles\"</span>,\n<span class=\"hljs-number\">13</span>          <span class=\"hljs-string\">\"Led Zeppelin\"</span>]\n<span class=\"hljs-number\">14</span>\n<span class=\"hljs-number\">15</span>\n<span class=\"hljs-number\">16</span>  djs = [<span class=\"hljs-string\">\"Zeds Dead\"</span>,\n<span class=\"hljs-number\">17</span>         <span class=\"hljs-string\">\"Tiesto\"</span>]\n<span class=\"hljs-number\">18</span>\n<span class=\"hljs-number\">19</span>\n<span class=\"hljs-number\">20</span>  lists.append(rap)\n<span class=\"hljs-number\">21</span>  lists.append(rock)\n<span class=\"hljs-number\">22</span>  lists.append(djs)\n<span class=\"hljs-number\">23</span>\n<span class=\"hljs-number\">24</span>\n<span class=\"hljs-number\">25</span>  print(lists)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [[<span class=\"hljs-string\">'Kanye West'</span>, <span class=\"hljs-string\">'Jay Z'</span>, <span class=\"hljs-string\">'Eminem'</span>, <span class=\"hljs-string\">'Nas'</span>], [<span class=\"hljs-string\">'Bob Dylan'</span>, <span class=\"hljs-string\">'The Beatles'</span>, <span class=\"hljs-string\">'Led Zeppelin'</span>], [<span class=\"hljs-string\">'Zeds Dead'</span>, <span class=\"hljs-string\">'Tiesto'</span>]]\n</code></pre>\n<p>在上述例中，<code>lists</code> 有 3 个元素。每个元素都是一个列表：第一个元素是嘻哈歌手列表，第二个元素是摇滚歌手列表，第三个元素是 DJ 列表。可通过元素对应的索引访问这些列表：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gu4mudk</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-comment\"># 接上例</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>  rap = lists[<span class=\"hljs-number\">0</span>]\n<span class=\"hljs-number\">8</span>  print(rap)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'Kanye West'</span>, <span class=\"hljs-string\">'Jay Z'</span>, <span class=\"hljs-string\">'Eminem'</span>, <span class=\"hljs-string\">'Nas'</span>]\n</code></pre>\n<p>如果向列表 <code>rap</code> 中添加一个新元素，该修改也会体现在 <code>lists</code> 列表中：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hdtosm2</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-comment\"># 接上例</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n08  rap = lists[<span class=\"hljs-number\">0</span>]\n09  rap.append(<span class=\"hljs-string\">\"Kendrick Lamar\"</span>)\n<span class=\"hljs-number\">10</span>  print(rap)\n<span class=\"hljs-number\">11</span>  print(lists)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'Kanye West'</span>, <span class=\"hljs-string\">'Jay Z'</span>, <span class=\"hljs-string\">'Eminem'</span>, <span class=\"hljs-string\">'Nas'</span>, <span class=\"hljs-string\">'Kendrick Lamar'</span>]\n<span class=\"hljs-meta\">&gt;&gt;</span> [[<span class=\"hljs-string\">'Kanye West'</span>, <span class=\"hljs-string\">'Jay Z'</span>, <span class=\"hljs-string\">'Eminem'</span>, <span class=\"hljs-string\">'Nas'</span>, <span class=\"hljs-string\">'Kendrick Lamar'</span>],\n[<span class=\"hljs-string\">'Bob Dylan'</span>, <span class=\"hljs-string\">'The Beatles'</span>, <span class=\"hljs-string\">'Led Zeppelin'</span>], [<span class=\"hljs-string\">'Zeds Dead'</span>, <span class=\"hljs-string\">'Tiesto'</span>]]\n</code></pre>\n<p>也可以在列表中存储元素，在元组中存储列表，还可以在列表或元组中存储字典：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z9dhema</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  locations = []\n<span class=\"hljs-number\">05</span>\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>  la = (<span class=\"hljs-number\">34.0522</span>, <span class=\"hljs-number\">188.2437</span>)\n08  chicago = (<span class=\"hljs-number\">41.8781</span>, <span class=\"hljs-number\">87.6298</span>)\n09\n<span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">11</span>  locations.append(la)\n<span class=\"hljs-number\">12</span>  locations.append(chicago)\n<span class=\"hljs-number\">13</span>\n<span class=\"hljs-number\">14</span>\n<span class=\"hljs-number\">15</span>  print(locations)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [(<span class=\"hljs-number\">34.0522</span>, <span class=\"hljs-number\">188.2437</span>), (<span class=\"hljs-number\">41.8781</span>, <span class=\"hljs-number\">87.6298</span>)]\n\n<span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/ht7gpsd</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  eights = [<span class=\"hljs-string\">\"Edgar Allan Poe\"</span>,\n<span class=\"hljs-number\">05</span>            <span class=\"hljs-string\">\"Charles Dickens\"</span>]\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>\n08  nines = [<span class=\"hljs-string\">\"Hemingway\"</span>,\n09           <span class=\"hljs-string\">\"Fitzgerald\"</span>,\n<span class=\"hljs-number\">10</span>          <span class=\"hljs-string\">\"Orwell\"</span>]\n<span class=\"hljs-number\">11</span>\n<span class=\"hljs-number\">12</span>\n<span class=\"hljs-number\">13</span>  authors = (eights, nines)\n<span class=\"hljs-number\">14</span>  print(authors)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> ([<span class=\"hljs-string\">'Edgar Allan Poe'</span>, <span class=\"hljs-string\">'Charles Dickens'</span>], [<span class=\"hljs-string\">'Hemingway'</span>, <span class=\"hljs-string\">'Fitzgerald'</span>, <span class=\"hljs-string\">'Orwell'</span>])\n\n<span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h8ck5er</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  bday = {<span class=\"hljs-string\">\"Hemingway\"</span>:\n<span class=\"hljs-number\">05</span>          <span class=\"hljs-string\">\"7.21.1899\"</span>,\n<span class=\"hljs-number\">06</span>          <span class=\"hljs-string\">\"Fitzgerald\"</span>:\n<span class=\"hljs-number\">07</span>          <span class=\"hljs-string\">\"9.24.1896\"</span>}\n08\n09\n<span class=\"hljs-number\">10</span>  my_list = [bday]\n<span class=\"hljs-number\">11</span>  print(my_list)\n<span class=\"hljs-number\">12</span>  my_tuple = (bday,)\n<span class=\"hljs-number\">13</span>  print(my_tuple)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [{<span class=\"hljs-string\">'Hemingway'</span>: <span class=\"hljs-string\">'7.21.1899'</span>, <span class=\"hljs-string\">'Fitzgerald'</span>: <span class=\"hljs-string\">'9.24.1896'</span>}]\n<span class=\"hljs-meta\">&gt;&gt;</span> ({<span class=\"hljs-string\">'Hemingway'</span>: <span class=\"hljs-string\">'7.21.1899'</span>, <span class=\"hljs-string\">'Fitzgerald'</span>: <span class=\"hljs-string\">'9.24.1896'</span>},)\n</code></pre>\n<p>列表、字典或元组都可以成为字典中的值：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/zqupwx4</span></span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  ny = {<span class=\"hljs-string\">\"locations\"</span>:\n<span class=\"hljs-number\">05</span>        (<span class=\"hljs-number\">40.7128</span>,\n<span class=\"hljs-number\">06</span>         <span class=\"hljs-number\">74.0059</span>),\n<span class=\"hljs-number\">07</span>\n<span class=\"hljs-number\">08</span>\n<span class=\"hljs-number\">09</span>        <span class=\"hljs-string\">\"celebs\"</span>:\n<span class=\"hljs-number\">10</span>        [<span class=\"hljs-string\">\"W. Allen\"</span>,\n<span class=\"hljs-number\">11</span>         <span class=\"hljs-string\">\"Jay Z\"</span>,\n<span class=\"hljs-number\">12</span>         <span class=\"hljs-string\">\"K. Bacon\"</span>],\n<span class=\"hljs-number\">13</span>\n<span class=\"hljs-number\">14</span>         <span class=\"hljs-string\">\"facts\"</span>:\n<span class=\"hljs-number\">15</span>         {<span class=\"hljs-string\">\"state\"</span>:\n<span class=\"hljs-number\">16</span>          <span class=\"hljs-string\">\"NY\"</span>,\n<span class=\"hljs-number\">17</span>          <span class=\"hljs-string\">\"country\"</span>:\n<span class=\"hljs-number\">18</span>          <span class=\"hljs-string\">\"America\"</span>}\n<span class=\"hljs-number\">19</span>  }\n</code></pre>\n<p>本例中，字典 <code>ny</code> 有 3 个键：<code>\"locations\"</code>、<code>\"celebs\"</code> 和 <code>\"facts\"</code>。第一个键的值是一个元组，因为地理坐标永远不会变。第二个键的值是生活在纽约的名人列表，因为可能会变化所以使用列表。第三个键的值是一个字典，因为键值对是表示纽约有关联事实的最好方式。</p>\n<h3 id=\"56\">5.6　术语表</h3>\n<p><strong>方法</strong>：与指定数据类型紧密相关的函数。</p>\n<p><strong>列表</strong>：存储有序对象的一种容器。</p>\n<p><strong>可迭代的</strong>：如果可使用循环访问对象中的每一个元素，则该对象是可迭代的。</p>\n<p><strong>可迭代对象</strong>：可迭代的对象，如字符串、列表和元素。</p>\n<p><strong>索引</strong>：代表元素在可迭代对象中位置的数字。</p>\n<p><strong>可变的</strong>：容器中的内容可以发生变化。</p>\n<p><strong>不可变的</strong>：容器中的内容不能改变。</p>\n<p><strong>字典</strong>：存储对象的一种内置容器，将一个称为键的对象，映射至一个称为值的对象。</p>\n<p><strong>键</strong>：用来查找字典中对应的值。</p>\n<p><strong>值</strong>：字典中映射至键的值。</p>\n<p><strong>映射</strong>：将一个对象链接至另一个对象。</p>\n<p><strong>键值对</strong>：字典中键映射至值。</p>\n<h3 id=\"57\">5.7　挑战练习</h3>\n<p>1．创建一个你最喜欢歌手的列表。</p>\n<p>2．创建一个由元组构成的列表，每个元组包含居住过或旅游过的城市的经纬度。</p>\n<p>3．创建一个包含你的不同属性的字典：身高、最喜欢的颜色和最喜欢的作者等。</p>\n<p>4．编写一个程序，让用户询问你的身高、最喜欢的颜色或最喜欢的作者，并返回上一个挑战中创建的字典。</p>\n<p>5．创建一个字典，将最喜欢的歌手映射至你最喜欢的歌曲。</p>\n<p>6．列表、元组和容器只是 Python 中内置容器的一部分。自行研究 Python 中的集合（也是一种容器）在什么情况下可以使用集合？</p>\n<p>答案可从异步社区（www.epubit.com）本书详情页的配套资源中下载。</p></div></article>\n</body>\n</html>","site":{"data":{}},"excerpt":"","more":"\n<!DOCTYPE html>\n<html lang=\"en\">\n<head><meta name=\"generator\" content=\"Hexo 3.8.0\">\n    <meta charset=\"UTF-8\">\n    <title>容器</title>\n</head>\n<body>\n<article id=\"articleDiv\"><div class=\"mazi-article-content dont-break-out\"><p></p><div class=\"toc\">\n<ul>\n<li><ul>\n<li><ul>\n<li><a href=\"#51\">5.1　方法</a></li>\n<li><a href=\"#52\">5.2　列表</a></li>\n<li><a href=\"#53\">5.3　元组</a></li>\n<li><a href=\"#54\">5.4　字典</a></li>\n<li><a href=\"#55\">5.5　容器嵌套容器</a></li>\n<li><a href=\"#56\">5.6　术语表</a></li>\n<li><a href=\"#57\">5.7　挑战练习</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>\n<p></p>\n<blockquote>\n  <p><span style=\"font-family: Times New Roman,楷体_GB2312\">“愚者困惑，智者提问。”</span></p>\n  <p><span style=\"font-family: Times New Roman,楷体_GB2312\">——本杰明 · 迪斯雷利（Benjamin Disraeli）</span></p>\n</blockquote>\n<p>在第 3 章中，我们学习了如何用变量保存对象。本章将讨论如何用容器保存对象。容器就像是文件柜，可有效整理数据。这里将学习 3 个常用的容器：列表、元组和字典。</p>\n<h3 id=\"51\">5.1　方法</h3>\n<p>第 4 章介绍了函数。Python 中有一个类似的概念，叫<strong>方法</strong>（method）。方法是与指定数据类型紧密相关的函数。方法与函数一样，可执行代码并返回结果。不同的是，只有在对象上才能调用方法。同样也可以传递参数给方法。调用字符串的 <code>upper</code> 和 <code>replace</code> 方法的示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zdllght</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"Hello\"</span>.upper()\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'HELLO'</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hfgpst5</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"Hello\"</span>.replace(<span class=\"hljs-string\">\"o\"</span>, <span class=\"hljs-string\">\"@\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'Hell@'</span>\n</code></pre>\n<p>本书第二部分将详细介绍方法。</p>\n<h3 id=\"52\">5.2　列表</h3>\n<p><strong>列表</strong>（list）是以固定顺序保存对象的容器（如图 5-1 所示）。</p>\n<p><img src=\"https://images.gitbook.cn/aab3b280-6fc3-11e9-9e1b-5b6158413fa5\" alt=\"enter image description here\"></p>\n<p>图 5-1　列表</p>\n<p>列表用方括号表示。我们可使用两种语法创建列表，一种是使用 <code>list</code> 函数创建空列表，示例如下：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/h4go6kg</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  fruit = <span class=\"hljs-built_in\">list</span>()\n<span class=\"hljs-number\">5</span>  fruit\n\n&gt;&gt; []\n</code></pre>\n<p>或者直接使用方括号：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jft8p7x</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  fruit = []\n<span class=\"hljs-number\">5</span>  fruit\n\n<span class=\"hljs-meta\">&gt;&gt;</span> []\n</code></pre>\n<p>使用第二种语法，并将你希望放在列表中的所有对象填入方括号中，用逗号分隔，即可创建一个包含所有对象的列表。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h2y8nos</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  fruit = [<span class=\"hljs-string\">\"Apple\"</span>, <span class=\"hljs-string\">\"Orange\"</span>, <span class=\"hljs-string\">\"Pear\"</span>]\n<span class=\"hljs-number\">5</span>  fruit\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'Apple'</span>, <span class=\"hljs-string\">'Orange'</span>, <span class=\"hljs-string\">'Pear'</span>]\n</code></pre>\n<p>上述示例中的列表有 3 个元素：<code>\"Apple\"</code>、<code>\"Orange\"</code> 和 <code>\"Pear\"</code>。列表中的元素是有序的。除非你重新调整列表中元素的顺序，否则 <code>\"Apple\"</code> 永远是第一个元素，<code>\"Orange\"</code> 是第二个元素，<code>\"Pear\"</code> 则是第三个元素。<code>\"Apple\"</code> 位于列表的开头，末尾则是 <code>\"Pear\"</code>。这里可使用 <code>append</code> 方法向列表中添加一个新元素。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h9w3z2m</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  fruit = [<span class=\"hljs-string\">\"Apple\"</span>, <span class=\"hljs-string\">\"Orange\"</span>, <span class=\"hljs-string\">\"Pear\"</span>]\n<span class=\"hljs-number\">5</span>  fruit.append(<span class=\"hljs-string\">\"Banana\"</span>)\n<span class=\"hljs-number\">6</span>  fruit.append(<span class=\"hljs-string\">\"Peach\"</span>)\n<span class=\"hljs-number\">7</span>  fruit\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'Apple'</span>, <span class=\"hljs-string\">'Orange'</span>, <span class=\"hljs-string\">'Pear'</span>, <span class=\"hljs-string\">'Banana'</span>, <span class=\"hljs-string\">'Peach'</span>]\n</code></pre>\n<p>传递给 <code>append</code> 方法的两个对象现在都加入了列表。但 <code>append</code> 方法永远是将新元素添加至列表的末尾。</p>\n<p>列表不仅可以保存字符串，它还可以保存任意数据类型。示例如下：</p>\n<pre><code class=\"hljs php\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zhpntsr</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  random = []\n<span class=\"hljs-number\">5</span>  random.append(<span class=\"hljs-keyword\">True</span>)\n<span class=\"hljs-number\">6</span>  random.append(<span class=\"hljs-number\">100</span>)\n<span class=\"hljs-number\">7</span>  random.append(<span class=\"hljs-number\">1.1</span>)\n<span class=\"hljs-number\">8</span>  random.append(<span class=\"hljs-string\">\"Hello\"</span>)\n<span class=\"hljs-number\">9</span>  random\n\n&gt;&gt; [<span class=\"hljs-keyword\">True</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">1.1</span>, <span class=\"hljs-string\">'Hello'</span>]\n</code></pre>\n<p>字符串、列表和元组都是<strong>可迭代的</strong>（iterable）。如果可以使用循环访问对象中的每一个元素，那么该对象是可迭代的，被称为<strong>可迭代对象</strong>。可迭代对象中的每一个元素都有一个<strong>索引</strong>（index），即表示元素在可迭代对象中位置的数字。列表中第一个元素的索引是 0，而不是 1。</p>\n<p>在如下示例中，<code>\"Apple\"</code> 的索引是 0，<code>\"Orange\"</code> 的索引是 1，<code>\"Pear\"</code> 的索引是 2：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/z8zzk8d</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  fruit = [<span class=\"hljs-string\">\"Apple\"</span>, <span class=\"hljs-string\">\"Orange\"</span>, <span class=\"hljs-string\">\"Pear\"</span>]\n</code></pre>\n<p>你可以使用语法[列表名][[索引]]获取一个元素：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jqtlwpf</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  fruit = [<span class=\"hljs-string\">\"Apple\"</span>, <span class=\"hljs-string\">\"Orange\"</span>, <span class=\"hljs-string\">\"Pear\"</span>]\n<span class=\"hljs-number\">5</span>  fruit[<span class=\"hljs-number\">0</span>]\n<span class=\"hljs-number\">6</span>  fruit[<span class=\"hljs-number\">1</span>]\n<span class=\"hljs-number\">7</span>  fruit[<span class=\"hljs-number\">2</span>]\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'Apple'</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'Orange'</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'Pear'</span>\n</code></pre>\n<p>如果获取的是不存在的索引，Python 会报告异常：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/za3rv95</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  colors = [<span class=\"hljs-string\">\"blue\"</span>, <span class=\"hljs-string\">\"green\"</span>, <span class=\"hljs-string\">\"yellow\"</span>]\n<span class=\"hljs-number\">5</span>  colors[<span class=\"hljs-number\">4</span>]\n\n&gt;&gt; IndexError: <span class=\"hljs-built_in\">list</span> index out of range\n</code></pre>\n<p>列表是<strong>可变的</strong>（mutable）。如果一个容器是可变的，则可以向该容器中增删对象。将列表中某个元素的索引赋给一个新的对象，即可改变该元素：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h4ahvf9</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  colors = [<span class=\"hljs-string\">\"blue\"</span>, <span class=\"hljs-string\">\"green\"</span>, <span class=\"hljs-string\">\"yellow\"</span>]\n<span class=\"hljs-number\">5</span>  colors\n<span class=\"hljs-number\">6</span>  colors[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-string\">\"red\"</span>\n<span class=\"hljs-number\">7</span>  colors\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'blue'</span>, <span class=\"hljs-string\">'green'</span>, <span class=\"hljs-string\">'yellow'</span>]\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'blue'</span>, <span class=\"hljs-string\">'green'</span>, <span class=\"hljs-string\">'red'</span>]\n</code></pre>\n<p>也可使用 <code>pop</code> 方法移除列表中的最后一个元素：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/j52uvmq</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  colors = [<span class=\"hljs-string\">\"blue\"</span>, <span class=\"hljs-string\">\"green\"</span>, <span class=\"hljs-string\">\"yellow\"</span>]\n<span class=\"hljs-number\">5</span>  colors\n<span class=\"hljs-number\">6</span>  item = colors.pop()\n<span class=\"hljs-number\">7</span>  item\n<span class=\"hljs-number\">8</span>  colors\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'blue'</span>, <span class=\"hljs-string\">'green'</span>, <span class=\"hljs-string\">'yellow'</span>]\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'yellow'</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'blue'</span>, <span class=\"hljs-string\">'green'</span>]\n</code></pre>\n<p>不能对空列表使用 <code>pop</code> 方法。否则，Python 则会报告异常。</p>\n<p>你可以使用加法操作符来合并两个列表：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jjxnk4z</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  colors1 = [<span class=\"hljs-string\">\"blue\"</span>, <span class=\"hljs-string\">\"green\"</span>, <span class=\"hljs-string\">\"yellow\"</span>]\n<span class=\"hljs-number\">5</span>  colors2 = [<span class=\"hljs-string\">\"orange\"</span>, <span class=\"hljs-string\">\"pink\"</span>, <span class=\"hljs-string\">\"black\"</span>]\n<span class=\"hljs-number\">6</span>  colors1 + colors2\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'blue'</span>, <span class=\"hljs-string\">'green'</span>, <span class=\"hljs-string\">'yellow'</span>, <span class=\"hljs-string\">'orange'</span>, <span class=\"hljs-string\">'pink'</span>, <span class=\"hljs-string\">'black'</span>]\n</code></pre>\n<p>也可以使用关键字 <code>in</code> 检查某个元素是否在列表中：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z4fnv39</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  colors = [<span class=\"hljs-string\">\"blue\"</span>, <span class=\"hljs-string\">\"green\"</span>, <span class=\"hljs-string\">\"yellow\"</span>]\n<span class=\"hljs-number\">5</span>  <span class=\"hljs-string\">\"green\"</span> <strong><span class=\"hljs-keyword\">in</span></strong> colors\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<p>使用关键字 <code>not</code> 检查某个元素是否不在列表中：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jqzk8pj</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  colors = [<span class=\"hljs-string\">\"blue\"</span>, <span class=\"hljs-string\">\"green\"</span>, <span class=\"hljs-string\">\"yellow\"</span>]\n<span class=\"hljs-number\">5</span>  <span class=\"hljs-string\">\"black\"</span> <strong><span class=\"hljs-keyword\">not</span></strong> <strong><span class=\"hljs-keyword\">in</span></strong> colors\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<p>使用函数 <code>len</code> 可获得列表的大小（包含元素的个数）：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hhx6rx4</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  len(colors)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">3</span>\n</code></pre>\n<p>下面是一个在实践中使用列表的例子：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">01  <span class=\"hljs-comment\"># http://tinyurl.com/gq7yjr7</span>\n02\n03\n04  colors = [<span class=\"hljs-string\">\"purple\"</span>,\n05            <span class=\"hljs-string\">\"orange\"</span>,\n06            <span class=\"hljs-string\">\"green\"</span>]\n07\n08\n09  guess = input(<span class=\"hljs-string\">\"Guess a color:\"</span>)\n10\n11\n12<strong><span class=\"hljs-keyword\">if</span></strong> guess <strong><span class=\"hljs-keyword\">in</span></strong> colors:\n13      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"You guessed correctly!\"</span>)\n14<strong><span class=\"hljs-keyword\">else</span></strong>:\n15      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Wrong! Try again.\"</span>)\n\n&gt;&gt; Guess a color:</code></pre>\n<p>列表 <code>colors</code> 包含了代表颜色的不同字符串。程序使用内置函数 <code>input</code> 来让用户猜测是什么颜色，并将用户的答案保存至变量。如果答案在 <code>colors</code> 列表中，则告知用户猜测正确。反之，让用户再次尝试。</p>\n<h3 id=\"53\">5.3　元组</h3>\n<p><strong>元组</strong>（tuple）是存储有序对象的一种容器。与列表不同，元组是<strong>不可变的</strong>（immutable），这意味着其内容不会变化。创建元组后，无法修改其中任何元组的值，也无法添加或修改元素。用圆括号表示元组，且必须用逗号分隔元组中的元素。有两种语法可以创建元组，第一种如下所示：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zo88eal</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  my_tuple = tuple()\n<span class=\"hljs-number\">5</span>  my_tuple\n\n<span class=\"hljs-meta\">&gt;&gt;</span> ()\n</code></pre>\n<p>以及第二种语法：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zm3y26j</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  my_tuple = ()\n<span class=\"hljs-number\">5</span>  my_tuple\n\n<span class=\"hljs-meta\">&gt;&gt;</span> ()\n</code></pre>\n<p>如果要向元组中新增对象，可用第二种语法创建一个新的元组，并在其中加入你希望增加的每个元素，用逗号分隔：</p>\n<pre><code class=\"hljs php\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zlwwfe3</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  rndm = (<span class=\"hljs-string\">\"M. Jackson\"</span>, <span class=\"hljs-number\">1958</span>, <span class=\"hljs-keyword\">True</span>)\n<span class=\"hljs-number\">5</span>  rndm\n\n&gt;&gt; (<span class=\"hljs-string\">'M. Jackson'</span>, <span class=\"hljs-number\">1958</span>, <span class=\"hljs-keyword\">True</span>)\n</code></pre>\n<p>即使元组中只有一个元素，也需要在该元素的后面加上逗号。只有这样，Python 才能将其与其他为了表示运算顺序而放在圆括号中的数字标记进行区分。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/j8mca8o</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-comment\"># 这是元组</span>\n<span class=\"hljs-number\">5</span>  (<span class=\"hljs-string\">\"self_taught\"</span>, )\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  <span class=\"hljs-comment\"># 这不是元组</span>\n<span class=\"hljs-number\">9</span>  (<span class=\"hljs-number\">9</span>) + <span class=\"hljs-number\">1</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> (<span class=\"hljs-string\">'self_taught'</span>, )\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">10</span>\n</code></pre>\n<p>创建元组之后，不能再新增元素或修改已有元素。如果在创建元组后这样做，Python 会报告异常：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z3x34nk</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  dys = (<span class=\"hljs-string\">\"1984\"</span>,\n<span class=\"hljs-number\">5</span>         <span class=\"hljs-string\">\"Brave New World\"</span>,\n<span class=\"hljs-number\">6</span>         <span class=\"hljs-string\">\"Fahrenheit 451\"</span>)\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>\n<span class=\"hljs-number\">9</span>  dys[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-string\">\"Handmaid's Tale\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-symbol\">TypeError:</span> <span class=\"hljs-string\">'tuple'</span> object does not support item assignment\n</code></pre>\n<p>可使用与列表一样的方法来获取元组的元素，即引用其索引：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z9dc6lo</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  dys = (<span class=\"hljs-string\">\"1984\"</span>,\n<span class=\"hljs-number\">5</span>         <span class=\"hljs-string\">\"Brave New World\"</span>,\n<span class=\"hljs-number\">6</span>         <span class=\"hljs-string\">\"Fahrenheit 451\"</span>)\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>\n<span class=\"hljs-number\">9</span>  dys[<span class=\"hljs-number\">2</span>]\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'Fahrenheit 451'</span>\n</code></pre>\n<p>可使用关键字 <code>in</code> 来检查某个元素是否在元组中：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/j3bsel7</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  dys = (<span class=\"hljs-string\">\"1984\"</span>,\n<span class=\"hljs-number\">5</span>         <span class=\"hljs-string\">\"Brave New World\"</span>,\n<span class=\"hljs-number\">6</span>         <span class=\"hljs-string\">\"Fahrenheit 451\"</span>)\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>\n<span class=\"hljs-number\">9</span>  <span class=\"hljs-string\">\"1984\"</span> <strong><span class=\"hljs-keyword\">in</span></strong> dys\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<p>在 <code>in</code> 前加上关键字 <code>not</code> 即可检查元素是否不在元组中：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jpdjjv9</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  dys = (<span class=\"hljs-string\">\"1984\"</span>,\n<span class=\"hljs-number\">5</span>         <span class=\"hljs-string\">\"Brave New World\"</span>,\n<span class=\"hljs-number\">6</span>         <span class=\"hljs-string\">\"Fahrenheit 451\"</span>)\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>\n<span class=\"hljs-number\">9</span>  <span class=\"hljs-string\">\"Handmaid's Tale\"</span> <strong><span class=\"hljs-keyword\">not</span></strong> <strong><span class=\"hljs-keyword\">in</span></strong> dys\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<p>你可能会疑惑为什么要使用一个看上去没有列表灵活的数据结构。因为在处理明确永远不会改变的，并且也不希望其他程序对其进行修改的值时，元组是非常有用的。地理坐标就是适合使用元组存储的一种数据。城市的经纬度应保存在元组中，因为这些值永远不会改变，保存为元组意味着程序不会意外对其进行修改。元组不像列表那样可以用作字典的键，这个知识点会在下一节介绍。</p>\n<h3 id=\"54\">5.4　字典</h3>\n<p><strong>字典</strong>（dictionary）是另一种用于存储对象的内置容器。它们被用来链接<strong>键</strong>（key）和<strong>值</strong>（value）这两个对象（如图 5-2 所示）。将一个对象链接至另一个对象，也被称为<strong>映射</strong>（mapping），结果为产生一个<strong>键值对</strong>（key-value pair）。可将键值对添加到字典，然后使用键在字典中查询，可获得其对应的值。但是无法使用值来查询键。</p>\n<p><img src=\"https://images.gitbook.cn/38d2e810-6fc4-11e9-9e1b-5b6158413fa5\" alt=\"enter image description here\"></p>\n<p>图 5-2　字典</p>\n<p>字典是可变的，因此可以向字典中新增键值对。与列表和元组不同，字典中存储的对象是无序的。字典的价值在于键与值之间的关联。需要成对存储数据的场景很多。例如，可以将关于某个人的信息存储在字典中，将名为 height 的键，映射至代表这个人身高的值；将名为 eyecolor 的键映射至代表这个人眼睛颜色的值；将名为 nationality 的键映射至代表这个人国籍的值。</p>\n<p>字典用花括号表示。有两种创建字典的语法，其一如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zfn6jmw</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  my_dict = dict()\n<span class=\"hljs-number\">5</span>  my_dict\n\n<span class=\"hljs-meta\">&gt;&gt;</span> {}\n</code></pre>\n<p>另一种方法如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jfgemf2</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  my_dict = {}\n<span class=\"hljs-number\">5</span>  my_dict\n\n<span class=\"hljs-meta\">&gt;&gt;</span> {}\n</code></pre>\n<p>可以在创建字典时直接添加键值对。上述两种语法都要求用冒号分隔键与值，每个键值对之间用逗号分隔。与元组不同的是，如果只有一个键值对，不需要在其后添加逗号。如下示例介绍了创建字典时如何添加键值对：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hplqc4u</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  fruits = {<span class=\"hljs-string\">\"Apple\"</span>:\n<span class=\"hljs-number\">5</span>            <span class=\"hljs-string\">\"Red\"</span>,\n<span class=\"hljs-number\">6</span>            <span class=\"hljs-string\">\"Banana\"</span>:\n<span class=\"hljs-number\">7</span>            <span class=\"hljs-string\">\"Yellow\"</span>}\n<span class=\"hljs-number\">8</span>  fruits\n\n<span class=\"hljs-meta\">&gt;&gt;</span> {<span class=\"hljs-string\">'Apple'</span>: <span class=\"hljs-string\">'Red'</span>, <span class=\"hljs-string\">'Banana'</span>: <span class=\"hljs-string\">'Yellow'</span>}\n</code></pre>\n<p>读者在 shell 中看到的字典元素顺序可能与上例中有所不同，因为字典的键是无序的，Python 会随机打印其元素（本节中所有示例均适用该情况）。</p>\n<p>字典是可变的。创建字典后，可通过语法“<code>[字典名][[键]] = [值]</code>”添加新的键值对，并通过语法“<code>[字典名][[键]]</code>”查找值。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/grc28lh</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  facts = dict()\n<span class=\"hljs-number\">05</span>\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>  <span class=\"hljs-comment\"># 添加键-值对</span>\n08  facts[<span class=\"hljs-string\">\"code\"</span>] = <span class=\"hljs-string\">\"fun\"</span>\n09  <span class=\"hljs-comment\"># 查找键对应的值</span>\n<span class=\"hljs-number\">10</span>  facts[<span class=\"hljs-string\">\"code\"</span>]\n<span class=\"hljs-number\">11</span>\n<span class=\"hljs-number\">12</span>\n<span class=\"hljs-number\">13</span>  <span class=\"hljs-comment\"># 添加键-值对</span>\n<span class=\"hljs-number\">14</span>  facts[<span class=\"hljs-string\">\"Bill\"</span>] = <span class=\"hljs-string\">\"Gates\"</span>\n<span class=\"hljs-number\">15</span>  <span class=\"hljs-comment\"># 查找键对应的值</span>\n<span class=\"hljs-number\">16</span>  facts[<span class=\"hljs-string\">\"Bill\"</span>]\n<span class=\"hljs-number\">17</span>\n<span class=\"hljs-number\">18</span>\n<span class=\"hljs-number\">19</span>  <span class=\"hljs-comment\"># 添加键-值对</span>\n<span class=\"hljs-number\">20</span>  facts[<span class=\"hljs-string\">\"founded\"</span>] = <span class=\"hljs-number\">1776</span>\n<span class=\"hljs-number\">21</span>  <span class=\"hljs-comment\"># 查找键对应的值</span>\n<span class=\"hljs-number\">22</span>  facts[<span class=\"hljs-string\">\"founded\"</span>]\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'fun'</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> Gates\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">1776</span>\n</code></pre>\n<p>字典的值可以是任意对象。在上例中，前两个值是字符串，最后一个值 1776 是整数。但是字典的键必须是不可变的。字符串或元组可以用作字典的键，但是列表或字典不可以。</p>\n<p>可以使用关键字 <code>in</code> 检查某个键是否在字典中，但不能用其检查某个值是否在字典中。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hgf9vmp</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  bill = dict({<span class=\"hljs-string\">\"Bill Gates\"</span>:\n<span class=\"hljs-number\">5</span>               <span class=\"hljs-string\">\"charitable\"</span>})\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  <span class=\"hljs-string\">\"Bill Gates\"</span> <strong><span class=\"hljs-keyword\">in</span></strong> bill\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<p>如果访问一个不在字典中的键，Python 将报告异常。</p>\n<p>在关键字 <code>in</code> 之前加上关键字 <code>not</code>，可检查键是否不在字典中。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/he3g993</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  bill = dict({<span class=\"hljs-string\">\"Bill Gates\"</span>:\n<span class=\"hljs-number\">5</span>                   <span class=\"hljs-string\">\"charitable\"</span>})\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  <span class=\"hljs-string\">\"Bill Doors\"</span> <strong><span class=\"hljs-keyword\">not</span></strong> <strong><span class=\"hljs-keyword\">in</span></strong> bill\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<p>可使用关键字 <code>del</code> 删除字典中的键值对。示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/htrd9lj</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  books = {<span class=\"hljs-string\">\"Dracula\"</span>: <span class=\"hljs-string\">\"Stoker\"</span>,\n<span class=\"hljs-number\">5</span>           <span class=\"hljs-string\">\"1984\"</span>: <span class=\"hljs-string\">\"Orwell\"</span>,\n<span class=\"hljs-number\">6</span>           <span class=\"hljs-string\">\"The Trial\"</span>: <span class=\"hljs-string\">\"Kafka\"</span>}\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>\n<span class=\"hljs-number\">9</span> <strong>del</strong> books[<span class=\"hljs-string\">\"The Trial\"</span>]\n<span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">11</span>  books\n\n<span class=\"hljs-meta\">&gt;&gt;</span> {<span class=\"hljs-string\">'Dracula'</span>: <span class=\"hljs-string\">'Stoker'</span>, <span class=\"hljs-string\">'1984'</span>: <span class=\"hljs-string\">'Orwell'</span>}</code></pre>\n<p>一个使用字典的程序示例如下：</p>\n<pre class=\"代码无行号\"><code class=\"hljs bash\">01  <span class=\"hljs-comment\"># http://tinyurl.com/gnjvep7</span>\n02\n03\n04  rhymes = {<span class=\"hljs-string\">\"1\"</span>: <span class=\"hljs-string\">\"fun\"</span>,\n05            <span class=\"hljs-string\">\"2\"</span>: <span class=\"hljs-string\">\"blue\"</span>\n06            <span class=\"hljs-string\">\"3\"</span>: <span class=\"hljs-string\">\"me\"</span>,\n07            <span class=\"hljs-string\">\"4\"</span>: <span class=\"hljs-string\">\"floor\"</span>,\n08            <span class=\"hljs-string\">\"5\"</span>: <span class=\"hljs-string\">\"live\"</span>\n09            }\n10\n11\n12  n = input(<span class=\"hljs-string\">\"Type a number:\"</span>)\n13 <strong><span class=\"hljs-keyword\">if</span></strong> n <strong><span class=\"hljs-keyword\">in</span></strong> rhymes:\n14      rhyme = rhymes[n]\n15      <span class=\"hljs-built_in\">print</span>(rhyme)\n16 <strong><span class=\"hljs-keyword\">else</span></strong>:\n17      <strong><span class=\"hljs-built_in\">print</span></strong>(<span class=\"hljs-string\">\"Not found.\"</span>)\n\nType a number:</code></pre>\n<p>字典 <code>rhymes</code> 中有 6 个数字（键），分别映射至 6 个单词（值）。程序让用户输入数字，并保存在变量中。在从字典中查找单词之前，记得先用 <code>in</code> 关键字检查字典中是否存在对应的键。如果存在，则查找字典中对应的单词并打印出来。否则会打印消息告诉用户未查找到。</p>\n<h3 id=\"55\">5.5　容器嵌套容器</h3>\n<p>可以在容器中存储容器。例如，你可以在列表中保存列表：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gops9fz</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  lists = []\n<span class=\"hljs-number\">05</span>  rap = [<span class=\"hljs-string\">\"Kanye West\"</span>,\n<span class=\"hljs-number\">06</span>         <span class=\"hljs-string\">\"Jay Z\"</span>,\n<span class=\"hljs-number\">07</span>         <span class=\"hljs-string\">\"Eminem\"</span>,\n08         <span class=\"hljs-string\">\"Nas\"</span>]\n09\n<span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">11</span>  rock = [<span class=\"hljs-string\">\"Bob Dylan\"</span>,\n<span class=\"hljs-number\">12</span>          <span class=\"hljs-string\">\"The Beatles\"</span>,\n<span class=\"hljs-number\">13</span>          <span class=\"hljs-string\">\"Led Zeppelin\"</span>]\n<span class=\"hljs-number\">14</span>\n<span class=\"hljs-number\">15</span>\n<span class=\"hljs-number\">16</span>  djs = [<span class=\"hljs-string\">\"Zeds Dead\"</span>,\n<span class=\"hljs-number\">17</span>         <span class=\"hljs-string\">\"Tiesto\"</span>]\n<span class=\"hljs-number\">18</span>\n<span class=\"hljs-number\">19</span>\n<span class=\"hljs-number\">20</span>  lists.append(rap)\n<span class=\"hljs-number\">21</span>  lists.append(rock)\n<span class=\"hljs-number\">22</span>  lists.append(djs)\n<span class=\"hljs-number\">23</span>\n<span class=\"hljs-number\">24</span>\n<span class=\"hljs-number\">25</span>  print(lists)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [[<span class=\"hljs-string\">'Kanye West'</span>, <span class=\"hljs-string\">'Jay Z'</span>, <span class=\"hljs-string\">'Eminem'</span>, <span class=\"hljs-string\">'Nas'</span>], [<span class=\"hljs-string\">'Bob Dylan'</span>, <span class=\"hljs-string\">'The Beatles'</span>, <span class=\"hljs-string\">'Led Zeppelin'</span>], [<span class=\"hljs-string\">'Zeds Dead'</span>, <span class=\"hljs-string\">'Tiesto'</span>]]\n</code></pre>\n<p>在上述例中，<code>lists</code> 有 3 个元素。每个元素都是一个列表：第一个元素是嘻哈歌手列表，第二个元素是摇滚歌手列表，第三个元素是 DJ 列表。可通过元素对应的索引访问这些列表：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gu4mudk</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-comment\"># 接上例</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>  rap = lists[<span class=\"hljs-number\">0</span>]\n<span class=\"hljs-number\">8</span>  print(rap)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'Kanye West'</span>, <span class=\"hljs-string\">'Jay Z'</span>, <span class=\"hljs-string\">'Eminem'</span>, <span class=\"hljs-string\">'Nas'</span>]\n</code></pre>\n<p>如果向列表 <code>rap</code> 中添加一个新元素，该修改也会体现在 <code>lists</code> 列表中：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hdtosm2</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-comment\"># 接上例</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n08  rap = lists[<span class=\"hljs-number\">0</span>]\n09  rap.append(<span class=\"hljs-string\">\"Kendrick Lamar\"</span>)\n<span class=\"hljs-number\">10</span>  print(rap)\n<span class=\"hljs-number\">11</span>  print(lists)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'Kanye West'</span>, <span class=\"hljs-string\">'Jay Z'</span>, <span class=\"hljs-string\">'Eminem'</span>, <span class=\"hljs-string\">'Nas'</span>, <span class=\"hljs-string\">'Kendrick Lamar'</span>]\n<span class=\"hljs-meta\">&gt;&gt;</span> [[<span class=\"hljs-string\">'Kanye West'</span>, <span class=\"hljs-string\">'Jay Z'</span>, <span class=\"hljs-string\">'Eminem'</span>, <span class=\"hljs-string\">'Nas'</span>, <span class=\"hljs-string\">'Kendrick Lamar'</span>],\n[<span class=\"hljs-string\">'Bob Dylan'</span>, <span class=\"hljs-string\">'The Beatles'</span>, <span class=\"hljs-string\">'Led Zeppelin'</span>], [<span class=\"hljs-string\">'Zeds Dead'</span>, <span class=\"hljs-string\">'Tiesto'</span>]]\n</code></pre>\n<p>也可以在列表中存储元素，在元组中存储列表，还可以在列表或元组中存储字典：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z9dhema</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  locations = []\n<span class=\"hljs-number\">05</span>\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>  la = (<span class=\"hljs-number\">34.0522</span>, <span class=\"hljs-number\">188.2437</span>)\n08  chicago = (<span class=\"hljs-number\">41.8781</span>, <span class=\"hljs-number\">87.6298</span>)\n09\n<span class=\"hljs-number\">10</span>\n<span class=\"hljs-number\">11</span>  locations.append(la)\n<span class=\"hljs-number\">12</span>  locations.append(chicago)\n<span class=\"hljs-number\">13</span>\n<span class=\"hljs-number\">14</span>\n<span class=\"hljs-number\">15</span>  print(locations)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [(<span class=\"hljs-number\">34.0522</span>, <span class=\"hljs-number\">188.2437</span>), (<span class=\"hljs-number\">41.8781</span>, <span class=\"hljs-number\">87.6298</span>)]\n\n<span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/ht7gpsd</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  eights = [<span class=\"hljs-string\">\"Edgar Allan Poe\"</span>,\n<span class=\"hljs-number\">05</span>            <span class=\"hljs-string\">\"Charles Dickens\"</span>]\n<span class=\"hljs-number\">06</span>\n<span class=\"hljs-number\">07</span>\n08  nines = [<span class=\"hljs-string\">\"Hemingway\"</span>,\n09           <span class=\"hljs-string\">\"Fitzgerald\"</span>,\n<span class=\"hljs-number\">10</span>          <span class=\"hljs-string\">\"Orwell\"</span>]\n<span class=\"hljs-number\">11</span>\n<span class=\"hljs-number\">12</span>\n<span class=\"hljs-number\">13</span>  authors = (eights, nines)\n<span class=\"hljs-number\">14</span>  print(authors)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> ([<span class=\"hljs-string\">'Edgar Allan Poe'</span>, <span class=\"hljs-string\">'Charles Dickens'</span>], [<span class=\"hljs-string\">'Hemingway'</span>, <span class=\"hljs-string\">'Fitzgerald'</span>, <span class=\"hljs-string\">'Orwell'</span>])\n\n<span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h8ck5er</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  bday = {<span class=\"hljs-string\">\"Hemingway\"</span>:\n<span class=\"hljs-number\">05</span>          <span class=\"hljs-string\">\"7.21.1899\"</span>,\n<span class=\"hljs-number\">06</span>          <span class=\"hljs-string\">\"Fitzgerald\"</span>:\n<span class=\"hljs-number\">07</span>          <span class=\"hljs-string\">\"9.24.1896\"</span>}\n08\n09\n<span class=\"hljs-number\">10</span>  my_list = [bday]\n<span class=\"hljs-number\">11</span>  print(my_list)\n<span class=\"hljs-number\">12</span>  my_tuple = (bday,)\n<span class=\"hljs-number\">13</span>  print(my_tuple)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [{<span class=\"hljs-string\">'Hemingway'</span>: <span class=\"hljs-string\">'7.21.1899'</span>, <span class=\"hljs-string\">'Fitzgerald'</span>: <span class=\"hljs-string\">'9.24.1896'</span>}]\n<span class=\"hljs-meta\">&gt;&gt;</span> ({<span class=\"hljs-string\">'Hemingway'</span>: <span class=\"hljs-string\">'7.21.1899'</span>, <span class=\"hljs-string\">'Fitzgerald'</span>: <span class=\"hljs-string\">'9.24.1896'</span>},)\n</code></pre>\n<p>列表、字典或元组都可以成为字典中的值：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/zqupwx4</span></span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  ny = {<span class=\"hljs-string\">\"locations\"</span>:\n<span class=\"hljs-number\">05</span>        (<span class=\"hljs-number\">40.7128</span>,\n<span class=\"hljs-number\">06</span>         <span class=\"hljs-number\">74.0059</span>),\n<span class=\"hljs-number\">07</span>\n<span class=\"hljs-number\">08</span>\n<span class=\"hljs-number\">09</span>        <span class=\"hljs-string\">\"celebs\"</span>:\n<span class=\"hljs-number\">10</span>        [<span class=\"hljs-string\">\"W. Allen\"</span>,\n<span class=\"hljs-number\">11</span>         <span class=\"hljs-string\">\"Jay Z\"</span>,\n<span class=\"hljs-number\">12</span>         <span class=\"hljs-string\">\"K. Bacon\"</span>],\n<span class=\"hljs-number\">13</span>\n<span class=\"hljs-number\">14</span>         <span class=\"hljs-string\">\"facts\"</span>:\n<span class=\"hljs-number\">15</span>         {<span class=\"hljs-string\">\"state\"</span>:\n<span class=\"hljs-number\">16</span>          <span class=\"hljs-string\">\"NY\"</span>,\n<span class=\"hljs-number\">17</span>          <span class=\"hljs-string\">\"country\"</span>:\n<span class=\"hljs-number\">18</span>          <span class=\"hljs-string\">\"America\"</span>}\n<span class=\"hljs-number\">19</span>  }\n</code></pre>\n<p>本例中，字典 <code>ny</code> 有 3 个键：<code>\"locations\"</code>、<code>\"celebs\"</code> 和 <code>\"facts\"</code>。第一个键的值是一个元组，因为地理坐标永远不会变。第二个键的值是生活在纽约的名人列表，因为可能会变化所以使用列表。第三个键的值是一个字典，因为键值对是表示纽约有关联事实的最好方式。</p>\n<h3 id=\"56\">5.6　术语表</h3>\n<p><strong>方法</strong>：与指定数据类型紧密相关的函数。</p>\n<p><strong>列表</strong>：存储有序对象的一种容器。</p>\n<p><strong>可迭代的</strong>：如果可使用循环访问对象中的每一个元素，则该对象是可迭代的。</p>\n<p><strong>可迭代对象</strong>：可迭代的对象，如字符串、列表和元素。</p>\n<p><strong>索引</strong>：代表元素在可迭代对象中位置的数字。</p>\n<p><strong>可变的</strong>：容器中的内容可以发生变化。</p>\n<p><strong>不可变的</strong>：容器中的内容不能改变。</p>\n<p><strong>字典</strong>：存储对象的一种内置容器，将一个称为键的对象，映射至一个称为值的对象。</p>\n<p><strong>键</strong>：用来查找字典中对应的值。</p>\n<p><strong>值</strong>：字典中映射至键的值。</p>\n<p><strong>映射</strong>：将一个对象链接至另一个对象。</p>\n<p><strong>键值对</strong>：字典中键映射至值。</p>\n<h3 id=\"57\">5.7　挑战练习</h3>\n<p>1．创建一个你最喜欢歌手的列表。</p>\n<p>2．创建一个由元组构成的列表，每个元组包含居住过或旅游过的城市的经纬度。</p>\n<p>3．创建一个包含你的不同属性的字典：身高、最喜欢的颜色和最喜欢的作者等。</p>\n<p>4．编写一个程序，让用户询问你的身高、最喜欢的颜色或最喜欢的作者，并返回上一个挑战中创建的字典。</p>\n<p>5．创建一个字典，将最喜欢的歌手映射至你最喜欢的歌曲。</p>\n<p>6．列表、元组和容器只是 Python 中内置容器的一部分。自行研究 Python 中的集合（也是一种容器）在什么情况下可以使用集合？</p>\n<p>答案可从异步社区（www.epubit.com）本书详情页的配套资源中下载。</p></div></article>\n</body>\n</html>"},{"title":"work_0603","_content":"\n### done\n    \n    源数据管理\n    功能接口\n    测试\n\n### doing\n    \n    花点时间把错误酒店导出来\n    增加一票否决机制\n    携程国内校验 将 房型描述相似度的权 调高，\n    \n   \n","source":"_posts/work_coding/work0603.md","raw":"---\ntitle: work_0603\n---\n\n### done\n    \n    源数据管理\n    功能接口\n    测试\n\n### doing\n    \n    花点时间把错误酒店导出来\n    增加一票否决机制\n    携程国内校验 将 房型描述相似度的权 调高，\n    \n   \n","slug":"work_coding/work0603","published":1,"date":"2019-06-04T02:05:48.446Z","updated":"2019-06-04T02:05:48.446Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwhbvhoy00009zh7w7nhqyit","content":"<h3 id=\"done\"><a href=\"#done\" class=\"headerlink\" title=\"done\"></a>done</h3><pre><code>源数据管理\n功能接口\n测试\n</code></pre><h3 id=\"doing\"><a href=\"#doing\" class=\"headerlink\" title=\"doing\"></a>doing</h3><pre><code>花点时间把错误酒店导出来\n增加一票否决机制\n携程国内校验 将 房型描述相似度的权 调高，\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"done\"><a href=\"#done\" class=\"headerlink\" title=\"done\"></a>done</h3><pre><code>源数据管理\n功能接口\n测试\n</code></pre><h3 id=\"doing\"><a href=\"#doing\" class=\"headerlink\" title=\"doing\"></a>doing</h3><pre><code>花点时间把错误酒店导出来\n增加一票否决机制\n携程国内校验 将 房型描述相似度的权 调高，\n</code></pre>"},{"_content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>字符串操作</title>\n</head>\n<body>\n<article id=\"articleDiv\"><div class=\"mazi-article-content dont-break-out\"><p></p><div class=\"toc\">\n<ul>\n<li><ul>\n<li><ul>\n<li><a href=\"#61\">6.1　三引号字符串</a></li>\n<li><a href=\"#62\">6.2　索引</a></li>\n<li><a href=\"#63\">6.3　字符串是不可变的</a></li>\n<li><a href=\"#64\">6.4　字符串拼接</a></li>\n<li><a href=\"#65\">6.5　字符串乘法</a></li>\n<li><a href=\"#66\">6.6　改变大小写</a></li>\n<li><a href=\"#67\">6.7　格式化</a></li>\n<li><a href=\"#68\">6.8　分割</a></li>\n<li><a href=\"#69\">6.9　连接</a></li>\n<li><a href=\"#610\">6.10　去除空格</a></li>\n<li><a href=\"#611\">6.11　替换</a></li>\n<li><a href=\"#612\">6.12　查找索引</a></li>\n<li><a href=\"#613in\">6.13　in 关键字</a></li>\n<li><a href=\"#614\">6.14　字符串转义</a></li>\n<li><a href=\"#615\">6.15　换行符</a></li>\n<li><a href=\"#616\">6.16　切片</a></li>\n<li><a href=\"#617\">6.17　术语表</a></li>\n<li><a href=\"#618\">6.18　挑战练习</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>\n<p></p>\n<blockquote>\n  <p><span style=\"font-family: Times New Roman,楷体_GB2312\">“理论上，理论和实践没有区别。但实践上，是有区别的。”</span></p>\n  <p><span style=\"font-family: Times New Roman,楷体_GB2312\">——简 · 范德斯奈普特（Jan L. A. van de Snepscheut）</span></p>\n</blockquote>\n<p>Python 自带操作字符串的功能，例如在指定位置将字符串分割为两部分，或者改变字符串的大小写。举个例子，假设有一个所有字符都是大写的字符串，现在希望将其全部改为小写，这通过 Python 可以轻松实现。在本章中，读者将学习更多有关字符串的知识，并掌握 Python 中操作字符串最有效的工具。</p>\n<h3 id=\"61\">6.1　三引号字符串</h3>\n<p>如果字符串跨越一行以上，可以使用三引号：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h59ygda</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"\"\" 第一行\n5      第二行\n6      第三行\n7  \"\"\"</span>\n</code></pre>\n<p>如果使用单引号或双引号定义一个跨行的字符串，Python 会报告语法错误。</p>\n<h3 id=\"62\">6.2　索引</h3>\n<p>与列表和元组一样，字符串也是可迭代的。可使用索引查找字符串中的每个字符。与其他可迭代对象一样，字符串中第一个字符所在的索引为 0，其后每个索引递增 1。</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zqqc2jw</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  author = <span class=\"hljs-string\">\"Kafka\"</span>\n<span class=\"hljs-number\">5</span>  author[<span class=\"hljs-number\">0</span>]\n<span class=\"hljs-number\">6</span>  author[<span class=\"hljs-number\">1</span>]\n<span class=\"hljs-number\">7</span>  author[<span class=\"hljs-number\">2</span>]\n<span class=\"hljs-number\">8</span>  author[<span class=\"hljs-number\">3</span>]\n<span class=\"hljs-number\">9</span>  author[<span class=\"hljs-number\">4</span>]\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'K'</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'a'</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'f'</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'k'</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'a'</span>\n</code></pre>\n<p>上述示例中，可使用索引 0、1、2、3、4 来查找字符串 <code>\"Kafka\"</code> 中的每个字符。如果查找的字符串索引大于最后一个索引的值，Python 会报告异常错误：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/zk52tef</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  author = <span class=\"hljs-string\">\"Kafka\"</span>\n<span class=\"hljs-number\">5</span>  author[<span class=\"hljs-number\">5</span>]\n\n&gt;&gt; IndexError: <span class=\"hljs-built_in\">string</span> index out of range\n</code></pre>\n<p>Python 还支持使用<strong>负索引（negative index）</strong>查找列表中的元素：可用来从右向左查找可迭代对象中元素的索引（必须是一个负数）。使用索引 <code>-1</code> 可以查找可迭代对象中的最后一个元素，示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hyju2t5</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  author = <span class=\"hljs-string\">\"Kafka\"</span>\n<span class=\"hljs-number\">5</span>  author[-<span class=\"hljs-number\">1</span>]\n\n<span class=\"hljs-meta\">&gt;&gt;</span> a\n</code></pre>\n<p>负索引 <code>-2</code> 查找的是倒数第二个元素，负索引 <code>-3</code> 查找的是倒数第三个元素，以此类推。</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jtpx7sr</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  author = <span class=\"hljs-string\">\"Kafka\"</span>\n<span class=\"hljs-number\">5</span>  author[-<span class=\"hljs-number\">2</span>]\n<span class=\"hljs-number\">6</span>  author[-<span class=\"hljs-number\">3</span>]\n\n<span class=\"hljs-meta\">&gt;&gt;</span> k\n<span class=\"hljs-meta\">&gt;&gt;</span> f\n</code></pre>\n<h3 id=\"63\">6.3　字符串是不可变的</h3>\n<p>字符串和元组一样都是不可变的，无法修改字符串中的字符。如果想要修改，就必须创建一个新的字符串：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hsr83lv</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  ff = <span class=\"hljs-string\">\"F.Fitzgerald\"</span>\n<span class=\"hljs-number\">5</span>  ff = <span class=\"hljs-string\">\"F. Scott Fitzgerald\"</span>\n<span class=\"hljs-number\">6</span>  ff\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'F. Scott Fitzgerald'</span>\n</code></pre>\n<p>Python 提供了多个从已有字符串中创建新字符串的方法，本章将逐一介绍。</p>\n<h3 id=\"64\">6.4　字符串拼接</h3>\n<p>可使用加法操作符，将两个或多个字符串组合在一起，结果就是由第一个字符串中的字符和其他字符串中的字符共同构成的一个新字符串。将字符串组合的做法，被称为字符串拼接。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h4z5mlg</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"cat\"</span> + <span class=\"hljs-string\">\"in\"</span> + <span class=\"hljs-string\">\"hat\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'catinhat'</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gsrajle</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"cat\"</span> + <span class=\"hljs-string\">\" in\"</span> + <span class=\"hljs-string\">\" the\"</span> + <span class=\"hljs-string\">\" hat\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'cat in the hat'</span>\n</code></pre>\n<h3 id=\"65\">6.5　字符串乘法</h3>\n<p>可使用乘法操作符，将字符串与数字相乘。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zvm9gng</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"Sawyer\"</span> * <span class=\"hljs-number\">3</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> SawyerSawyerSawyer\n</code></pre>\n<h3 id=\"66\">6.6　改变大小写</h3>\n<p>可使用字符串的 <code>upper</code> 方法，将字符串中的每个字符改为大写。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hhancz6</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"We hold these truths...\"</span>.upper()\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'WE HOLD THESE TRUTHS...'</span>\n</code></pre>\n<p>类似地，可使用字符串的 <code>lower</code> 方法将字符串中的每个字符改为小写。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zkz48u5</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"SO IT GOES.\"</span>.lower()\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'so it goes.'</span>\n</code></pre>\n<p>还可使用字符串的 <code>capitalize</code> 方法，将字符串的首字母改为大写。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jp5hexn</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"four score and...\"</span>.capitalize()\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'Four score and...'</span>\n</code></pre>\n<h3 id=\"67\">6.7　格式化</h3>\n<p>可使用 <code>format</code> 方法创建新字符串，该方法会把字符串中的“<code>{}</code>”替换为传入的字符串：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/juvguy8</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"William {}\"</span>.format(<span class=\"hljs-string\">\"Faulkner\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'William Faulkner'</span>\n</code></pre>\n<p>也可以把变量作为参数传递：</p>\n<pre><code class=\"hljs perl\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zcpt9se</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-keyword\">last</span> = <span class=\"hljs-string\">\"Faulkner\"</span>\n<span class=\"hljs-number\">5</span>  <span class=\"hljs-string\">\"William {}\"</span>.format(<span class=\"hljs-keyword\">last</span>)\n\n&gt;&gt; <span class=\"hljs-string\">'William Faulkner'</span>\n</code></pre>\n<p>花括号可重复使用：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z6t6d8n</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  author = <span class=\"hljs-string\">\"William Faulkner\"</span>\n<span class=\"hljs-number\">5</span>  year_born = <span class=\"hljs-string\">\"1897\"</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  <span class=\"hljs-string\">\"{} was born in {}.\"</span>.format(author, year_born)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'William Faulkner was born in 1897.'</span>\n</code></pre>\n<p>如果要根据用户输入来创建字符串，<code>format</code> 方法很有用。示例如下：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gnrdsj9</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  n1 = input(<span class=\"hljs-string\">\"Enter a noun:\"</span>)\n<span class=\"hljs-number\">05</span>  v = input(<span class=\"hljs-string\">\"Enter a verb:\"</span>)\n<span class=\"hljs-number\">06</span>  adj = input(<span class=\"hljs-string\">\"Enter an adj:\"</span>)\n<span class=\"hljs-number\">07</span>  n2 = input(<span class=\"hljs-string\">\"Enter a noun:\"</span>)\n<span class=\"hljs-number\">08</span>\n<span class=\"hljs-number\">09</span>\n<span class=\"hljs-number\">10</span>  r = <span class=\"hljs-string\">\"\"\"The {} {} the {} {}\n11      \"\"\"</span>.format(n1,\n<span class=\"hljs-number\">12</span>                 v,\n<span class=\"hljs-number\">13</span>                 adj,\n<span class=\"hljs-number\">14</span>                 n2)\n<span class=\"hljs-number\">15</span>  print(r)\n\n&gt;&gt; Enter a noun:\n</code></pre>\n<p>程序让用户输入两个名词、一个动词和一个形容词，然后通过 <code>fomrat</code> 方法将这些输入创建为一个字符串并打印出来。</p>\n<h3 id=\"68\">6.8　分割</h3>\n<p>字符串有一个叫 <code>split</code> 的方法，可用来将字符串分割为两个或多个字符串。需要传入一个字符串作为 <code>split</code> 方法的参数，并用其将原字符串分割为多个字符串。例如，可以传入句号作为 <code>split</code> 方法的参数，将字符串 <code>\"I jumped over the puddle. It was 12 feet!\"</code> 分割成两个不同的字符串。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/he8u28o</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"I jumped over the puddle. It was 12 feet!\"</span>.split(<span class=\"hljs-string\">\".\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">\"I jumped over the puddle\"</span>, <span class=\"hljs-string\">\"It was 12 feet!\"</span>]\n</code></pre>\n<p>结果是一个含有两个元素的列表：分别是句号前的所有字符组成的字符串，以及句号后所有字符组成的字符串。</p>\n<h3 id=\"69\">6.9　连接</h3>\n<p><code>join</code> 方法可以在字符串的每个字符间添加新字符：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h2pjkso</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  first_three = <span class=\"hljs-string\">\"abc\"</span>\n<span class=\"hljs-number\">5</span>  result = <span class=\"hljs-string\">\"+\"</span>.join(first_three)\n<span class=\"hljs-number\">6</span>  result\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'a+b+c'</span>\n</code></pre>\n<p>也可以在空字符串上调用 <code>join</code> 方法，传入一个字符串列表作为参数，从而将这些字符串连接为一个单一字符串：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z49e3up</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  words = [<span class=\"hljs-string\">\"The\"</span>,\n<span class=\"hljs-number\">05</span>           <span class=\"hljs-string\">\"fox\"</span>,\n<span class=\"hljs-number\">06</span>           <span class=\"hljs-string\">\"jumped\"</span>,\n<span class=\"hljs-number\">07</span>           <span class=\"hljs-string\">\"over\"</span>,\n08           <span class=\"hljs-string\">\"the\"</span>,\n09           <span class=\"hljs-string\">\"fence\"</span>,\n<span class=\"hljs-number\">10</span>           <span class=\"hljs-string\">\".\"</span>]\n<span class=\"hljs-number\">11</span>  one = <span class=\"hljs-string\">\"\"</span>.join(words)\n<span class=\"hljs-number\">12</span>  one\n\n<span class=\"hljs-meta\">&gt;&gt;</span> Thefoxjumpedoverthefence.\n</code></pre>\n<p>还可以在包含空格符的字符串上，调用 <code>join</code> 方法，创建一个所有单词均由空格符分隔的字符串：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h4qq5oy</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  words = [<span class=\"hljs-string\">\"The\"</span>,\n<span class=\"hljs-number\">05</span>           <span class=\"hljs-string\">\"fox\"</span>,\n<span class=\"hljs-number\">06</span>           <span class=\"hljs-string\">\"jumped\"</span>,\n<span class=\"hljs-number\">07</span>           <span class=\"hljs-string\">\"over\"</span>,\n08           <span class=\"hljs-string\">\"the\"</span>,\n09           <span class=\"hljs-string\">\"fence\"</span>,\n<span class=\"hljs-number\">10</span>           <span class=\"hljs-string\">\".\"</span>]\n<span class=\"hljs-number\">11</span>  one = <span class=\"hljs-string\">\" \"</span>.join(words)\n<span class=\"hljs-number\">12</span>  one\n\n<span class=\"hljs-meta\">&gt;&gt;</span> The fox jumped over the fence.\n</code></pre>\n<h3 id=\"610\">6.10　去除空格</h3>\n<p>可使用 <code>strip</code> 方法去除字符串开头和末尾的空白字符：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jfndhgx</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  s = <span class=\"hljs-string\">\"   The       \"</span>\n<span class=\"hljs-number\">5</span>  s = s.strip()\n<span class=\"hljs-number\">6</span>  s\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'The'</span>\n</code></pre>\n<h3 id=\"611\">6.11　替换</h3>\n<p>在 <code>replace</code> 方法中，第一个参数是要被替换的字符串，第二个参数是用来替换的字符串。可使用第二个字符串替换原字符串中所有与第一个字符串一样的内容。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zha4uwo</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  equ = <span class=\"hljs-string\">\"All animals are equal.\"</span>\n<span class=\"hljs-number\">5</span>  equ = equ.replace(<span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-string\">\"@\"</span>)\n<span class=\"hljs-number\">6</span>  print(equ)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> All @nim@ls @re equ@l.\n</code></pre>\n<h3 id=\"612\">6.12　查找索引</h3>\n<p>可使用 <code>index</code> 方法，获得字符串中某个字符第一次出现的索引。将希望查找的字符作为参数传入，<code>index</code> 方法可以返回该字符在字符串中第一次出现的索引：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hzc6asc</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"animals\"</span>.index(<span class=\"hljs-string\">\"m\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">3</span>\n</code></pre>\n<p>如果 <code>index</code> 方法没有找到匹配的结果，Python 会报告异常错误。如下所示：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jmtc984</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"animals\"</span>.index(<span class=\"hljs-string\">\"z\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-symbol\">ValueError:</span> substring not found\n</code></pre>\n<p>如果不确定是否有匹配的结果，可使用如下异常处理的方法：</p>\n<pre class=\"代码无行号\"><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zl6q4fd</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-keyword\">try</span></strong>:\n<span class=\"hljs-number\">5</span>      <span class=\"hljs-string\">\"animals\"</span>.index(<span class=\"hljs-string\">\"z\"</span>)\n<span class=\"hljs-number\">6</span>  <strong><span class=\"hljs-keyword\">except</span></strong>:\n<span class=\"hljs-number\">7</span>      print(<span class=\"hljs-string\">\"Not found.\"</span>)\n\n&gt;&gt; Not found.</code></pre>\n<h3 id=\"613in\">6.13　in 关键字</h3>\n<p>关键字 <code>in</code> 可检查某个字符串是否在另一个字符串中，返回结果为 <code>True</code> 或 <code>False</code>：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hsnygwz</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"Cat\"</span> <strong><span class=\"hljs-keyword\">in</span></strong> <span class=\"hljs-string\">\"Cat in the hat.\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z9b3e97</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"Bat\"</span> <strong><span class=\"hljs-keyword\">in</span></strong> <span class=\"hljs-string\">\"Cat in the hat.\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False</code></pre>\n<p>在 <code>in</code> 前面加上关键字 <code>not</code>，即可检查某个字符串是否不在另一个字符串中：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jz8sygd</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>  <span class=\"hljs-string\">\"Potter\"</span> <strong><span class=\"hljs-keyword\">not</span></strong> <strong><span class=\"hljs-keyword\">in</span></strong> <span class=\"hljs-string\">\"Harry\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<h3 id=\"614\">6.14　字符串转义</h3>\n<p>如果在字符串中使用了双引号，则会出现如下语法错误：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zj6hc4r</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-comment\"># 该段代码无法执行。</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>  <span class=\"hljs-string\">\"She said \"</span>Surely.<span class=\"hljs-string\">\"\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-symbol\">SyntaxError:</span> invalid syntax\n</code></pre>\n<p>在双引号前加上反斜杠，即可解决这个错误：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jdsrr7e</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"She said \\\"Surely.\\\"\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'She said \"Surely.\"'</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zr7o7d7</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">'She said \\\"Surely.\\\"'</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'She said \"Surely.\"'</span>\n</code></pre>\n<p>字符串<strong>转义</strong>（escaping），指的是在 Python 中有特殊意义的字符（上例中为双引号）前加上一个符号，告诉 Python 在本例中该符号代表的是一个字符，而没有特殊意义。在 Python 中用反斜杠进行转义。</p>\n<p>如果在字符串中使用单引号，而非双引号，则不需要进行转义：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hoef63o</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"She said 'Surely'\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">\"She said 'Surely'\"</span>\n</code></pre>\n<p>还可以在单引号中使用双引号，这比对双引号进行转义更加简单：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zkgfawo</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">'She said \"Surely.\"'</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'She said \"Surely.\"'</span>\n</code></pre>\n<h3 id=\"615\">6.15　换行符</h3>\n<p>在字符串中加入 <code>\\n</code> 来表示换行：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zyrhaeg</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  print(<span class=\"hljs-string\">\"line1\\nline2\\nline3\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> line1\n<span class=\"hljs-meta\">&gt;&gt;</span> line2\n<span class=\"hljs-meta\">&gt;&gt;</span> line3\n</code></pre>\n<h3 id=\"616\">6.16　切片</h3>\n<p><strong>切片</strong>（slicing）可将一个可迭代对象中元素的子集，创建为一个新的可迭代对象。切片的语法是<code>[可迭代对象][[起始索引:结束索引]]</code>。<strong>起始索引</strong>（start index）是开始切片的索引，<strong>结束索引</strong>（end index）是结束索引的位置。</p>\n<p>进行列表切片的示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h2rqj2a</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  fict = [<span class=\"hljs-string\">\"Tolstoy\"</span>,\n<span class=\"hljs-number\">5</span>          <span class=\"hljs-string\">\"Camus\"</span>,\n<span class=\"hljs-number\">6</span>          <span class=\"hljs-string\">\"Orwell\"</span>,\n<span class=\"hljs-number\">7</span>          <span class=\"hljs-string\">\"Huxley\"</span>,\n<span class=\"hljs-number\">8</span>          <span class=\"hljs-string\">\"Austin\"</span>]\n<span class=\"hljs-number\">9</span>  fict[<span class=\"hljs-number\">0</span><span class=\"hljs-symbol\">:</span><span class=\"hljs-number\">3</span>]\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'Tolstoy'</span>, <span class=\"hljs-string\">'Camus'</span>, <span class=\"hljs-string\">'Orwell'</span>]\n</code></pre>\n<p>切片时包含起始索引位置的元素，但不包括结束索引位置的元素。因此，如果要从 <code>\"Tolstoy\"</code>（索引为 0）切片到 <code>\"Orwell\"</code>（索引为 2），则需从索引 0 到索引 3 进行切片。</p>\n<p>字符串切片的示例如下：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hug9euj</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  ivan = <span class=\"hljs-string\">\"\"\"In place of death there was light.\"\"\"</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>  ivan[<span class=\"hljs-number\">0</span>:<span class=\"hljs-number\">17</span>]\n<span class=\"hljs-number\">8</span>  ivan[<span class=\"hljs-number\">17</span>:<span class=\"hljs-number\">33</span>]\n\n&gt;&gt; <span class=\"hljs-string\">'In place of death'</span>\n&gt;&gt; <span class=\"hljs-string\">' there was light.'</span>\n</code></pre>\n<p>如果起始索引是 0，那么可以将起始索引的位置留空：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/judcpx4</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  ivan = <span class=\"hljs-string\">\"\"\"In place of death there was light.\"\"\"</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>  ivan[:<span class=\"hljs-number\">17</span>]\n\n&gt;&gt; <span class=\"hljs-string\">'In place of death'</span>\n</code></pre>\n<p>如果结束索引是可迭代对象中最后一个元素的索引，那么可以将结束索引的位置留空：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zqoscn4</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  ivan = <span class=\"hljs-string\">\"\"\"In place of death there was light.\"\"\"</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>  ivan[<span class=\"hljs-number\">17</span>:]\n\n&gt;&gt; <span class=\"hljs-string\">' there was light.'</span>\n</code></pre>\n<p>起始索引和结束索引均留空，则会返回原可迭代对象：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zqvuqoc</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  ivan = <span class=\"hljs-string\">\"\"\"In place of death there was light.\"\"\"</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>  ivan[:]\n\n&gt;&gt; <span class=\"hljs-string\">\"In place of death there was light.\"</span>\n</code></pre>\n<h3 id=\"617\">6.17　术语表</h3>\n<p><strong>负索引</strong>：可用来从右向左查找可迭代对象中元素的索引（必须是一个负数）。</p>\n<p><strong>转义</strong>：在 Python 中具有特殊意义的字符（如双引号）前加上一个符号，告诉 Python 在本例中该字符代表的只是一个字符，没有特殊意义。</p>\n<p><strong>切片</strong>：将一个可迭代对象中元素的子集，创建为一个新的可迭代对象。</p>\n<p><strong>起始索引</strong>：开始切片的索引。</p>\n<p><strong>结束索引</strong>：结束切片的索引。</p>\n<h3 id=\"618\">6.18　挑战练习</h3>\n<p>1．打印字符串 <code>\"Camus\"</code> 中的所有字符。</p>\n<p>2．编写程序，从用户处获取两个字符串，将其插入字符串 <code>\"Yesterday I wrote a [用户输入1]. I sent it to [用户输入2]!\"</code> 中，并打印新字符串。</p>\n<p>3．想办法将字符串 <code>\"aldous Huxley was born in 1894.\"</code> 的第一个字符大写，从而使语法正确。</p>\n<p>4．对字符串 <code>\"Where now? Who now? When now?\"</code> 调用一个方法，返回如下述的列表 <code>[\"Where now?\", \"Who now?\", \"When now?\"]</code>。</p>\n<p>5．对列表 <code>[\"The\", \"fox\", \"jumped\", \"over\", \"the\", \"fence\", \".\"]</code> 进行处理，将其变成一个语法正确的字符串。每个单词间以空格符分隔，但是单词 <code>fence</code> 和句号之间不能有空格符。（别忘了，我们之前已经学过将字符串列表连接为单个字符串的方法。）</p>\n<p>6．将字符串 <code>\"A screaming comes across the sky.\"</code> 中所有的 <code>\"s\"</code> 字符替换为美元符号。</p>\n<p>7．找到字符串 <code>\"Hemingway\"</code> 中字符 <code>\"m\"</code> 所在的第一个索引。</p>\n<p>8．在你最喜欢的书中找一段对话，将其变成一个字符串。</p>\n<p>9．先后使用字符串拼接和字符串乘法，创建字符串 <code>\"three three three\"</code>。</p>\n<p>10．对字符串 <code>\"It was bright cold day in April, and the clocks were striking thirteen.\"</code> 进行切片，只保留逗号之前的字符。</p>\n<p>答案可从异步社区（www.epubit.com）本书详情页的配套资源中下载。</p></div></article>\n</body>\n</html>","source":"_posts/Python无师自通/strings.html","raw":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>字符串操作</title>\n</head>\n<body>\n<article id=\"articleDiv\"><div class=\"mazi-article-content dont-break-out\"><p></p><div class=\"toc\">\n<ul>\n<li><ul>\n<li><ul>\n<li><a href=\"#61\">6.1　三引号字符串</a></li>\n<li><a href=\"#62\">6.2　索引</a></li>\n<li><a href=\"#63\">6.3　字符串是不可变的</a></li>\n<li><a href=\"#64\">6.4　字符串拼接</a></li>\n<li><a href=\"#65\">6.5　字符串乘法</a></li>\n<li><a href=\"#66\">6.6　改变大小写</a></li>\n<li><a href=\"#67\">6.7　格式化</a></li>\n<li><a href=\"#68\">6.8　分割</a></li>\n<li><a href=\"#69\">6.9　连接</a></li>\n<li><a href=\"#610\">6.10　去除空格</a></li>\n<li><a href=\"#611\">6.11　替换</a></li>\n<li><a href=\"#612\">6.12　查找索引</a></li>\n<li><a href=\"#613in\">6.13　in 关键字</a></li>\n<li><a href=\"#614\">6.14　字符串转义</a></li>\n<li><a href=\"#615\">6.15　换行符</a></li>\n<li><a href=\"#616\">6.16　切片</a></li>\n<li><a href=\"#617\">6.17　术语表</a></li>\n<li><a href=\"#618\">6.18　挑战练习</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>\n<p></p>\n<blockquote>\n  <p><span style=\"font-family: Times New Roman,楷体_GB2312\">“理论上，理论和实践没有区别。但实践上，是有区别的。”</span></p>\n  <p><span style=\"font-family: Times New Roman,楷体_GB2312\">——简 · 范德斯奈普特（Jan L. A. van de Snepscheut）</span></p>\n</blockquote>\n<p>Python 自带操作字符串的功能，例如在指定位置将字符串分割为两部分，或者改变字符串的大小写。举个例子，假设有一个所有字符都是大写的字符串，现在希望将其全部改为小写，这通过 Python 可以轻松实现。在本章中，读者将学习更多有关字符串的知识，并掌握 Python 中操作字符串最有效的工具。</p>\n<h3 id=\"61\">6.1　三引号字符串</h3>\n<p>如果字符串跨越一行以上，可以使用三引号：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h59ygda</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"\"\" 第一行\n5      第二行\n6      第三行\n7  \"\"\"</span>\n</code></pre>\n<p>如果使用单引号或双引号定义一个跨行的字符串，Python 会报告语法错误。</p>\n<h3 id=\"62\">6.2　索引</h3>\n<p>与列表和元组一样，字符串也是可迭代的。可使用索引查找字符串中的每个字符。与其他可迭代对象一样，字符串中第一个字符所在的索引为 0，其后每个索引递增 1。</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zqqc2jw</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  author = <span class=\"hljs-string\">\"Kafka\"</span>\n<span class=\"hljs-number\">5</span>  author[<span class=\"hljs-number\">0</span>]\n<span class=\"hljs-number\">6</span>  author[<span class=\"hljs-number\">1</span>]\n<span class=\"hljs-number\">7</span>  author[<span class=\"hljs-number\">2</span>]\n<span class=\"hljs-number\">8</span>  author[<span class=\"hljs-number\">3</span>]\n<span class=\"hljs-number\">9</span>  author[<span class=\"hljs-number\">4</span>]\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'K'</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'a'</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'f'</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'k'</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'a'</span>\n</code></pre>\n<p>上述示例中，可使用索引 0、1、2、3、4 来查找字符串 <code>\"Kafka\"</code> 中的每个字符。如果查找的字符串索引大于最后一个索引的值，Python 会报告异常错误：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/zk52tef</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  author = <span class=\"hljs-string\">\"Kafka\"</span>\n<span class=\"hljs-number\">5</span>  author[<span class=\"hljs-number\">5</span>]\n\n&gt;&gt; IndexError: <span class=\"hljs-built_in\">string</span> index out of range\n</code></pre>\n<p>Python 还支持使用<strong>负索引（negative index）</strong>查找列表中的元素：可用来从右向左查找可迭代对象中元素的索引（必须是一个负数）。使用索引 <code>-1</code> 可以查找可迭代对象中的最后一个元素，示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hyju2t5</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  author = <span class=\"hljs-string\">\"Kafka\"</span>\n<span class=\"hljs-number\">5</span>  author[-<span class=\"hljs-number\">1</span>]\n\n<span class=\"hljs-meta\">&gt;&gt;</span> a\n</code></pre>\n<p>负索引 <code>-2</code> 查找的是倒数第二个元素，负索引 <code>-3</code> 查找的是倒数第三个元素，以此类推。</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jtpx7sr</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  author = <span class=\"hljs-string\">\"Kafka\"</span>\n<span class=\"hljs-number\">5</span>  author[-<span class=\"hljs-number\">2</span>]\n<span class=\"hljs-number\">6</span>  author[-<span class=\"hljs-number\">3</span>]\n\n<span class=\"hljs-meta\">&gt;&gt;</span> k\n<span class=\"hljs-meta\">&gt;&gt;</span> f\n</code></pre>\n<h3 id=\"63\">6.3　字符串是不可变的</h3>\n<p>字符串和元组一样都是不可变的，无法修改字符串中的字符。如果想要修改，就必须创建一个新的字符串：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hsr83lv</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  ff = <span class=\"hljs-string\">\"F.Fitzgerald\"</span>\n<span class=\"hljs-number\">5</span>  ff = <span class=\"hljs-string\">\"F. Scott Fitzgerald\"</span>\n<span class=\"hljs-number\">6</span>  ff\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'F. Scott Fitzgerald'</span>\n</code></pre>\n<p>Python 提供了多个从已有字符串中创建新字符串的方法，本章将逐一介绍。</p>\n<h3 id=\"64\">6.4　字符串拼接</h3>\n<p>可使用加法操作符，将两个或多个字符串组合在一起，结果就是由第一个字符串中的字符和其他字符串中的字符共同构成的一个新字符串。将字符串组合的做法，被称为字符串拼接。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h4z5mlg</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"cat\"</span> + <span class=\"hljs-string\">\"in\"</span> + <span class=\"hljs-string\">\"hat\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'catinhat'</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gsrajle</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"cat\"</span> + <span class=\"hljs-string\">\" in\"</span> + <span class=\"hljs-string\">\" the\"</span> + <span class=\"hljs-string\">\" hat\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'cat in the hat'</span>\n</code></pre>\n<h3 id=\"65\">6.5　字符串乘法</h3>\n<p>可使用乘法操作符，将字符串与数字相乘。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zvm9gng</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"Sawyer\"</span> * <span class=\"hljs-number\">3</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> SawyerSawyerSawyer\n</code></pre>\n<h3 id=\"66\">6.6　改变大小写</h3>\n<p>可使用字符串的 <code>upper</code> 方法，将字符串中的每个字符改为大写。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hhancz6</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"We hold these truths...\"</span>.upper()\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'WE HOLD THESE TRUTHS...'</span>\n</code></pre>\n<p>类似地，可使用字符串的 <code>lower</code> 方法将字符串中的每个字符改为小写。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zkz48u5</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"SO IT GOES.\"</span>.lower()\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'so it goes.'</span>\n</code></pre>\n<p>还可使用字符串的 <code>capitalize</code> 方法，将字符串的首字母改为大写。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jp5hexn</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"four score and...\"</span>.capitalize()\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'Four score and...'</span>\n</code></pre>\n<h3 id=\"67\">6.7　格式化</h3>\n<p>可使用 <code>format</code> 方法创建新字符串，该方法会把字符串中的“<code>{}</code>”替换为传入的字符串：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/juvguy8</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"William {}\"</span>.format(<span class=\"hljs-string\">\"Faulkner\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'William Faulkner'</span>\n</code></pre>\n<p>也可以把变量作为参数传递：</p>\n<pre><code class=\"hljs perl\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zcpt9se</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-keyword\">last</span> = <span class=\"hljs-string\">\"Faulkner\"</span>\n<span class=\"hljs-number\">5</span>  <span class=\"hljs-string\">\"William {}\"</span>.format(<span class=\"hljs-keyword\">last</span>)\n\n&gt;&gt; <span class=\"hljs-string\">'William Faulkner'</span>\n</code></pre>\n<p>花括号可重复使用：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z6t6d8n</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  author = <span class=\"hljs-string\">\"William Faulkner\"</span>\n<span class=\"hljs-number\">5</span>  year_born = <span class=\"hljs-string\">\"1897\"</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  <span class=\"hljs-string\">\"{} was born in {}.\"</span>.format(author, year_born)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'William Faulkner was born in 1897.'</span>\n</code></pre>\n<p>如果要根据用户输入来创建字符串，<code>format</code> 方法很有用。示例如下：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gnrdsj9</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  n1 = input(<span class=\"hljs-string\">\"Enter a noun:\"</span>)\n<span class=\"hljs-number\">05</span>  v = input(<span class=\"hljs-string\">\"Enter a verb:\"</span>)\n<span class=\"hljs-number\">06</span>  adj = input(<span class=\"hljs-string\">\"Enter an adj:\"</span>)\n<span class=\"hljs-number\">07</span>  n2 = input(<span class=\"hljs-string\">\"Enter a noun:\"</span>)\n<span class=\"hljs-number\">08</span>\n<span class=\"hljs-number\">09</span>\n<span class=\"hljs-number\">10</span>  r = <span class=\"hljs-string\">\"\"\"The {} {} the {} {}\n11      \"\"\"</span>.format(n1,\n<span class=\"hljs-number\">12</span>                 v,\n<span class=\"hljs-number\">13</span>                 adj,\n<span class=\"hljs-number\">14</span>                 n2)\n<span class=\"hljs-number\">15</span>  print(r)\n\n&gt;&gt; Enter a noun:\n</code></pre>\n<p>程序让用户输入两个名词、一个动词和一个形容词，然后通过 <code>fomrat</code> 方法将这些输入创建为一个字符串并打印出来。</p>\n<h3 id=\"68\">6.8　分割</h3>\n<p>字符串有一个叫 <code>split</code> 的方法，可用来将字符串分割为两个或多个字符串。需要传入一个字符串作为 <code>split</code> 方法的参数，并用其将原字符串分割为多个字符串。例如，可以传入句号作为 <code>split</code> 方法的参数，将字符串 <code>\"I jumped over the puddle. It was 12 feet!\"</code> 分割成两个不同的字符串。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/he8u28o</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"I jumped over the puddle. It was 12 feet!\"</span>.split(<span class=\"hljs-string\">\".\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">\"I jumped over the puddle\"</span>, <span class=\"hljs-string\">\"It was 12 feet!\"</span>]\n</code></pre>\n<p>结果是一个含有两个元素的列表：分别是句号前的所有字符组成的字符串，以及句号后所有字符组成的字符串。</p>\n<h3 id=\"69\">6.9　连接</h3>\n<p><code>join</code> 方法可以在字符串的每个字符间添加新字符：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h2pjkso</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  first_three = <span class=\"hljs-string\">\"abc\"</span>\n<span class=\"hljs-number\">5</span>  result = <span class=\"hljs-string\">\"+\"</span>.join(first_three)\n<span class=\"hljs-number\">6</span>  result\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'a+b+c'</span>\n</code></pre>\n<p>也可以在空字符串上调用 <code>join</code> 方法，传入一个字符串列表作为参数，从而将这些字符串连接为一个单一字符串：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z49e3up</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  words = [<span class=\"hljs-string\">\"The\"</span>,\n<span class=\"hljs-number\">05</span>           <span class=\"hljs-string\">\"fox\"</span>,\n<span class=\"hljs-number\">06</span>           <span class=\"hljs-string\">\"jumped\"</span>,\n<span class=\"hljs-number\">07</span>           <span class=\"hljs-string\">\"over\"</span>,\n08           <span class=\"hljs-string\">\"the\"</span>,\n09           <span class=\"hljs-string\">\"fence\"</span>,\n<span class=\"hljs-number\">10</span>           <span class=\"hljs-string\">\".\"</span>]\n<span class=\"hljs-number\">11</span>  one = <span class=\"hljs-string\">\"\"</span>.join(words)\n<span class=\"hljs-number\">12</span>  one\n\n<span class=\"hljs-meta\">&gt;&gt;</span> Thefoxjumpedoverthefence.\n</code></pre>\n<p>还可以在包含空格符的字符串上，调用 <code>join</code> 方法，创建一个所有单词均由空格符分隔的字符串：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h4qq5oy</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  words = [<span class=\"hljs-string\">\"The\"</span>,\n<span class=\"hljs-number\">05</span>           <span class=\"hljs-string\">\"fox\"</span>,\n<span class=\"hljs-number\">06</span>           <span class=\"hljs-string\">\"jumped\"</span>,\n<span class=\"hljs-number\">07</span>           <span class=\"hljs-string\">\"over\"</span>,\n08           <span class=\"hljs-string\">\"the\"</span>,\n09           <span class=\"hljs-string\">\"fence\"</span>,\n<span class=\"hljs-number\">10</span>           <span class=\"hljs-string\">\".\"</span>]\n<span class=\"hljs-number\">11</span>  one = <span class=\"hljs-string\">\" \"</span>.join(words)\n<span class=\"hljs-number\">12</span>  one\n\n<span class=\"hljs-meta\">&gt;&gt;</span> The fox jumped over the fence.\n</code></pre>\n<h3 id=\"610\">6.10　去除空格</h3>\n<p>可使用 <code>strip</code> 方法去除字符串开头和末尾的空白字符：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jfndhgx</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  s = <span class=\"hljs-string\">\"   The       \"</span>\n<span class=\"hljs-number\">5</span>  s = s.strip()\n<span class=\"hljs-number\">6</span>  s\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'The'</span>\n</code></pre>\n<h3 id=\"611\">6.11　替换</h3>\n<p>在 <code>replace</code> 方法中，第一个参数是要被替换的字符串，第二个参数是用来替换的字符串。可使用第二个字符串替换原字符串中所有与第一个字符串一样的内容。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zha4uwo</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  equ = <span class=\"hljs-string\">\"All animals are equal.\"</span>\n<span class=\"hljs-number\">5</span>  equ = equ.replace(<span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-string\">\"@\"</span>)\n<span class=\"hljs-number\">6</span>  print(equ)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> All @nim@ls @re equ@l.\n</code></pre>\n<h3 id=\"612\">6.12　查找索引</h3>\n<p>可使用 <code>index</code> 方法，获得字符串中某个字符第一次出现的索引。将希望查找的字符作为参数传入，<code>index</code> 方法可以返回该字符在字符串中第一次出现的索引：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hzc6asc</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"animals\"</span>.index(<span class=\"hljs-string\">\"m\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">3</span>\n</code></pre>\n<p>如果 <code>index</code> 方法没有找到匹配的结果，Python 会报告异常错误。如下所示：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jmtc984</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"animals\"</span>.index(<span class=\"hljs-string\">\"z\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-symbol\">ValueError:</span> substring not found\n</code></pre>\n<p>如果不确定是否有匹配的结果，可使用如下异常处理的方法：</p>\n<pre class=\"代码无行号\"><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zl6q4fd</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-keyword\">try</span></strong>:\n<span class=\"hljs-number\">5</span>      <span class=\"hljs-string\">\"animals\"</span>.index(<span class=\"hljs-string\">\"z\"</span>)\n<span class=\"hljs-number\">6</span>  <strong><span class=\"hljs-keyword\">except</span></strong>:\n<span class=\"hljs-number\">7</span>      print(<span class=\"hljs-string\">\"Not found.\"</span>)\n\n&gt;&gt; Not found.</code></pre>\n<h3 id=\"613in\">6.13　in 关键字</h3>\n<p>关键字 <code>in</code> 可检查某个字符串是否在另一个字符串中，返回结果为 <code>True</code> 或 <code>False</code>：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hsnygwz</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"Cat\"</span> <strong><span class=\"hljs-keyword\">in</span></strong> <span class=\"hljs-string\">\"Cat in the hat.\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z9b3e97</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"Bat\"</span> <strong><span class=\"hljs-keyword\">in</span></strong> <span class=\"hljs-string\">\"Cat in the hat.\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False</code></pre>\n<p>在 <code>in</code> 前面加上关键字 <code>not</code>，即可检查某个字符串是否不在另一个字符串中：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jz8sygd</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>  <span class=\"hljs-string\">\"Potter\"</span> <strong><span class=\"hljs-keyword\">not</span></strong> <strong><span class=\"hljs-keyword\">in</span></strong> <span class=\"hljs-string\">\"Harry\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<h3 id=\"614\">6.14　字符串转义</h3>\n<p>如果在字符串中使用了双引号，则会出现如下语法错误：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zj6hc4r</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-comment\"># 该段代码无法执行。</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>  <span class=\"hljs-string\">\"She said \"</span>Surely.<span class=\"hljs-string\">\"\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-symbol\">SyntaxError:</span> invalid syntax\n</code></pre>\n<p>在双引号前加上反斜杠，即可解决这个错误：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jdsrr7e</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"She said \\\"Surely.\\\"\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'She said \"Surely.\"'</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zr7o7d7</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">'She said \\\"Surely.\\\"'</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'She said \"Surely.\"'</span>\n</code></pre>\n<p>字符串<strong>转义</strong>（escaping），指的是在 Python 中有特殊意义的字符（上例中为双引号）前加上一个符号，告诉 Python 在本例中该符号代表的是一个字符，而没有特殊意义。在 Python 中用反斜杠进行转义。</p>\n<p>如果在字符串中使用单引号，而非双引号，则不需要进行转义：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hoef63o</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"She said 'Surely'\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">\"She said 'Surely'\"</span>\n</code></pre>\n<p>还可以在单引号中使用双引号，这比对双引号进行转义更加简单：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zkgfawo</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">'She said \"Surely.\"'</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'She said \"Surely.\"'</span>\n</code></pre>\n<h3 id=\"615\">6.15　换行符</h3>\n<p>在字符串中加入 <code>\\n</code> 来表示换行：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zyrhaeg</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  print(<span class=\"hljs-string\">\"line1\\nline2\\nline3\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> line1\n<span class=\"hljs-meta\">&gt;&gt;</span> line2\n<span class=\"hljs-meta\">&gt;&gt;</span> line3\n</code></pre>\n<h3 id=\"616\">6.16　切片</h3>\n<p><strong>切片</strong>（slicing）可将一个可迭代对象中元素的子集，创建为一个新的可迭代对象。切片的语法是<code>[可迭代对象][[起始索引:结束索引]]</code>。<strong>起始索引</strong>（start index）是开始切片的索引，<strong>结束索引</strong>（end index）是结束索引的位置。</p>\n<p>进行列表切片的示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h2rqj2a</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  fict = [<span class=\"hljs-string\">\"Tolstoy\"</span>,\n<span class=\"hljs-number\">5</span>          <span class=\"hljs-string\">\"Camus\"</span>,\n<span class=\"hljs-number\">6</span>          <span class=\"hljs-string\">\"Orwell\"</span>,\n<span class=\"hljs-number\">7</span>          <span class=\"hljs-string\">\"Huxley\"</span>,\n<span class=\"hljs-number\">8</span>          <span class=\"hljs-string\">\"Austin\"</span>]\n<span class=\"hljs-number\">9</span>  fict[<span class=\"hljs-number\">0</span><span class=\"hljs-symbol\">:</span><span class=\"hljs-number\">3</span>]\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'Tolstoy'</span>, <span class=\"hljs-string\">'Camus'</span>, <span class=\"hljs-string\">'Orwell'</span>]\n</code></pre>\n<p>切片时包含起始索引位置的元素，但不包括结束索引位置的元素。因此，如果要从 <code>\"Tolstoy\"</code>（索引为 0）切片到 <code>\"Orwell\"</code>（索引为 2），则需从索引 0 到索引 3 进行切片。</p>\n<p>字符串切片的示例如下：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hug9euj</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  ivan = <span class=\"hljs-string\">\"\"\"In place of death there was light.\"\"\"</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>  ivan[<span class=\"hljs-number\">0</span>:<span class=\"hljs-number\">17</span>]\n<span class=\"hljs-number\">8</span>  ivan[<span class=\"hljs-number\">17</span>:<span class=\"hljs-number\">33</span>]\n\n&gt;&gt; <span class=\"hljs-string\">'In place of death'</span>\n&gt;&gt; <span class=\"hljs-string\">' there was light.'</span>\n</code></pre>\n<p>如果起始索引是 0，那么可以将起始索引的位置留空：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/judcpx4</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  ivan = <span class=\"hljs-string\">\"\"\"In place of death there was light.\"\"\"</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>  ivan[:<span class=\"hljs-number\">17</span>]\n\n&gt;&gt; <span class=\"hljs-string\">'In place of death'</span>\n</code></pre>\n<p>如果结束索引是可迭代对象中最后一个元素的索引，那么可以将结束索引的位置留空：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zqoscn4</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  ivan = <span class=\"hljs-string\">\"\"\"In place of death there was light.\"\"\"</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>  ivan[<span class=\"hljs-number\">17</span>:]\n\n&gt;&gt; <span class=\"hljs-string\">' there was light.'</span>\n</code></pre>\n<p>起始索引和结束索引均留空，则会返回原可迭代对象：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zqvuqoc</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  ivan = <span class=\"hljs-string\">\"\"\"In place of death there was light.\"\"\"</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>  ivan[:]\n\n&gt;&gt; <span class=\"hljs-string\">\"In place of death there was light.\"</span>\n</code></pre>\n<h3 id=\"617\">6.17　术语表</h3>\n<p><strong>负索引</strong>：可用来从右向左查找可迭代对象中元素的索引（必须是一个负数）。</p>\n<p><strong>转义</strong>：在 Python 中具有特殊意义的字符（如双引号）前加上一个符号，告诉 Python 在本例中该字符代表的只是一个字符，没有特殊意义。</p>\n<p><strong>切片</strong>：将一个可迭代对象中元素的子集，创建为一个新的可迭代对象。</p>\n<p><strong>起始索引</strong>：开始切片的索引。</p>\n<p><strong>结束索引</strong>：结束切片的索引。</p>\n<h3 id=\"618\">6.18　挑战练习</h3>\n<p>1．打印字符串 <code>\"Camus\"</code> 中的所有字符。</p>\n<p>2．编写程序，从用户处获取两个字符串，将其插入字符串 <code>\"Yesterday I wrote a [用户输入1]. I sent it to [用户输入2]!\"</code> 中，并打印新字符串。</p>\n<p>3．想办法将字符串 <code>\"aldous Huxley was born in 1894.\"</code> 的第一个字符大写，从而使语法正确。</p>\n<p>4．对字符串 <code>\"Where now? Who now? When now?\"</code> 调用一个方法，返回如下述的列表 <code>[\"Where now?\", \"Who now?\", \"When now?\"]</code>。</p>\n<p>5．对列表 <code>[\"The\", \"fox\", \"jumped\", \"over\", \"the\", \"fence\", \".\"]</code> 进行处理，将其变成一个语法正确的字符串。每个单词间以空格符分隔，但是单词 <code>fence</code> 和句号之间不能有空格符。（别忘了，我们之前已经学过将字符串列表连接为单个字符串的方法。）</p>\n<p>6．将字符串 <code>\"A screaming comes across the sky.\"</code> 中所有的 <code>\"s\"</code> 字符替换为美元符号。</p>\n<p>7．找到字符串 <code>\"Hemingway\"</code> 中字符 <code>\"m\"</code> 所在的第一个索引。</p>\n<p>8．在你最喜欢的书中找一段对话，将其变成一个字符串。</p>\n<p>9．先后使用字符串拼接和字符串乘法，创建字符串 <code>\"three three three\"</code>。</p>\n<p>10．对字符串 <code>\"It was bright cold day in April, and the clocks were striking thirteen.\"</code> 进行切片，只保留逗号之前的字符。</p>\n<p>答案可从异步社区（www.epubit.com）本书详情页的配套资源中下载。</p></div></article>\n</body>\n</html>","slug":"Python无师自通/strings","published":1,"date":"2019-06-04T04:53:17.835Z","updated":"2019-06-04T04:53:17.835Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwhbvhq700019zh77k9hkpam","content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head><meta name=\"generator\" content=\"Hexo 3.8.0\">\n    <meta charset=\"UTF-8\">\n    <title>字符串操作</title>\n</head>\n<body>\n<article id=\"articleDiv\"><div class=\"mazi-article-content dont-break-out\"><p></p><div class=\"toc\">\n<ul>\n<li><ul>\n<li><ul>\n<li><a href=\"#61\">6.1　三引号字符串</a></li>\n<li><a href=\"#62\">6.2　索引</a></li>\n<li><a href=\"#63\">6.3　字符串是不可变的</a></li>\n<li><a href=\"#64\">6.4　字符串拼接</a></li>\n<li><a href=\"#65\">6.5　字符串乘法</a></li>\n<li><a href=\"#66\">6.6　改变大小写</a></li>\n<li><a href=\"#67\">6.7　格式化</a></li>\n<li><a href=\"#68\">6.8　分割</a></li>\n<li><a href=\"#69\">6.9　连接</a></li>\n<li><a href=\"#610\">6.10　去除空格</a></li>\n<li><a href=\"#611\">6.11　替换</a></li>\n<li><a href=\"#612\">6.12　查找索引</a></li>\n<li><a href=\"#613in\">6.13　in 关键字</a></li>\n<li><a href=\"#614\">6.14　字符串转义</a></li>\n<li><a href=\"#615\">6.15　换行符</a></li>\n<li><a href=\"#616\">6.16　切片</a></li>\n<li><a href=\"#617\">6.17　术语表</a></li>\n<li><a href=\"#618\">6.18　挑战练习</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>\n<p></p>\n<blockquote>\n  <p><span style=\"font-family: Times New Roman,楷体_GB2312\">“理论上，理论和实践没有区别。但实践上，是有区别的。”</span></p>\n  <p><span style=\"font-family: Times New Roman,楷体_GB2312\">——简 · 范德斯奈普特（Jan L. A. van de Snepscheut）</span></p>\n</blockquote>\n<p>Python 自带操作字符串的功能，例如在指定位置将字符串分割为两部分，或者改变字符串的大小写。举个例子，假设有一个所有字符都是大写的字符串，现在希望将其全部改为小写，这通过 Python 可以轻松实现。在本章中，读者将学习更多有关字符串的知识，并掌握 Python 中操作字符串最有效的工具。</p>\n<h3 id=\"61\">6.1　三引号字符串</h3>\n<p>如果字符串跨越一行以上，可以使用三引号：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h59ygda</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"\"\" 第一行\n5      第二行\n6      第三行\n7  \"\"\"</span>\n</code></pre>\n<p>如果使用单引号或双引号定义一个跨行的字符串，Python 会报告语法错误。</p>\n<h3 id=\"62\">6.2　索引</h3>\n<p>与列表和元组一样，字符串也是可迭代的。可使用索引查找字符串中的每个字符。与其他可迭代对象一样，字符串中第一个字符所在的索引为 0，其后每个索引递增 1。</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zqqc2jw</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  author = <span class=\"hljs-string\">\"Kafka\"</span>\n<span class=\"hljs-number\">5</span>  author[<span class=\"hljs-number\">0</span>]\n<span class=\"hljs-number\">6</span>  author[<span class=\"hljs-number\">1</span>]\n<span class=\"hljs-number\">7</span>  author[<span class=\"hljs-number\">2</span>]\n<span class=\"hljs-number\">8</span>  author[<span class=\"hljs-number\">3</span>]\n<span class=\"hljs-number\">9</span>  author[<span class=\"hljs-number\">4</span>]\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'K'</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'a'</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'f'</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'k'</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'a'</span>\n</code></pre>\n<p>上述示例中，可使用索引 0、1、2、3、4 来查找字符串 <code>\"Kafka\"</code> 中的每个字符。如果查找的字符串索引大于最后一个索引的值，Python 会报告异常错误：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/zk52tef</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  author = <span class=\"hljs-string\">\"Kafka\"</span>\n<span class=\"hljs-number\">5</span>  author[<span class=\"hljs-number\">5</span>]\n\n&gt;&gt; IndexError: <span class=\"hljs-built_in\">string</span> index out of range\n</code></pre>\n<p>Python 还支持使用<strong>负索引（negative index）</strong>查找列表中的元素：可用来从右向左查找可迭代对象中元素的索引（必须是一个负数）。使用索引 <code>-1</code> 可以查找可迭代对象中的最后一个元素，示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hyju2t5</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  author = <span class=\"hljs-string\">\"Kafka\"</span>\n<span class=\"hljs-number\">5</span>  author[-<span class=\"hljs-number\">1</span>]\n\n<span class=\"hljs-meta\">&gt;&gt;</span> a\n</code></pre>\n<p>负索引 <code>-2</code> 查找的是倒数第二个元素，负索引 <code>-3</code> 查找的是倒数第三个元素，以此类推。</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jtpx7sr</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  author = <span class=\"hljs-string\">\"Kafka\"</span>\n<span class=\"hljs-number\">5</span>  author[-<span class=\"hljs-number\">2</span>]\n<span class=\"hljs-number\">6</span>  author[-<span class=\"hljs-number\">3</span>]\n\n<span class=\"hljs-meta\">&gt;&gt;</span> k\n<span class=\"hljs-meta\">&gt;&gt;</span> f\n</code></pre>\n<h3 id=\"63\">6.3　字符串是不可变的</h3>\n<p>字符串和元组一样都是不可变的，无法修改字符串中的字符。如果想要修改，就必须创建一个新的字符串：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hsr83lv</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  ff = <span class=\"hljs-string\">\"F.Fitzgerald\"</span>\n<span class=\"hljs-number\">5</span>  ff = <span class=\"hljs-string\">\"F. Scott Fitzgerald\"</span>\n<span class=\"hljs-number\">6</span>  ff\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'F. Scott Fitzgerald'</span>\n</code></pre>\n<p>Python 提供了多个从已有字符串中创建新字符串的方法，本章将逐一介绍。</p>\n<h3 id=\"64\">6.4　字符串拼接</h3>\n<p>可使用加法操作符，将两个或多个字符串组合在一起，结果就是由第一个字符串中的字符和其他字符串中的字符共同构成的一个新字符串。将字符串组合的做法，被称为字符串拼接。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h4z5mlg</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"cat\"</span> + <span class=\"hljs-string\">\"in\"</span> + <span class=\"hljs-string\">\"hat\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'catinhat'</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gsrajle</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"cat\"</span> + <span class=\"hljs-string\">\" in\"</span> + <span class=\"hljs-string\">\" the\"</span> + <span class=\"hljs-string\">\" hat\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'cat in the hat'</span>\n</code></pre>\n<h3 id=\"65\">6.5　字符串乘法</h3>\n<p>可使用乘法操作符，将字符串与数字相乘。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zvm9gng</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"Sawyer\"</span> * <span class=\"hljs-number\">3</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> SawyerSawyerSawyer\n</code></pre>\n<h3 id=\"66\">6.6　改变大小写</h3>\n<p>可使用字符串的 <code>upper</code> 方法，将字符串中的每个字符改为大写。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hhancz6</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"We hold these truths...\"</span>.upper()\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'WE HOLD THESE TRUTHS...'</span>\n</code></pre>\n<p>类似地，可使用字符串的 <code>lower</code> 方法将字符串中的每个字符改为小写。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zkz48u5</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"SO IT GOES.\"</span>.lower()\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'so it goes.'</span>\n</code></pre>\n<p>还可使用字符串的 <code>capitalize</code> 方法，将字符串的首字母改为大写。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jp5hexn</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"four score and...\"</span>.capitalize()\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'Four score and...'</span>\n</code></pre>\n<h3 id=\"67\">6.7　格式化</h3>\n<p>可使用 <code>format</code> 方法创建新字符串，该方法会把字符串中的“<code>{}</code>”替换为传入的字符串：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/juvguy8</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"William {}\"</span>.format(<span class=\"hljs-string\">\"Faulkner\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'William Faulkner'</span>\n</code></pre>\n<p>也可以把变量作为参数传递：</p>\n<pre><code class=\"hljs perl\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zcpt9se</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-keyword\">last</span> = <span class=\"hljs-string\">\"Faulkner\"</span>\n<span class=\"hljs-number\">5</span>  <span class=\"hljs-string\">\"William {}\"</span>.format(<span class=\"hljs-keyword\">last</span>)\n\n&gt;&gt; <span class=\"hljs-string\">'William Faulkner'</span>\n</code></pre>\n<p>花括号可重复使用：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z6t6d8n</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  author = <span class=\"hljs-string\">\"William Faulkner\"</span>\n<span class=\"hljs-number\">5</span>  year_born = <span class=\"hljs-string\">\"1897\"</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  <span class=\"hljs-string\">\"{} was born in {}.\"</span>.format(author, year_born)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'William Faulkner was born in 1897.'</span>\n</code></pre>\n<p>如果要根据用户输入来创建字符串，<code>format</code> 方法很有用。示例如下：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gnrdsj9</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  n1 = input(<span class=\"hljs-string\">\"Enter a noun:\"</span>)\n<span class=\"hljs-number\">05</span>  v = input(<span class=\"hljs-string\">\"Enter a verb:\"</span>)\n<span class=\"hljs-number\">06</span>  adj = input(<span class=\"hljs-string\">\"Enter an adj:\"</span>)\n<span class=\"hljs-number\">07</span>  n2 = input(<span class=\"hljs-string\">\"Enter a noun:\"</span>)\n<span class=\"hljs-number\">08</span>\n<span class=\"hljs-number\">09</span>\n<span class=\"hljs-number\">10</span>  r = <span class=\"hljs-string\">\"\"\"The {} {} the {} {}\n11      \"\"\"</span>.format(n1,\n<span class=\"hljs-number\">12</span>                 v,\n<span class=\"hljs-number\">13</span>                 adj,\n<span class=\"hljs-number\">14</span>                 n2)\n<span class=\"hljs-number\">15</span>  print(r)\n\n&gt;&gt; Enter a noun:\n</code></pre>\n<p>程序让用户输入两个名词、一个动词和一个形容词，然后通过 <code>fomrat</code> 方法将这些输入创建为一个字符串并打印出来。</p>\n<h3 id=\"68\">6.8　分割</h3>\n<p>字符串有一个叫 <code>split</code> 的方法，可用来将字符串分割为两个或多个字符串。需要传入一个字符串作为 <code>split</code> 方法的参数，并用其将原字符串分割为多个字符串。例如，可以传入句号作为 <code>split</code> 方法的参数，将字符串 <code>\"I jumped over the puddle. It was 12 feet!\"</code> 分割成两个不同的字符串。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/he8u28o</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"I jumped over the puddle. It was 12 feet!\"</span>.split(<span class=\"hljs-string\">\".\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">\"I jumped over the puddle\"</span>, <span class=\"hljs-string\">\"It was 12 feet!\"</span>]\n</code></pre>\n<p>结果是一个含有两个元素的列表：分别是句号前的所有字符组成的字符串，以及句号后所有字符组成的字符串。</p>\n<h3 id=\"69\">6.9　连接</h3>\n<p><code>join</code> 方法可以在字符串的每个字符间添加新字符：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h2pjkso</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  first_three = <span class=\"hljs-string\">\"abc\"</span>\n<span class=\"hljs-number\">5</span>  result = <span class=\"hljs-string\">\"+\"</span>.join(first_three)\n<span class=\"hljs-number\">6</span>  result\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'a+b+c'</span>\n</code></pre>\n<p>也可以在空字符串上调用 <code>join</code> 方法，传入一个字符串列表作为参数，从而将这些字符串连接为一个单一字符串：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z49e3up</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  words = [<span class=\"hljs-string\">\"The\"</span>,\n<span class=\"hljs-number\">05</span>           <span class=\"hljs-string\">\"fox\"</span>,\n<span class=\"hljs-number\">06</span>           <span class=\"hljs-string\">\"jumped\"</span>,\n<span class=\"hljs-number\">07</span>           <span class=\"hljs-string\">\"over\"</span>,\n08           <span class=\"hljs-string\">\"the\"</span>,\n09           <span class=\"hljs-string\">\"fence\"</span>,\n<span class=\"hljs-number\">10</span>           <span class=\"hljs-string\">\".\"</span>]\n<span class=\"hljs-number\">11</span>  one = <span class=\"hljs-string\">\"\"</span>.join(words)\n<span class=\"hljs-number\">12</span>  one\n\n<span class=\"hljs-meta\">&gt;&gt;</span> Thefoxjumpedoverthefence.\n</code></pre>\n<p>还可以在包含空格符的字符串上，调用 <code>join</code> 方法，创建一个所有单词均由空格符分隔的字符串：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h4qq5oy</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  words = [<span class=\"hljs-string\">\"The\"</span>,\n<span class=\"hljs-number\">05</span>           <span class=\"hljs-string\">\"fox\"</span>,\n<span class=\"hljs-number\">06</span>           <span class=\"hljs-string\">\"jumped\"</span>,\n<span class=\"hljs-number\">07</span>           <span class=\"hljs-string\">\"over\"</span>,\n08           <span class=\"hljs-string\">\"the\"</span>,\n09           <span class=\"hljs-string\">\"fence\"</span>,\n<span class=\"hljs-number\">10</span>           <span class=\"hljs-string\">\".\"</span>]\n<span class=\"hljs-number\">11</span>  one = <span class=\"hljs-string\">\" \"</span>.join(words)\n<span class=\"hljs-number\">12</span>  one\n\n<span class=\"hljs-meta\">&gt;&gt;</span> The fox jumped over the fence.\n</code></pre>\n<h3 id=\"610\">6.10　去除空格</h3>\n<p>可使用 <code>strip</code> 方法去除字符串开头和末尾的空白字符：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jfndhgx</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  s = <span class=\"hljs-string\">\"   The       \"</span>\n<span class=\"hljs-number\">5</span>  s = s.strip()\n<span class=\"hljs-number\">6</span>  s\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'The'</span>\n</code></pre>\n<h3 id=\"611\">6.11　替换</h3>\n<p>在 <code>replace</code> 方法中，第一个参数是要被替换的字符串，第二个参数是用来替换的字符串。可使用第二个字符串替换原字符串中所有与第一个字符串一样的内容。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zha4uwo</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  equ = <span class=\"hljs-string\">\"All animals are equal.\"</span>\n<span class=\"hljs-number\">5</span>  equ = equ.replace(<span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-string\">\"@\"</span>)\n<span class=\"hljs-number\">6</span>  print(equ)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> All @nim@ls @re equ@l.\n</code></pre>\n<h3 id=\"612\">6.12　查找索引</h3>\n<p>可使用 <code>index</code> 方法，获得字符串中某个字符第一次出现的索引。将希望查找的字符作为参数传入，<code>index</code> 方法可以返回该字符在字符串中第一次出现的索引：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hzc6asc</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"animals\"</span>.index(<span class=\"hljs-string\">\"m\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">3</span>\n</code></pre>\n<p>如果 <code>index</code> 方法没有找到匹配的结果，Python 会报告异常错误。如下所示：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jmtc984</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"animals\"</span>.index(<span class=\"hljs-string\">\"z\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-symbol\">ValueError:</span> substring not found\n</code></pre>\n<p>如果不确定是否有匹配的结果，可使用如下异常处理的方法：</p>\n<pre class=\"代码无行号\"><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zl6q4fd</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-keyword\">try</span></strong>:\n<span class=\"hljs-number\">5</span>      <span class=\"hljs-string\">\"animals\"</span>.index(<span class=\"hljs-string\">\"z\"</span>)\n<span class=\"hljs-number\">6</span>  <strong><span class=\"hljs-keyword\">except</span></strong>:\n<span class=\"hljs-number\">7</span>      print(<span class=\"hljs-string\">\"Not found.\"</span>)\n\n&gt;&gt; Not found.</code></pre>\n<h3 id=\"613in\">6.13　in 关键字</h3>\n<p>关键字 <code>in</code> 可检查某个字符串是否在另一个字符串中，返回结果为 <code>True</code> 或 <code>False</code>：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hsnygwz</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"Cat\"</span> <strong><span class=\"hljs-keyword\">in</span></strong> <span class=\"hljs-string\">\"Cat in the hat.\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z9b3e97</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"Bat\"</span> <strong><span class=\"hljs-keyword\">in</span></strong> <span class=\"hljs-string\">\"Cat in the hat.\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False</code></pre>\n<p>在 <code>in</code> 前面加上关键字 <code>not</code>，即可检查某个字符串是否不在另一个字符串中：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jz8sygd</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>  <span class=\"hljs-string\">\"Potter\"</span> <strong><span class=\"hljs-keyword\">not</span></strong> <strong><span class=\"hljs-keyword\">in</span></strong> <span class=\"hljs-string\">\"Harry\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<h3 id=\"614\">6.14　字符串转义</h3>\n<p>如果在字符串中使用了双引号，则会出现如下语法错误：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zj6hc4r</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-comment\"># 该段代码无法执行。</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>  <span class=\"hljs-string\">\"She said \"</span>Surely.<span class=\"hljs-string\">\"\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-symbol\">SyntaxError:</span> invalid syntax\n</code></pre>\n<p>在双引号前加上反斜杠，即可解决这个错误：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jdsrr7e</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"She said \\\"Surely.\\\"\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'She said \"Surely.\"'</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zr7o7d7</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">'She said \\\"Surely.\\\"'</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'She said \"Surely.\"'</span>\n</code></pre>\n<p>字符串<strong>转义</strong>（escaping），指的是在 Python 中有特殊意义的字符（上例中为双引号）前加上一个符号，告诉 Python 在本例中该符号代表的是一个字符，而没有特殊意义。在 Python 中用反斜杠进行转义。</p>\n<p>如果在字符串中使用单引号，而非双引号，则不需要进行转义：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hoef63o</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"She said 'Surely'\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">\"She said 'Surely'\"</span>\n</code></pre>\n<p>还可以在单引号中使用双引号，这比对双引号进行转义更加简单：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zkgfawo</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">'She said \"Surely.\"'</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'She said \"Surely.\"'</span>\n</code></pre>\n<h3 id=\"615\">6.15　换行符</h3>\n<p>在字符串中加入 <code>\\n</code> 来表示换行：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zyrhaeg</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  print(<span class=\"hljs-string\">\"line1\\nline2\\nline3\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> line1\n<span class=\"hljs-meta\">&gt;&gt;</span> line2\n<span class=\"hljs-meta\">&gt;&gt;</span> line3\n</code></pre>\n<h3 id=\"616\">6.16　切片</h3>\n<p><strong>切片</strong>（slicing）可将一个可迭代对象中元素的子集，创建为一个新的可迭代对象。切片的语法是<code>[可迭代对象][[起始索引:结束索引]]</code>。<strong>起始索引</strong>（start index）是开始切片的索引，<strong>结束索引</strong>（end index）是结束索引的位置。</p>\n<p>进行列表切片的示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h2rqj2a</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  fict = [<span class=\"hljs-string\">\"Tolstoy\"</span>,\n<span class=\"hljs-number\">5</span>          <span class=\"hljs-string\">\"Camus\"</span>,\n<span class=\"hljs-number\">6</span>          <span class=\"hljs-string\">\"Orwell\"</span>,\n<span class=\"hljs-number\">7</span>          <span class=\"hljs-string\">\"Huxley\"</span>,\n<span class=\"hljs-number\">8</span>          <span class=\"hljs-string\">\"Austin\"</span>]\n<span class=\"hljs-number\">9</span>  fict[<span class=\"hljs-number\">0</span><span class=\"hljs-symbol\">:</span><span class=\"hljs-number\">3</span>]\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'Tolstoy'</span>, <span class=\"hljs-string\">'Camus'</span>, <span class=\"hljs-string\">'Orwell'</span>]\n</code></pre>\n<p>切片时包含起始索引位置的元素，但不包括结束索引位置的元素。因此，如果要从 <code>\"Tolstoy\"</code>（索引为 0）切片到 <code>\"Orwell\"</code>（索引为 2），则需从索引 0 到索引 3 进行切片。</p>\n<p>字符串切片的示例如下：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hug9euj</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  ivan = <span class=\"hljs-string\">\"\"\"In place of death there was light.\"\"\"</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>  ivan[<span class=\"hljs-number\">0</span>:<span class=\"hljs-number\">17</span>]\n<span class=\"hljs-number\">8</span>  ivan[<span class=\"hljs-number\">17</span>:<span class=\"hljs-number\">33</span>]\n\n&gt;&gt; <span class=\"hljs-string\">'In place of death'</span>\n&gt;&gt; <span class=\"hljs-string\">' there was light.'</span>\n</code></pre>\n<p>如果起始索引是 0，那么可以将起始索引的位置留空：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/judcpx4</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  ivan = <span class=\"hljs-string\">\"\"\"In place of death there was light.\"\"\"</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>  ivan[:<span class=\"hljs-number\">17</span>]\n\n&gt;&gt; <span class=\"hljs-string\">'In place of death'</span>\n</code></pre>\n<p>如果结束索引是可迭代对象中最后一个元素的索引，那么可以将结束索引的位置留空：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zqoscn4</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  ivan = <span class=\"hljs-string\">\"\"\"In place of death there was light.\"\"\"</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>  ivan[<span class=\"hljs-number\">17</span>:]\n\n&gt;&gt; <span class=\"hljs-string\">' there was light.'</span>\n</code></pre>\n<p>起始索引和结束索引均留空，则会返回原可迭代对象：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zqvuqoc</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  ivan = <span class=\"hljs-string\">\"\"\"In place of death there was light.\"\"\"</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>  ivan[:]\n\n&gt;&gt; <span class=\"hljs-string\">\"In place of death there was light.\"</span>\n</code></pre>\n<h3 id=\"617\">6.17　术语表</h3>\n<p><strong>负索引</strong>：可用来从右向左查找可迭代对象中元素的索引（必须是一个负数）。</p>\n<p><strong>转义</strong>：在 Python 中具有特殊意义的字符（如双引号）前加上一个符号，告诉 Python 在本例中该字符代表的只是一个字符，没有特殊意义。</p>\n<p><strong>切片</strong>：将一个可迭代对象中元素的子集，创建为一个新的可迭代对象。</p>\n<p><strong>起始索引</strong>：开始切片的索引。</p>\n<p><strong>结束索引</strong>：结束切片的索引。</p>\n<h3 id=\"618\">6.18　挑战练习</h3>\n<p>1．打印字符串 <code>\"Camus\"</code> 中的所有字符。</p>\n<p>2．编写程序，从用户处获取两个字符串，将其插入字符串 <code>\"Yesterday I wrote a [用户输入1]. I sent it to [用户输入2]!\"</code> 中，并打印新字符串。</p>\n<p>3．想办法将字符串 <code>\"aldous Huxley was born in 1894.\"</code> 的第一个字符大写，从而使语法正确。</p>\n<p>4．对字符串 <code>\"Where now? Who now? When now?\"</code> 调用一个方法，返回如下述的列表 <code>[\"Where now?\", \"Who now?\", \"When now?\"]</code>。</p>\n<p>5．对列表 <code>[\"The\", \"fox\", \"jumped\", \"over\", \"the\", \"fence\", \".\"]</code> 进行处理，将其变成一个语法正确的字符串。每个单词间以空格符分隔，但是单词 <code>fence</code> 和句号之间不能有空格符。（别忘了，我们之前已经学过将字符串列表连接为单个字符串的方法。）</p>\n<p>6．将字符串 <code>\"A screaming comes across the sky.\"</code> 中所有的 <code>\"s\"</code> 字符替换为美元符号。</p>\n<p>7．找到字符串 <code>\"Hemingway\"</code> 中字符 <code>\"m\"</code> 所在的第一个索引。</p>\n<p>8．在你最喜欢的书中找一段对话，将其变成一个字符串。</p>\n<p>9．先后使用字符串拼接和字符串乘法，创建字符串 <code>\"three three three\"</code>。</p>\n<p>10．对字符串 <code>\"It was bright cold day in April, and the clocks were striking thirteen.\"</code> 进行切片，只保留逗号之前的字符。</p>\n<p>答案可从异步社区（www.epubit.com）本书详情页的配套资源中下载。</p></div></article>\n</body>\n</html>","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE html>\n<html lang=\"en\">\n<head><meta name=\"generator\" content=\"Hexo 3.8.0\">\n    <meta charset=\"UTF-8\">\n    <title>字符串操作</title>\n</head>\n<body>\n<article id=\"articleDiv\"><div class=\"mazi-article-content dont-break-out\"><p></p><div class=\"toc\">\n<ul>\n<li><ul>\n<li><ul>\n<li><a href=\"#61\">6.1　三引号字符串</a></li>\n<li><a href=\"#62\">6.2　索引</a></li>\n<li><a href=\"#63\">6.3　字符串是不可变的</a></li>\n<li><a href=\"#64\">6.4　字符串拼接</a></li>\n<li><a href=\"#65\">6.5　字符串乘法</a></li>\n<li><a href=\"#66\">6.6　改变大小写</a></li>\n<li><a href=\"#67\">6.7　格式化</a></li>\n<li><a href=\"#68\">6.8　分割</a></li>\n<li><a href=\"#69\">6.9　连接</a></li>\n<li><a href=\"#610\">6.10　去除空格</a></li>\n<li><a href=\"#611\">6.11　替换</a></li>\n<li><a href=\"#612\">6.12　查找索引</a></li>\n<li><a href=\"#613in\">6.13　in 关键字</a></li>\n<li><a href=\"#614\">6.14　字符串转义</a></li>\n<li><a href=\"#615\">6.15　换行符</a></li>\n<li><a href=\"#616\">6.16　切片</a></li>\n<li><a href=\"#617\">6.17　术语表</a></li>\n<li><a href=\"#618\">6.18　挑战练习</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>\n<p></p>\n<blockquote>\n  <p><span style=\"font-family: Times New Roman,楷体_GB2312\">“理论上，理论和实践没有区别。但实践上，是有区别的。”</span></p>\n  <p><span style=\"font-family: Times New Roman,楷体_GB2312\">——简 · 范德斯奈普特（Jan L. A. van de Snepscheut）</span></p>\n</blockquote>\n<p>Python 自带操作字符串的功能，例如在指定位置将字符串分割为两部分，或者改变字符串的大小写。举个例子，假设有一个所有字符都是大写的字符串，现在希望将其全部改为小写，这通过 Python 可以轻松实现。在本章中，读者将学习更多有关字符串的知识，并掌握 Python 中操作字符串最有效的工具。</p>\n<h3 id=\"61\">6.1　三引号字符串</h3>\n<p>如果字符串跨越一行以上，可以使用三引号：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h59ygda</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"\"\" 第一行\n5      第二行\n6      第三行\n7  \"\"\"</span>\n</code></pre>\n<p>如果使用单引号或双引号定义一个跨行的字符串，Python 会报告语法错误。</p>\n<h3 id=\"62\">6.2　索引</h3>\n<p>与列表和元组一样，字符串也是可迭代的。可使用索引查找字符串中的每个字符。与其他可迭代对象一样，字符串中第一个字符所在的索引为 0，其后每个索引递增 1。</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zqqc2jw</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  author = <span class=\"hljs-string\">\"Kafka\"</span>\n<span class=\"hljs-number\">5</span>  author[<span class=\"hljs-number\">0</span>]\n<span class=\"hljs-number\">6</span>  author[<span class=\"hljs-number\">1</span>]\n<span class=\"hljs-number\">7</span>  author[<span class=\"hljs-number\">2</span>]\n<span class=\"hljs-number\">8</span>  author[<span class=\"hljs-number\">3</span>]\n<span class=\"hljs-number\">9</span>  author[<span class=\"hljs-number\">4</span>]\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'K'</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'a'</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'f'</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'k'</span>\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'a'</span>\n</code></pre>\n<p>上述示例中，可使用索引 0、1、2、3、4 来查找字符串 <code>\"Kafka\"</code> 中的每个字符。如果查找的字符串索引大于最后一个索引的值，Python 会报告异常错误：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//tinyurl.com/zk52tef</span></span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  author = <span class=\"hljs-string\">\"Kafka\"</span>\n<span class=\"hljs-number\">5</span>  author[<span class=\"hljs-number\">5</span>]\n\n&gt;&gt; IndexError: <span class=\"hljs-built_in\">string</span> index out of range\n</code></pre>\n<p>Python 还支持使用<strong>负索引（negative index）</strong>查找列表中的元素：可用来从右向左查找可迭代对象中元素的索引（必须是一个负数）。使用索引 <code>-1</code> 可以查找可迭代对象中的最后一个元素，示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hyju2t5</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  author = <span class=\"hljs-string\">\"Kafka\"</span>\n<span class=\"hljs-number\">5</span>  author[-<span class=\"hljs-number\">1</span>]\n\n<span class=\"hljs-meta\">&gt;&gt;</span> a\n</code></pre>\n<p>负索引 <code>-2</code> 查找的是倒数第二个元素，负索引 <code>-3</code> 查找的是倒数第三个元素，以此类推。</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jtpx7sr</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  author = <span class=\"hljs-string\">\"Kafka\"</span>\n<span class=\"hljs-number\">5</span>  author[-<span class=\"hljs-number\">2</span>]\n<span class=\"hljs-number\">6</span>  author[-<span class=\"hljs-number\">3</span>]\n\n<span class=\"hljs-meta\">&gt;&gt;</span> k\n<span class=\"hljs-meta\">&gt;&gt;</span> f\n</code></pre>\n<h3 id=\"63\">6.3　字符串是不可变的</h3>\n<p>字符串和元组一样都是不可变的，无法修改字符串中的字符。如果想要修改，就必须创建一个新的字符串：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hsr83lv</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  ff = <span class=\"hljs-string\">\"F.Fitzgerald\"</span>\n<span class=\"hljs-number\">5</span>  ff = <span class=\"hljs-string\">\"F. Scott Fitzgerald\"</span>\n<span class=\"hljs-number\">6</span>  ff\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'F. Scott Fitzgerald'</span>\n</code></pre>\n<p>Python 提供了多个从已有字符串中创建新字符串的方法，本章将逐一介绍。</p>\n<h3 id=\"64\">6.4　字符串拼接</h3>\n<p>可使用加法操作符，将两个或多个字符串组合在一起，结果就是由第一个字符串中的字符和其他字符串中的字符共同构成的一个新字符串。将字符串组合的做法，被称为字符串拼接。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h4z5mlg</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"cat\"</span> + <span class=\"hljs-string\">\"in\"</span> + <span class=\"hljs-string\">\"hat\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'catinhat'</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gsrajle</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"cat\"</span> + <span class=\"hljs-string\">\" in\"</span> + <span class=\"hljs-string\">\" the\"</span> + <span class=\"hljs-string\">\" hat\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'cat in the hat'</span>\n</code></pre>\n<h3 id=\"65\">6.5　字符串乘法</h3>\n<p>可使用乘法操作符，将字符串与数字相乘。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zvm9gng</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"Sawyer\"</span> * <span class=\"hljs-number\">3</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> SawyerSawyerSawyer\n</code></pre>\n<h3 id=\"66\">6.6　改变大小写</h3>\n<p>可使用字符串的 <code>upper</code> 方法，将字符串中的每个字符改为大写。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hhancz6</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"We hold these truths...\"</span>.upper()\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'WE HOLD THESE TRUTHS...'</span>\n</code></pre>\n<p>类似地，可使用字符串的 <code>lower</code> 方法将字符串中的每个字符改为小写。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zkz48u5</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"SO IT GOES.\"</span>.lower()\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'so it goes.'</span>\n</code></pre>\n<p>还可使用字符串的 <code>capitalize</code> 方法，将字符串的首字母改为大写。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jp5hexn</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"four score and...\"</span>.capitalize()\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'Four score and...'</span>\n</code></pre>\n<h3 id=\"67\">6.7　格式化</h3>\n<p>可使用 <code>format</code> 方法创建新字符串，该方法会把字符串中的“<code>{}</code>”替换为传入的字符串：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/juvguy8</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"William {}\"</span>.format(<span class=\"hljs-string\">\"Faulkner\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'William Faulkner'</span>\n</code></pre>\n<p>也可以把变量作为参数传递：</p>\n<pre><code class=\"hljs perl\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zcpt9se</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-keyword\">last</span> = <span class=\"hljs-string\">\"Faulkner\"</span>\n<span class=\"hljs-number\">5</span>  <span class=\"hljs-string\">\"William {}\"</span>.format(<span class=\"hljs-keyword\">last</span>)\n\n&gt;&gt; <span class=\"hljs-string\">'William Faulkner'</span>\n</code></pre>\n<p>花括号可重复使用：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z6t6d8n</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  author = <span class=\"hljs-string\">\"William Faulkner\"</span>\n<span class=\"hljs-number\">5</span>  year_born = <span class=\"hljs-string\">\"1897\"</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>\n<span class=\"hljs-number\">8</span>  <span class=\"hljs-string\">\"{} was born in {}.\"</span>.format(author, year_born)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'William Faulkner was born in 1897.'</span>\n</code></pre>\n<p>如果要根据用户输入来创建字符串，<code>format</code> 方法很有用。示例如下：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/gnrdsj9</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  n1 = input(<span class=\"hljs-string\">\"Enter a noun:\"</span>)\n<span class=\"hljs-number\">05</span>  v = input(<span class=\"hljs-string\">\"Enter a verb:\"</span>)\n<span class=\"hljs-number\">06</span>  adj = input(<span class=\"hljs-string\">\"Enter an adj:\"</span>)\n<span class=\"hljs-number\">07</span>  n2 = input(<span class=\"hljs-string\">\"Enter a noun:\"</span>)\n<span class=\"hljs-number\">08</span>\n<span class=\"hljs-number\">09</span>\n<span class=\"hljs-number\">10</span>  r = <span class=\"hljs-string\">\"\"\"The {} {} the {} {}\n11      \"\"\"</span>.format(n1,\n<span class=\"hljs-number\">12</span>                 v,\n<span class=\"hljs-number\">13</span>                 adj,\n<span class=\"hljs-number\">14</span>                 n2)\n<span class=\"hljs-number\">15</span>  print(r)\n\n&gt;&gt; Enter a noun:\n</code></pre>\n<p>程序让用户输入两个名词、一个动词和一个形容词，然后通过 <code>fomrat</code> 方法将这些输入创建为一个字符串并打印出来。</p>\n<h3 id=\"68\">6.8　分割</h3>\n<p>字符串有一个叫 <code>split</code> 的方法，可用来将字符串分割为两个或多个字符串。需要传入一个字符串作为 <code>split</code> 方法的参数，并用其将原字符串分割为多个字符串。例如，可以传入句号作为 <code>split</code> 方法的参数，将字符串 <code>\"I jumped over the puddle. It was 12 feet!\"</code> 分割成两个不同的字符串。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/he8u28o</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"I jumped over the puddle. It was 12 feet!\"</span>.split(<span class=\"hljs-string\">\".\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">\"I jumped over the puddle\"</span>, <span class=\"hljs-string\">\"It was 12 feet!\"</span>]\n</code></pre>\n<p>结果是一个含有两个元素的列表：分别是句号前的所有字符组成的字符串，以及句号后所有字符组成的字符串。</p>\n<h3 id=\"69\">6.9　连接</h3>\n<p><code>join</code> 方法可以在字符串的每个字符间添加新字符：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h2pjkso</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  first_three = <span class=\"hljs-string\">\"abc\"</span>\n<span class=\"hljs-number\">5</span>  result = <span class=\"hljs-string\">\"+\"</span>.join(first_three)\n<span class=\"hljs-number\">6</span>  result\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'a+b+c'</span>\n</code></pre>\n<p>也可以在空字符串上调用 <code>join</code> 方法，传入一个字符串列表作为参数，从而将这些字符串连接为一个单一字符串：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z49e3up</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  words = [<span class=\"hljs-string\">\"The\"</span>,\n<span class=\"hljs-number\">05</span>           <span class=\"hljs-string\">\"fox\"</span>,\n<span class=\"hljs-number\">06</span>           <span class=\"hljs-string\">\"jumped\"</span>,\n<span class=\"hljs-number\">07</span>           <span class=\"hljs-string\">\"over\"</span>,\n08           <span class=\"hljs-string\">\"the\"</span>,\n09           <span class=\"hljs-string\">\"fence\"</span>,\n<span class=\"hljs-number\">10</span>           <span class=\"hljs-string\">\".\"</span>]\n<span class=\"hljs-number\">11</span>  one = <span class=\"hljs-string\">\"\"</span>.join(words)\n<span class=\"hljs-number\">12</span>  one\n\n<span class=\"hljs-meta\">&gt;&gt;</span> Thefoxjumpedoverthefence.\n</code></pre>\n<p>还可以在包含空格符的字符串上，调用 <code>join</code> 方法，创建一个所有单词均由空格符分隔的字符串：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">01</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h4qq5oy</span>\n<span class=\"hljs-number\">02</span>\n<span class=\"hljs-number\">03</span>\n<span class=\"hljs-number\">04</span>  words = [<span class=\"hljs-string\">\"The\"</span>,\n<span class=\"hljs-number\">05</span>           <span class=\"hljs-string\">\"fox\"</span>,\n<span class=\"hljs-number\">06</span>           <span class=\"hljs-string\">\"jumped\"</span>,\n<span class=\"hljs-number\">07</span>           <span class=\"hljs-string\">\"over\"</span>,\n08           <span class=\"hljs-string\">\"the\"</span>,\n09           <span class=\"hljs-string\">\"fence\"</span>,\n<span class=\"hljs-number\">10</span>           <span class=\"hljs-string\">\".\"</span>]\n<span class=\"hljs-number\">11</span>  one = <span class=\"hljs-string\">\" \"</span>.join(words)\n<span class=\"hljs-number\">12</span>  one\n\n<span class=\"hljs-meta\">&gt;&gt;</span> The fox jumped over the fence.\n</code></pre>\n<h3 id=\"610\">6.10　去除空格</h3>\n<p>可使用 <code>strip</code> 方法去除字符串开头和末尾的空白字符：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jfndhgx</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  s = <span class=\"hljs-string\">\"   The       \"</span>\n<span class=\"hljs-number\">5</span>  s = s.strip()\n<span class=\"hljs-number\">6</span>  s\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'The'</span>\n</code></pre>\n<h3 id=\"611\">6.11　替换</h3>\n<p>在 <code>replace</code> 方法中，第一个参数是要被替换的字符串，第二个参数是用来替换的字符串。可使用第二个字符串替换原字符串中所有与第一个字符串一样的内容。示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zha4uwo</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  equ = <span class=\"hljs-string\">\"All animals are equal.\"</span>\n<span class=\"hljs-number\">5</span>  equ = equ.replace(<span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-string\">\"@\"</span>)\n<span class=\"hljs-number\">6</span>  print(equ)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> All @nim@ls @re equ@l.\n</code></pre>\n<h3 id=\"612\">6.12　查找索引</h3>\n<p>可使用 <code>index</code> 方法，获得字符串中某个字符第一次出现的索引。将希望查找的字符作为参数传入，<code>index</code> 方法可以返回该字符在字符串中第一次出现的索引：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hzc6asc</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"animals\"</span>.index(<span class=\"hljs-string\">\"m\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-number\">3</span>\n</code></pre>\n<p>如果 <code>index</code> 方法没有找到匹配的结果，Python 会报告异常错误。如下所示：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jmtc984</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"animals\"</span>.index(<span class=\"hljs-string\">\"z\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-symbol\">ValueError:</span> substring not found\n</code></pre>\n<p>如果不确定是否有匹配的结果，可使用如下异常处理的方法：</p>\n<pre class=\"代码无行号\"><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zl6q4fd</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <strong><span class=\"hljs-keyword\">try</span></strong>:\n<span class=\"hljs-number\">5</span>      <span class=\"hljs-string\">\"animals\"</span>.index(<span class=\"hljs-string\">\"z\"</span>)\n<span class=\"hljs-number\">6</span>  <strong><span class=\"hljs-keyword\">except</span></strong>:\n<span class=\"hljs-number\">7</span>      print(<span class=\"hljs-string\">\"Not found.\"</span>)\n\n&gt;&gt; Not found.</code></pre>\n<h3 id=\"613in\">6.13　in 关键字</h3>\n<p>关键字 <code>in</code> 可检查某个字符串是否在另一个字符串中，返回结果为 <code>True</code> 或 <code>False</code>：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hsnygwz</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"Cat\"</span> <strong><span class=\"hljs-keyword\">in</span></strong> <span class=\"hljs-string\">\"Cat in the hat.\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/z9b3e97</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"Bat\"</span> <strong><span class=\"hljs-keyword\">in</span></strong> <span class=\"hljs-string\">\"Cat in the hat.\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> False</code></pre>\n<p>在 <code>in</code> 前面加上关键字 <code>not</code>，即可检查某个字符串是否不在另一个字符串中：</p>\n<pre class=\"代码无行号\"><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jz8sygd</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>  <span class=\"hljs-string\">\"Potter\"</span> <strong><span class=\"hljs-keyword\">not</span></strong> <strong><span class=\"hljs-keyword\">in</span></strong> <span class=\"hljs-string\">\"Harry\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> True</code></pre>\n<h3 id=\"614\">6.14　字符串转义</h3>\n<p>如果在字符串中使用了双引号，则会出现如下语法错误：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zj6hc4r</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-comment\"># 该段代码无法执行。</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>  <span class=\"hljs-string\">\"She said \"</span>Surely.<span class=\"hljs-string\">\"\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-symbol\">SyntaxError:</span> invalid syntax\n</code></pre>\n<p>在双引号前加上反斜杠，即可解决这个错误：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/jdsrr7e</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"She said \\\"Surely.\\\"\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'She said \"Surely.\"'</span>\n\n<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zr7o7d7</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">'She said \\\"Surely.\\\"'</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'She said \"Surely.\"'</span>\n</code></pre>\n<p>字符串<strong>转义</strong>（escaping），指的是在 Python 中有特殊意义的字符（上例中为双引号）前加上一个符号，告诉 Python 在本例中该符号代表的是一个字符，而没有特殊意义。在 Python 中用反斜杠进行转义。</p>\n<p>如果在字符串中使用单引号，而非双引号，则不需要进行转义：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hoef63o</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">\"She said 'Surely'\"</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">\"She said 'Surely'\"</span>\n</code></pre>\n<p>还可以在单引号中使用双引号，这比对双引号进行转义更加简单：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zkgfawo</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-string\">'She said \"Surely.\"'</span>\n\n<span class=\"hljs-meta\">&gt;&gt;</span> <span class=\"hljs-string\">'She said \"Surely.\"'</span>\n</code></pre>\n<h3 id=\"615\">6.15　换行符</h3>\n<p>在字符串中加入 <code>\\n</code> 来表示换行：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zyrhaeg</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  print(<span class=\"hljs-string\">\"line1\\nline2\\nline3\"</span>)\n\n<span class=\"hljs-meta\">&gt;&gt;</span> line1\n<span class=\"hljs-meta\">&gt;&gt;</span> line2\n<span class=\"hljs-meta\">&gt;&gt;</span> line3\n</code></pre>\n<h3 id=\"616\">6.16　切片</h3>\n<p><strong>切片</strong>（slicing）可将一个可迭代对象中元素的子集，创建为一个新的可迭代对象。切片的语法是<code>[可迭代对象][[起始索引:结束索引]]</code>。<strong>起始索引</strong>（start index）是开始切片的索引，<strong>结束索引</strong>（end index）是结束索引的位置。</p>\n<p>进行列表切片的示例如下：</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/h2rqj2a</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  fict = [<span class=\"hljs-string\">\"Tolstoy\"</span>,\n<span class=\"hljs-number\">5</span>          <span class=\"hljs-string\">\"Camus\"</span>,\n<span class=\"hljs-number\">6</span>          <span class=\"hljs-string\">\"Orwell\"</span>,\n<span class=\"hljs-number\">7</span>          <span class=\"hljs-string\">\"Huxley\"</span>,\n<span class=\"hljs-number\">8</span>          <span class=\"hljs-string\">\"Austin\"</span>]\n<span class=\"hljs-number\">9</span>  fict[<span class=\"hljs-number\">0</span><span class=\"hljs-symbol\">:</span><span class=\"hljs-number\">3</span>]\n\n<span class=\"hljs-meta\">&gt;&gt;</span> [<span class=\"hljs-string\">'Tolstoy'</span>, <span class=\"hljs-string\">'Camus'</span>, <span class=\"hljs-string\">'Orwell'</span>]\n</code></pre>\n<p>切片时包含起始索引位置的元素，但不包括结束索引位置的元素。因此，如果要从 <code>\"Tolstoy\"</code>（索引为 0）切片到 <code>\"Orwell\"</code>（索引为 2），则需从索引 0 到索引 3 进行切片。</p>\n<p>字符串切片的示例如下：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/hug9euj</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  ivan = <span class=\"hljs-string\">\"\"\"In place of death there was light.\"\"\"</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>  ivan[<span class=\"hljs-number\">0</span>:<span class=\"hljs-number\">17</span>]\n<span class=\"hljs-number\">8</span>  ivan[<span class=\"hljs-number\">17</span>:<span class=\"hljs-number\">33</span>]\n\n&gt;&gt; <span class=\"hljs-string\">'In place of death'</span>\n&gt;&gt; <span class=\"hljs-string\">' there was light.'</span>\n</code></pre>\n<p>如果起始索引是 0，那么可以将起始索引的位置留空：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/judcpx4</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  ivan = <span class=\"hljs-string\">\"\"\"In place of death there was light.\"\"\"</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>  ivan[:<span class=\"hljs-number\">17</span>]\n\n&gt;&gt; <span class=\"hljs-string\">'In place of death'</span>\n</code></pre>\n<p>如果结束索引是可迭代对象中最后一个元素的索引，那么可以将结束索引的位置留空：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zqoscn4</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  ivan = <span class=\"hljs-string\">\"\"\"In place of death there was light.\"\"\"</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>  ivan[<span class=\"hljs-number\">17</span>:]\n\n&gt;&gt; <span class=\"hljs-string\">' there was light.'</span>\n</code></pre>\n<p>起始索引和结束索引均留空，则会返回原可迭代对象：</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># http://tinyurl.com/zqvuqoc</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span>\n<span class=\"hljs-number\">4</span>  ivan = <span class=\"hljs-string\">\"\"\"In place of death there was light.\"\"\"</span>\n<span class=\"hljs-number\">5</span>\n<span class=\"hljs-number\">6</span>\n<span class=\"hljs-number\">7</span>  ivan[:]\n\n&gt;&gt; <span class=\"hljs-string\">\"In place of death there was light.\"</span>\n</code></pre>\n<h3 id=\"617\">6.17　术语表</h3>\n<p><strong>负索引</strong>：可用来从右向左查找可迭代对象中元素的索引（必须是一个负数）。</p>\n<p><strong>转义</strong>：在 Python 中具有特殊意义的字符（如双引号）前加上一个符号，告诉 Python 在本例中该字符代表的只是一个字符，没有特殊意义。</p>\n<p><strong>切片</strong>：将一个可迭代对象中元素的子集，创建为一个新的可迭代对象。</p>\n<p><strong>起始索引</strong>：开始切片的索引。</p>\n<p><strong>结束索引</strong>：结束切片的索引。</p>\n<h3 id=\"618\">6.18　挑战练习</h3>\n<p>1．打印字符串 <code>\"Camus\"</code> 中的所有字符。</p>\n<p>2．编写程序，从用户处获取两个字符串，将其插入字符串 <code>\"Yesterday I wrote a [用户输入1]. I sent it to [用户输入2]!\"</code> 中，并打印新字符串。</p>\n<p>3．想办法将字符串 <code>\"aldous Huxley was born in 1894.\"</code> 的第一个字符大写，从而使语法正确。</p>\n<p>4．对字符串 <code>\"Where now? Who now? When now?\"</code> 调用一个方法，返回如下述的列表 <code>[\"Where now?\", \"Who now?\", \"When now?\"]</code>。</p>\n<p>5．对列表 <code>[\"The\", \"fox\", \"jumped\", \"over\", \"the\", \"fence\", \".\"]</code> 进行处理，将其变成一个语法正确的字符串。每个单词间以空格符分隔，但是单词 <code>fence</code> 和句号之间不能有空格符。（别忘了，我们之前已经学过将字符串列表连接为单个字符串的方法。）</p>\n<p>6．将字符串 <code>\"A screaming comes across the sky.\"</code> 中所有的 <code>\"s\"</code> 字符替换为美元符号。</p>\n<p>7．找到字符串 <code>\"Hemingway\"</code> 中字符 <code>\"m\"</code> 所在的第一个索引。</p>\n<p>8．在你最喜欢的书中找一段对话，将其变成一个字符串。</p>\n<p>9．先后使用字符串拼接和字符串乘法，创建字符串 <code>\"three three three\"</code>。</p>\n<p>10．对字符串 <code>\"It was bright cold day in April, and the clocks were striking thirteen.\"</code> 进行切片，只保留逗号之前的字符。</p>\n<p>答案可从异步社区（www.epubit.com）本书详情页的配套资源中下载。</p></div></article>\n</body>\n</html>"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}